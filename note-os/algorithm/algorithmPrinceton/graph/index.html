<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Zhenhua Wang">
        <link rel="canonical" href="http://larryim.cc/note-os/algorithm/algorithmPrinceton/graph/">
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>Topic 8: Graph - Zhenhua's Notes</title>
        <link href="../../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/docco.min.css">
        <link href="../../../extra_css/custom.css" rel="stylesheet">
        <link href="../../../extra_css/custom.js" rel="stylesheet">
        <link href="../../../extra_css/friendly.css" rel="stylesheet">
        <link href="../../../extra_css/theme.css" rel="stylesheet">
        <link href="../../../extra_css/mkdocs/js/lunr-0.5.7.min.js" rel="stylesheet">
        <link href="../../../extra_css/mkdocs/js/mustache.min.js" rel="stylesheet">
        <link href="../../../extra_css/mkdocs/js/require.js" rel="stylesheet">
        <link href="../../../extra_css/mkdocs/js/search.js" rel="stylesheet">
        <link href="../../../extra_css/mkdocs/js/text.js" rel="stylesheet">
        <link href="../../../extra_css/code-tab.css" rel="stylesheet">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../../..">Zhenhua's Notes</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../../..">Home</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Algorithm <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../">Contents</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#">AlgorithmPrinceton</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../">Contents</a>
</li>
            
<li >
    <a href="../unionfind/">Topic 1: UnionFind</a>
</li>
            
<li >
    <a href="../stackqueue/">Topic 2: StackQueue</a>
</li>
            
<li >
    <a href="../sort/">Topic 3: Sort</a>
</li>
            
<li >
    <a href="../priorityqueue/">Topic 4: PriorityQueues</a>
</li>
            
<li >
    <a href="../symboltable/">Topic 5: Symbol Tables</a>
</li>
            
<li >
    <a href="../bst/">Topic 6: Balanced Search Trees</a>
</li>
            
<li >
    <a href="../hashtable/">Topic 7: Hash Table</a>
</li>
            
<li class="active">
    <a href="./">Topic 8: Graph</a>
</li>
            
<li >
    <a href="../mst_shortestpath/">Topic 9: Minimum Spanning Tree and Shortest Path</a>
</li>
            
<li >
    <a href="../stringsort/">Topic 11: String Sort</a>
</li>
            
<li >
    <a href="../tries/">Topic 12: Tries</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">AlgorithmStanford</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../algorithmStanford/">Contents</a>
</li>
            
<li >
    <a href="../../algorithmStanford/dynamicprogramming/">Topic: Dynammic Programming</a>
</li>
            
<li >
    <a href="../../algorithmStanford/heap/">Topic: Heap</a>
</li>
            
<li >
    <a href="../../algorithmStanford/graph/">Topic: Graph</a>
</li>
            
<li >
    <a href="../../algorithmStanford/greedy/">Topic: Greedy Algorithm</a>
</li>
            
<li >
    <a href="../../algorithmStanford/hashtable/">Topic: Hash Table</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">CS61B</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../cs61b/">Contents</a>
</li>
            
<li >
    <a href="../../cs61b/Lab1/">Lab1: javac, java, git</a>
</li>
            
<li >
    <a href="../../cs61b/Lab2/">Lab2: Unit Testing with JUnit and IntLists</a>
</li>
            
<li >
    <a href="../../cs61b/Lab3/">Lab3: Unit Testing with JUnit, Debugging</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">SWORD</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../sword/">Contents</a>
</li>
            
<li >
    <a href="../../sword/solution/">剑指Offer题解</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">OS <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../../os/">Contents</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#">OSC</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../os/osc/">Contents</a>
</li>
            
<li >
    <a href="../../../os/osc/ch1/">Chapter 1: Introduction </a>
</li>
            
<li >
    <a href="../../../os/osc/ch2/">Chapter 2: Operating System structures</a>
</li>
            
<li >
    <a href="../../../os/osc/ch3/">Chapter 3: Processes</a>
</li>
            
<li >
    <a href="../../../os/osc/ch4/">Chapter 4: Threads and Concurrency</a>
</li>
            
<li >
    <a href="../../../os/osc/ch5/">Chapter 5: CPU Scheduling</a>
</li>
            
<li >
    <a href="../../../os/osc/ch6/">Chapter 6: Synchronization Tools</a>
</li>
            
<li >
    <a href="../../../os/osc/ch7/">Chapter 7: Synchronization Examples</a>
</li>
            
<li >
    <a href="../../../os/osc/ch8/">Chapter 8: Deadlocks</a>
</li>
            
<li >
    <a href="../../../os/osc/ch9/">Chapter 9: Main Memory</a>
</li>
            
<li >
    <a href="../../../os/osc/ch10/">Chapter 10: Virtual Memory</a>
</li>
            
<li >
    <a href="../../../os/osc/ch11/">Chapter 11: Mass-Storage Structure</a>
</li>
            
<li >
    <a href="../../../os/osc/ch13/">Chapter 13: File-System Interfaces</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">CSAPP</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../os/csapp/">Contents</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch1/">Chapter 1: 计算机系统漫游</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch2/">Chapter 2: 信息的表示和处理</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch3/">Chapter 3: 程序的机器级表示</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch4/">Chapter 4: 处理器体系结构</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch5/">Chapter 5: 优化程序性能</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch6/">Chapter 6: 存储器层次结构</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch7/">Chapter 7: 链接</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch8/">Chapter 8: 异常控制流</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch9/">Chapter 9: 虚拟内存</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch10/">Chapter 10: 系统级I/O</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch11/">Chapter 11: 网络编程</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">DataBase <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../../database/">Contents</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#">MySql</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../database/mysql/">Contents</a>
</li>
            
<li >
    <a href="../../../database/mysql/LearningMySQLandMariaDB/">Chapter Learning MySQL and MariaDB</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Java <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../../java/">Contents</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#">HFJ</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../java/hfj/">Contents</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch1/">Chapter 1: Dive in A Quick Dip</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch2/">Chapter 2: Classes and Objects</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch3/">Chapter 3: Primitives and References</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch4/">Chapter 4: Methods use Instance Variables</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch5/">Chapter 5: Writing a Program</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch6/">Chapter 6: Get to Know the Java API</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch7/">Chapter 7: Inheritance and Polymorphism</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch8/">Chapter 8: Interfaces and Abstract Classes</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch9/">Chapter 9: Constructors and Garbage Collection</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch10/">Chapter 10: Numbers and Statics</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch11/">Chapter 11: Exception Handling</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch12/">Chapter 12: Getting GUI</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch13/">Chapter 13: Using Swing</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch14/">Chapter 14: Serialization and File I/O</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch15/">Chapter 15: Networking and Threads</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch16/">Chapter 16: Collections and Generics</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch17/">Chapter 17: Packages, Jars and Deployment</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch18/">Chapter 18: Remote deploy with RMI</a>
</li>
            
<li >
    <a href="../../../java/hfj/Appendix/">Appendix: The Top Ten Topics</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">HFDP</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../java/hfdp/">Contents</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch1/">Chapter 1: Strategy Pattern </a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch2/">Chapter 2: Observer Pattern</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch3/">Chapter 3: Decorator Pattern </a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch4/">Chapter 4: Factory Pattern</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch5/">Chapter 5: Singleton Pattern</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch6/">Chapter 6: Command Pattern</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch7/">Chapter 7: Adapter and Facade Patterns</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch8/">Chapter 8: Template Method Pattern</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch9/">Chapter 9: Iterator and Composite Patterns</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">MultiThreading</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../java/multithreading/">Contents</a>
</li>
            
<li >
    <a href="../../../java/multithreading/pre1/">序章1 Java线程</a>
</li>
            
<li >
    <a href="../../../java/multithreading/pre2/">序章2 多线程程序的评价标准</a>
</li>
            
<li >
    <a href="../../../java/multithreading/ch1/">第1章 Single Threaded Execution模式</a>
</li>
            
<li >
    <a href="../../../java/multithreading/ch1/">第2章 Immutable模式</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">TIJ</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../java/tij/">Contents</a>
</li>
            
<li >
    <a href="../../../java/tij/ch1/">Chapter 1: Introduction</a>
</li>
            
<li >
    <a href="../../../java/tij/ch2/">Chapter 2: Introduction to Objects</a>
</li>
            
<li >
    <a href="../../../java/tij/ch3/">Chapter 3: Everything is an Object</a>
</li>
            
<li >
    <a href="../../../java/tij/ch4/">Chapter 4: Opertors</a>
</li>
            
<li >
    <a href="../../../java/tij/ch5/">Chapter 5: Controlling Execution</a>
</li>
            
<li >
    <a href="../../../java/tij/ch6/">Chapter 6: Initialization & Cleanup</a>
</li>
            
<li >
    <a href="../../../java/tij/ch7/">Chapter 7: Access Control</a>
</li>
            
<li >
    <a href="../../../java/tij/ch8/">Chapter 8: Reusing Clases</a>
</li>
            
<li >
    <a href="../../../java/tij/ch9/">Chapter 9: Polymorphism</a>
</li>
            
<li >
    <a href="../../../java/tij/ch10/">Chapter 10: Interfaces</a>
</li>
            
<li >
    <a href="../../../java/tij/ch11/">Chapter 11: Inner Classes</a>
</li>
            
<li >
    <a href="../../../java/tij/ch12/">Chapter 12: Holding Your Objects</a>
</li>
            
<li >
    <a href="../../../java/tij/ch13/">Chapter 13: Error Handling with Exceptions</a>
</li>
            
<li >
    <a href="../../../java/tij/ch14/">Chapter 14: Strings</a>
</li>
            
<li >
    <a href="../../../java/tij/ch15/">Chapter 15: Type Information</a>
</li>
            
<li >
    <a href="../../../java/tij/ch16/">Chapter 16: Generics</a>
</li>
            
<li >
    <a href="../../../java/tij/ch17/">Chapter 17: Arrays</a>
</li>
            
<li >
    <a href="../../../java/tij/ch18/">Chapter 18: Containers in Depth</a>
</li>
            
<li >
    <a href="../../../java/tij/ch19/">Chapter 19: I/O</a>
</li>
            
<li >
    <a href="../../../java/tij/ch20/">Chapter 20: Enumerated Types</a>
</li>
            
<li >
    <a href="../../../java/tij/ch21/">Chapter 21: Annotations</a>
</li>
            
<li >
    <a href="../../../java/tij/ch22/">Chapter 22: Concurrency</a>
</li>
            
<li >
    <a href="../../../java/tij/ch23/">Chapter 23: Graphical User Interfaces</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">UJVM</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../java/ujvm/">Contents</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch1/">Chapter 1 : 走进Java</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch2/">Chapter 2 : Java内存区域与内存溢出正常</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch3/">Chapter 3 : 垃圾收集器与内存分配策略</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch4/">Chapter 4 : 虚拟机性能监控与故障处理工具</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch5/">Chapter 5 : 调优案例分析与实战</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch6/">Chapter 6 : 类文件结构</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch7/">Chapter 7 : 虚拟机类加载机制</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch8/">Chapter 8 : 虚拟机字节码执行引擎</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch9/">Chapter 9 : 类加载及执行子系统的案例与实战</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch10/">Chapter 10 : 早期(编译期)优化</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch11/">Chapter 11 : 晚期(运行期)优化</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch12/">Chapter 12 : Java内存模型与线程</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch13/">Chapter 13 : 线程安全与锁优化</a>
</li>
            
<li >
    <a href="../../../java/ujvm/AppendixC/">Appendix HotSpot虚拟机主要参数列表</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">BigData <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../../bigdata/">Contents</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#">HADOOP</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/hadoop/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch1/">Chapter 1: Meet Hadoop</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch2/">Chapter 2: MapReduce</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch3/">Chapter 3: The Hadoop Distributed FileSystem</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch4/">Chapter 4: YARN</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch5/">Chapter 5: Hadoop I/O</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch6/">Chapter 6: Developing a MapReduce Application</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch7/">Chapter 7: How MapReduce Works</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch8/">Chapter 8: MapReduce Types and Formats</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch9/">Chapter 9: MapReduce Features</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch10/">Chapter 10: Setting Up a Hadoop Cluster</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch11/">Chapter 11: Adminstering Hadoop</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch12/">Chapter 12: Avro</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch13/">Chapter 13: Parquet</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch14/">Chapter 14: Flume</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch15/">Chapter 15: Sqoop</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch16/">Chapter 16: Pig</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch17/">Chapter 17: Hive</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch18/">Chapter 18: Crunch</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch19/">Chapter 19: Spark</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch20/">Chapter 20: HBase</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch21/">Chapter 21: ZooKeeper</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch22/">Chapter 22: Composable Data at Center</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch23/">Chapter 23: Biological Data Science: Saving Lives with Software</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch24/">Chapter 24: Cascading</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Spark</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/spark/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch1/">Chapter 1: Introduction to Data Analysis with Spark</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch2/">Chapter 2: Downloading Spark and Getting Started</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch3/">Chapter 3: Programming with RDDs</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch4/">Chapter 4: Working with Key/Value Pairs</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch5/">Chapter 5: Loading and Saving Your Data</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch6/">Chapter 6: Advanced Spark Programming</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch7/">Chapter 7: Running on a Cluster</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch8/">Chapter 8: Tuning and Debugging Spark</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch9/">Chapter 9: Spark SQL</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch10/">Chapter 10: Spark Streaming</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch11/">Chapter 11: Machine Learning with MLlib</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">GDM</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/gdm/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch1/">Chapter 1: 推荐系统入门</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch2/">Chapter 2: 隐式评价和基于物品的过滤算法</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch3/">Chapter 3: 分类</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch4/">Chapter 4: 进一步探索分类</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch5/">Chapter 5: 概率和朴素贝叶斯</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch6/">Chapter 6: 朴素贝叶斯和文本数据</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch7/">Chapter 7: 聚类</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">MLIA</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/mlia/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch1/">Chapter 1: 机器学习基础</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch2/">Chapter 2: k-近邻算法</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch3/">Chapter 3: 决策树</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch4/">Chapter 4: 基于概率论的分类方法：朴素贝叶斯</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch5/">Chapter 5: Logistic回归</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch6/">Chapter 6: 支持向量机</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch7/">Chapter 7: 利用AdaBoost元算法提高分类性能</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch8/">Chapter 8: 预测数值型数据：回归</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch9/">Chapter 9: 树回归</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch10/">Chapter 10: 利用Ｋ-均值聚类算法对未标注数据分组</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch11/">Chapter 11: 使用Apriori算法进行关联分析</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch11/">Chapter 12: 使用FP-growth算法来高效发现频繁项集</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch13/">Chapter 13: 利用PCA来简化数据</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Crawler</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/crawler/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch1/">Chapter 1: 开发环境配置</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch2/">Chapter 2: 爬虫基础</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch3/">Chapter 3: 基本库的使用</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch4/">Chapter 4: 解析库的使用</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch5/">Chapter 5: 数据存储</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch7/">Chapter 7: 动态渲染页面爬取</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch13/">Chapter 13: Scrapy框架的使用</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Projects</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/projects/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/projects/SparkStreaming实时流处理项目/">SparkStreaming实时流处理</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li >
                                <a href="../../../books/">Books</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>

                     <!--
                            <li >
                                <a rel="next" href="../hashtable/">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="../mst_shortestpath/">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    -->
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#topic-8-graph">Topic 8: Graph</a></li>
        <li class="main "><a href="#undirected-graph">UnDirected Graph</a></li>
            <li><a href="#glossary">Glossary</a></li>
            <li><a href="#api">API</a></li>
            <li><a href="#dfs">DFS</a></li>
            <li><a href="#finding-paths">Finding Paths</a></li>
            <li><a href="#bfs">BFS</a></li>
            <li><a href="#connected-components">Connected components</a></li>
            <li><a href="#cycle">Cycle</a></li>
            <li><a href="#bipartite-graph">Bipartite Graph</a></li>
        <li class="main "><a href="#directed-graph">Directed Graph</a></li>
            <li><a href="#glossary_1">Glossary</a></li>
            <li><a href="#api_1">API</a></li>
            <li><a href="#reachability-in-digraphs">Reachability in digraphs</a></li>
            <li><a href="#dfs-edge-classification">DFS Edge Classification</a></li>
            <li><a href="#cycles-and-dags">Cycles and DAGs</a></li>
            <li><a href="#topological-sort">Topological Sort</a></li>
            <li><a href="#dfs-edge-classification_1">DFS Edge Classification</a></li>
            <li><a href="#strong-connectivity-in-digraphs">Strong connectivity in digraphs</a></li>
        <li class="main "><a href="#application-wordnet">Application: WordNet</a></li>
            <li><a href="#the-wordnet-digraph">The WordNet digraph</a></li>
            <li><a href="#shortest-ancestral-path">Shortest ancestral path</a></li>
            <li><a href="#outcast-detection">Outcast detection</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h3 id="topic-8-graph"><strong>Topic 8: Graph</strong><a class="headerlink" href="#topic-8-graph" title="Permanent link">&para;</a></h3>
<p><span class="badge badge-pill badge-info">DAG</span>
<span class="badge badge-pill badge-info">DFS</span>
<span class="badge badge-pill badge-info">BFS</span></p>
<h3 id="undirected-graph">UnDirected Graph<a class="headerlink" href="#undirected-graph" title="Permanent link">&para;</a></h3>
<blockquote>
<p>A <em>graph</em> is a set of <em>vertices</em> and a collection of <em>edges</em> that each connect a pair of vertices.</p>
</blockquote>
<h4 id="glossary">Glossary<a class="headerlink" href="#glossary" title="Permanent link">&para;</a></h4>
<ul>
<li>A <em>path</em> in a graph is a sequence of vertices connected by edges.</li>
<li>A <em>simple path</em> is one with no repeated vertices. </li>
<li>A <em>cycle</em> is a path with at least one edge whose first and last vertices are the same. </li>
<li>A <em>simple cycle</em> is a cycle with no repeated edges or vertices (except the requisite repetition of the first and last vertices). The length of a path or a cycle is its number of edges.</li>
<li>A <em>self-loop</em> is an edge that connects a vertex to itself.</li>
<li>A graph is <em>connected</em> if there is a path from every vertex to every other vertex in the graph. A graph that is not connected consists of a set of <em>connected components</em>, which are maximal connected subgraphs.</li>
<li>An <em>acyclic</em> graph is a graph with no cycles. A tree is an <em>acyclic</em> connected graph.</li>
<li>A disjoint set of trees is called a <em>forest</em>. A <em>spanning tree</em> of a connected graph is a subgraph that contains all of that graph’s vertices and is a single tree. A <em>spanning forest</em> of a graph is the union of spanning trees of its connected components.</li>
</ul>
<h4 id="api">API<a class="headerlink" href="#api" title="Permanent link">&para;</a></h4>
<p><img alt="undirected_graph_api" src="../figures/undirected_graph_api.png" /></p>
<p>Use the adjacency-lists representation, where we maintain a vertex-indexed array of lists of the vertices connected by an edge to each vertex.</p>
<p><img alt="" src="../figures/adjacency-list-represent-of-graph.png" /></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Graph</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>V</span><span class=o>;</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>E</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>LinkedList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;[]</span> <span class=n>adj</span><span class=o>;</span>

    <span class=c1>// Initializes an empty graph with V vertices and 0 edges.</span>
    <span class=kd>public</span> <span class=nf>Graph</span><span class=o>(</span><span class=kt>int</span> <span class=n>V</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>V</span> <span class=o>=</span> <span class=n>V</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>E</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
        <span class=n>adj</span> <span class=o>=</span>  <span class=o>(</span><span class=n>LinkedList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;[])</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;?&gt;[</span><span class=n>V</span><span class=o>];</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>V</span><span class=o>;</span> <span class=n>v</span><span class=o>++)</span>
            <span class=n>adj</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span>
    <span class=o>}</span>

    <span class=c1>// Returns the number of vertices in this graph.</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>V</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>V</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=c1>// Returns the number of edges in this graph.</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>E</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>E</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=c1>// Adds the undirected edge v-w to this graph.</span>
    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>addEdge</span><span class=o>(</span><span class=kt>int</span> <span class=n>v</span><span class=o>,</span> <span class=kt>int</span> <span class=n>w</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>E</span><span class=o>++;</span>
        <span class=n>adj</span><span class=o>[</span><span class=n>v</span><span class=o>].</span><span class=na>add</span><span class=o>(</span><span class=n>w</span><span class=o>);</span>
        <span class=n>adj</span><span class=o>[</span><span class=n>w</span><span class=o>].</span><span class=na>add</span><span class=o>(</span><span class=n>v</span><span class=o>);</span>
    <span class=o>}</span>


    <span class=c1>// Returns the vertices adjacent to vertex v.</span>
    <span class=kd>public</span> <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>adj</span><span class=o>(</span><span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>adj</span><span class=o>[</span><span class=n>v</span><span class=o>];</span>
    <span class=o>}</span>

    <span class=c1>// Returns the degree of vertex v.</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>degree</span><span class=o>(</span><span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>adj</span><span class=o>[</span><span class=n>v</span><span class=o>].</span><span class=na>size</span><span class=o>();</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<h4 id="dfs">DFS<a class="headerlink" href="#dfs" title="Permanent link">&para;</a></h4>
<p>DFS (to visit a vertex <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>)</p>
<ul>
<li>Mark <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> as visited.</li>
<li>Recursively visit all unmarked vertices <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> adjacent to <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>.</li>
</ul>
<p>DFS marks all the vertices connected to a given source in time proportional to the sum of their degrees.</p>
<p><img alt="depth-first-search-demo" src="../figures/depth-first-search-demo.gif" /></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>DepthFirstSearch</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>boolean</span><span class=o>[]</span> <span class=n>marked</span><span class=o>;</span>    <span class=c1>// marked[v] = is there an s-v path?</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>count</span><span class=o>;</span>           <span class=c1>// number of vertices connected to s</span>

    <span class=c1>// Computes the vertices in graph G that are</span>
    <span class=c1>// connected to the source vertex s.</span>
    <span class=kd>public</span> <span class=nf>DepthFirstSearch</span><span class=o>(</span><span class=n>Graph</span> <span class=n>G</span><span class=o>,</span> <span class=kt>int</span> <span class=n>s</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>marked</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>s</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=c1>// depth first search from v</span>
    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>dfs</span><span class=o>(</span><span class=n>Graph</span> <span class=n>G</span><span class=o>,</span> <span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>count</span><span class=o>++;</span>
        <span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>w</span> <span class=o>:</span> <span class=n>G</span><span class=o>.</span><span class=na>adj</span><span class=o>(</span><span class=n>v</span><span class=o>))</span> <span class=o>{</span>
            <span class=k>if</span> <span class=o>(!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>])</span> <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>w</span><span class=o>);</span> 
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<p>Typical applications.</p>
<ul>
<li>Find all vertices connected to a given source vertex. </li>
<li>Find a path between two vertices.</li>
</ul>
<h4 id="finding-paths">Finding Paths<a class="headerlink" href="#finding-paths" title="Permanent link">&para;</a></h4>
<p><strong><em>Single-source paths</em></strong>. Given a graph and a source vertex <span><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span>, support queries of the form: Is there a path from <span><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span> to a given target vertex <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>? If so, find such a path.</p>
<p><img alt="paths_api" src="../figures/paths_api.png" /></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Paths</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>boolean</span><span class=o>[]</span> <span class=n>marked</span><span class=o>;</span>    <span class=c1>// marked[v] = is there a s-v path?</span>
    <span class=kd>private</span> <span class=kt>int</span><span class=o>[]</span> <span class=n>edgeTo</span><span class=o>;</span>        <span class=c1>// edgeTo[v] = last edge on s-v path</span>
    <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>s</span><span class=o>;</span>         <span class=c1>// source vertex</span>

    <span class=c1>// Computes a path between s and every other vertex in graph G.</span>
    <span class=kd>public</span> <span class=nf>Paths</span><span class=o>(</span><span class=n>Graph</span> <span class=n>G</span><span class=o>,</span> <span class=kt>int</span> <span class=n>s</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>s</span> <span class=o>=</span> <span class=n>s</span><span class=o>;</span>
        <span class=n>edgeTo</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=n>marked</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>s</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=c1>// depth first search from v</span>
    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>dfs</span><span class=o>(</span><span class=n>Graph</span> <span class=n>G</span><span class=o>,</span> <span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>w</span> <span class=o>:</span> <span class=n>G</span><span class=o>.</span><span class=na>adj</span><span class=o>(</span><span class=n>v</span><span class=o>))</span>
            <span class=k>if</span> <span class=o>(!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>])</span> <span class=o>{</span>
                <span class=n>edgeTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span> <span class=o>=</span> <span class=n>v</span><span class=o>;</span>
                <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>w</span><span class=o>);</span>
            <span class=o>}</span>
    <span class=o>}</span>

    <span class=c1>// Is there a path between the source vertex s and vertex v?</span>
    <span class=kt>boolean</span> <span class=nf>hasPathTo</span><span class=o>(</span><span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>];</span>
    <span class=o>}</span>

   <span class=c1>// Returns a path between the source vertex s and vertex v, </span>
   <span class=c1>// or null if no such path.</span>
    <span class=kd>public</span> <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>pathTo</span><span class=o>(</span><span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(!</span><span class=n>hasPathTo</span><span class=o>(</span><span class=n>v</span><span class=o>))</span> <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
        <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>path</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;();</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=n>v</span><span class=o>;</span> <span class=n>x</span> <span class=o>!=</span> <span class=n>s</span><span class=o>;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>edgeTo</span><span class=o>[</span><span class=n>x</span><span class=o>])</span> <span class=n>path</span><span class=o>.</span><span class=na>push</span><span class=o>(</span><span class=n>x</span><span class=o>);</span>
        <span class=n>path</span><span class=o>.</span><span class=na>push</span><span class=o>(</span><span class=n>s</span><span class=o>);</span>
        <span class=k>return</span> <span class=n>path</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<h4 id="bfs">BFS<a class="headerlink" href="#bfs" title="Permanent link">&para;</a></h4>
<p><strong><em>Single-source shortest paths</em></strong> Given a graph and a source vertex <span><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span>, support queries of the form: Is there a path from <span><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span> to a given target vertex <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>? If so, find a <em>shortest</em> such path (one with a minimal number of edges).</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>BreadthFirstPaths</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>boolean</span><span class=o>[]</span> <span class=n>marked</span><span class=o>;</span>  <span class=c1>// marked[v] = is there an s-v path</span>
    <span class=kd>private</span> <span class=kt>int</span><span class=o>[]</span> <span class=n>edgeTo</span><span class=o>;</span>      <span class=c1>// edgeTo[v] = previous edge on shortest s-v path</span>
    <span class=kd>private</span> <span class=kt>int</span><span class=o>[]</span> <span class=n>distTo</span><span class=o>;</span>      <span class=c1>// distTo[v] = number of edges shortest s-v path</span>

    <span class=c1>// Computes the shortest path between the source vertex s</span>
    <span class=c1>// and every other vertex in the graph {@code G}.</span>
    <span class=kd>public</span> <span class=nf>BreadthFirstPaths</span><span class=o>(</span><span class=n>Graph</span> <span class=n>G</span><span class=o>,</span> <span class=kt>int</span> <span class=n>s</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>marked</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=n>distTo</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=n>edgeTo</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=n>bfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>s</span><span class=o>);</span>
    <span class=o>}</span>


    <span class=c1>// breadth-first search from a single source</span>
    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>bfs</span><span class=o>(</span><span class=n>Graph</span> <span class=n>G</span><span class=o>,</span> <span class=kt>int</span> <span class=n>s</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>q</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span>
        <span class=n>distTo</span><span class=o>[</span><span class=n>s</span><span class=o>]</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
        <span class=n>marked</span><span class=o>[</span><span class=n>s</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
        <span class=n>q</span><span class=o>.</span><span class=na>offer</span><span class=o>(</span><span class=n>s</span><span class=o>);</span>

        <span class=k>while</span> <span class=o>(!</span><span class=n>q</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span> <span class=o>{</span>
            <span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=n>q</span><span class=o>.</span><span class=na>poll</span><span class=o>();</span>
            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>w</span> <span class=o>:</span> <span class=n>G</span><span class=o>.</span><span class=na>adj</span><span class=o>(</span><span class=n>v</span><span class=o>))</span>
                <span class=k>if</span> <span class=o>(!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>])</span> <span class=o>{</span>
                    <span class=n>edgeTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span> <span class=o>=</span> <span class=n>v</span><span class=o>;</span>
                    <span class=n>distTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span> <span class=o>=</span> <span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>+</span> <span class=mi>1</span><span class=o>;</span>
                    <span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
                    <span class=n>q</span><span class=o>.</span><span class=na>offer</span><span class=o>(</span><span class=n>w</span><span class=o>);</span>
                <span class=o>}</span><span class=c1>// end if</span>
        <span class=o>}</span> <span class=c1>// end while</span>
    <span class=o>}</span>

    <span class=c1>// Is there a path between the source vertex s and vertex v?</span>
    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>hasPathTo</span><span class=o>(</span><span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>];</span>
    <span class=o>}</span>

    <span class=c1>// Returns the number of edges in a shortest path between </span>
    <span class=c1>// the source vertex s and vertex v, or -1 if no such path.</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>distTo</span><span class=o>(</span><span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(!</span><span class=n>hasPathTo</span><span class=o>(</span><span class=n>v</span><span class=o>))</span> <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=o>;</span>
        <span class=k>return</span> <span class=n>distTo</span><span class=o>[</span><span class=n>v</span><span class=o>];</span>
    <span class=o>}</span>

    <span class=c1>// Returns a shortest path between the source vertex s </span>
    <span class=c1>// and v, or null if no such path.</span>
    <span class=kd>public</span> <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>pathTo</span><span class=o>(</span><span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(!</span><span class=n>hasPathTo</span><span class=o>(</span><span class=n>v</span><span class=o>))</span> <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
        <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>path</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;&gt;();</span>
        <span class=kt>int</span> <span class=n>x</span><span class=o>;</span>
        <span class=k>for</span> <span class=o>(</span><span class=n>x</span> <span class=o>=</span> <span class=n>v</span><span class=o>;</span> <span class=n>distTo</span><span class=o>[</span><span class=n>x</span><span class=o>]</span> <span class=o>!=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>edgeTo</span><span class=o>[</span><span class=n>x</span><span class=o>])</span>
            <span class=n>path</span><span class=o>.</span><span class=na>push</span><span class=o>(</span><span class=n>x</span><span class=o>);</span>
        <span class=n>path</span><span class=o>.</span><span class=na>push</span><span class=o>(</span><span class=n>x</span><span class=o>);</span>
        <span class=k>return</span> <span class=n>path</span><span class=o>;</span>
    <span class=o>}</span>
</pre></div></p>
<h4 id="connected-components">Connected components<a class="headerlink" href="#connected-components" title="Permanent link">&para;</a></h4>
<p>Next direct application of depth-first search is to find the connected components of a graph.</p>
<p><img alt="api_for_connected_components" src="../figures/api_for_connected_components.png" /></p>
<p>Depth-first search to find connected components in a graph:</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CC</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>boolean</span><span class=o>[]</span> <span class=n>marked</span><span class=o>;</span>   <span class=c1>// marked[v] = has vertex v been marked?</span>
    <span class=kd>private</span> <span class=kt>int</span><span class=o>[]</span> <span class=n>id</span><span class=o>;</span>           <span class=c1>// id[v] = id of connected component containing v</span>
    <span class=kd>private</span> <span class=kt>int</span><span class=o>[]</span> <span class=n>size</span><span class=o>;</span>         <span class=c1>// size[id] = number of vertices in given component</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>count</span><span class=o>;</span>          <span class=c1>// number of connected components</span>

    <span class=c1>// Computes the connected components of the undirected graph G.</span>
    <span class=kd>public</span> <span class=nf>CC</span><span class=o>(</span><span class=n>Graph</span> <span class=n>G</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>marked</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=n>id</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=n>size</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>();</span> <span class=n>v</span><span class=o>++)</span>
            <span class=k>if</span> <span class=o>(!</span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>])</span> <span class=o>{</span>
                <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>v</span><span class=o>);</span>
                <span class=n>count</span><span class=o>++;</span>
            <span class=o>}</span>
    <span class=o>}</span>

    <span class=c1>// depth-first search for a Graph</span>
    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>dfs</span><span class=o>(</span><span class=n>Graph</span> <span class=n>G</span><span class=o>,</span> <span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
        <span class=n>id</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>=</span> <span class=n>count</span><span class=o>;</span>
        <span class=n>size</span><span class=o>[</span><span class=n>count</span><span class=o>]++;</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>w</span> <span class=o>:</span> <span class=n>G</span><span class=o>.</span><span class=na>adj</span><span class=o>(</span><span class=n>v</span><span class=o>))</span>
            <span class=k>if</span> <span class=o>(!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>])</span>  <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>w</span><span class=o>);</span>
    <span class=o>}</span>

   <span class=c1>// Returns the component id of the connected component containing vertex v.</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>id</span><span class=o>(</span><span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>id</span><span class=o>[</span><span class=n>v</span><span class=o>];</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<h4 id="cycle">Cycle<a class="headerlink" href="#cycle" title="Permanent link">&para;</a></h4>
<p><a href="../unionfind/">UnionFind</a> and dfs can be used to check whether an undirected graph contains cycle or not. </p>
<p><hh>DFS</hh>: For every visited vertex <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>, if there is an adjacent <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> such that <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> is already visited and <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> is not parent of <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>, then there is a cycle in graph.</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Cycle</span> <span class=o>{</span>

    <span class=kd>private</span> <span class=kt>boolean</span><span class=o>[]</span> <span class=n>marked</span><span class=o>;</span> 
    <span class=kd>private</span> <span class=kt>boolean</span> <span class=n>hasCycle</span><span class=o>;</span>
    <span class=kd>public</span> <span class=nf>Cycle</span><span class=o>(</span><span class=n>Graph</span> <span class=n>G</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>marked</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>s</span> <span class=o>&lt;</span> <span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>();</span> <span class=n>s</span><span class=o>++)</span>
            <span class=k>if</span> <span class=o>(!</span><span class=n>hasCycle</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>marked</span><span class=o>[</span><span class=n>s</span><span class=o>])</span> <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>s</span><span class=o>,</span> <span class=n>s</span><span class=o>);</span> 
    <span class=o>}</span>

    <span class=c1>// u is parent of v, try to visit v&#39;s adjcent</span>
    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>dfs</span><span class=o>(</span><span class=n>Graph</span> <span class=n>G</span><span class=o>,</span> <span class=kt>int</span> <span class=n>v</span><span class=o>,</span> <span class=kt>int</span> <span class=n>u</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>w</span> <span class=o>:</span> <span class=n>G</span><span class=o>.</span><span class=na>adj</span><span class=o>(</span><span class=n>v</span><span class=o>))</span>
            <span class=k>if</span> <span class=o>(!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>])</span> <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>w</span><span class=o>,</span> <span class=n>v</span><span class=o>);</span>
            <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>w</span> <span class=o>!=</span> <span class=n>u</span><span class=o>)</span> <span class=n>hasCycle</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span> 
     <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>hasCycle</span><span class=o>()</span> <span class=o>{</span> 
        <span class=k>return</span> <span class=n>hasCycle</span><span class=o>;</span> 
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<p><hh>UnionFind</hh>: For each edge, make subsets using both the vertices of the edge. If both the vertices are in the same subset, a cycle is found.</p>
<p> <div class=codehilite><pre><span class=kt>boolean</span> <span class=nf>hasCycle</span><span class=o>(</span><span class=n>Graph</span> <span class=n>graph</span><span class=o>)</span> <span class=o>{</span> 
    <span class=c1>// union find</span>
    <span class=n>WeightedQuickUnion</span> <span class=n>union</span> <span class=o>=</span> <span class=k>new</span> <span class=n>WeightedQuickUnion</span><span class=o>(</span><span class=n>graph</span><span class=o>.</span><span class=na>V</span><span class=o>());</span> 

    <span class=c1>// Iterate through all edges of graph, find subset of both </span>
    <span class=c1>// vertices of every edge, if both subsets are same, then </span>
    <span class=c1>// there is cycle in graph. </span>
    <span class=k>for</span> <span class=o>(</span><span class=n>Edge</span> <span class=n>edge</span> <span class=o>:</span> <span class=n>graph</span><span class=o>.</span><span class=na>edges</span><span class=o>())</span> <span class=o>{</span> 
        <span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=n>edge</span><span class=o>.</span><span class=na>either</span><span class=o>(),</span> <span class=n>w</span> <span class=o>=</span> <span class=n>edge</span><span class=o>.</span><span class=na>other</span><span class=o>(</span><span class=n>v</span><span class=o>);</span>
        <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>union</span><span class=o>.</span><span class=na>find</span><span class=o>(</span><span class=n>v</span><span class=o>);</span> 
        <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>union</span><span class=o>.</span><span class=na>find</span><span class=o>(</span><span class=n>j</span><span class=o>);</span> 
        <span class=k>if</span> <span class=o>(</span><span class=n>i</span> <span class=o>==</span> <span class=n>j</span><span class=o>)</span> <span class=k>return</span> <span class=kc>true</span><span class=o>;</span> 
        <span class=n>union</span><span class=o>.</span><span class=na>union</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=n>j</span><span class=o>);</span> 
    <span class=o>}</span> 
    <span class=k>return</span> <span class=kc>false</span><span class=o>;</span> 
<span class=o>}</span> 
</pre></div></p>
<h4 id="bipartite-graph">Bipartite Graph<a class="headerlink" href="#bipartite-graph" title="Permanent link">&para;</a></h4>
<blockquote>
<p>A <em>bipartite graph</em>(<font size=2>二分图</font>) is a graph whose vertices we can divide into two sets such that all edges connect a vertex in one set with a vertex in the other set. </p>
</blockquote>
<p>The figure below gives an example of a bipartite graph, where one set of vertices is colored red and the other set of vertices is colored black.</p>
<p><img alt="bipartite" src="../figures/bipartite-graph.png" /></p>
<p><strong><em>Two-colorability</em></strong> Support this query: Can the vertices of a given graph be assigned one of two colors in such a way that no edge connects vertices of the same color? which is equivalent to this question: <em>Is the graph bipartite</em>?</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Bipartite</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>boolean</span> <span class=n>isBipartite</span><span class=o>;</span>   <span class=c1>// is the graph bipartite?</span>
    <span class=kd>private</span> <span class=kt>boolean</span><span class=o>[]</span> <span class=n>color</span><span class=o>;</span>       <span class=c1>// color[v] gives vertices on one side of bipartition</span>
    <span class=kd>private</span> <span class=kt>boolean</span><span class=o>[]</span> <span class=n>marked</span><span class=o>;</span>      <span class=c1>// marked[v] = true if v has been visited in DFS</span>

    <span class=c1>// Determines whether an undirected graph is bipartite and finds either a</span>
    <span class=c1>// bipartition or an odd-length cycle.</span>
    <span class=kd>public</span> <span class=nf>Bipartite</span><span class=o>(</span><span class=n>Graph</span> <span class=n>G</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>isBipartite</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
        <span class=n>color</span>  <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=n>marked</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>

        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>();</span> <span class=n>v</span><span class=o>++)</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>isBipartite</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>])</span> <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>v</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>dfs</span><span class=o>(</span><span class=n>Graph</span> <span class=n>G</span><span class=o>,</span> <span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span> 
        <span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>w</span> <span class=o>:</span> <span class=n>G</span><span class=o>.</span><span class=na>adj</span><span class=o>(</span><span class=n>v</span><span class=o>))</span> <span class=o>{</span>
            <span class=c1>// if not bipartite</span>
            <span class=k>if</span> <span class=o>(!</span><span class=n>isBipartite</span><span class=o>)</span> <span class=k>return</span><span class=o>;</span>

            <span class=c1>// found uncolored vertex, so recur</span>
            <span class=k>else</span> <span class=k>if</span> <span class=o>(!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>])</span> <span class=o>{</span>
                <span class=n>color</span><span class=o>[</span><span class=n>w</span><span class=o>]</span> <span class=o>=</span> <span class=o>!</span><span class=n>color</span><span class=o>[</span><span class=n>v</span><span class=o>];</span>
                <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>w</span><span class=o>);</span>
            <span class=o>}</span> 
            <span class=c1>// if v, w have same color, not bipartitable</span>
            <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>color</span><span class=o>[</span><span class=n>w</span><span class=o>]</span> <span class=o>==</span> <span class=n>color</span><span class=o>[</span><span class=n>v</span><span class=o>])</span> <span class=n>isBipartite</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=o>}</span>

    <span class=c1>// Returns true if the graph is bipartite.</span>
    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>isBipartite</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>isBipartite</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="directed-graph">Directed Graph<a class="headerlink" href="#directed-graph" title="Permanent link">&para;</a></h3>
<blockquote>
<p>Definition. A <strong>directed graph</strong> (or <em>digraph</em>) is a set of vertices and a collection of <em>directed edges</em>. Each directed edge connects an ordered pair of vertices.</p>
</blockquote>
<h4 id="glossary_1">Glossary<a class="headerlink" href="#glossary_1" title="Permanent link">&para;</a></h4>
<ul>
<li>The <em>outdegree</em>(出度) of a vertex in a digraph is the number of edges going <em>from</em> it. The <em>indegree</em>(入度) of a vertex is the number of edges going to it.</li>
<li>A <em>directed path</em> in a digraph is a sequence of vertices in which there is a (directed) edge pointing from each vertex in the sequence to its successor in the sequence.</li>
<li>A <em>directed cycle</em> is a directed path with at least one edge whose first and last vertices are the same.</li>
<li>The <em>length</em> of a path or a cycle is its number of edges.</li>
<li>A vertex <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> is <em>reachable</em> from a vertex <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> if there is a directed path from <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> to <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span>. Each vertex is reachable from itself.</li>
</ul>
<h4 id="api_1">API<a class="headerlink" href="#api_1" title="Permanent link">&para;</a></h4>
<p>The API below and the class <C>Digraph</C> are virtually identical to those for <C>Graph</C>.</p>
<p><img alt="API_FOR_DIGRAPH" src="../figures/API_FOR_DIGRAPH.png" /></p>
<p>The <C>Digraph</C> data type is identical to <C>Graph</C> except that <C>addEdge</C> only calls <C>add()</C> once, and it has an instance method <C>reverse()</C> that returns a copy with all its edges reversed.</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Digraph</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>V</span><span class=o>;</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>E</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>Bag</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;[]</span> <span class=n>adj</span><span class=o>;</span>

    <span class=kd>public</span> <span class=nf>Digraph</span><span class=o>(</span><span class=kt>int</span> <span class=n>V</span><span class=o>){</span>
        <span class=k>this</span><span class=o>.</span><span class=na>V</span> <span class=o>=</span> <span class=n>V</span><span class=o>;</span>
        <span class=k>this</span><span class=o>.</span><span class=na>E</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
        <span class=n>adj</span> <span class=o>=</span> <span class=o>(</span><span class=n>Bag</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;[])</span> <span class=k>new</span> <span class=n>Bag</span><span class=o>[</span><span class=n>V</span><span class=o>];</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>V</span><span class=o>;</span> <span class=n>v</span><span class=o>++)</span>
            <span class=n>adj</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Bag</span><span class=o>&lt;&gt;();</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>V</span><span class=o>()</span> <span class=o>{</span> <span class=k>return</span> <span class=n>V</span><span class=o>;</span> <span class=o>}</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>E</span><span class=o>()</span> <span class=o>{</span> <span class=k>return</span> <span class=n>E</span><span class=o>;</span> <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>addEdge</span><span class=o>(</span><span class=kt>int</span> <span class=n>v</span><span class=o>,</span> <span class=kt>int</span> <span class=n>w</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>adj</span><span class=o>[</span><span class=n>v</span><span class=o>].</span><span class=na>add</span><span class=o>(</span><span class=n>w</span><span class=o>);</span>
        <span class=n>E</span><span class=o>++;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>adj</span><span class=o>(</span><span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>adj</span><span class=o>[</span><span class=n>v</span><span class=o>];</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=n>Digraph</span> <span class=nf>reverse</span><span class=o>()</span> <span class=o>{</span>
        <span class=n>Digraph</span> <span class=n>R</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Digraph</span><span class=o>(</span><span class=n>V</span><span class=o>);</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>V</span><span class=o>;</span> <span class=n>v</span><span class=o>++)</span>
            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>w</span> <span class=o>:</span> <span class=n>adj</span><span class=o>(</span><span class=n>v</span><span class=o>))</span>
                <span class=n>R</span><span class=o>.</span><span class=na>addEdge</span><span class=o>(</span><span class=n>w</span><span class=o>,</span> <span class=n>v</span><span class=o>);</span>
        <span class=k>return</span> <span class=n>R</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<h4 id="reachability-in-digraphs">Reachability in digraphs<a class="headerlink" href="#reachability-in-digraphs" title="Permanent link">&para;</a></h4>
<p><hh>DFS</hh></p>
<ul>
<li>Single source reachability. Given a digraph and a source vertex <span><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span>, support queries of the form, <em>Is there a directed path from <span><span class="MathJax_Preview">s</span><script type="math/tex">s</script></span> to a given target vertex <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span></em>?</li>
<li>Multiple-source reachability. Given a digraph and a set of source vertices, support queries of the form, <em>Is there a directed path from any vertex in the set to a given target vertex <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span></em>?</li>
</ul>
<p>DFS marks all the vertices in a digraph reachable from a given set of sources in time proportional to the sum of the outdegrees of the vertices marked.</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>DirectedDFS</span> <span class=o>{</span>
    <span class=c1>// marked[v] = true if v is reachable from source(s)</span>
    <span class=kd>private</span> <span class=kt>boolean</span><span class=o>[]</span> <span class=n>marked</span><span class=o>;</span>         

    <span class=c1>// Computes the vertices in digraph G that are</span>
    <span class=c1>// reachable from the source vertex s.</span>
    <span class=kd>public</span> <span class=nf>DirectedDFS</span><span class=o>(</span><span class=n>Digraph</span> <span class=n>G</span><span class=o>,</span> <span class=kt>int</span> <span class=n>s</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>marked</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>s</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=c1>// Computes the vertices in digraph {@code G} that are</span>
    <span class=c1>// connected to any of the source vertices  sources.</span>
    <span class=kd>public</span> <span class=nf>DirectedDFS</span><span class=o>(</span><span class=n>Digraph</span> <span class=n>G</span><span class=o>,</span> <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>sources</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>marked</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>v</span> <span class=o>:</span> <span class=n>sources</span><span class=o>)</span> <span class=o>{</span>
            <span class=k>if</span> <span class=o>(!</span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>])</span> <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>v</span><span class=o>);</span>
        <span class=o>}</span>
    <span class=o>}</span>

    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>dfs</span><span class=o>(</span><span class=n>Digraph</span> <span class=n>G</span><span class=o>,</span> <span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span> 
        <span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>w</span> <span class=o>:</span> <span class=n>G</span><span class=o>.</span><span class=na>adj</span><span class=o>(</span><span class=n>v</span><span class=o>))</span>
            <span class=k>if</span> <span class=o>(!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>])</span> <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>w</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=c1>// Is there a directed path from the source vertex (or any</span>
    <span class=c1>// of the source vertices) and vertex v?</span>
    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>marked</span><span class=o>(</span><span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>];</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<p><hh>Application: Mark-and-sweep garbage collection</hh></p>
<p>An important application of multiple-source reachability is found in typical memory-management systems, including many implementations of Java. A digraph where each vertex represents an object and each edge represents a reference to an object is an appropriate model for the memory usage of a running Java program. A mark-and-sweep garbage collection strategy reserves one bit per object for the purpose of garbage collection, then periodically marks the set of potentially accessible objects by running a digraph reachability algorithm like <C>DirectedDFS</C> and sweeps through all objects, collecting the unmarked ones for use for new objects.</p>
<p><img alt="mark-sweep-garbage-collection" src="../figures/mark-sweep-garbage-collection.png" /></p>
<h4 id="dfs-edge-classification">DFS Edge Classification<a class="headerlink" href="#dfs-edge-classification" title="Permanent link">&para;</a></h4>
<p><a href="https://courses.csail.mit.edu/6.006/fall11/rec/rec14.pdf">MIT 6.006 Introduction to Algorithms</a></p>
<p>The edges which dfs traverse can be classified into four edge types. During a DFS execution, the classification of edge (<span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>, <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>), the edge from vertex <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> to vertex <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>, depends on whether we have visited <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> before in the DFS and if so, the relationship between <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> and <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>.</p>
<ol>
<li>If <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> is visited for the first time as we traverse the edge (<span><span class="MathJax_Preview">u, v</span><script type="math/tex">u, v</script></span>), then the edge is a tree edge. </li>
<li>Else, <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> has already been visited:<ul>
<li>If <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> is an ancestor of <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>, then edge (<span><span class="MathJax_Preview">u, v</span><script type="math/tex">u, v</script></span>) is a <em>back edge</em>.</li>
<li>Else, if <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> is a descendant of <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>, then edge (<span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>, <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>) is a <em>forward edge</em>.</li>
<li>Else, if <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> is neither an ancestor or descendant of <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>, then edge (<span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>, <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>) is a <em>cross edge</em>.</li>
</ul>
</li>
</ol>
<h4 id="cycles-and-dags">Cycles and DAGs<a class="headerlink" href="#cycles-and-dags" title="Permanent link">&para;</a></h4>
<p>Directed cycle detection: Does a given digraph have a directed cycle? If so, find the vertices on some such cycle, in order from some vertex back to itself.</p>
<blockquote>
<p>Definition. A <strong>directed acyclic graph</strong> (DAG, 有向无环图) is a digraph with no directed cycles.</p>
</blockquote>
<p>Developing a dfs-based solution to this problem is not difficult, based on the fact that the recursive call stack maintained by the system represents the “current” directed path under consideration. If we ever find a directed edge <span><span class="MathJax_Preview">v\rightarrow w</span><script type="math/tex">v\rightarrow w</script></span> to a vertex <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> that is on that stack, we have found a cycle, since the stack is evidence of a directed path from <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> to <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>, and the edge <span><span class="MathJax_Preview">v\rightarrow w</span><script type="math/tex">v\rightarrow w</script></span>(<em>back edge</em>) completes the cycle.</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>DirectedCycle</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>boolean</span><span class=o>[]</span> <span class=n>marked</span><span class=o>;</span>        <span class=c1>// marked[v] = has vertex v been marked?</span>
    <span class=kd>private</span> <span class=kt>int</span><span class=o>[]</span> <span class=n>edgeTo</span><span class=o>;</span>            <span class=c1>// edgeTo[v] = previous vertex on path to v</span>
    <span class=kd>private</span> <span class=kt>boolean</span><span class=o>[]</span> <span class=n>onStack</span><span class=o>;</span>       <span class=c1>// onStack[v] = is vertex on the stack?</span>
    <span class=kd>private</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>cycle</span><span class=o>;</span>    <span class=c1>// directed cycle (or null if no such cycle)</span>

    <span class=c1>// Determines whether the digraph G has a directed cycle and, </span>
    <span class=c1>// if so, finds such a cycle.</span>
    <span class=kd>public</span> <span class=nf>DirectedCycle</span><span class=o>(</span><span class=n>Digraph</span> <span class=n>G</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>marked</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=n>onStack</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=n>edgeTo</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>();</span> <span class=n>v</span><span class=o>++)</span>
            <span class=k>if</span> <span class=o>(!</span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>&amp;&amp;</span> <span class=n>cycle</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>v</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=c1>// check that algorithm computes either the topological order or finds a directed cycle</span>
    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>dfs</span><span class=o>(</span><span class=n>Digraph</span> <span class=n>G</span><span class=o>,</span> <span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>onStack</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
        <span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>w</span> <span class=o>:</span> <span class=n>G</span><span class=o>.</span><span class=na>adj</span><span class=o>(</span><span class=n>v</span><span class=o>))</span> <span class=o>{</span>
            <span class=c1>// short circuit if directed cycle found</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>cycle</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=k>return</span><span class=o>;</span>
            <span class=c1>// found new vertex, so recur</span>
            <span class=k>else</span> <span class=k>if</span> <span class=o>(!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>])</span> <span class=o>{</span>
                <span class=n>edgeTo</span><span class=o>[</span><span class=n>w</span><span class=o>]</span> <span class=o>=</span> <span class=n>v</span><span class=o>;</span>
                <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>w</span><span class=o>);</span>
            <span class=o>}</span>
            <span class=c1>// trace back directed cycle</span>
            <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>onStack</span><span class=o>[</span><span class=n>w</span><span class=o>])</span> <span class=o>{</span>
                <span class=n>cycle</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;();</span>
                <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=n>v</span><span class=o>;</span> <span class=n>x</span> <span class=o>!=</span> <span class=n>w</span><span class=o>;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>edgeTo</span><span class=o>[</span><span class=n>x</span><span class=o>])</span>
                    <span class=n>cycle</span><span class=o>.</span><span class=na>push</span><span class=o>(</span><span class=n>x</span><span class=o>);</span>
                <span class=n>cycle</span><span class=o>.</span><span class=na>push</span><span class=o>(</span><span class=n>w</span><span class=o>);</span>
                <span class=n>cycle</span><span class=o>.</span><span class=na>push</span><span class=o>(</span><span class=n>v</span><span class=o>);</span>
            <span class=o>}</span>
        <span class=o>}</span>
        <span class=n>onStack</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<p>When executing <C>dfs(G, v)</C>, we have followed a directed path from the source to <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>. To keep track of this path, <C>DirectedCycle</C> maintains a vertex-indexed array <C>onStack[]</C> that marks the vertices on the recursive call stack (by setting <C>onStack[v]</C> to true on entry to <C>dfs(G, v)</C> and to false on exit). <C>DirectedCycle</C> also maintains an <C>edgeTo[]</C> array so that it can return the cycle when it is detected.</p>
<h4 id="topological-sort">Topological Sort<a class="headerlink" href="#topological-sort" title="Permanent link">&para;</a></h4>
<blockquote>
<p>Topological sort. Given a digraph, put the vertices in order such that all its directed edges point from a vertex earlier in the order to a vertex later in the order (or report that doing so is not possible).</p>
</blockquote>
<p>Example: All edges point down, so it clearly represents a solution to the precedence-constrained scheduling problem that this digraph models: the student can satisfy all course prerequisites by taking the courses in this order.</p>
<p><img alt="topological_sort" src="../figures/topological_sort.png" /></p>
<p>A digraph has a topological order if and only if it is a DAG. To get the topological order:</p>
<ul>
<li>Run depth-first search.</li>
<li>Return vertices in reverse postorder.</li>
</ul>
<p><hh>DFS Order</hh></p>
<p>Three vertex orderings of dfs are of interest in typical applications:</p>
<ul>
<li>Preorder: Put the vertex on a queue before the recursive calls.<ul>
<li>for course schedule, [0, 5, 4, 1, 6, 9, 12, 11, 10, 2, 3, 7, 8] </li>
</ul>
</li>
<li>Postorder: Put the vertex on a queue after the recursive calls.<ul>
<li>for course schedule, [4, 5, 1, 12, 11, 10, 9, 6, 0, 3, 2, 7, 8]</li>
</ul>
</li>
<li>Reverse postorder: Put the vertex on a stack after the recursive calls.<ul>
<li>for course schedule, [8, 7, 2, 3, 0, 6, 9, 10, 11, 12, 1, 5, 4]</li>
</ul>
</li>
</ul>
<p> <div class=codehilite><pre><span class=cm>/**</span>
<span class=cm> *  The DFSOrder class represents a data type for</span>
<span class=cm> *  determining depth-first search ordering of the vertices in a digraph</span>
<span class=cm> *  or edge-weighted digraph, including preorder, postorder, and reverse postorder.</span>
<span class=cm> */</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>DFSOrder</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>boolean</span><span class=o>[]</span> <span class=n>marked</span><span class=o>;</span>          <span class=c1>// marked[v] = has v been marked in dfs?</span>
    <span class=kd>private</span> <span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>preorder</span><span class=o>;</span>   <span class=c1>// vertices in preorder</span>
    <span class=kd>private</span> <span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>postorder</span><span class=o>;</span>  <span class=c1>// vertices in postorder</span>

    <span class=cm>/**</span>
<span class=cm>     * Determines a depth-first order for the digraph {@code G}.</span>
<span class=cm>     */</span>
    <span class=kd>public</span> <span class=nf>DFSOrder</span><span class=o>(</span><span class=n>Digraph</span> <span class=n>G</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>postorder</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span>
        <span class=n>preorder</span>  <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span>
        <span class=n>marked</span>    <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>();</span> <span class=n>v</span><span class=o>++)</span>
            <span class=k>if</span> <span class=o>(!</span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>])</span> <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>v</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=c1>// run DFS in digraph G from vertex v and compute preorder/postorder</span>
    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>dfs</span><span class=o>(</span><span class=n>Digraph</span> <span class=n>G</span><span class=o>,</span> <span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
        <span class=n>preorder</span><span class=o>.</span><span class=na>offer</span><span class=o>(</span><span class=n>v</span><span class=o>);</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>w</span> <span class=o>:</span> <span class=n>G</span><span class=o>.</span><span class=na>adj</span><span class=o>(</span><span class=n>v</span><span class=o>))</span>
            <span class=k>if</span> <span class=o>(!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>])</span> <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>w</span><span class=o>);</span>
        <span class=n>postorder</span><span class=o>.</span><span class=na>offer</span><span class=o>(</span><span class=n>v</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=c1>// Returns the vertices in postorder.</span>
    <span class=kd>public</span> <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>post</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>postorder</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=c1>// Returns the vertices in preorder.</span>
    <span class=kd>public</span> <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>pre</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>preorder</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=c1>// Returns the vertices in reverse postorder.</span>
    <span class=kd>public</span> <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>reversePost</span><span class=o>()</span> <span class=o>{</span>
        <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>reverse</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;(</span><span class=n>postorder</span><span class=o>);</span>
        <span class=n>Collections</span><span class=o>.</span><span class=na>reverse</span><span class=o>(</span><span class=n>reverse</span><span class=o>);</span>
        <span class=k>return</span> <span class=n>reverse</span><span class=o>;</span>
    <span class=o>}</span>

<span class=o>}</span>
</pre></div></p>
<div class="admonition proposition">
<p class="admonition-title">Proposition</p>
<p>Reverse postorder in a DAG is a topological sort.</p>
<p>Proof: Consider any edge <span><span class="MathJax_Preview">v\rightarrow w</span><script type="math/tex">v\rightarrow w</script></span>. One of the following three cases must hold when <C>dfs(v)</C> is called:</p>
<ul>
<li><C>dfs(w)</C> has already been called and has returned (<span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> is marked). </li>
<li>
<p><C>dfs(w)</C> has not yet been called (<span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> is unmarked), so <span><span class="MathJax_Preview">v\rightarrow w</span><script type="math/tex">v\rightarrow w</script></span> will cause <C>dfs(w)</C> to be called (and return), either directly or indirectly, before <C>dfs(v)</C> returns.</p>
</li>
<li>
<p><C>dfs(w)</C> has been called and has not yet returned when <C>dfs(v)</C> is called. The key to the proof is that this case is impossible in a DAG, because the recursive call chain implies a path from <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> to <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> and <span><span class="MathJax_Preview">v\rightarrow w</span><script type="math/tex">v\rightarrow w</script></span> would complete a directed cycle.</p>
</li>
</ul>
</div>
<p>With DFS, we can topologically sort a DAG in time proportional to <span><span class="MathJax_Preview">|V|+|E|</span><script type="math/tex">|V|+|E|</script></span>.</p>
<h4 id="dfs-edge-classification_1">DFS Edge Classification<a class="headerlink" href="#dfs-edge-classification_1" title="Permanent link">&para;</a></h4>
<p><a href="https://courses.csail.mit.edu/6.006/fall11/rec/rec14.pdf">MIT 6.006 Introduction to Algorithms</a></p>
<p>The edges which dfs traverse can be classified into four edge types. During a DFS execution, the classification of edge (<span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>, <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span>), the edge from vertex <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span> to vertex <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> is classified as:</p>
<ol>
<li>If <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> is visited for the first time as we traverse the edge (<span><span class="MathJax_Preview">u, w</span><script type="math/tex">u, w</script></span>), then the edge is a <em>tree edge</em>. </li>
<li>
<p>Else, <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> has already been visited:</p>
<ul>
<li>If <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> is an ancestor of <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>, then edge (<span><span class="MathJax_Preview">u, w</span><script type="math/tex">u, w</script></span>) is a <em>back edge</em>.</li>
<li>Else, if <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> is a descendant of <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>, then edge (<span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>, <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span>) is a <em>forward edge</em>.</li>
<li>Else, if <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> is neither an ancestor or descendant of <span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>, then edge (<span><span class="MathJax_Preview">u</span><script type="math/tex">u</script></span>, <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span>) is a <em>cross edge</em>.</li>
</ul>
</li>
</ol>
<p><img alt="" src="../figures/edge_classification.png" /></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>EdgeClassification</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>boolean</span><span class=o>[]</span> <span class=n>marked</span><span class=o>;</span> <span class=c1>// marked[v] = v has been marked in dfs?</span>
    <span class=kd>private</span> <span class=kt>boolean</span><span class=o>[]</span> <span class=n>finish</span><span class=o>;</span> <span class=c1>// finish[v] = v has been finished visit in dfs?</span>
    <span class=kd>private</span> <span class=kt>int</span><span class=o>[]</span> <span class=n>start</span><span class=o>;</span>      <span class=c1>// start[v] = start time of visit v.</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>order</span><span class=o>;</span>       <span class=c1>// visit order of dfs</span>
    <span class=kd>private</span> <span class=n>Map</span><span class=o>&lt;</span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;,</span> <span class=n>String</span><span class=o>&gt;</span> <span class=n>edges</span><span class=o>;</span> <span class=c1>// edge classification of graph</span>

    <span class=c1>// Classify edges of the given graph.</span>
    <span class=kd>public</span> <span class=nf>EdgeClassification</span><span class=o>(</span><span class=n>Digraph</span> <span class=n>G</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>// initialize</span>
        <span class=n>marked</span>    <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=n>finish</span>  <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=n>start</span>   <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>()];</span>
        <span class=n>edges</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashMap</span><span class=o>&lt;&gt;();</span>

        <span class=c1>// dfs</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>v</span> <span class=o>&lt;</span> <span class=n>G</span><span class=o>.</span><span class=na>V</span><span class=o>();</span> <span class=n>v</span><span class=o>++)</span>
            <span class=k>if</span> <span class=o>(!</span><span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>])</span> <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>v</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=c1>// run DFS in digraph G</span>
    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>dfs</span><span class=o>(</span><span class=n>Digraph</span> <span class=n>G</span><span class=o>,</span> <span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>start</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>=</span> <span class=n>order</span><span class=o>++;</span>
        <span class=n>marked</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>w</span> <span class=o>:</span> <span class=n>G</span><span class=o>.</span><span class=na>adj</span><span class=o>(</span><span class=n>v</span><span class=o>))</span>
            <span class=k>if</span> <span class=o>(!</span><span class=n>marked</span><span class=o>[</span><span class=n>w</span><span class=o>])</span> <span class=o>{</span> <span class=n>edges</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=n>v</span><span class=o>,</span> <span class=n>w</span><span class=o>),</span> <span class=s>&quot;tree edge&quot;</span><span class=o>);</span>  <span class=n>dfs</span><span class=o>(</span><span class=n>G</span><span class=o>,</span> <span class=n>w</span><span class=o>);</span> <span class=o>}</span>
            <span class=k>else</span> <span class=k>if</span> <span class=o>(!</span><span class=n>finish</span><span class=o>[</span><span class=n>w</span><span class=o>])</span> <span class=n>edges</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=n>v</span><span class=o>,</span> <span class=n>w</span><span class=o>),</span> <span class=s>&quot;back edge&quot;</span><span class=o>);</span>
            <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>start</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>&lt;</span> <span class=n>start</span><span class=o>[</span><span class=n>w</span><span class=o>])</span> <span class=n>edges</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=n>v</span><span class=o>,</span> <span class=n>w</span><span class=o>),</span> <span class=s>&quot;forward edge&quot;</span><span class=o>);</span>
            <span class=k>else</span> <span class=n>edges</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=n>v</span><span class=o>,</span> <span class=n>w</span><span class=o>),</span> <span class=s>&quot;cross edge&quot;</span><span class=o>);</span>
        <span class=n>finish</span><span class=o>[</span><span class=n>v</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=n>Map</span><span class=o>&lt;</span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;,</span> <span class=n>String</span><span class=o>&gt;</span> <span class=nf>getEdgesClass</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>edges</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<h4 id="strong-connectivity-in-digraphs">Strong connectivity in digraphs<a class="headerlink" href="#strong-connectivity-in-digraphs" title="Permanent link">&para;</a></h4>
<blockquote>
<p>Definition. Two vertices <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> and <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> are <em>strongly connected</em> if they are mutually reachable: that is, if there is a directed path from <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> to <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> and a directed path from <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> to <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>. A digraph is <em>strongly connected</em> if all its vertices are strongly connected to one another.</p>
</blockquote>
<h3 id="application-wordnet">Application: WordNet<a class="headerlink" href="#application-wordnet" title="Permanent link">&para;</a></h3>
<p><a href="http://wordnet.princeton.edu/">WordNet</a> is a semantic lexicon for the English language that computational linguists and cognitive scientists use extensively. WordNet groups words into sets of synonyms called <em>synsets</em>. For example, { AND circuit, AND gate } is a synset that represent a logical gate that ﬁres only when all of its inputs ﬁre. WordNet also describes semantic relationships between synsets. One such relationship is the is-a relationship, which connects a <em>hyponym</em> (more specific synset, 下位词) to a <em>hypernym</em> (more general synset, 上位词). For example, the synset { gate, logic gate } is a hypernym of { AND circuit, AND gate } because an AND gate is a kind of logic gate.</p>
<h4 id="the-wordnet-digraph">The WordNet digraph<a class="headerlink" href="#the-wordnet-digraph" title="Permanent link">&para;</a></h4>
<p>WordNet digraph: each vertex <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> is an integer that represents a synset, and each directed edge <span><span class="MathJax_Preview">v\rightarrow w</span><script type="math/tex">v\rightarrow w</script></span> represents that <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> is a hypernym of <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>. The WordNet digraph is a rooted DAG: it is acyclic and has one vertex—the root—that is an ancestor of every other vertex. However, it is not necessarily a tree because a synset can have more than one hypernym. A small subgraph of the WordNet digraph appears below.</p>
<p><img alt="" src="../figures/wordNetGraph.jpg" /></p>
<p><hh>The WordNet input ﬁle formats</hh></p>
<p>WordNet digraph files are in comma-separated values (CSV) format: each line contains a sequence of fields, separated by commas.</p>
<ul>
<li>List of synsets. Synsets file contains all noun synsets in WordNet, one per line.</li>
<li>List of hypernyms. Hypernyms file contains the hypernym relationships.</li>
</ul>
<p><details><summary>Click Here to View Code</summary></p>
<p> <div class=codehilite><pre><span class=cm>/**</span>
<span class=cm> * WordNet digraph.</span>
<span class=cm> * Each vertex v is an integer that represents a synset,</span>
<span class=cm> * and each directed edge v-&gt;w represents that w is a hypernym of v.</span>
<span class=cm> *</span>
<span class=cm> */</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>WordNet</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=n>Digraph</span> <span class=n>digraph</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>HashMap</span><span class=o>&lt;</span><span class=n>String</span><span class=o>,</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>wordsMap</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>wordsList</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>SAP</span> <span class=n>sap</span><span class=o>;</span>


    <span class=cm>/**</span>
<span class=cm>     * constructor takes the name of the two input files</span>
<span class=cm>     * @param synsets: synset file</span>
<span class=cm>     * @param hypernyms: hypernym file,</span>
<span class=cm>     *   Line i of the file (counting from 0) contains the hypernyms of synset i.</span>
<span class=cm>     *   The first field is the synset id, which is always the integer i;</span>
<span class=cm>     *   subsequent fields are the id numbers of the synset’s hypernyms.</span>
<span class=cm>     * @throws IllegalArgumentException if argument is null,</span>
<span class=cm>     *  or the input does not correspond to a rooted DAG.</span>
<span class=cm>     */</span>
    <span class=kd>public</span> <span class=nf>WordNet</span><span class=o>(</span><span class=n>String</span> <span class=n>synsets</span><span class=o>,</span> <span class=n>String</span> <span class=n>hypernyms</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>synsets</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>hypernyms</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>();</span>
        <span class=n>In</span> <span class=n>in</span> <span class=o>=</span> <span class=k>new</span> <span class=n>In</span><span class=o>(</span><span class=n>synsets</span><span class=o>);</span>
        <span class=n>Integer</span> <span class=n>id</span><span class=o>;</span>
        <span class=n>String</span> <span class=n>line</span><span class=o>;</span>
        <span class=n>String</span><span class=o>[]</span> <span class=n>line_seg</span><span class=o>,</span> <span class=n>words</span><span class=o>;</span>

        <span class=c1>// read synsets</span>
        <span class=n>wordsMap</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashMap</span><span class=o>&lt;&gt;();</span>
        <span class=n>wordsList</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
        <span class=k>while</span> <span class=o>(</span><span class=n>in</span><span class=o>.</span><span class=na>hasNextLine</span><span class=o>())</span> <span class=o>{</span>
            <span class=n>line</span> <span class=o>=</span> <span class=n>in</span><span class=o>.</span><span class=na>readLine</span><span class=o>();</span>
            <span class=n>line_seg</span> <span class=o>=</span> <span class=n>line</span><span class=o>.</span><span class=na>split</span><span class=o>(</span><span class=s>&quot;,&quot;</span><span class=o>);</span>
            <span class=n>id</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>.</span><span class=na>parseInt</span><span class=o>(</span><span class=n>line_seg</span><span class=o>[</span><span class=mi>0</span><span class=o>]);</span>
            <span class=n>words</span> <span class=o>=</span> <span class=n>line_seg</span><span class=o>[</span><span class=mi>1</span><span class=o>].</span><span class=na>split</span><span class=o>(</span><span class=s>&quot;\\s&quot;</span><span class=o>);</span>
            <span class=c1>// put every word into wordsMap</span>
            <span class=k>for</span> <span class=o>(</span><span class=n>String</span> <span class=n>word</span> <span class=o>:</span> <span class=n>words</span><span class=o>)</span> <span class=o>{</span>
                <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=n>wordsMap</span><span class=o>.</span><span class=na>getOrDefault</span><span class=o>(</span><span class=n>word</span><span class=o>,</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;());</span>
                <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>id</span><span class=o>);</span>
                <span class=n>wordsMap</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>word</span><span class=o>,</span> <span class=n>list</span><span class=o>);</span>
            <span class=o>}</span>
            <span class=c1>// put entire word into a list</span>
            <span class=n>wordsList</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>line_seg</span><span class=o>[</span><span class=mi>1</span><span class=o>]);</span>
        <span class=o>}</span>

        <span class=c1>// read hypernyms</span>
        <span class=n>digraph</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Digraph</span><span class=o>(</span><span class=n>wordsList</span><span class=o>.</span><span class=na>size</span><span class=o>());</span>
        <span class=n>in</span> <span class=o>=</span> <span class=k>new</span> <span class=n>In</span><span class=o>(</span><span class=n>hypernyms</span><span class=o>);</span>
        <span class=k>while</span> <span class=o>(</span><span class=n>in</span><span class=o>.</span><span class=na>hasNextLine</span><span class=o>())</span> <span class=o>{</span>
            <span class=n>line</span> <span class=o>=</span> <span class=n>in</span><span class=o>.</span><span class=na>readLine</span><span class=o>();</span>
            <span class=n>line_seg</span> <span class=o>=</span> <span class=n>line</span><span class=o>.</span><span class=na>split</span><span class=o>(</span><span class=s>&quot;,&quot;</span><span class=o>);</span>
            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>line_seg</span><span class=o>.</span><span class=na>length</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
                <span class=n>digraph</span><span class=o>.</span><span class=na>addEdge</span><span class=o>(</span><span class=n>Integer</span><span class=o>.</span><span class=na>parseInt</span><span class=o>(</span><span class=n>line_seg</span><span class=o>[</span><span class=mi>0</span><span class=o>]),</span> <span class=n>Integer</span><span class=o>.</span><span class=na>parseInt</span><span class=o>(</span><span class=n>line_seg</span><span class=o>[</span><span class=n>i</span><span class=o>]));</span>
        <span class=o>}</span>

        <span class=n>assertRootedDag</span><span class=o>();</span>
        <span class=n>assertNoCycle</span><span class=o>();</span>
        <span class=n>sap</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SAP</span><span class=o>(</span><span class=n>digraph</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=cm>/**</span>
<span class=cm>     * assert digraph has no cycle</span>
<span class=cm>     * @throws IllegalArgumentException if it has a cycle.</span>
<span class=cm>     */</span>
    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>assertNoCycle</span><span class=o>()</span> <span class=o>{</span>
        <span class=c1>// assert the graph NOT contain a cycle</span>
        <span class=n>DirectedCycle</span> <span class=n>directedCycle</span> <span class=o>=</span> <span class=k>new</span> <span class=n>DirectedCycle</span><span class=o>(</span><span class=n>digraph</span><span class=o>);</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>directedCycle</span><span class=o>.</span><span class=na>hasCycle</span><span class=o>())</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&quot;The input graph has a cycle!&quot;</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=cm>/**</span>
<span class=cm>     * assert digraph is a rooted dag.</span>
<span class=cm>     * @throws IllegalArgumentException if it is NOT.</span>
<span class=cm>     */</span>
    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>assertRootedDag</span><span class=o>()</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>numOfRoot</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=c1>// the number of the root, which has no parent</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>vertex</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>vertex</span> <span class=o>&lt;</span> <span class=n>digraph</span><span class=o>.</span><span class=na>V</span><span class=o>();</span> <span class=n>vertex</span><span class=o>++)</span>
            <span class=c1>// a rooted dag has zero outdegree.</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>digraph</span><span class=o>.</span><span class=na>outdegree</span><span class=o>(</span><span class=n>vertex</span><span class=o>)</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
                <span class=k>if</span> <span class=o>(</span><span class=n>numOfRoot</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=n>numOfRoot</span><span class=o>++;</span>
                <span class=k>else</span> <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&quot;The digraph is NOT a rooted DAG! It has more than one root.&quot;</span><span class=o>);</span>
            <span class=o>}</span>
    <span class=o>}</span>

    <span class=cm>/**</span>
<span class=cm>     * returns all WordNet nouns</span>
<span class=cm>     * @return a list of wordnet nouns</span>
<span class=cm>     */</span>
    <span class=kd>public</span> <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=nf>nouns</span><span class=o>()</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>wordsMap</span><span class=o>.</span><span class=na>keySet</span><span class=o>();</span>
    <span class=o>}</span>

    <span class=cm>/**</span>
<span class=cm>     * Is the word a WordNet noun?</span>
<span class=cm>     * @param word: a string represent a word</span>
<span class=cm>     * @return: true if the word is a WordNet noun, otherwise false</span>
<span class=cm>     * @throws IllegalArgumentException if word is null.</span>
<span class=cm>     *</span>
<span class=cm>     */</span>
    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>isNoun</span><span class=o>(</span><span class=n>String</span> <span class=n>word</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>word</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>();</span>
        <span class=k>return</span> <span class=n>wordsMap</span><span class=o>.</span><span class=na>containsKey</span><span class=o>(</span><span class=n>word</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=cm>/**</span>
<span class=cm>     * Distance between nounA and nounB.</span>
<span class=cm>     *</span>
<span class=cm>     * Defined as the length of shortest ancestral path of subsets A and B,</span>
<span class=cm>     * where A/B denotes sets of synsets in which nounA/nounB appears.</span>
<span class=cm>     *</span>
<span class=cm>     * @param nounA : a noun</span>
<span class=cm>     * @param nounB: a noun</span>
<span class=cm>     * @return an integer, which denotes the distance between nounA and nounB</span>
<span class=cm>     * @throws IllegalArgumentException if any of nouns is null,</span>
<span class=cm>     *      or any of nouns is NOT a WordNet noun.</span>
<span class=cm>     *</span>
<span class=cm>     */</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>distance</span><span class=o>(</span><span class=n>String</span> <span class=n>nounA</span><span class=o>,</span> <span class=n>String</span> <span class=n>nounB</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(!</span><span class=n>isNoun</span><span class=o>(</span><span class=n>nounA</span><span class=o>)</span> <span class=o>||</span> <span class=o>!</span><span class=n>isNoun</span><span class=o>(</span><span class=n>nounB</span><span class=o>))</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>();</span>
        <span class=kt>int</span> <span class=n>minlength</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>.</span><span class=na>MAX_VALUE</span><span class=o>,</span> <span class=n>length</span><span class=o>;</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>vertexA</span> <span class=o>:</span> <span class=n>wordsMap</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>nounA</span><span class=o>))</span>
            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>vertexB</span> <span class=o>:</span> <span class=n>wordsMap</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>nounB</span><span class=o>))</span> <span class=o>{</span>
                <span class=n>length</span> <span class=o>=</span> <span class=n>sap</span><span class=o>.</span><span class=na>length</span><span class=o>(</span><span class=n>vertexA</span><span class=o>,</span> <span class=n>vertexB</span><span class=o>);</span>
                <span class=k>if</span> <span class=o>(</span><span class=n>length</span> <span class=o>&lt;</span> <span class=n>minlength</span><span class=o>)</span> <span class=n>minlength</span> <span class=o>=</span> <span class=n>length</span><span class=o>;</span>
            <span class=o>}</span>
        <span class=k>return</span> <span class=n>minlength</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=cm>/**</span>
<span class=cm>     *  A synset (second field of synsets.txt) that is the common ancestor of nounA and nounB</span>
<span class=cm>     *     in a shortest ancestral path.</span>
<span class=cm>     * @param nounA: a noun</span>
<span class=cm>     * @param nounB: a noun</span>
<span class=cm>     * @return a synset</span>
<span class=cm>     * @throws IllegalArgumentException if any of nouns is null,</span>
<span class=cm>     *      or any of nouns is NOT a WordNet noun.</span>
<span class=cm>     */</span>
    <span class=kd>public</span> <span class=n>String</span> <span class=nf>sap</span><span class=o>(</span><span class=n>String</span> <span class=n>nounA</span><span class=o>,</span> <span class=n>String</span> <span class=n>nounB</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(!</span><span class=n>isNoun</span><span class=o>(</span><span class=n>nounA</span><span class=o>)</span> <span class=o>||</span> <span class=o>!</span><span class=n>isNoun</span><span class=o>(</span><span class=n>nounB</span><span class=o>))</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>();</span>
        <span class=kt>int</span> <span class=n>minlength</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>.</span><span class=na>MAX_VALUE</span><span class=o>,</span> <span class=n>length</span><span class=o>;</span>
        <span class=kt>int</span> <span class=n>minVertexA</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>minVertexB</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>vertexA</span> <span class=o>:</span> <span class=n>wordsMap</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>nounA</span><span class=o>))</span>
            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>vertexB</span> <span class=o>:</span> <span class=n>wordsMap</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>nounB</span><span class=o>))</span> <span class=o>{</span>
                <span class=n>length</span> <span class=o>=</span> <span class=n>sap</span><span class=o>.</span><span class=na>length</span><span class=o>(</span><span class=n>vertexA</span><span class=o>,</span> <span class=n>vertexB</span><span class=o>);</span>
                <span class=k>if</span> <span class=o>(</span><span class=n>length</span> <span class=o>&lt;</span> <span class=n>minlength</span><span class=o>)</span> <span class=o>{</span>
                    <span class=n>minlength</span> <span class=o>=</span> <span class=n>length</span><span class=o>;</span>
                    <span class=n>minVertexA</span> <span class=o>=</span> <span class=n>vertexA</span><span class=o>;</span>
                    <span class=n>minVertexB</span> <span class=o>=</span> <span class=n>vertexB</span><span class=o>;</span>
                <span class=o>}</span>
            <span class=o>}</span>

        <span class=k>return</span> <span class=n>wordsList</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>sap</span><span class=o>.</span><span class=na>ancestor</span><span class=o>(</span><span class=n>minVertexA</span><span class=o>,</span> <span class=n>minVertexB</span><span class=o>));</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<p></details></p>
<h4 id="shortest-ancestral-path">Shortest ancestral path<a class="headerlink" href="#shortest-ancestral-path" title="Permanent link">&para;</a></h4>
<p>An <em>ancestral path</em> between two vertices <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> and <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> in a digraph is a directed path from <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> to a common ancestor <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>, together with a directed path from <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> to the same ancestor <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>. A <em>shortest ancestral path</em> is an ancestral path of minimum total length. We refer to the common ancestor in a shortest ancestral path as a <em>shortest common ancestor</em>.</p>
<p><img alt="" src="../figures/shortestCommonAncestor.jpg" /></p>
<p>We could generalize the notion of shortest common ancestor to <em>subsets</em> of vertices. A shortest ancestral path of two subsets of vertices A and B is a shortest ancestral path over all pairs of vertices <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> and <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span>, with <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> in A and <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> in B. The figure below shows an example in which, for two subsets, red and blue, there are several (but not all) ancestral paths, including the shortest one.</p>
<p><img alt="" src="../figures/shortestCommonAncestorForTwoSubsets.jpg" /></p>
<p>In order to find shortest common ancestor, run the two breadth-first searches from <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> and <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span> in <em>lockstep</em> (alternating back and forth between exploring vertices in each of the two searches), then terminate the BFS from <span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> (or <span><span class="MathJax_Preview">w</span><script type="math/tex">w</script></span>) as soon as the distance exceeds the length of the best ancestral path found so far. </p>
<p>In order to speed up the query, we could implement a software cache of recently computed <C>length()</C> and <C>ancestor()</C> queries.</p>
<p><details><summary>Click Here to View Code</summary></p>
<p> <div class=codehilite><pre><span class=cm>/**</span>
<span class=cm> * Shortest ancestral path.</span>
<span class=cm> */</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>SAP</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=n>Digraph</span> <span class=n>digraph</span><span class=o>;</span>
    <span class=kd>private</span> <span class=n>LRUCache</span> <span class=n>cache</span><span class=o>;</span>

    <span class=cm>/**</span>
<span class=cm>     * constructor takes a digraph (not necessarily a DAG)</span>
<span class=cm>     * @param G: an digraph</span>
<span class=cm>     */</span>
    <span class=kd>public</span> <span class=nf>SAP</span><span class=o>(</span><span class=n>Digraph</span> <span class=n>G</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>//make a deep copy of G</span>
        <span class=n>digraph</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Digraph</span><span class=o>(</span><span class=n>G</span><span class=o>);</span>
        <span class=n>cache</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LRUCache</span><span class=o>(</span><span class=mi>100</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=cm>/**</span>
<span class=cm>     *  length of shortest ancestral path between v and w;</span>
<span class=cm>     *  -1 if no such path</span>
<span class=cm>     * @param v: a vertex</span>
<span class=cm>     * @param w: a vertex</span>
<span class=cm>     * @throws IllegalArgumentException if any of the vertex is out of range</span>
<span class=cm>     */</span>
    <span class=c1>// -1 if no such path</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>length</span><span class=o>(</span><span class=kt>int</span> <span class=n>v</span><span class=o>,</span> <span class=kt>int</span> <span class=n>w</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>// validate vertex</span>
        <span class=n>validateVertex</span><span class=o>(</span><span class=n>v</span><span class=o>);</span>
        <span class=n>validateVertex</span><span class=o>(</span><span class=n>w</span><span class=o>);</span>

        <span class=c1>// already calculated?</span>
        <span class=kt>int</span><span class=o>[]</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[]{</span><span class=n>v</span><span class=o>,</span> <span class=n>w</span><span class=o>};</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>cache</span><span class=o>.</span><span class=na>containsKey</span><span class=o>(</span><span class=n>p</span><span class=o>))</span>
            <span class=k>return</span> <span class=n>cache</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>p</span><span class=o>)[</span><span class=mi>1</span><span class=o>];</span>

        <span class=c1>// bfs search for ancestor</span>
        <span class=kt>int</span><span class=o>[]</span> <span class=n>res</span> <span class=o>=</span> <span class=n>bfs</span><span class=o>(</span><span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=n>v</span><span class=o>),</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=n>w</span><span class=o>));</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>res</span><span class=o>[</span><span class=mi>1</span><span class=o>]</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>cache</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>p</span><span class=o>,</span> <span class=n>res</span><span class=o>);</span>
            <span class=n>cache</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=k>new</span> <span class=kt>int</span><span class=o>[]{</span><span class=n>w</span><span class=o>,</span> <span class=n>v</span><span class=o>},</span> <span class=n>res</span><span class=o>);</span>
        <span class=o>}</span>
        <span class=k>return</span> <span class=n>res</span><span class=o>[</span><span class=mi>1</span><span class=o>];</span>
    <span class=o>}</span>

    <span class=cm>/**</span>
<span class=cm>     * a common ancestor of v and w that participates in a shortest ancestral path;</span>
<span class=cm>     * -1 if no such path</span>
<span class=cm>     * @param v: a vertex</span>
<span class=cm>     * @param w: a vertex</span>
<span class=cm>     * @throws IllegalArgumentException if any of the vertex is out of range</span>
<span class=cm>     *</span>
<span class=cm>     */</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>ancestor</span><span class=o>(</span><span class=kt>int</span> <span class=n>v</span><span class=o>,</span> <span class=kt>int</span> <span class=n>w</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>// validate vertex</span>
        <span class=n>validateVertex</span><span class=o>(</span><span class=n>v</span><span class=o>);</span>
        <span class=n>validateVertex</span><span class=o>(</span><span class=n>w</span><span class=o>);</span>

        <span class=c1>// already calculated?</span>
        <span class=kt>int</span><span class=o>[]</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[]{</span><span class=n>v</span><span class=o>,</span> <span class=n>w</span><span class=o>};</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>cache</span><span class=o>.</span><span class=na>containsKey</span><span class=o>(</span><span class=n>p</span><span class=o>))</span>
            <span class=k>return</span> <span class=n>cache</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>p</span><span class=o>)[</span><span class=mi>0</span><span class=o>];</span>

        <span class=c1>// bfs search for ancestor</span>
        <span class=kt>int</span><span class=o>[]</span> <span class=n>res</span> <span class=o>=</span> <span class=n>bfs</span><span class=o>(</span><span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=n>v</span><span class=o>),</span> <span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=n>w</span><span class=o>));</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>res</span><span class=o>[</span><span class=mi>0</span><span class=o>]</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>cache</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>p</span><span class=o>,</span> <span class=n>res</span><span class=o>);</span>
            <span class=n>cache</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=k>new</span> <span class=kt>int</span><span class=o>[]{</span><span class=n>w</span><span class=o>,</span> <span class=n>v</span><span class=o>},</span> <span class=n>res</span><span class=o>);</span>
        <span class=o>}</span>
        <span class=k>return</span> <span class=n>res</span><span class=o>[</span><span class=mi>0</span><span class=o>];</span>
    <span class=o>}</span>

    <span class=cm>/**</span>
<span class=cm>     * length of shortest ancestral path between any vertex in v and any vertex in w;</span>
<span class=cm>     * -1 if no such path</span>
<span class=cm>     * @param v: a vertex</span>
<span class=cm>     * @param w: a vertex</span>
<span class=cm>     * @throws IllegalArgumentException if any of the vertex is out of range</span>
<span class=cm>     */</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>length</span><span class=o>(</span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>v</span><span class=o>,</span> <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>w</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>v</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>w</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>();</span>
        <span class=c1>// validate vertex</span>
        <span class=k>for</span> <span class=o>(</span><span class=n>Integer</span> <span class=n>vertex</span> <span class=o>:</span> <span class=n>v</span><span class=o>)</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>vertex</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>();</span>
            <span class=k>else</span>  <span class=n>validateVertex</span><span class=o>(</span><span class=n>vertex</span><span class=o>);</span>
        <span class=k>for</span> <span class=o>(</span><span class=n>Integer</span> <span class=n>vertex</span> <span class=o>:</span> <span class=n>w</span><span class=o>)</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>vertex</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>();</span>
            <span class=k>else</span>  <span class=n>validateVertex</span><span class=o>(</span><span class=n>vertex</span><span class=o>);</span>

        <span class=c1>// bfs search for ancestor</span>
        <span class=kt>int</span><span class=o>[]</span> <span class=n>res</span> <span class=o>=</span> <span class=n>bfs</span><span class=o>(</span><span class=n>v</span><span class=o>,</span> <span class=n>w</span><span class=o>);</span>
        <span class=k>return</span> <span class=n>res</span><span class=o>[</span><span class=mi>1</span><span class=o>];</span>
    <span class=o>}</span>

    <span class=cm>/**</span>
<span class=cm>     *  a common ancestor that participates in shortest ancestral path;</span>
<span class=cm>     *  -1 if no such path</span>
<span class=cm>     * @param v: a vertex</span>
<span class=cm>     * @param w: a vertex</span>
<span class=cm>     * @throws IllegalArgumentException if any of the vertex is out of range</span>
<span class=cm>     */</span>
    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>ancestor</span><span class=o>(</span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>v</span><span class=o>,</span> <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>w</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>v</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>w</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>();</span>
        <span class=c1>// validate vertex</span>
        <span class=k>for</span> <span class=o>(</span><span class=n>Integer</span> <span class=n>vertex</span> <span class=o>:</span> <span class=n>v</span><span class=o>)</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>vertex</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>();</span>
            <span class=k>else</span>  <span class=n>validateVertex</span><span class=o>(</span><span class=n>vertex</span><span class=o>);</span>
        <span class=k>for</span> <span class=o>(</span><span class=n>Integer</span> <span class=n>vertex</span> <span class=o>:</span> <span class=n>w</span><span class=o>)</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>vertex</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>();</span>
            <span class=k>else</span>  <span class=n>validateVertex</span><span class=o>(</span><span class=n>vertex</span><span class=o>);</span>

        <span class=c1>// bfs search for ancestor</span>
        <span class=kt>int</span><span class=o>[]</span> <span class=n>res</span> <span class=o>=</span> <span class=n>bfs</span><span class=o>(</span><span class=n>v</span><span class=o>,</span> <span class=n>w</span><span class=o>);</span>
        <span class=k>return</span> <span class=n>res</span><span class=o>[</span><span class=mi>0</span><span class=o>];</span>
    <span class=o>}</span>


    <span class=cm>/**</span>
<span class=cm>     * Initialize BFS.</span>
<span class=cm>     * @param queueListv: a list of queue</span>
<span class=cm>     * @param v : a list of vertex to add</span>
<span class=cm>     * @param visitedThis : a set of visisted vertex</span>
<span class=cm>     * @param visitedOther : a set of visisted vertex</span>
<span class=cm>     * @return -1 if all vertexes are unvisited,</span>
<span class=cm>     *      otherwise return the visited vertex;</span>
<span class=cm>     */</span>
     <span class=kd>private</span> <span class=kt>int</span> <span class=nf>initializeBFS</span><span class=o>(</span><span class=n>List</span><span class=o>&lt;</span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>queueListv</span><span class=o>,</span> <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>v</span><span class=o>,</span>
                               <span class=n>Map</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>visitedThis</span><span class=o>,</span> <span class=n>Map</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>visitedOther</span><span class=o>)</span> <span class=o>{</span>
         <span class=k>for</span> <span class=o>(</span><span class=n>Integer</span> <span class=n>i</span> <span class=o>:</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
             <span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>queue</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span>
             <span class=n>queue</span><span class=o>.</span><span class=na>offer</span><span class=o>(</span><span class=n>i</span><span class=o>);</span>
             <span class=n>queueListv</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>queue</span><span class=o>);</span>
             <span class=k>if</span> <span class=o>(</span><span class=n>visitedThis</span><span class=o>.</span><span class=na>containsKey</span><span class=o>(</span><span class=n>i</span><span class=o>))</span> <span class=k>return</span> <span class=n>i</span><span class=o>;</span>
             <span class=k>if</span> <span class=o>(</span><span class=n>visitedOther</span><span class=o>.</span><span class=na>containsKey</span><span class=o>(</span><span class=n>i</span><span class=o>))</span> <span class=k>return</span> <span class=n>i</span><span class=o>;</span>
             <span class=n>visitedThis</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=mi>0</span><span class=o>);</span>
         <span class=o>}</span>
         <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=cm>/**</span>
<span class=cm>     * Search for the shortest Common Ancestor by bfs.</span>
<span class=cm>     * search from v(start) to w(end)</span>
<span class=cm>     * @param v: a list of vertex</span>
<span class=cm>     * @param w: a list of vertex</span>
<span class=cm>     * @return: a common ancestor ( -1 if not found),</span>
<span class=cm>     *      and corresponding length of path (-1 if not found).</span>
<span class=cm>     */</span>
    <span class=kd>private</span> <span class=kt>int</span><span class=o>[]</span> <span class=nf>bfs</span><span class=o>(</span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>v</span><span class=o>,</span> <span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>w</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>queueListv</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;(),</span>
                <span class=n>queueListw</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
        <span class=c1>// viisted vertex</span>
        <span class=n>HashMap</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>visitedV</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashMap</span><span class=o>&lt;&gt;(),</span>
                <span class=n>visitedW</span> <span class=o>=</span> <span class=k>new</span> <span class=n>HashMap</span><span class=o>&lt;&gt;();</span>
        <span class=c1>// initialize bfs, if vertexes are repeated,</span>
        <span class=c1>// which means their shortest Common Ancestor is repeated vertex,</span>
        <span class=c1>// return {repeated vertex, 0}</span>
        <span class=kt>int</span> <span class=n>state</span><span class=o>;</span>
        <span class=n>state</span> <span class=o>=</span> <span class=n>initializeBFS</span><span class=o>(</span><span class=n>queueListv</span><span class=o>,</span> <span class=n>v</span><span class=o>,</span> <span class=n>visitedV</span><span class=o>,</span> <span class=n>visitedW</span><span class=o>);</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>state</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=o>)</span> <span class=k>return</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[]{</span><span class=n>state</span><span class=o>,</span> <span class=mi>0</span><span class=o>};</span>
        <span class=n>state</span> <span class=o>=</span> <span class=n>initializeBFS</span><span class=o>(</span><span class=n>queueListw</span><span class=o>,</span> <span class=n>w</span><span class=o>,</span> <span class=n>visitedW</span><span class=o>,</span> <span class=n>visitedV</span><span class=o>);</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>state</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=o>)</span> <span class=k>return</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[]{</span><span class=n>state</span><span class=o>,</span> <span class=mi>0</span><span class=o>};</span>

        <span class=c1>// number of bfs steps</span>
        <span class=kt>int</span> <span class=n>numOfSteps</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>

        <span class=c1>// commonAncestor</span>
        <span class=kt>int</span> <span class=n>commonAncestor</span><span class=o>,</span> <span class=n>shortestCommonAncestor</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=o>;</span>
        <span class=kt>int</span> <span class=n>sap</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>.</span><span class=na>MAX_VALUE</span><span class=o>;</span>
        <span class=k>while</span> <span class=o>(</span><span class=kc>true</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// bfs for v</span>
            <span class=n>commonAncestor</span> <span class=o>=</span> <span class=n>bfsOneStep</span><span class=o>(</span><span class=n>queueListv</span><span class=o>,</span> <span class=n>visitedV</span><span class=o>,</span> <span class=n>visitedW</span><span class=o>,</span> <span class=n>numOfSteps</span><span class=o>);</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>commonAncestor</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>visitedV</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>commonAncestor</span><span class=o>)</span> <span class=o>&lt;</span> <span class=n>sap</span><span class=o>)</span> <span class=o>{</span>
                <span class=n>shortestCommonAncestor</span> <span class=o>=</span> <span class=n>commonAncestor</span><span class=o>;</span>
                <span class=n>sap</span> <span class=o>=</span> <span class=n>visitedV</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>commonAncestor</span><span class=o>);</span>
            <span class=o>}</span>

            <span class=c1>// bfs for w</span>
            <span class=n>commonAncestor</span> <span class=o>=</span> <span class=n>bfsOneStep</span><span class=o>(</span><span class=n>queueListw</span><span class=o>,</span> <span class=n>visitedW</span><span class=o>,</span> <span class=n>visitedV</span><span class=o>,</span> <span class=n>numOfSteps</span><span class=o>);</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>commonAncestor</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>visitedW</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>commonAncestor</span><span class=o>)</span> <span class=o>&lt;</span> <span class=n>sap</span><span class=o>)</span> <span class=o>{</span>
                <span class=n>shortestCommonAncestor</span> <span class=o>=</span> <span class=n>commonAncestor</span><span class=o>;</span>
                <span class=n>sap</span> <span class=o>=</span> <span class=n>visitedW</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>commonAncestor</span><span class=o>);</span>
            <span class=o>}</span>

            <span class=c1>// number of step plus one</span>
            <span class=n>numOfSteps</span><span class=o>++;</span>

            <span class=c1>// break if all queues are empty</span>
            <span class=kt>boolean</span> <span class=n>allEmpty</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
            <span class=k>for</span> <span class=o>(</span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>q</span> <span class=o>:</span> <span class=n>queueListv</span><span class=o>)</span>
                <span class=n>allEmpty</span> <span class=o>&amp;=</span> <span class=n>q</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>();</span>
            <span class=k>for</span> <span class=o>(</span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>q</span> <span class=o>:</span> <span class=n>queueListw</span><span class=o>)</span>
                <span class=n>allEmpty</span> <span class=o>&amp;=</span> <span class=n>q</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>();</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>allEmpty</span><span class=o>)</span> <span class=k>break</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>shortestCommonAncestor</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=o>)</span>
            <span class=k>return</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[]{-</span><span class=mi>1</span><span class=o>,</span> <span class=o>-</span><span class=mi>1</span><span class=o>};</span>
        <span class=k>return</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[]{</span><span class=n>shortestCommonAncestor</span><span class=o>,</span> <span class=n>sap</span><span class=o>};</span>
    <span class=o>}</span>


    <span class=cm>/**</span>
<span class=cm>     * A step of Binary First Search.</span>
<span class=cm>     * @param queueList: a list of queues maintains the vertexes to visit</span>
<span class=cm>     * @param visitedThis: a set of vertexes that has been visited</span>
<span class=cm>     * @param visitedOther: a set of vertexes that has been visited</span>
<span class=cm>     * @param length: the length of path bfs already visited</span>
<span class=cm>     * @return: a common ancestor, or -1 if not found.</span>
<span class=cm>     */</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=nf>bfsOneStep</span><span class=o>(</span><span class=n>Iterable</span><span class=o>&lt;</span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>queueList</span><span class=o>,</span>
                           <span class=n>Map</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>visitedThis</span><span class=o>,</span> <span class=n>Map</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Integer</span><span class=o>&gt;</span> <span class=n>visitedOther</span><span class=o>,</span>  <span class=kt>int</span> <span class=n>length</span><span class=o>)</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>commonAncestor</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=o>;</span>
        <span class=k>for</span> <span class=o>(</span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>q</span> <span class=o>:</span> <span class=n>queueList</span><span class=o>)</span> <span class=o>{</span>
            <span class=c1>// queue is emtpy</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>q</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span> <span class=k>continue</span><span class=o>;</span>

            <span class=c1>// visit all unvisited neighbors</span>
            <span class=kt>int</span> <span class=n>lenOfQueue</span> <span class=o>=</span> <span class=n>q</span><span class=o>.</span><span class=na>size</span><span class=o>();</span>
            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>lenOfQueue</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
                <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>neighbor</span> <span class=o>:</span> <span class=n>digraph</span><span class=o>.</span><span class=na>adj</span><span class=o>(</span><span class=n>q</span><span class=o>.</span><span class=na>poll</span><span class=o>()))</span> <span class=o>{</span>
                    <span class=c1>// another set is already visted this vertex!!</span>
                    <span class=c1>// the neighbor is the common ancestor we try to find.</span>
                    <span class=k>if</span> <span class=o>(</span><span class=n>visitedOther</span><span class=o>.</span><span class=na>containsKey</span><span class=o>(</span><span class=n>neighbor</span><span class=o>))</span> <span class=o>{</span>
                        <span class=k>if</span> <span class=o>(!</span><span class=n>visitedThis</span><span class=o>.</span><span class=na>containsKey</span><span class=o>(</span><span class=n>neighbor</span><span class=o>))</span>  <span class=n>q</span><span class=o>.</span><span class=na>offer</span><span class=o>(</span><span class=n>neighbor</span><span class=o>);</span>
                        <span class=n>visitedThis</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>neighbor</span><span class=o>,</span> <span class=n>visitedOther</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>neighbor</span><span class=o>)</span> <span class=o>+</span> <span class=n>length</span> <span class=o>+</span> <span class=mi>1</span><span class=o>);</span>
                        <span class=k>if</span> <span class=o>(</span><span class=n>commonAncestor</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=o>)</span>
                            <span class=n>commonAncestor</span> <span class=o>=</span> <span class=n>neighbor</span><span class=o>;</span>
                        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>visitedThis</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>neighbor</span><span class=o>)</span>  <span class=o>&lt;</span> <span class=n>visitedThis</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>commonAncestor</span><span class=o>))</span>
                            <span class=n>commonAncestor</span> <span class=o>=</span> <span class=n>neighbor</span><span class=o>;</span>
                    <span class=o>}</span>

                    <span class=c1>// visit vertex</span>
                    <span class=k>if</span> <span class=o>(!</span><span class=n>visitedThis</span><span class=o>.</span><span class=na>containsKey</span><span class=o>(</span><span class=n>neighbor</span><span class=o>))</span> <span class=o>{</span>
                        <span class=n>visitedThis</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>neighbor</span><span class=o>,</span> <span class=n>length</span> <span class=o>+</span> <span class=mi>1</span><span class=o>);</span>
                        <span class=n>q</span><span class=o>.</span><span class=na>offer</span><span class=o>(</span><span class=n>neighbor</span><span class=o>);</span>
                    <span class=o>}</span>
                <span class=o>}</span>
            <span class=o>}</span>

        <span class=o>}</span>
        <span class=k>return</span> <span class=n>commonAncestor</span><span class=o>;</span>
    <span class=o>}</span>


    <span class=cm>/**</span>
<span class=cm>     * validate vertex</span>
<span class=cm>     * @throws IllegalArgumentException unless {@code 0 &lt;= v &lt; V}</span>
<span class=cm>     */</span>
    <span class=kd>private</span> <span class=kt>void</span> <span class=nf>validateVertex</span><span class=o>(</span><span class=kt>int</span> <span class=n>v</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>v</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>v</span> <span class=o>&gt;=</span> <span class=n>digraph</span><span class=o>.</span><span class=na>V</span><span class=o>())</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&quot;vertex &quot;</span> <span class=o>+</span> <span class=n>v</span> <span class=o>+</span> <span class=s>&quot; is not between 0 and &quot;</span> <span class=o>+</span> <span class=o>(</span><span class=n>digraph</span><span class=o>.</span><span class=na>V</span><span class=o>()</span> <span class=o>-</span> <span class=mi>1</span><span class=o>));</span>
    <span class=o>}</span>

    <span class=cm>/**</span>
<span class=cm>     * LRU cache.</span>
<span class=cm>     */</span>
    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>class</span> <span class=nc>LRUCache</span> <span class=kd>extends</span> <span class=n>LinkedHashMap</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>[],</span> <span class=kt>int</span><span class=o>[]&gt;</span> <span class=o>{</span>
        <span class=kd>private</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>CAPACITY</span><span class=o>;</span>
        <span class=n>LRUCache</span><span class=o>(</span><span class=kt>int</span> <span class=n>capacity</span><span class=o>)</span> <span class=o>{</span>
            <span class=kd>super</span><span class=o>(</span><span class=n>capacity</span><span class=o>,</span> <span class=mf>0.75f</span><span class=o>,</span> <span class=kc>true</span><span class=o>);</span>
            <span class=k>this</span><span class=o>.</span><span class=na>CAPACITY</span> <span class=o>=</span> <span class=n>capacity</span><span class=o>;</span>
        <span class=o>}</span>

        <span class=kd>public</span> <span class=kt>int</span><span class=o>[]</span> <span class=nf>put</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>key</span><span class=o>,</span> <span class=kt>int</span><span class=o>[]</span> <span class=n>value</span><span class=o>)</span> <span class=o>{</span>
            <span class=k>return</span> <span class=kd>super</span><span class=o>.</span><span class=na>put</span><span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>value</span><span class=o>);</span>
        <span class=o>}</span>

        <span class=kd>public</span> <span class=kt>int</span><span class=o>[]</span> <span class=nf>get</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>key</span><span class=o>)</span> <span class=o>{</span>
            <span class=k>return</span> <span class=kd>super</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>key</span><span class=o>);</span>
        <span class=o>}</span>

        <span class=nd>@Override</span>
        <span class=kd>protected</span> <span class=kt>boolean</span> <span class=nf>removeEldestEntry</span><span class=o>(</span><span class=n>Map</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>[],</span> <span class=kt>int</span><span class=o>[]&gt;</span> <span class=n>eldest</span><span class=o>)</span> <span class=o>{</span>
            <span class=k>return</span> <span class=n>size</span><span class=o>()</span> <span class=o>&gt;</span> <span class=k>this</span><span class=o>.</span><span class=na>CAPACITY</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<p></details></p>
<p><hh>Analysis</hh></p>
<p>All methods (and the constructor) take time proportional to <span><span class="MathJax_Preview">|E| + |V|</span><script type="math/tex">|E| + |V|</script></span> in the worst case, where <span><span class="MathJax_Preview">|E|</span><script type="math/tex">|E|</script></span> and <span><span class="MathJax_Preview">|V|</span><script type="math/tex">|V|</script></span> are the number of edges and vertices in the digraph, respectively. And data type uses space proportional to <span><span class="MathJax_Preview">|E| + |V|</span><script type="math/tex">|E| + |V|</script></span>.</p>
<h4 id="outcast-detection">Outcast detection<a class="headerlink" href="#outcast-detection" title="Permanent link">&para;</a></h4>
<p>Given a list of WordNet nouns <span><span class="MathJax_Preview">x_1, x_2, ..., x_n</span><script type="math/tex">x_1, x_2, ..., x_n</script></span> , which noun is the least related to the others? To identify an outcast, compute the sum of the distances between each noun and every other one:</p>
<p><span><span class="MathJax_Preview">d_i = distance(x_i, x_1) + distance(x_i, x_2) + ... + distance(x_i, x_n)</span><script type="math/tex">d_i = distance(x_i, x_1) + distance(x_i, x_2) + ... + distance(x_i, x_n)</script></span> and return a noun <span><span class="MathJax_Preview">x_t</span><script type="math/tex">x_t</script></span> for which <span><span class="MathJax_Preview">d_t</span><script type="math/tex">d_t</script></span> is maximum. Note that <span><span class="MathJax_Preview">distance(x_i , x_i ) = 0</span><script type="math/tex">distance(x_i , x_i ) = 0</script></span>, so it will not contribute to the sum.</p>
<p><em>Semantic relatedness</em> refers to the degree to which two concepts are related. Define the semantic relatedness of two WordNet nouns <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> and <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> as follows:</p>
<ul>
<li>A = set of synsets in which x appears</li>
<li>B = set of synsets in which y appears</li>
<li><span><span class="MathJax_Preview">distance(x, y)</span><script type="math/tex">distance(x, y)</script></span> = length of shortest ancestral path of subsets A and B</li>
<li><span><span class="MathJax_Preview">sca(x, y)</span><script type="math/tex">sca(x, y)</script></span> = a shortest common ancestor of subsets A and B</li>
</ul>
<p><details><summary>Click Here to View Code</summary></p>
<p> <div class=codehilite><pre><span class=cm>/**</span>
<span class=cm> * Identify an outcast from a list of words.</span>
<span class=cm> */</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>Outcast</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=n>WordNet</span> <span class=n>wordNet</span><span class=o>;</span>
    <span class=cm>/**</span>
<span class=cm>     * constructor takes a WordNet object</span>
<span class=cm>     * @param wordnet: a wordnet</span>
<span class=cm>     */</span>
    <span class=kd>public</span> <span class=nf>Outcast</span><span class=o>(</span><span class=n>WordNet</span> <span class=n>wordnet</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>wordNet</span> <span class=o>=</span> <span class=n>wordnet</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=cm>/**</span>
<span class=cm>     * given an array of WordNet nouns, return an outcast</span>
<span class=cm>     * @param nouns: a list of nouns</span>
<span class=cm>     * @return: an outcast</span>
<span class=cm>     * @throws IllegalArgumentException if nouns is null,</span>
<span class=cm>     *      or any of the noun is not part of the wordNet.</span>
<span class=cm>     */</span>
    <span class=kd>public</span> <span class=n>String</span> <span class=nf>outcast</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>nouns</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>nouns</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&quot;nouns is null!&quot;</span><span class=o>);</span>
        <span class=k>for</span> <span class=o>(</span><span class=n>String</span> <span class=n>noun</span> <span class=o>:</span> <span class=n>nouns</span><span class=o>)</span>
            <span class=k>if</span> <span class=o>(!</span><span class=n>wordNet</span><span class=o>.</span><span class=na>isNoun</span><span class=o>(</span><span class=n>noun</span><span class=o>))</span>
                <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&quot;nouns are not part of wordNet!&quot;</span><span class=o>);</span>

        <span class=kt>int</span> <span class=n>maxDistance</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=o>;</span>
        <span class=n>String</span> <span class=n>outcastNoun</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
        <span class=kt>int</span> <span class=n>distance</span><span class=o>;</span>
        <span class=k>for</span> <span class=o>(</span><span class=n>String</span> <span class=n>nounA</span> <span class=o>:</span> <span class=n>nouns</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>distance</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
            <span class=k>for</span> <span class=o>(</span><span class=n>String</span> <span class=n>nounB</span> <span class=o>:</span> <span class=n>nouns</span><span class=o>)</span> <span class=o>{</span>
                <span class=kt>int</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>wordNet</span><span class=o>.</span><span class=na>distance</span><span class=o>(</span><span class=n>nounA</span><span class=o>,</span> <span class=n>nounB</span><span class=o>);</span>
                <span class=n>distance</span> <span class=o>+=</span> <span class=n>tmp</span><span class=o>;</span>
            <span class=o>}</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>distance</span> <span class=o>&gt;</span> <span class=n>maxDistance</span><span class=o>)</span> <span class=o>{</span>
                <span class=n>maxDistance</span> <span class=o>=</span> <span class=n>distance</span><span class=o>;</span>
                <span class=n>outcastNoun</span> <span class=o>=</span> <span class=n>nounA</span><span class=o>;</span>
            <span class=o>}</span>
        <span class=o>}</span>
        <span class=k>return</span> <span class=n>outcastNoun</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<p></details></p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../../..",
                shortcuts = {"search": 83, "next": 78, "help": 191, "previous": 80};
        </script>
        <script src="../../../js/base.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
        <script src="../../../extra_javascript/tabhack.js" defer></script>
        <script src="../../../extra_javascript/baidu.js" defer></script>
        <script src="../../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
