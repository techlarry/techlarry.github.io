<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Zhenhua Wang">
        <link rel="canonical" href="http://larryim.cc/note-os/algorithm/sword/ch2/">
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>⾯试需要的基础知识 - Zhenhua's Notes</title>
        <link href="../../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/docco.min.css">
        <link href="../../../extra_css/custom.css" rel="stylesheet">
        <link href="../../../extra_css/custom.js" rel="stylesheet">
        <link href="../../../extra_css/friendly.css" rel="stylesheet">
        <link href="../../../extra_css/theme.css" rel="stylesheet">
        <link href="../../../extra_css/mkdocs/js/lunr-0.5.7.min.js" rel="stylesheet">
        <link href="../../../extra_css/mkdocs/js/mustache.min.js" rel="stylesheet">
        <link href="../../../extra_css/mkdocs/js/require.js" rel="stylesheet">
        <link href="../../../extra_css/mkdocs/js/search.js" rel="stylesheet">
        <link href="../../../extra_css/mkdocs/js/text.js" rel="stylesheet">
        <link href="../../../extra_css/code-tab.css" rel="stylesheet">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../../..">Zhenhua's Notes</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../../..">Home</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Algorithm <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../">Contents</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#">AlgorithmPrinceton</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../algorithmPrinceton/">Contents</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/unionfind/">Topic 1: UnionFind</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/stackqueue/">Topic 2: StackQueue</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/sort/">Topic 3: Sort</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/priorityqueue/">Topic 4: PriorityQueues</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/symboltable/">Topic 5: Symbol Tables</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/bst/">Topic 6: Balanced Search Trees</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/hashtable/">Topic 7: Hash Table</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/graph/">Topic 8: Graph</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/mst_shortestpath/">Topic 9: Minimum Spanning Tree and Shortest Path</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/stringsort/">Topic 11: String Sort</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/tries/">Topic 12: Tries</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">AlgorithmStanford</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../algorithmStanford/">Contents</a>
</li>
            
<li >
    <a href="../../algorithmStanford/dynamicprogramming/">Topic: Dynammic Programming</a>
</li>
            
<li >
    <a href="../../algorithmStanford/heap/">Topic: Heap</a>
</li>
            
<li >
    <a href="../../algorithmStanford/graph/">Topic: Graph</a>
</li>
            
<li >
    <a href="../../algorithmStanford/greedy/">Topic: Greedy Algorithm</a>
</li>
            
<li >
    <a href="../../algorithmStanford/hashtable/">Topic: Hash Table</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">CS61B</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../cs61b/">Contents</a>
</li>
            
<li >
    <a href="../../cs61b/Lab1/">Lab1: javac, java, git</a>
</li>
            
<li >
    <a href="../../cs61b/Lab2/">Lab2: Unit Testing with JUnit and IntLists</a>
</li>
            
<li >
    <a href="../../cs61b/Lab3/">Lab3: Unit Testing with JUnit, Debugging</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Sword</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../">Contents</a>
</li>
            
<li class="active">
    <a href="./">⾯试需要的基础知识</a>
</li>
            
<li >
    <a href="../ch3/">高质量的代码</a>
</li>
            
<li >
    <a href="../ch4/">解决面试题的思路</a>
</li>
            
<li >
    <a href="../ch5/">优化时间和空间效率</a>
</li>
            
<li >
    <a href="../ch6/">面试中的各项能力</a>
</li>
            
<li >
    <a href="../ch7/">两个面试案例</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">OS <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../../os/">Contents</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#">OSC</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../os/osc/">Contents</a>
</li>
            
<li >
    <a href="../../../os/osc/ch1/">Chapter 1: Introduction </a>
</li>
            
<li >
    <a href="../../../os/osc/ch2/">Chapter 2: Operating System structures</a>
</li>
            
<li >
    <a href="../../../os/osc/ch3/">Chapter 3: Processes</a>
</li>
            
<li >
    <a href="../../../os/osc/ch4/">Chapter 4: Threads and Concurrency</a>
</li>
            
<li >
    <a href="../../../os/osc/ch5/">Chapter 5: CPU Scheduling</a>
</li>
            
<li >
    <a href="../../../os/osc/ch6/">Chapter 6: Synchronization Tools</a>
</li>
            
<li >
    <a href="../../../os/osc/ch7/">Chapter 7: Synchronization Examples</a>
</li>
            
<li >
    <a href="../../../os/osc/ch8/">Chapter 8: Deadlocks</a>
</li>
            
<li >
    <a href="../../../os/osc/ch9/">Chapter 9: Main Memory</a>
</li>
            
<li >
    <a href="../../../os/osc/ch10/">Chapter 10: Virtual Memory</a>
</li>
            
<li >
    <a href="../../../os/osc/ch11/">Chapter 11: Mass-Storage Structure</a>
</li>
            
<li >
    <a href="../../../os/osc/ch13/">Chapter 13: File-System Interfaces</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">CSAPP</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../os/csapp/">Contents</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch1/">Chapter 1: 计算机系统漫游</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch2/">Chapter 2: 信息的表示和处理</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch3/">Chapter 3: 程序的机器级表示</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch4/">Chapter 4: 处理器体系结构</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch5/">Chapter 5: 优化程序性能</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch6/">Chapter 6: 存储器层次结构</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch7/">Chapter 7: 链接</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch8/">Chapter 8: 异常控制流</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch9/">Chapter 9: 虚拟内存</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch10/">Chapter 10: 系统级I/O</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch11/">Chapter 11: 网络编程</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">DataBase <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../../database/">Contents</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#">MySql</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../database/mysql/">Contents</a>
</li>
            
<li >
    <a href="../../../database/mysql/LearningMySQLandMariaDB/">Chapter Learning MySQL and MariaDB</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Java <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../../java/">Contents</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#">HFJ</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../java/hfj/">Contents</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch1/">Chapter 1: Dive in A Quick Dip</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch2/">Chapter 2: Classes and Objects</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch3/">Chapter 3: Primitives and References</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch4/">Chapter 4: Methods use Instance Variables</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch5/">Chapter 5: Writing a Program</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch6/">Chapter 6: Get to Know the Java API</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch7/">Chapter 7: Inheritance and Polymorphism</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch8/">Chapter 8: Interfaces and Abstract Classes</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch9/">Chapter 9: Constructors and Garbage Collection</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch10/">Chapter 10: Numbers and Statics</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch11/">Chapter 11: Exception Handling</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch12/">Chapter 12: Getting GUI</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch13/">Chapter 13: Using Swing</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch14/">Chapter 14: Serialization and File I/O</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch15/">Chapter 15: Networking and Threads</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch16/">Chapter 16: Collections and Generics</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch17/">Chapter 17: Packages, Jars and Deployment</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch18/">Chapter 18: Remote deploy with RMI</a>
</li>
            
<li >
    <a href="../../../java/hfj/Appendix/">Appendix: The Top Ten Topics</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">HFDP</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../java/hfdp/">Contents</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch1/">Chapter 1: Strategy Pattern </a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch2/">Chapter 2: Observer Pattern</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch3/">Chapter 3: Decorator Pattern </a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch4/">Chapter 4: Factory Pattern</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch5/">Chapter 5: Singleton Pattern</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch6/">Chapter 6: Command Pattern</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch7/">Chapter 7: Adapter and Facade Patterns</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch8/">Chapter 8: Template Method Pattern</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch9/">Chapter 9: Iterator and Composite Patterns</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">MultiThreading</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../java/multithreading/">Contents</a>
</li>
            
<li >
    <a href="../../../java/multithreading/pre1/">序章1 Java线程</a>
</li>
            
<li >
    <a href="../../../java/multithreading/pre2/">序章2 多线程程序的评价标准</a>
</li>
            
<li >
    <a href="../../../java/multithreading/ch1/">第1章 Single Threaded Execution模式</a>
</li>
            
<li >
    <a href="../../../java/multithreading/ch1/">第2章 Immutable模式</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">TIJ</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../java/tij/">Contents</a>
</li>
            
<li >
    <a href="../../../java/tij/ch1/">Chapter 1: Introduction</a>
</li>
            
<li >
    <a href="../../../java/tij/ch2/">Chapter 2: Introduction to Objects</a>
</li>
            
<li >
    <a href="../../../java/tij/ch3/">Chapter 3: Everything is an Object</a>
</li>
            
<li >
    <a href="../../../java/tij/ch4/">Chapter 4: Opertors</a>
</li>
            
<li >
    <a href="../../../java/tij/ch5/">Chapter 5: Controlling Execution</a>
</li>
            
<li >
    <a href="../../../java/tij/ch6/">Chapter 6: Initialization & Cleanup</a>
</li>
            
<li >
    <a href="../../../java/tij/ch7/">Chapter 7: Access Control</a>
</li>
            
<li >
    <a href="../../../java/tij/ch8/">Chapter 8: Reusing Clases</a>
</li>
            
<li >
    <a href="../../../java/tij/ch9/">Chapter 9: Polymorphism</a>
</li>
            
<li >
    <a href="../../../java/tij/ch10/">Chapter 10: Interfaces</a>
</li>
            
<li >
    <a href="../../../java/tij/ch11/">Chapter 11: Inner Classes</a>
</li>
            
<li >
    <a href="../../../java/tij/ch12/">Chapter 12: Holding Your Objects</a>
</li>
            
<li >
    <a href="../../../java/tij/ch13/">Chapter 13: Error Handling with Exceptions</a>
</li>
            
<li >
    <a href="../../../java/tij/ch14/">Chapter 14: Strings</a>
</li>
            
<li >
    <a href="../../../java/tij/ch15/">Chapter 15: Type Information</a>
</li>
            
<li >
    <a href="../../../java/tij/ch16/">Chapter 16: Generics</a>
</li>
            
<li >
    <a href="../../../java/tij/ch17/">Chapter 17: Arrays</a>
</li>
            
<li >
    <a href="../../../java/tij/ch18/">Chapter 18: Containers in Depth</a>
</li>
            
<li >
    <a href="../../../java/tij/ch19/">Chapter 19: I/O</a>
</li>
            
<li >
    <a href="../../../java/tij/ch20/">Chapter 20: Enumerated Types</a>
</li>
            
<li >
    <a href="../../../java/tij/ch21/">Chapter 21: Annotations</a>
</li>
            
<li >
    <a href="../../../java/tij/ch22/">Chapter 22: Concurrency</a>
</li>
            
<li >
    <a href="../../../java/tij/ch23/">Chapter 23: Graphical User Interfaces</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">UJVM</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../java/ujvm/">Contents</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch1/">Chapter 1 : 走进Java</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch2/">Chapter 2 : Java内存区域与内存溢出正常</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch3/">Chapter 3 : 垃圾收集器与内存分配策略</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch4/">Chapter 4 : 虚拟机性能监控与故障处理工具</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch5/">Chapter 5 : 调优案例分析与实战</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch6/">Chapter 6 : 类文件结构</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch7/">Chapter 7 : 虚拟机类加载机制</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch8/">Chapter 8 : 虚拟机字节码执行引擎</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch9/">Chapter 9 : 类加载及执行子系统的案例与实战</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch10/">Chapter 10 : 早期(编译期)优化</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch11/">Chapter 11 : 晚期(运行期)优化</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch12/">Chapter 12 : Java内存模型与线程</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch13/">Chapter 13 : 线程安全与锁优化</a>
</li>
            
<li >
    <a href="../../../java/ujvm/AppendixC/">Appendix HotSpot虚拟机主要参数列表</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">BigData <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../../bigdata/">Contents</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#">HADOOP</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/hadoop/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch1/">Chapter 1: Meet Hadoop</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch2/">Chapter 2: MapReduce</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch3/">Chapter 3: The Hadoop Distributed FileSystem</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch4/">Chapter 4: YARN</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch5/">Chapter 5: Hadoop I/O</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch6/">Chapter 6: Developing a MapReduce Application</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch7/">Chapter 7: How MapReduce Works</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch8/">Chapter 8: MapReduce Types and Formats</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch9/">Chapter 9: MapReduce Features</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch10/">Chapter 10: Setting Up a Hadoop Cluster</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch11/">Chapter 11: Adminstering Hadoop</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch12/">Chapter 12: Avro</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch13/">Chapter 13: Parquet</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch14/">Chapter 14: Flume</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch15/">Chapter 15: Sqoop</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch16/">Chapter 16: Pig</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch17/">Chapter 17: Hive</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch18/">Chapter 18: Crunch</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch19/">Chapter 19: Spark</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch20/">Chapter 20: HBase</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch21/">Chapter 21: ZooKeeper</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch22/">Chapter 22: Composable Data at Center</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch23/">Chapter 23: Biological Data Science: Saving Lives with Software</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch24/">Chapter 24: Cascading</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Spark</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/spark/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch1/">Chapter 1: Introduction to Data Analysis with Spark</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch2/">Chapter 2: Downloading Spark and Getting Started</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch3/">Chapter 3: Programming with RDDs</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch4/">Chapter 4: Working with Key/Value Pairs</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch5/">Chapter 5: Loading and Saving Your Data</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch6/">Chapter 6: Advanced Spark Programming</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch7/">Chapter 7: Running on a Cluster</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch8/">Chapter 8: Tuning and Debugging Spark</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch9/">Chapter 9: Spark SQL</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch10/">Chapter 10: Spark Streaming</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch11/">Chapter 11: Machine Learning with MLlib</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">GDM</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/gdm/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch1/">Chapter 1: 推荐系统入门</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch2/">Chapter 2: 隐式评价和基于物品的过滤算法</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch3/">Chapter 3: 分类</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch4/">Chapter 4: 进一步探索分类</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch5/">Chapter 5: 概率和朴素贝叶斯</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch6/">Chapter 6: 朴素贝叶斯和文本数据</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch7/">Chapter 7: 聚类</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">MLIA</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/mlia/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch1/">Chapter 1: 机器学习基础</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch2/">Chapter 2: k-近邻算法</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch3/">Chapter 3: 决策树</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch4/">Chapter 4: 基于概率论的分类方法：朴素贝叶斯</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch5/">Chapter 5: Logistic回归</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch6/">Chapter 6: 支持向量机</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch7/">Chapter 7: 利用AdaBoost元算法提高分类性能</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch8/">Chapter 8: 预测数值型数据：回归</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch9/">Chapter 9: 树回归</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch10/">Chapter 10: 利用Ｋ-均值聚类算法对未标注数据分组</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch11/">Chapter 11: 使用Apriori算法进行关联分析</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch11/">Chapter 12: 使用FP-growth算法来高效发现频繁项集</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch13/">Chapter 13: 利用PCA来简化数据</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Crawler</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/crawler/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch1/">Chapter 1: 开发环境配置</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch2/">Chapter 2: 爬虫基础</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch3/">Chapter 3: 基本库的使用</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch4/">Chapter 4: 解析库的使用</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch5/">Chapter 5: 数据存储</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch7/">Chapter 7: 动态渲染页面爬取</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch13/">Chapter 13: Scrapy框架的使用</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Projects</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/projects/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/projects/SparkStreaming实时流处理项目/">SparkStreaming实时流处理</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li >
                                <a href="../../../books/">Books</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>

                     <!--
                            <li >
                                <a rel="next" href="../">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="../ch3/">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    -->
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#offer-">剑指Offer - ⾯试需要的基础知识</a></li>
        <li class="main "><a href="#2-singleton">2. 实现 Singleton</a></li>
        <li class="main "><a href="#3">3. 数组中重复的数字</a></li>
        <li class="main "><a href="#3_1">3. 二维数组中的查找</a></li>
        <li class="main "><a href="#4">4. 替换空格</a></li>
        <li class="main "><a href="#5">5. 从尾到头打印链表</a></li>
        <li class="main "><a href="#6">6. 重建二叉树</a></li>
        <li class="main "><a href="#8">8. 二叉树的下一个结点</a></li>
        <li class="main "><a href="#7">7. 用两个栈实现队列</a></li>
        <li class="main "><a href="#8_1">8. 旋转数组的最小数字</a></li>
        <li class="main "><a href="#9">9 斐波那契数列</a></li>
            <li><a href="#_1">斐波那契数列</a></li>
            <li><a href="#_2">跳台阶</a></li>
            <li><a href="#_3">矩形覆盖</a></li>
            <li><a href="#_4">变态跳台阶</a></li>
        <li class="main "><a href="#10-1">10. 二进制中1的个数</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h3 id="offer-"><strong>剑指Offer - ⾯试需要的基础知识</strong><a class="headerlink" href="#offer-" title="Permanent link">&para;</a></h3>
<h3 id="2-singleton">2. 实现 Singleton<a class="headerlink" href="#2-singleton" title="Permanent link">&para;</a></h3>
<p><a href="http://larryim.cc/note-os/java/hfdp/ch5/index.html">Singleton Pattern</a></p>
<h3 id="3">3. 数组中重复的数字<a class="headerlink" href="#3" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p>在一个长度为<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>的数组里的所有数字都在0到<span><span class="MathJax_Preview">n-1</span><script type="math/tex">n-1</script></span>的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组<span><span class="MathJax_Preview">[2,3,1,0,2,5,3]</span><script type="math/tex">[2,3,1,0,2,5,3]</script></span>，那么对应的输出是第一个重复的数字2。</p>
<p><hh>解题思路</hh></p>
<p>解决这个问题的一个简单的方法是先把输入的数组排序。然后从头到尾扫描数组，找出重复的数字。或者利用哈希表，每扫到一个数字的时候，都可以用<span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>的时间来判断哈希表里是否已经包含了该数字。如果哈希表里还没有这个数字，就把它加入哈希表，否则，就找到一个重复的数字。</p>
<p>有没有更好的方法呢？要求时间复杂度<span><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span>，空间复杂度<span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>。因此不能使用排序的方法，也不能使用额外的标记数组。</p>
<p>注意到数组中的数字都在<span><span class="MathJax_Preview">0\sim n-1</span><script type="math/tex">0\sim n-1</script></span>的范围内。如果这个数组中没有重复的数字，那么当数组排序之后数字<span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>将出现在下标为<span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>的位置。所以可以将值为<span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>的元素调整到第<span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>个位置上。</p>
<p>以 (2, 3, 1, 0, 2, 5) 为例：</p>
<p> <div class=codehilite><pre>position-0 : (2,3,1,0,2,5) // 2 &lt;-&gt; 1
             (1,3,2,0,2,5) // 1 &lt;-&gt; 3
             (3,1,2,0,2,5) // 3 &lt;-&gt; 0
             (0,1,2,3,2,5) // already in position
position-1 : (0,1,2,3,2,5) // already in position
position-2 : (0,1,2,3,2,5) // already in position
position-3 : (0,1,2,3,2,5) // already in position
position-4 : (0,1,2,3,2,5) // nums[i] == nums[nums[i]], exit
</pre></div></p>
<p>遍历到位置4时，该位置上的数为2，但是第2个位置上已经有一个2的值了，因此可以知道2重复。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>duplicate</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>,</span> <span class=kt>int</span> <span class=n>length</span><span class=o>,</span> <span class=kt>int</span><span class=o>[]</span> <span class=n>duplication</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>nums</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>length</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=o>)</span> <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=k>while</span> <span class=o>(</span><span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>!=</span> <span class=n>i</span><span class=o>)</span> <span class=o>{</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>==</span> <span class=n>nums</span><span class=o>[</span><span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]])</span> <span class=o>{</span>
                <span class=n>duplication</span><span class=o>[</span><span class=mi>0</span><span class=o>]</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
                <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
            <span class=o>}</span>
            <span class=n>swap</span><span class=o>(</span><span class=n>nums</span><span class=o>,</span> <span class=n>i</span><span class=o>,</span> <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]);</span>
        <span class=o>}</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>swap</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>,</span> <span class=kt>int</span> <span class=n>i</span><span class=o>,</span> <span class=kt>int</span> <span class=n>j</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
    <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>j</span><span class=o>];</span>
    <span class=n>nums</span><span class=o>[</span><span class=n>j</span><span class=o>]</span> <span class=o>=</span> <span class=n>t</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="3_1">3. 二维数组中的查找<a class="headerlink" href="#3_1" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p> <div class=codehilite><pre>Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
</pre></div></p>
<p><hh>解题思路</hh></p>
<p>首先选取数组中右上角的数字。</p>
<ul>
<li>如果该数字等于要查找的数字，查找过程结束：</li>
<li>如果该数字大于要查找的数字，剔除这个数字所在的列; 如果该数字小于要查找的数字，剔除这个数字所在的行。也就是说如果要查找的数字不在数组的右上角，则每－次都在数组的查找范围中剔除）行或者一列，这样每一步都可以缩小.</li>
<li>查找的范围，直到找到要查找的数字，或者查找范围为空。</li>
</ul>
<p>时间复杂度：<span><span class="MathJax_Preview">O(M + N) + O(1)</span><script type="math/tex">O(M + N) + O(1)</script></span></p>
<p>当前元素的查找区间为左下角的所有元素，例如元素12的查找区间如下：</p>
<p><img alt="" src="../figures/Q4er-wei-shu-zu-zhong-de-cha-zhao.jpg" /></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>Find</span><span class=o>(</span><span class=kt>int</span> <span class=n>target</span><span class=o>,</span> <span class=kt>int</span> <span class=o>[][]</span> <span class=n>array</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>array</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>array</span><span class=o>.</span><span class=na>length</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>array</span><span class=o>[</span><span class=mi>0</span><span class=o>].</span><span class=na>length</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>row</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>col</span> <span class=o>=</span> <span class=n>array</span><span class=o>[</span><span class=mi>0</span><span class=o>].</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>row</span> <span class=o>&lt;</span> <span class=n>array</span><span class=o>.</span><span class=na>length</span> <span class=o>&amp;&amp;</span> <span class=n>col</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>cmp</span> <span class=o>=</span> <span class=n>array</span><span class=o>[</span><span class=n>row</span><span class=o>][</span><span class=n>col</span><span class=o>]</span> <span class=o>-</span> <span class=n>target</span><span class=o>;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>cmp</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=n>col</span><span class=o>--;</span>
        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>cmp</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span> <span class=n>row</span><span class=o>++;</span>
        <span class=k>else</span> <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="4">4. 替换空格<a class="headerlink" href="#4" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&amp;tqId=11155&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为"We Are Happy". 则经过替换之后的字符串"为We%20Are%20Happy"。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在⽹络编程中，如果URL参数中含有特殊字符，如空格、'#'等，可能导致服务器端⽆法获得正确的参数值。我们需要将这些特殊符号转换成服务器可以识别的字符。转换的规则是在'%'后⾯跟上ASCII码的两位⼗六进制的表⽰。⽐如空格的ASCII码是32，即⼗六进制的0x20，因此空格被替换成"%20"。再⽐如'#'的ASCII码为35，即⼗六进制的0x23，它在URL中被替换为"%23"。</p>
</div>
<p><hh>解题思路</hh></p>
<p>最直观的做法是从头到尾扫描字符串，每次碰到空格字符的时候进行替换。由于是把1个字符替换成3个字符，我们必须要把空格后面的字符都后移2个字节，否则就有两个字符被覆盖了。</p>
<p>从前往后把字符串"We are happy."中的空格替换成"%20"的过程。灰色背景表示需要移动的字符。
<img alt="" src="../figures/Q5-kong-ge-ti-huan.jpg" /></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>String</span> <span class=nf>replaceSpace</span><span class=o>(</span><span class=n>StringBuffer</span> <span class=n>str</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>str</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>()</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=k>return</span> <span class=s>&quot;&quot;</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>();</span> <span class=n>i</span><span class=o>++)</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>str</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>i</span><span class=o>)</span> <span class=o>==</span> <span class=sc>&#39; &#39;</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>str</span><span class=o>.</span><span class=na>setCharAt</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=sc>&#39;%&#39;</span><span class=o>);</span>
            <span class=n>str</span><span class=o>.</span><span class=na>insert</span><span class=o>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=o>,</span> <span class=s>&quot;20&quot;</span><span class=o>);</span>
            <span class=n>i</span> <span class=o>+=</span> <span class=mi>2</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=k>return</span> <span class=n>str</span><span class=o>.</span><span class=na>toString</span><span class=o>();</span>
<span class=o>}</span>
</pre></div></p>
<p>假设字符串的长度是<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>。对每个空格字符，需要移动后面<span><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span>个字符，因此对于含有<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>个字符的字符串而言，最坏时间复杂度是<span><span class="MathJax_Preview">O(n^2)</span><script type="math/tex">O(n^2)</script></span>。</p>
<p>能不能减少移动次数呢？答案是肯定的，把从前向后替换改成从后向前替换。可以先遍历一次字符串，统计出字符串中空格的综述，计算出替换之后的字符串长度 = <span><span class="MathJax_Preview">n + 2 \times</span><script type="math/tex">n + 2 \times</script></span> 空格数。</p>
<p>在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。准备两个指针，P1和P2，P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾.接下来我们向前移动指针P1，逐个把它指向的字符复制到P2指向的位置，直到碰到空格为止，此时把P1向前移动1格，并在P2之前插入字符串"%20",然后向前移动3格。重复此过程，直到P1和P2指向同一位置，表明所有空格都已经替换完毕。</p>
<p><img alt="" src="../figures/Q5-ti-huan-kong-ge-p1-p2.jpg" /></p>
<p>由于所有的字符都指复制/移动一次，因此时间复杂度是<span><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span>。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>String</span> <span class=nf>replaceSpace</span><span class=o>(</span><span class=n>StringBuffer</span> <span class=n>str</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>str</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>()</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=k>return</span> <span class=s>&quot;&quot;</span><span class=o>;</span>
    <span class=c1>// 获取空格的数量</span>
    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>();</span>
    <span class=kt>int</span> <span class=n>numOfSpace</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>str</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>i</span><span class=o>)</span> <span class=o>==</span> <span class=sc>&#39; &#39;</span><span class=o>)</span> <span class=n>numOfSpace</span><span class=o>++;</span>

    <span class=c1>// 插入空格</span>
    <span class=kt>int</span> <span class=n>newStringLength</span> <span class=o>=</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>numOfSpace</span><span class=o>;</span> <span class=c1>// 新字符串长度</span>
    <span class=n>str</span><span class=o>.</span><span class=na>setLength</span><span class=o>(</span><span class=n>newStringLength</span><span class=o>);</span>    <span class=c1>// 扩充字符串</span>
    <span class=kt>int</span> <span class=n>p1</span> <span class=o>=</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=o>,</span> <span class=n>p2</span> <span class=o>=</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>()</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span>    <span class=c1>// p1指向旧字符串，p2指向新字符串</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>p1</span> <span class=o>!=</span> <span class=n>p2</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>str</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>p1</span><span class=o>)</span> <span class=o>!=</span> <span class=sc>&#39; &#39;</span><span class=o>)</span> <span class=n>str</span><span class=o>.</span><span class=na>setCharAt</span><span class=o>(</span><span class=n>p2</span><span class=o>--,</span> <span class=n>str</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>p1</span><span class=o>));</span>
        <span class=k>else</span> <span class=o>{</span>
            <span class=n>str</span><span class=o>.</span><span class=na>setCharAt</span><span class=o>(</span><span class=n>p2</span><span class=o>--,</span> <span class=sc>&#39;0&#39;</span><span class=o>);</span>
            <span class=n>str</span><span class=o>.</span><span class=na>setCharAt</span><span class=o>(</span><span class=n>p2</span><span class=o>--,</span> <span class=sc>&#39;2&#39;</span><span class=o>);</span>
            <span class=n>str</span><span class=o>.</span><span class=na>setCharAt</span><span class=o>(</span><span class=n>p2</span><span class=o>--,</span> <span class=sc>&#39;%&#39;</span><span class=o>);</span>
        <span class=o>}</span>
        <span class=n>p1</span><span class=o>--;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>str</span><span class=o>.</span><span class=na>toString</span><span class=o>();</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="5">5. 从尾到头打印链表<a class="headerlink" href="#5" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>输入链表的第一个节点，从尾到头反过来打印出每个结点的值。链表结点定义如下：</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ListNode</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>val</span><span class=o>;</span>
    <span class=n>ListNode</span> <span class=n>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
    <span class=n>ListNode</span><span class=o>(</span><span class=kt>int</span> <span class=n>val</span><span class=o>)</span> <span class=o>{</span>
         <span class=k>this</span><span class=o>.</span><span class=na>val</span> <span class=o>=</span> <span class=n>val</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<p><hh>解题思路</hh></p>
<p>我们想到解决这个问题肯定要遍历链表。遍历的顺序是从头到尾的顺序，可输出的顺序却是从尾到头。也就是说第⼀个遍历到的结点最后⼀个输出，⽽最后⼀个遍历到的结点第⼀个输出。这就是典型的“后进先出”，我们可以⽤栈实现这种顺序。每经过⼀个结点的时候，把该结点放到⼀个栈中。当遍历完整个链表后，再从栈顶开始逐个输出结点的值，此时输出的结点的顺序已经反转过来了。</p>
<p><hh>使用栈</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>printListFromTailToHead</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>listNode</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>listNode</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=k>return</span> <span class=k>new</span> <span class=n>ArrayList</span>
    <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>stack</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;&gt;();</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>listNode</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>stack</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>listNode</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
        <span class=n>listNode</span> <span class=o>=</span> <span class=n>listNode</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=c1>// 不能直接返回: return new ArrayList&lt;&gt;(stack);</span>
    <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>ret</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=k>while</span> <span class=o>(!</span><span class=n>stack</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span>
        <span class=n>res</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>stack</span><span class=o>.</span><span class=na>pop</span><span class=o>());</span>
    <span class=k>return</span> <span class=n>res</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<p><hh>使用递归</hh></p>
<p>既然想到了⽤栈来实现这个函数，⽽递归在本质上就是⼀个栈结构， 于是很⾃然地又想到了⽤递归来实现。要实现反过来输出链表，我们每访问到⼀个结点的时候，先递归输出它后⾯的结点，再输出该结点⾃⾝，这样链表的输出结果就反过来了。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>printListFromTailToHead</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>listNode</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=n>printListFromTailToHead</span><span class=o>(</span><span class=n>list</span><span class=o>,</span> <span class=n>listNode</span><span class=o>);</span>
   <span class=k>return</span> <span class=n>list</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>printListFromTailToHead</span><span class=o>(</span><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span><span class=o>,</span> <span class=n>ListNode</span> <span class=n>listNode</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>listNode</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=k>return</span><span class=o>;</span>
    <span class=n>printListFromTailToHead</span><span class=o>(</span><span class=n>list</span><span class=o>,</span> <span class=n>listNode</span><span class=o>.</span><span class=na>next</span><span class=o>);</span>
    <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>listNode</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
<span class=o>}</span>
</pre></div></p>
<p>也可以使用<code class="codehilite">ArrayList.addAll()</code>，从而省去辅助函数，当然效率比较低：</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>printListFromTailToHead</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>listNode</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>listNode</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=k>return</span> <span class=n>list</span><span class=o>;</span>
    <span class=n>list</span><span class=o>.</span><span class=na>addAll</span><span class=o>(</span><span class=n>printListFromTailToHead</span><span class=o>(</span><span class=n>listNode</span><span class=o>.</span><span class=na>next</span><span class=o>));</span>
    <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>listNode</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>list</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<p>虽然上⾯的基于递归的代码看起来很简洁，但有个问题：当链表⾮常长的时候，就会导致函数调⽤的层级很深，从⽽有可能导致<em>函数调⽤栈溢出</em>。显式⽤栈基于循环实现的代码的鲁棒性要好⼀些。</p>
<p><hh>使用Collections.reverse()</hh></p>
<p>顺序遍历链表，获取链表节点的值，然后反转。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>printListFromTailToHead</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>listNode</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>res</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>listNode</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>res</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>listNode</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
        <span class=n>listNode</span> <span class=o>=</span> <span class=n>listNode</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=n>Collections</span><span class=o>.</span><span class=na>reverse</span><span class=o>(</span><span class=n>res</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>res</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="6">6. 重建二叉树<a class="headerlink" href="#6" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p> <div class=codehilite><pre>preorder = [3,9,20,15,7]
inorder =  [9,3,15,20,7]
</pre></div></p>
<p><img alt="" src="../figures/Q7-reconstruct-binary-tree.jpg" /></p>
<p><hh>解题思路</hh>见<a href="http://localhost/wiki/2017/10/30/Leetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/">LeetCode 105</a>.</p>
<h3 id="8">8. 二叉树的下一个结点<a class="headerlink" href="#8" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<p><C>TreeLinkNode</C>定义：</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>TreeLinkNode</span> <span class=o>{</span>

    <span class=kt>int</span> <span class=n>val</span><span class=o>;</span>
    <span class=n>TreeLinkNode</span> <span class=n>left</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
    <span class=n>TreeLinkNode</span> <span class=n>right</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
    <span class=n>TreeLinkNode</span> <span class=n>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>

    <span class=n>TreeLinkNode</span><span class=o>(</span><span class=kt>int</span> <span class=n>val</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>val</span> <span class=o>=</span> <span class=n>val</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<p><hh>解题思路</hh></p>
<p>① 如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点；</p>
<p><img alt="" src="../figures/Q8-1.jpg" /></p>
<p>② 否则，向上找第一个左链接指向的树包含该节点的祖先节点。</p>
<p><img alt="" src="../figures/Q8-2.jpg" /></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>TreeLinkNode</span> <span class=nf>GetNext</span><span class=o>(</span><span class=n>TreeLinkNode</span> <span class=n>root</span><span class=o>){</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
    <span class=c1>// 右子树的最左节点</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>root</span> <span class=o>=</span> <span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>;</span>
        <span class=k>while</span> <span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=n>root</span> <span class=o>=</span> <span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>;</span>
        <span class=k>return</span> <span class=n>root</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=c1>// 第一个左链接指向的树包含左子树</span>
    <span class=n>TreeLinkNode</span> <span class=n>parent</span> <span class=o>=</span> <span class=n>root</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=k>while</span><span class=o>(</span><span class=n>parent</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>root</span> <span class=o>!=</span> <span class=n>parent</span><span class=o>.</span><span class=na>left</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>root</span> <span class=o>=</span> <span class=n>parent</span><span class=o>;</span>
        <span class=n>parent</span> <span class=o>=</span> <span class=n>root</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>parent</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="7">7. 用两个栈实现队列<a class="headerlink" href="#7" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。</p>
<p><hh>解题思路</hh></p>
<p>in栈用来处理入栈(push)操作，out栈用来处理出栈(pop)操作。一个元素进入in栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入out栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。</p>
<p>当out栈中不为空时，在out栈中的栈顶元素是最先进⼊队列的元素，可以弹出。当out栈为空时，我们把in栈中的元素逐个弹出并压⼊out栈。由于先进⼊队列的元素被压到in栈的底端，经过弹出和压⼊之后就处于out栈的顶端了，又可以直接弹出。</p>
<p>例如，1,2,3,4的入栈和出栈：</p>
<p><img alt="" src="../figures/Q9-yong-liang-ge-zhan-shi-xian-dui-lie.jpg" /></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Queue</span> <span class=o>{</span>
    <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>in</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;();</span>
    <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>out</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;();</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>push</span><span class=o>(</span><span class=kt>int</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>in</span><span class=o>.</span><span class=na>push</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>pop</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>out</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span>
            <span class=k>while</span> <span class=o>(!</span><span class=n>in</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span>
                <span class=n>out</span><span class=o>.</span><span class=na>push</span><span class=o>(</span><span class=n>in</span><span class=o>.</span><span class=na>pop</span><span class=o>());</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>out</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span> <span class=k>throw</span> <span class=k>new</span> <span class=n>Exception</span><span class=o>(</span><span class=s>&quot;Queue is Empty!&quot;</span><span class=o>);</span>
        <span class=k>return</span> <span class=n>out</span><span class=o>.</span><span class=na>pop</span><span class=o>();</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="8_1">8. 旋转数组的最小数字<a class="headerlink" href="#8_1" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p><hh>解题思路</hh>
如果数字不重复，见<a href="http://larryim.cc/wiki/2017/10/30/Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array/">LeetCode 153 Find Minimum in Rotated Sorted Array</a>.</p>
<p>如果数组元素允许重复的话，那么就会出现一个特殊的情况：nums<span><span class="MathJax_Preview">[lo]</span><script type="math/tex">[lo]</script></span> = nums<span><span class="MathJax_Preview">[mid]</span><script type="math/tex">[mid]</script></span> = nums<span><span class="MathJax_Preview">[hi]</span><script type="math/tex">[hi]</script></span>，那么此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，<span><span class="MathJax_Preview">lo、mid</span><script type="math/tex">lo、mid</script></span>和<span><span class="MathJax_Preview">hi</span><script type="math/tex">hi</script></span>指向的数都为1，此时无法知道最小数字0在哪个区间。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>minNumberInRotateArray</span><span class=o>(</span><span class=kt>int</span> <span class=o>[]</span> <span class=n>nums</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>nums</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>nums</span><span class=o>.</span><span class=na>length</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>lo</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>hi</span> <span class=o>=</span> <span class=n>nums</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=o>,</span> <span class=n>mid</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>lo</span> <span class=o>&lt;</span> <span class=n>hi</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>// 取中间的位置</span>
        <span class=n>mid</span> <span class=o>=</span> <span class=n>lo</span> <span class=o>+</span> <span class=o>(</span><span class=n>hi</span> <span class=o>-</span> <span class=n>lo</span><span class=o>)</span> <span class=o>/</span> <span class=mi>2</span><span class=o>;</span>
        <span class=c1>// 如果三个数都相等，则需要进行顺序处理，从头到尾找最小的值</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>nums</span><span class=o>[</span><span class=n>mid</span><span class=o>]</span> <span class=o>==</span> <span class=n>nums</span><span class=o>[</span><span class=n>hi</span><span class=o>]</span> <span class=o>&amp;&amp;</span> <span class=n>nums</span><span class=o>[</span><span class=n>mid</span><span class=o>]</span> <span class=o>==</span> <span class=n>nums</span><span class=o>[</span><span class=n>lo</span><span class=o>])</span> 
            <span class=k>return</span> <span class=n>findMin</span><span class=o>(</span><span class=n>nums</span><span class=o>,</span> <span class=n>lo</span> <span class=o>,</span> <span class=n>hi</span><span class=o>);</span>
        <span class=c1>// 如果中间位置对应的值在后一个排好序的部分，将hi设置为新的处理位置</span>
        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>nums</span><span class=o>[</span><span class=n>mid</span><span class=o>]</span> <span class=o>&gt;</span> <span class=n>nums</span><span class=o>[</span><span class=n>hi</span><span class=o>])</span> <span class=n>lo</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=o>;</span>
        <span class=k>else</span> <span class=n>hi</span> <span class=o>=</span> <span class=n>mid</span><span class=o>;</span> <span class=c1>// 不是 hi = mid - 1;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>nums</span><span class=o>[</span><span class=n>lo</span><span class=o>];</span>
<span class=o>}</span>
<span class=c1>// 找数组中的最小值</span>
<span class=kd>private</span> <span class=kt>int</span> <span class=nf>findMin</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>,</span> <span class=kt>int</span> <span class=n>lo</span><span class=o>,</span> <span class=kt>int</span> <span class=n>hi</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>min</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>lo</span><span class=o>];</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>lo</span> <span class=o>+</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>hi</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>&lt;</span> <span class=n>min</span><span class=o>)</span> <span class=n>min</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
    <span class=k>return</span> <span class=n>min</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="9">9 斐波那契数列<a class="headerlink" href="#9" title="Permanent link">&para;</a></h3>
<h4 id="_1">斐波那契数列<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h4>
<p><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;tqId=11160&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>求斐波那契数列的第<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>项，<span><span class="MathJax_Preview">n &lt;= 39</span><script type="math/tex">n <= 39</script></span>。</p>
<div align="center"><img src="https://latex.codecogs.com/gif.latex?f(n)=\left\{\begin{array}{rcl}0&&{n=0}\\1&&{n=1}\\f(n-1)+f(n-2)&&{n>1}\end{array}\right."/></div>

<p><hh>解题思路</hh></p>
<p>由于斐波那契数列可以用递归函数表示，最直接的方法是用递归来解决。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>Fibonacci</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=o>)</span> <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=o>)</span> <span class=k>return</span> <span class=mi>1</span><span class=o>;</span>
    <span class=k>return</span> <span class=n>Fibonacci</span><span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)</span> <span class=o>+</span> <span class=n>Fibonacci</span><span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>2</span><span class=o>);</span>
<span class=o>}</span>
</pre></div></p>
<p>但是如果使用递归求解，会重复计算一些子问题。例如，计算<span><span class="MathJax_Preview">f(10)</span><script type="math/tex">f(10)</script></span>需要计算 <span><span class="MathJax_Preview">f(9)</span><script type="math/tex">f(9)</script></span>和<span><span class="MathJax_Preview">f(8)</span><script type="math/tex">f(8)</script></span>，计算<span><span class="MathJax_Preview">f(9)</span><script type="math/tex">f(9)</script></span>需要计算<span><span class="MathJax_Preview">f(8)</span><script type="math/tex">f(8)</script></span>和<span><span class="MathJax_Preview">f(7)</span><script type="math/tex">f(7)</script></span>，可以看到<span><span class="MathJax_Preview">f(8)</span><script type="math/tex">f(8)</script></span>被重复计算了。事实上，⽤递归⽅法计算的时间复杂度是以<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>的指数的⽅式递增的。</p>
<p>使用动态规划的思想把子问题的解缓存起来，从而避免重复求解子问题。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>Fibonacci</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=o>)</span> <span class=k>return</span> <span class=n>n</span><span class=o>;</span>
    <span class=kt>int</span><span class=o>[]</span> <span class=n>fib</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=o>];</span>
    <span class=n>fib</span><span class=o>[</span><span class=mi>1</span><span class=o>]</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=n>fib</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>fib</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=o>]</span> <span class=o>+</span> <span class=n>fib</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>2</span><span class=o>];</span>
    <span class=k>return</span> <span class=n>fib</span><span class=o>[</span><span class=n>n</span><span class=o>];</span>
<span class=o>}</span>
</pre></div></p>
<p>考虑到第<span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>项只与第<span><span class="MathJax_Preview">i-1</span><script type="math/tex">i-1</script></span>和第<span><span class="MathJax_Preview">i-2</span><script type="math/tex">i-2</script></span>项有关，因此只需要存储前两项的值就能求解第<span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>项，从而将空间复杂度由<span><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span>降低为<span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>Fibonacci</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span> <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&quot;n must be a non-negative integer&quot;</span><span class=o>);</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=o>)</span> <span class=k>return</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=mi>1</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>prev</span> <span class=o>=</span> <span class=mi>1</span><span class=o>,</span> <span class=n>before_prev</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>cur</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=n>cur</span> <span class=o>=</span> <span class=n>prev</span> <span class=o>+</span> <span class=n>before_prev</span><span class=o>;</span>
        <span class=n>before_prev</span> <span class=o>=</span> <span class=n>prev</span><span class=o>;</span>
        <span class=n>prev</span> <span class=o>=</span> <span class=n>cur</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>cur</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<p>由于待求解的<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>小于40，因此也可以将前40项的结果先进行计算，之后就能以 <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>时间复杂度得到第<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>项的值了。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>

    <span class=kd>private</span> <span class=kt>int</span><span class=o>[]</span> <span class=n>fib</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=mi>40</span><span class=o>];</span>

    <span class=kd>public</span> <span class=nf>Solution</span><span class=o>()</span> <span class=o>{</span>
        <span class=n>fib</span><span class=o>[</span><span class=mi>1</span><span class=o>]</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>
        <span class=n>fib</span><span class=o>[</span><span class=mi>2</span><span class=o>]</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>fib</span><span class=o>.</span><span class=na>length</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
            <span class=n>fib</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>fib</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=o>]</span> <span class=o>+</span> <span class=n>fib</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>2</span><span class=o>];</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>Fibonacci</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>fib</span><span class=o>[</span><span class=n>n</span><span class=o>];</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<h4 id="_2">跳台阶<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h4>
<p><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p><hh>解题思路</hh></p>
<p>题目类似于<a href="http://larryim.cc/wiki/2017/10/30/Leetcode-70-Climbing-Stairs/">LeetCode 70 climbing stairs</a>。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>JumpFloor</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>2</span><span class=o>)</span> <span class=k>return</span> <span class=n>n</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>last</span> <span class=o>=</span> <span class=mi>1</span><span class=o>,</span> <span class=n>secondLast</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=n>result</span> <span class=o>=</span> <span class=n>secondLast</span> <span class=o>+</span> <span class=n>last</span><span class=o>;</span>
        <span class=n>secondLast</span> <span class=o>=</span> <span class=n>last</span><span class=o>;</span>
        <span class=n>last</span> <span class=o>=</span> <span class=n>result</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>result</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h4 id="_3">矩形覆盖<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h4>
<p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>我们可以用<span><span class="MathJax_Preview">2\times 1</span><script type="math/tex">2\times 1</script></span>的小矩形横着或者竖着去覆盖更大的矩形。请问用<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>个<span><span class="MathJax_Preview">2\times 1</span><script type="math/tex">2\times 1</script></span>的小矩形无重叠地覆盖一个<span><span class="MathJax_Preview">2\times n</span><script type="math/tex">2\times n</script></span>的大矩形，总共有多少种方法？</p>
<p><img alt="" src="../figures/juxingfugai.jpg" /></p>
<p><hh>解题思路</hh></p>
<p>我们先把<span><span class="MathJax_Preview">2×8</span><script type="math/tex">2×8</script></span>的覆盖⽅法记为<span><span class="MathJax_Preview">f(8</span><script type="math/tex">f(8</script></span>。⽤第⼀个<span><span class="MathJax_Preview">1×2</span><script type="math/tex">1×2</script></span>⼩矩形去覆盖⼤矩形的最左边时有两个选择，竖着放或者横着放。当竖着放的时候，右边还剩下<span><span class="MathJax_Preview">2×7</span><script type="math/tex">2×7</script></span>的区域，这种情形下的覆盖⽅法记为<span><span class="MathJax_Preview">f(7)</span><script type="math/tex">f(7)</script></span>。接下来考虑横着放的情况。当<span><span class="MathJax_Preview">1×2</span><script type="math/tex">1×2</script></span>的⼩矩形横着放在左上⾓的时候，左下⾓必须和横着放⼀个<span><span class="MathJax_Preview">1×2</span><script type="math/tex">1×2</script></span>的⼩矩形，⽽在右边还还剩下<span><span class="MathJax_Preview">2×6</span><script type="math/tex">2×6</script></span>的区域，这种情形下的覆盖⽅法记为 <span><span class="MathJax_Preview">f(6)</span><script type="math/tex">f(6)</script></span>，因此<span><span class="MathJax_Preview">f(8)</span><script type="math/tex">f(8)</script></span>=<span><span class="MathJax_Preview">f(7)＋f(6)</span><script type="math/tex">f(7)＋f(6)</script></span>。此时我们可以看出，这仍然是斐波那契数列。</p>
<h4 id="_4">变态跳台阶<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h4>
<p><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tqId=11162&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级... 它也可以跳上<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>级。求该青蛙跳上一个<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>级的台阶总共有多少种跳法。</p>
<p><span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>个台阶总共有<span><span class="MathJax_Preview">2^{n-1}</span><script type="math/tex">2^{n-1}</script></span>种跳法。分析如下:</p>
<ul>
<li><span><span class="MathJax_Preview">f(1) = 1</span><script type="math/tex">f(1) = 1</script></span></li>
<li><span><span class="MathJax_Preview">f(2) = f(2-1) + f(2-2)</span><script type="math/tex">f(2) = f(2-1) + f(2-2)</script></span></li>
<li><span><span class="MathJax_Preview">f(3) = f(3-1) + f(3-2) + f(3-3)</span><script type="math/tex">f(3) = f(3-1) + f(3-2) + f(3-3)</script></span></li>
<li>...</li>
<li><span><span class="MathJax_Preview">f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)</span><script type="math/tex">f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)</script></span></li>
</ul>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>JumpFloorII</span><span class=o>(</span><span class=kt>int</span> <span class=n>target</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>target</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=o>)</span> <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
    <span class=kt>int</span><span class=o>[]</span> <span class=n>dp</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>target</span> <span class=o>+</span> <span class=mi>1</span><span class=o>];</span>
    <span class=n>dp</span><span class=o>[</span><span class=mi>0</span><span class=o>]</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>target</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>i</span><span class=o>;</span> <span class=n>j</span><span class=o>++)</span>
            <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>+=</span> <span class=n>dp</span><span class=o>[</span><span class=n>j</span><span class=o>];</span>
        <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>+=</span> <span class=mi>1</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>dp</span><span class=o>[</span><span class=n>target</span><span class=o>];</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="10-1">10. 二进制中1的个数<a class="headerlink" href="#10-1" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&amp;tqId=11164&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p><hh>解题思路</hh></p>
<p>见<a href="http://larryim.cc/wiki/2017/10/30/Leetcode-191-Number-of-1-Bits/">LeetCode 191 Number of 1 bits</a>。</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../../..",
                shortcuts = {"search": 83, "next": 78, "help": 191, "previous": 80};
        </script>
        <script src="../../../js/base.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
        <script src="../../../extra_javascript/tabhack.js" defer></script>
        <script src="../../../extra_javascript/baidu.js" defer></script>
        <script src="../../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
