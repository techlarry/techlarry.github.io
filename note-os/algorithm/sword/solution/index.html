<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Zhenhua Wang">
        <link rel="canonical" href="http://larryim.cc/note-os/algorithm/sword/solution/">
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>剑指Offer题解 - Zhenhua's Notes</title>
        <link href="../../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/docco.min.css">
        <link href="../../../extra_css/custom.css" rel="stylesheet">
        <link href="../../../extra_css/custom.js" rel="stylesheet">
        <link href="../../../extra_css/friendly.css" rel="stylesheet">
        <link href="../../../extra_css/theme.css" rel="stylesheet">
        <link href="../../../extra_css/mkdocs/js/lunr-0.5.7.min.js" rel="stylesheet">
        <link href="../../../extra_css/mkdocs/js/mustache.min.js" rel="stylesheet">
        <link href="../../../extra_css/mkdocs/js/require.js" rel="stylesheet">
        <link href="../../../extra_css/mkdocs/js/search.js" rel="stylesheet">
        <link href="../../../extra_css/mkdocs/js/text.js" rel="stylesheet">
        <link href="../../../extra_css/code-tab.css" rel="stylesheet">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../../..">Zhenhua's Notes</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../../..">Home</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Algorithm <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../">Contents</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#">AlgorithmPrinceton</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../algorithmPrinceton/">Contents</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/unionfind/">Topic 1: UnionFind</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/stackqueue/">Topic 2: StackQueue</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/sort/">Topic 3: Sort</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/priorityqueue/">Topic 4: PriorityQueues</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/symboltable/">Topic 5: Symbol Tables</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/bst/">Topic 6: Balanced Search Trees</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/hashtable/">Topic 7: Hash Table</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/graph/">Topic 8: Graph</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/mst_shortestpath/">Topic 9: Minimum Spanning Tree and Shortest Path</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/stringsort/">Topic 11: String Sort</a>
</li>
            
<li >
    <a href="../../algorithmPrinceton/tries/">Topic 12: Tries</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">AlgorithmStanford</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../algorithmStanford/">Contents</a>
</li>
            
<li >
    <a href="../../algorithmStanford/dynamicprogramming/">Topic: Dynammic Programming</a>
</li>
            
<li >
    <a href="../../algorithmStanford/heap/">Topic: Heap</a>
</li>
            
<li >
    <a href="../../algorithmStanford/graph/">Topic: Graph</a>
</li>
            
<li >
    <a href="../../algorithmStanford/greedy/">Topic: Greedy Algorithm</a>
</li>
            
<li >
    <a href="../../algorithmStanford/hashtable/">Topic: Hash Table</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">CS61B</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../cs61b/">Contents</a>
</li>
            
<li >
    <a href="../../cs61b/Lab1/">Lab1: javac, java, git</a>
</li>
            
<li >
    <a href="../../cs61b/Lab2/">Lab2: Unit Testing with JUnit and IntLists</a>
</li>
            
<li >
    <a href="../../cs61b/Lab3/">Lab3: Unit Testing with JUnit, Debugging</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">SWORD</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../">Contents</a>
</li>
            
<li class="active">
    <a href="./">剑指Offer题解</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">OS <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../../os/">Contents</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#">OSC</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../os/osc/">Contents</a>
</li>
            
<li >
    <a href="../../../os/osc/ch1/">Chapter 1: Introduction </a>
</li>
            
<li >
    <a href="../../../os/osc/ch2/">Chapter 2: Operating System structures</a>
</li>
            
<li >
    <a href="../../../os/osc/ch3/">Chapter 3: Processes</a>
</li>
            
<li >
    <a href="../../../os/osc/ch4/">Chapter 4: Threads and Concurrency</a>
</li>
            
<li >
    <a href="../../../os/osc/ch5/">Chapter 5: CPU Scheduling</a>
</li>
            
<li >
    <a href="../../../os/osc/ch6/">Chapter 6: Synchronization Tools</a>
</li>
            
<li >
    <a href="../../../os/osc/ch7/">Chapter 7: Synchronization Examples</a>
</li>
            
<li >
    <a href="../../../os/osc/ch8/">Chapter 8: Deadlocks</a>
</li>
            
<li >
    <a href="../../../os/osc/ch9/">Chapter 9: Main Memory</a>
</li>
            
<li >
    <a href="../../../os/osc/ch10/">Chapter 10: Virtual Memory</a>
</li>
            
<li >
    <a href="../../../os/osc/ch11/">Chapter 11: Mass-Storage Structure</a>
</li>
            
<li >
    <a href="../../../os/osc/ch13/">Chapter 13: File-System Interfaces</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">CSAPP</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../os/csapp/">Contents</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch1/">Chapter 1: 计算机系统漫游</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch2/">Chapter 2: 信息的表示和处理</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch3/">Chapter 3: 程序的机器级表示</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch4/">Chapter 4: 处理器体系结构</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch5/">Chapter 5: 优化程序性能</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch6/">Chapter 6: 存储器层次结构</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch7/">Chapter 7: 链接</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch8/">Chapter 8: 异常控制流</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch9/">Chapter 9: 虚拟内存</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch10/">Chapter 10: 系统级I/O</a>
</li>
            
<li >
    <a href="../../../os/csapp/ch11/">Chapter 11: 网络编程</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">DataBase <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../../database/">Contents</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#">MySql</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../database/mysql/">Contents</a>
</li>
            
<li >
    <a href="../../../database/mysql/LearningMySQLandMariaDB/">Chapter Learning MySQL and MariaDB</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Java <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../../java/">Contents</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#">HFJ</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../java/hfj/">Contents</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch1/">Chapter 1: Dive in A Quick Dip</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch2/">Chapter 2: Classes and Objects</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch3/">Chapter 3: Primitives and References</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch4/">Chapter 4: Methods use Instance Variables</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch5/">Chapter 5: Writing a Program</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch6/">Chapter 6: Get to Know the Java API</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch7/">Chapter 7: Inheritance and Polymorphism</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch8/">Chapter 8: Interfaces and Abstract Classes</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch9/">Chapter 9: Constructors and Garbage Collection</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch10/">Chapter 10: Numbers and Statics</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch11/">Chapter 11: Exception Handling</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch12/">Chapter 12: Getting GUI</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch13/">Chapter 13: Using Swing</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch14/">Chapter 14: Serialization and File I/O</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch15/">Chapter 15: Networking and Threads</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch16/">Chapter 16: Collections and Generics</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch17/">Chapter 17: Packages, Jars and Deployment</a>
</li>
            
<li >
    <a href="../../../java/hfj/ch18/">Chapter 18: Remote deploy with RMI</a>
</li>
            
<li >
    <a href="../../../java/hfj/Appendix/">Appendix: The Top Ten Topics</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">HFDP</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../java/hfdp/">Contents</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch1/">Chapter 1: Strategy Pattern </a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch2/">Chapter 2: Observer Pattern</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch3/">Chapter 3: Decorator Pattern </a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch4/">Chapter 4: Factory Pattern</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch5/">Chapter 5: Singleton Pattern</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch6/">Chapter 6: Command Pattern</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch7/">Chapter 7: Adapter and Facade Patterns</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch8/">Chapter 8: Template Method Pattern</a>
</li>
            
<li >
    <a href="../../../java/hfdp/ch9/">Chapter 9: Iterator and Composite Patterns</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">MultiThreading</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../java/multithreading/">Contents</a>
</li>
            
<li >
    <a href="../../../java/multithreading/pre1/">序章1 Java线程</a>
</li>
            
<li >
    <a href="../../../java/multithreading/pre2/">序章2 多线程程序的评价标准</a>
</li>
            
<li >
    <a href="../../../java/multithreading/ch1/">第1章 Single Threaded Execution模式</a>
</li>
            
<li >
    <a href="../../../java/multithreading/ch1/">第2章 Immutable模式</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">TIJ</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../java/tij/">Contents</a>
</li>
            
<li >
    <a href="../../../java/tij/ch1/">Chapter 1: Introduction</a>
</li>
            
<li >
    <a href="../../../java/tij/ch2/">Chapter 2: Introduction to Objects</a>
</li>
            
<li >
    <a href="../../../java/tij/ch3/">Chapter 3: Everything is an Object</a>
</li>
            
<li >
    <a href="../../../java/tij/ch4/">Chapter 4: Opertors</a>
</li>
            
<li >
    <a href="../../../java/tij/ch5/">Chapter 5: Controlling Execution</a>
</li>
            
<li >
    <a href="../../../java/tij/ch6/">Chapter 6: Initialization & Cleanup</a>
</li>
            
<li >
    <a href="../../../java/tij/ch7/">Chapter 7: Access Control</a>
</li>
            
<li >
    <a href="../../../java/tij/ch8/">Chapter 8: Reusing Clases</a>
</li>
            
<li >
    <a href="../../../java/tij/ch9/">Chapter 9: Polymorphism</a>
</li>
            
<li >
    <a href="../../../java/tij/ch10/">Chapter 10: Interfaces</a>
</li>
            
<li >
    <a href="../../../java/tij/ch11/">Chapter 11: Inner Classes</a>
</li>
            
<li >
    <a href="../../../java/tij/ch12/">Chapter 12: Holding Your Objects</a>
</li>
            
<li >
    <a href="../../../java/tij/ch13/">Chapter 13: Error Handling with Exceptions</a>
</li>
            
<li >
    <a href="../../../java/tij/ch14/">Chapter 14: Strings</a>
</li>
            
<li >
    <a href="../../../java/tij/ch15/">Chapter 15: Type Information</a>
</li>
            
<li >
    <a href="../../../java/tij/ch16/">Chapter 16: Generics</a>
</li>
            
<li >
    <a href="../../../java/tij/ch17/">Chapter 17: Arrays</a>
</li>
            
<li >
    <a href="../../../java/tij/ch18/">Chapter 18: Containers in Depth</a>
</li>
            
<li >
    <a href="../../../java/tij/ch19/">Chapter 19: I/O</a>
</li>
            
<li >
    <a href="../../../java/tij/ch20/">Chapter 20: Enumerated Types</a>
</li>
            
<li >
    <a href="../../../java/tij/ch21/">Chapter 21: Annotations</a>
</li>
            
<li >
    <a href="../../../java/tij/ch22/">Chapter 22: Concurrency</a>
</li>
            
<li >
    <a href="../../../java/tij/ch23/">Chapter 23: Graphical User Interfaces</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">UJVM</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../java/ujvm/">Contents</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch1/">Chapter 1 : 走进Java</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch2/">Chapter 2 : Java内存区域与内存溢出正常</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch3/">Chapter 3 : 垃圾收集器与内存分配策略</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch4/">Chapter 4 : 虚拟机性能监控与故障处理工具</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch5/">Chapter 5 : 调优案例分析与实战</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch6/">Chapter 6 : 类文件结构</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch7/">Chapter 7 : 虚拟机类加载机制</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch8/">Chapter 8 : 虚拟机字节码执行引擎</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch9/">Chapter 9 : 类加载及执行子系统的案例与实战</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch10/">Chapter 10 : 早期(编译期)优化</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch11/">Chapter 11 : 晚期(运行期)优化</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch12/">Chapter 12 : Java内存模型与线程</a>
</li>
            
<li >
    <a href="../../../java/ujvm/ch13/">Chapter 13 : 线程安全与锁优化</a>
</li>
            
<li >
    <a href="../../../java/ujvm/AppendixC/">Appendix HotSpot虚拟机主要参数列表</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">BigData <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../../bigdata/">Contents</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#">HADOOP</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/hadoop/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch1/">Chapter 1: Meet Hadoop</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch2/">Chapter 2: MapReduce</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch3/">Chapter 3: The Hadoop Distributed FileSystem</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch4/">Chapter 4: YARN</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch5/">Chapter 5: Hadoop I/O</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch6/">Chapter 6: Developing a MapReduce Application</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch7/">Chapter 7: How MapReduce Works</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch8/">Chapter 8: MapReduce Types and Formats</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch9/">Chapter 9: MapReduce Features</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch10/">Chapter 10: Setting Up a Hadoop Cluster</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch11/">Chapter 11: Adminstering Hadoop</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch12/">Chapter 12: Avro</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch13/">Chapter 13: Parquet</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch14/">Chapter 14: Flume</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch15/">Chapter 15: Sqoop</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch16/">Chapter 16: Pig</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch17/">Chapter 17: Hive</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch18/">Chapter 18: Crunch</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch19/">Chapter 19: Spark</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch20/">Chapter 20: HBase</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch21/">Chapter 21: ZooKeeper</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch22/">Chapter 22: Composable Data at Center</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch23/">Chapter 23: Biological Data Science: Saving Lives with Software</a>
</li>
            
<li >
    <a href="../../../bigdata/hadoop/ch24/">Chapter 24: Cascading</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Spark</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/spark/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch1/">Chapter 1: Introduction to Data Analysis with Spark</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch2/">Chapter 2: Downloading Spark and Getting Started</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch3/">Chapter 3: Programming with RDDs</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch4/">Chapter 4: Working with Key/Value Pairs</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch5/">Chapter 5: Loading and Saving Your Data</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch6/">Chapter 6: Advanced Spark Programming</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch7/">Chapter 7: Running on a Cluster</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch8/">Chapter 8: Tuning and Debugging Spark</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch9/">Chapter 9: Spark SQL</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch10/">Chapter 10: Spark Streaming</a>
</li>
            
<li >
    <a href="../../../bigdata/spark/ch11/">Chapter 11: Machine Learning with MLlib</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">GDM</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/gdm/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch1/">Chapter 1: 推荐系统入门</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch2/">Chapter 2: 隐式评价和基于物品的过滤算法</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch3/">Chapter 3: 分类</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch4/">Chapter 4: 进一步探索分类</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch5/">Chapter 5: 概率和朴素贝叶斯</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch6/">Chapter 6: 朴素贝叶斯和文本数据</a>
</li>
            
<li >
    <a href="../../../bigdata/gdm/ch7/">Chapter 7: 聚类</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">MLIA</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/mlia/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch1/">Chapter 1: 机器学习基础</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch2/">Chapter 2: k-近邻算法</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch3/">Chapter 3: 决策树</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch4/">Chapter 4: 基于概率论的分类方法：朴素贝叶斯</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch5/">Chapter 5: Logistic回归</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch6/">Chapter 6: 支持向量机</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch7/">Chapter 7: 利用AdaBoost元算法提高分类性能</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch8/">Chapter 8: 预测数值型数据：回归</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch9/">Chapter 9: 树回归</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch10/">Chapter 10: 利用Ｋ-均值聚类算法对未标注数据分组</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch11/">Chapter 11: 使用Apriori算法进行关联分析</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch11/">Chapter 12: 使用FP-growth算法来高效发现频繁项集</a>
</li>
            
<li >
    <a href="../../../bigdata/mlia/ch13/">Chapter 13: 利用PCA来简化数据</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Crawler</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/crawler/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch1/">Chapter 1: 开发环境配置</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch2/">Chapter 2: 爬虫基础</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch3/">Chapter 3: 基本库的使用</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch4/">Chapter 4: 解析库的使用</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch5/">Chapter 5: 数据存储</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch7/">Chapter 7: 动态渲染页面爬取</a>
</li>
            
<li >
    <a href="../../../bigdata/crawler/ch13/">Chapter 13: Scrapy框架的使用</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Projects</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../bigdata/projects/">Contents</a>
</li>
            
<li >
    <a href="../../../bigdata/projects/SparkStreaming实时流处理项目/">SparkStreaming实时流处理</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li >
                                <a href="../../../books/">Books</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>

                     <!--
                            <li >
                                <a rel="next" href="../">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="../../../os/">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    -->
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#offer">剑指Offer</a></li>
        <li class="main "><a href="#1">1. 前言</a></li>
        <li class="main "><a href="#2-singleton">2. 实现 Singleton</a></li>
        <li class="main "><a href="#3">3. 数组中重复的数字</a></li>
        <li class="main "><a href="#3_1">3. 二维数组中的查找</a></li>
        <li class="main "><a href="#4">4. 替换空格</a></li>
        <li class="main "><a href="#5">5. 从尾到头打印链表</a></li>
        <li class="main "><a href="#6">6. 重建二叉树</a></li>
        <li class="main "><a href="#8">8. 二叉树的下一个结点</a></li>
        <li class="main "><a href="#7">7. 用两个栈实现队列</a></li>
        <li class="main "><a href="#8_1">8. 旋转数组的最小数字</a></li>
        <li class="main "><a href="#9">9 斐波那契数列</a></li>
            <li><a href="#_1">斐波那契数列</a></li>
            <li><a href="#_2">跳台阶</a></li>
            <li><a href="#_3">矩形覆盖</a></li>
            <li><a href="#_4">变态跳台阶</a></li>
        <li class="main "><a href="#10-1">10. 二进制中 1 的个数</a></li>
        <li class="main "><a href="#11">11. 数值的整数次方</a></li>
        <li class="main "><a href="#12-1-n">12. 打印从 1 到最大的 n 位数</a></li>
        <li class="main "><a href="#12">12. 矩阵中的路径</a></li>
        <li class="main "><a href="#13">13. 机器人的运动范围</a></li>
        <li class="main "><a href="#14">14. 剪绳子</a></li>
            <li><a href="#_5">贪心</a></li>
            <li><a href="#_6">动态规划</a></li>
        <li class="main "><a href="#181-o1">18.1 在 O(1) 时间内删除链表节点</a></li>
        <li class="main "><a href="#182">18.2 删除链表中重复的结点</a></li>
            <li><a href="#_7">解题描述</a></li>
        <li class="main "><a href="#19">19. 正则表达式匹配</a></li>
        <li class="main "><a href="#20">20. 表示数值的字符串</a></li>
        <li class="main "><a href="#21">21. 调整数组顺序使奇数位于偶数前面</a></li>
        <li class="main "><a href="#22-k">22. 链表中倒数第 K 个结点</a></li>
        <li class="main "><a href="#23">23. 链表中环的入口结点</a></li>
        <li class="main "><a href="#24">24. 反转链表</a></li>
        <li class="main "><a href="#_8">递归</a></li>
        <li class="main "><a href="#_9">迭代</a></li>
        <li class="main "><a href="#25">25. 合并两个排序的链表</a></li>
            <li><a href="#_10">递归</a></li>
            <li><a href="#_11">迭代</a></li>
        <li class="main "><a href="#26">26. 树的子结构</a></li>
        <li class="main "><a href="#27">27. 二叉树的镜像</a></li>
        <li class="main "><a href="#28">28 对称的二叉树</a></li>
        <li class="main "><a href="#29">29. 顺时针打印矩阵</a></li>
        <li class="main "><a href="#30-min">30. 包含 min 函数的栈</a></li>
        <li class="main "><a href="#31">31. 栈的压入、弹出序列</a></li>
        <li class="main "><a href="#321">32.1 从上往下打印二叉树</a></li>
        <li class="main "><a href="#322">32.2 把二叉树打印成多行</a></li>
        <li class="main "><a href="#323">32.3 按之字形顺序打印二叉树</a></li>
        <li class="main "><a href="#33">33. 二叉搜索树的后序遍历序列</a></li>
        <li class="main "><a href="#34">34. 二叉树中和为某一值的路径</a></li>
        <li class="main "><a href="#35">35. 复杂链表的复制</a></li>
        <li class="main "><a href="#36">36. 二叉搜索树与双向链表</a></li>
        <li class="main "><a href="#37">37. 序列化二叉树</a></li>
        <li class="main "><a href="#38">38. 字符串的排列</a></li>
        <li class="main "><a href="#39">39. 数组中出现次数超过一半的数字</a></li>
        <li class="main "><a href="#40-k">40. 最小的 K 个数</a></li>
            <li><a href="#_12">快速选择</a></li>
            <li><a href="#k">大小为 K 的最小堆</a></li>
        <li class="main "><a href="#411">41.1 数据流中的中位数</a></li>
        <li class="main "><a href="#412">41.2 字符流中第一个不重复的字符</a></li>
        <li class="main "><a href="#42">42. 连续子数组的最大和</a></li>
        <li class="main "><a href="#43-1-n-1">43. 从 1 到 n 整数中 1 出现的次数</a></li>
        <li class="main "><a href="#44">44. 数字序列中的某一位数字</a></li>
        <li class="main "><a href="#45">45. 把数组排成最小的数</a></li>
        <li class="main "><a href="#46">46. 把数字翻译成字符串</a></li>
        <li class="main "><a href="#47">47. 礼物的最大价值</a></li>
        <li class="main "><a href="#48">48. 最长不含重复字符的子字符串</a></li>
        <li class="main "><a href="#49">49. 丑数</a></li>
        <li class="main "><a href="#50">50. 第一个只出现一次的字符位置</a></li>
        <li class="main "><a href="#51">51. 数组中的逆序对</a></li>
        <li class="main "><a href="#52">52. 两个链表的第一个公共结点</a></li>
        <li class="main "><a href="#53">53. 数字在排序数组中出现的次数</a></li>
        <li class="main "><a href="#54-k">54. 二叉查找树的第 K 个结点</a></li>
        <li class="main "><a href="#551">55.1 二叉树的深度</a></li>
        <li class="main "><a href="#552">55.2 平衡二叉树</a></li>
        <li class="main "><a href="#56">56. 数组中只出现一次的数字</a></li>
        <li class="main "><a href="#571-s">57.1 和为 S 的两个数字</a></li>
        <li class="main "><a href="#572-s">57.2 和为 S 的连续正数序列</a></li>
        <li class="main "><a href="#581">58.1 翻转单词顺序列</a></li>
        <li class="main "><a href="#582">58.2 左旋转字符串</a></li>
        <li class="main "><a href="#59">59. 滑动窗口的最大值</a></li>
        <li class="main "><a href="#60-n">60. n 个骰子的点数</a></li>
            <li><a href="#_13">动态规划解法</a></li>
        <li class="main "><a href="#_14">动态规划解法 + 旋转数组</a></li>
        <li class="main "><a href="#61">61. 扑克牌顺子</a></li>
        <li class="main "><a href="#62">62. 圆圈中最后剩下的数</a></li>
        <li class="main "><a href="#63">63. 股票的最大利润</a></li>
        <li class="main "><a href="#64-123n">64. 求 1+2+3+...+n</a></li>
        <li class="main "><a href="#65">65. 不用加减乘除做加法</a></li>
        <li class="main "><a href="#66">66. 构建乘积数组</a></li>
        <li class="main "><a href="#67">67. 把字符串转换成整数</a></li>
        <li class="main "><a href="#68">68. 树中两个节点的最低公共祖先</a></li>
            <li><a href="#_15">二叉查找树</a></li>
            <li><a href="#_16">普通二叉树</a></li>
            <li><a href="#reference">Reference</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h3 id="offer"><strong>剑指Offer</strong><a class="headerlink" href="#offer" title="Permanent link">&para;</a></h3>
<h3 id="1">1. 前言<a class="headerlink" href="#1" title="Permanent link">&para;</a></h3>
<p>本文的绘图可通过以下途径免费获得并使用：</p>
<ul>
<li><a href="https://www.processon.com/view/5a3e4c7be4b0909c1aa18b49">ProcessOn</a></li>
<li><a href="https://drive.google.com/file/d/1nSSCpPUC05MFoeFuf_aeTtkm7dG5-bJ1/view?usp=sharing">DrawIO</a></li>
</ul>
<h3 id="2-singleton">2. 实现 Singleton<a class="headerlink" href="#2-singleton" title="Permanent link">&para;</a></h3>
<p><a href="http://larryim.cc/note-os/java/hfdp/ch5/index.html">Singleton Pattern</a></p>
<h3 id="3">3. 数组中重复的数字<a class="headerlink" href="#3" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&amp;tqId=11203&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p>在一个长度为<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>的数组里的所有数字都在0到<span><span class="MathJax_Preview">n-1</span><script type="math/tex">n-1</script></span>的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组<span><span class="MathJax_Preview">[2,3,1,0,2,5,3]</span><script type="math/tex">[2,3,1,0,2,5,3]</script></span>，那么对应的输出是第一个重复的数字2。</p>
<p><hh>解题思路</hh></p>
<p>解决这个问题的一个简单的方法是先把输入的数组排序。然后从头到尾扫描数组，找出重复的数字。或者利用哈希表，每扫到一个数字的时候，都可以用<span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>的时间来判断哈希表里是否已经包含了该数字。如果哈希表里还没有这个数字，就把它加入哈希表，否则，就找到一个重复的数字。</p>
<p>有没有更好的方法呢？要求时间复杂度<span><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span>，空间复杂度<span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>。因此不能使用排序的方法，也不能使用额外的标记数组。</p>
<p>注意到数组中的数字都在<span><span class="MathJax_Preview">0\sim n-1</span><script type="math/tex">0\sim n-1</script></span>的范围内。如果这个数组中没有重复的数字，那么当数组排序之后数字<span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>将出现在下标为<span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>的位置。所以可以将值为<span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>的元素调整到第<span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>个位置上。</p>
<p>以 (2, 3, 1, 0, 2, 5) 为例：</p>
<p> <div class=codehilite><pre>position-0 : (2,3,1,0,2,5) // 2 &lt;-&gt; 1
             (1,3,2,0,2,5) // 1 &lt;-&gt; 3
             (3,1,2,0,2,5) // 3 &lt;-&gt; 0
             (0,1,2,3,2,5) // already in position
position-1 : (0,1,2,3,2,5) // already in position
position-2 : (0,1,2,3,2,5) // already in position
position-3 : (0,1,2,3,2,5) // already in position
position-4 : (0,1,2,3,2,5) // nums[i] == nums[nums[i]], exit
</pre></div></p>
<p>遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>duplicate</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>,</span> <span class=kt>int</span> <span class=n>length</span><span class=o>,</span> <span class=kt>int</span><span class=o>[]</span> <span class=n>duplication</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>nums</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>length</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=o>)</span> <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=k>while</span> <span class=o>(</span><span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>!=</span> <span class=n>i</span><span class=o>)</span> <span class=o>{</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>==</span> <span class=n>nums</span><span class=o>[</span><span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]])</span> <span class=o>{</span>
                <span class=n>duplication</span><span class=o>[</span><span class=mi>0</span><span class=o>]</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
                <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
            <span class=o>}</span>
            <span class=n>swap</span><span class=o>(</span><span class=n>nums</span><span class=o>,</span> <span class=n>i</span><span class=o>,</span> <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]);</span>
        <span class=o>}</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>swap</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>,</span> <span class=kt>int</span> <span class=n>i</span><span class=o>,</span> <span class=kt>int</span> <span class=n>j</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
    <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>j</span><span class=o>];</span>
    <span class=n>nums</span><span class=o>[</span><span class=n>j</span><span class=o>]</span> <span class=o>=</span> <span class=n>t</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="3_1">3. 二维数组中的查找<a class="headerlink" href="#3_1" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p> <div class=codehilite><pre>Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
</pre></div></p>
<p><hh>解题思路</hh></p>
<p>首先选取数组中右上角的数字。</p>
<ul>
<li>如果该数字等于要查找的数字，查找过程结束：</li>
<li>如果该数字大于要查找的数字，剔除这个数字所在的列; 如果该数字小于要查找的数字，剔除这个数字所在的行。也就是说如果要查找的数字不在数组的右上角，则每－次都在数组的查找范围中剔除）行或者一列，这样每一步都可以缩小.</li>
<li>查找的范围，直到找到要查找的数字，或者查找范围为空。</li>
</ul>
<p>时间复杂度：<span><span class="MathJax_Preview">O(M + N) + O(1)</span><script type="math/tex">O(M + N) + O(1)</script></span></p>
<p>当前元素的查找区间为左下角的所有元素，例如元素12的查找区间如下：</p>
<p><img alt="" src="../figures/Q4er-wei-shu-zu-zhong-de-cha-zhao.jpg" /></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>Find</span><span class=o>(</span><span class=kt>int</span> <span class=n>target</span><span class=o>,</span> <span class=kt>int</span> <span class=o>[][]</span> <span class=n>array</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>array</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>array</span><span class=o>.</span><span class=na>length</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>array</span><span class=o>[</span><span class=mi>0</span><span class=o>].</span><span class=na>length</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>row</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>col</span> <span class=o>=</span> <span class=n>array</span><span class=o>[</span><span class=mi>0</span><span class=o>].</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>row</span> <span class=o>&lt;</span> <span class=n>array</span><span class=o>.</span><span class=na>length</span> <span class=o>&amp;&amp;</span> <span class=n>col</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>cmp</span> <span class=o>=</span> <span class=n>array</span><span class=o>[</span><span class=n>row</span><span class=o>][</span><span class=n>col</span><span class=o>]</span> <span class=o>-</span> <span class=n>target</span><span class=o>;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>cmp</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=n>col</span><span class=o>--;</span>
        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>cmp</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span> <span class=n>row</span><span class=o>++;</span>
        <span class=k>else</span> <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="4">4. 替换空格<a class="headerlink" href="#4" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&amp;tqId=11155&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为"We Are Happy". 则经过替换之后的字符串"为We%20Are%20Happy"。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>在⽹络编程中，如果URL参数中含有特殊字符，如空格、'#'等，可能导致服务器端⽆法获得正确的参数值。我们需要将这些特殊符号转换成服务器可以识别的字符。转换的规则是在'%'后⾯跟上ASCII码的两位⼗六进制的表⽰。⽐如空格的ASCII码是32，即⼗六进制的0x20，因此空格被替换成"%20"。再⽐如'#'的ASCII码为35，即⼗六进制的0x23，它在URL中被替换为"%23"。</p>
</div>
<p><hh>解题思路</hh></p>
<p>最直观的做法是从头到尾扫描字符串，每次碰到空格字符的时候进行替换。由于是把1个字符替换成3个字符，我们必须要把空格后面的字符都后移2个字节，否则就有两个字符被覆盖了。</p>
<p>从前往后把字符串"We are happy."中的空格替换成"%20"的过程。灰色背景表示需要移动的字符。
<img alt="" src="../figures/Q5-kong-ge-ti-huan.jpg" /></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>String</span> <span class=nf>replaceSpace</span><span class=o>(</span><span class=n>StringBuffer</span> <span class=n>str</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>str</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>()</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=k>return</span> <span class=s>&quot;&quot;</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>();</span> <span class=n>i</span><span class=o>++)</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>str</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>i</span><span class=o>)</span> <span class=o>==</span> <span class=sc>&#39; &#39;</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>str</span><span class=o>.</span><span class=na>setCharAt</span><span class=o>(</span><span class=n>i</span><span class=o>,</span> <span class=sc>&#39;%&#39;</span><span class=o>);</span>
            <span class=n>str</span><span class=o>.</span><span class=na>insert</span><span class=o>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=o>,</span> <span class=s>&quot;20&quot;</span><span class=o>);</span>
            <span class=n>i</span> <span class=o>+=</span> <span class=mi>2</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=k>return</span> <span class=n>str</span><span class=o>.</span><span class=na>toString</span><span class=o>();</span>
<span class=o>}</span>
</pre></div></p>
<p>假设字符串的长度是<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>。对每个空格字符，需要移动后面<span><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span>个字符，因此对于含有<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>个字符的字符串而言，最坏时间复杂度是<span><span class="MathJax_Preview">O(n^2)</span><script type="math/tex">O(n^2)</script></span>。</p>
<p>能不能减少移动次数呢？答案是肯定的，把从前向后替换改成从后向前替换。可以先遍历一次字符串，统计出字符串中空格的综述，计算出替换之后的字符串长度 = <span><span class="MathJax_Preview">n + 2 \times</span><script type="math/tex">n + 2 \times</script></span> 空格数。</p>
<p>在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。准备两个指针，P1和P2，P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾.接下来我们向前移动指针P1，逐个把它指向的字符复制到P2指向的位置，直到碰到空格为止，此时把P1向前移动1格，并在P2之前插入字符串"%20",然后向前移动3格。重复此过程，直到P1和P2指向同一位置，表明所有空格都已经替换完毕。</p>
<p><img alt="" src="../figures/Q5-ti-huan-kong-ge-p1-p2.jpg" /></p>
<p>由于所有的字符都指复制/移动一次，因此时间复杂度是<span><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span>。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>String</span> <span class=nf>replaceSpace</span><span class=o>(</span><span class=n>StringBuffer</span> <span class=n>str</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>str</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>()</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=k>return</span> <span class=s>&quot;&quot;</span><span class=o>;</span>
    <span class=c1>// 获取空格的数量</span>
    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>();</span>
    <span class=kt>int</span> <span class=n>numOfSpace</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>str</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>i</span><span class=o>)</span> <span class=o>==</span> <span class=sc>&#39; &#39;</span><span class=o>)</span> <span class=n>numOfSpace</span><span class=o>++;</span>

    <span class=c1>// 插入空格</span>
    <span class=kt>int</span> <span class=n>newStringLength</span> <span class=o>=</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>numOfSpace</span><span class=o>;</span> <span class=c1>// 新字符串长度</span>
    <span class=n>str</span><span class=o>.</span><span class=na>setLength</span><span class=o>(</span><span class=n>newStringLength</span><span class=o>);</span>    <span class=c1>// 扩充字符串</span>
    <span class=kt>int</span> <span class=n>p1</span> <span class=o>=</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=o>,</span> <span class=n>p2</span> <span class=o>=</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>()</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span>    <span class=c1>// p1指向旧字符串，p2指向新字符串</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>p1</span> <span class=o>!=</span> <span class=n>p2</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>str</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>p1</span><span class=o>)</span> <span class=o>!=</span> <span class=sc>&#39; &#39;</span><span class=o>)</span> <span class=n>str</span><span class=o>.</span><span class=na>setCharAt</span><span class=o>(</span><span class=n>p2</span><span class=o>--,</span> <span class=n>str</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>p1</span><span class=o>));</span>
        <span class=k>else</span> <span class=o>{</span>
            <span class=n>str</span><span class=o>.</span><span class=na>setCharAt</span><span class=o>(</span><span class=n>p2</span><span class=o>--,</span> <span class=sc>&#39;0&#39;</span><span class=o>);</span>
            <span class=n>str</span><span class=o>.</span><span class=na>setCharAt</span><span class=o>(</span><span class=n>p2</span><span class=o>--,</span> <span class=sc>&#39;2&#39;</span><span class=o>);</span>
            <span class=n>str</span><span class=o>.</span><span class=na>setCharAt</span><span class=o>(</span><span class=n>p2</span><span class=o>--,</span> <span class=sc>&#39;%&#39;</span><span class=o>);</span>
        <span class=o>}</span>
        <span class=n>p1</span><span class=o>--;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>str</span><span class=o>.</span><span class=na>toString</span><span class=o>();</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="5">5. 从尾到头打印链表<a class="headerlink" href="#5" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>输入链表的第一个节点，从尾到头反过来打印出每个结点的值。链表结点定义如下：</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ListNode</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>val</span><span class=o>;</span>
    <span class=n>ListNode</span> <span class=n>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
    <span class=n>ListNode</span><span class=o>(</span><span class=kt>int</span> <span class=n>val</span><span class=o>)</span> <span class=o>{</span>
         <span class=k>this</span><span class=o>.</span><span class=na>val</span> <span class=o>=</span> <span class=n>val</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<p><hh>解题思路</hh></p>
<p>我们想到解决这个问题肯定要遍历链表。遍历的顺序是从头到尾的顺序，可输出的顺序却是从尾到头。也就是说第⼀个遍历到的结点最后⼀个输出，⽽最后⼀个遍历到的结点第⼀个输出。这就是典型的“后进先出”，我们可以⽤栈实现这种顺序。每经过⼀个结点的时候，把该结点放到⼀个栈中。当遍历完整个链表后，再从栈顶开始逐个输出结点的值，此时输出的结点的顺序已经反转过来了。</p>
<p><hh>使用栈</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>printListFromTailToHead</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>listNode</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>listNode</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=k>return</span> <span class=k>new</span> <span class=n>ArrayList</span>
    <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>stack</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;&gt;();</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>listNode</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>stack</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>listNode</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
        <span class=n>listNode</span> <span class=o>=</span> <span class=n>listNode</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>ret</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=k>while</span> <span class=o>(!</span><span class=n>stack</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span>
        <span class=n>res</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>stack</span><span class=o>.</span><span class=na>pop</span><span class=o>());</span>
    <span class=k>return</span> <span class=n>res</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<p><hh>使用递归</hh></p>
<p>既然想到了⽤栈来实现这个函数，⽽递归在本质上就是⼀个栈结构， 于是很⾃然地又想到了⽤递归来实现。要实现反过来输出链表，我们每访问到⼀个结点的时候，先递归输出它后⾯的结点，再输出该结点⾃⾝，这样链表的输出结果就反过来了。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>printListFromTailToHead</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>listNode</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=n>printListFromTailToHead</span><span class=o>(</span><span class=n>list</span><span class=o>,</span> <span class=n>listNode</span><span class=o>);</span>
   <span class=k>return</span> <span class=n>list</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>printListFromTailToHead</span><span class=o>(</span><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span><span class=o>,</span> <span class=n>ListNode</span> <span class=n>listNode</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>listNode</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=k>return</span><span class=o>;</span>
    <span class=n>printListFromTailToHead</span><span class=o>(</span><span class=n>list</span><span class=o>,</span> <span class=n>listNode</span><span class=o>.</span><span class=na>next</span><span class=o>);</span>
    <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>listNode</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
<span class=o>}</span>
</pre></div></p>
<p>也可以利用<code class="codehilite">ArrayList.addAll()</code>，而省去了辅助函数：</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>printListFromTailToHead</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>listNode</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>listNode</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=k>return</span> <span class=n>list</span><span class=o>;</span>
    <span class=n>list</span><span class=o>.</span><span class=na>addAll</span><span class=o>(</span><span class=n>printListFromTailToHead</span><span class=o>(</span><span class=n>listNode</span><span class=o>.</span><span class=na>next</span><span class=o>));</span>
    <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>listNode</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>list</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<p>虽然上⾯的基于递归的代码看起来很简洁，但有个问题：当链表⾮常长的时候，就会导致函数调⽤的层级很深，从⽽有可能导致函数调⽤栈溢出。 显式⽤栈基于循环实现的代码的鲁棒性要好⼀些。</p>
<p><hh>使用Collections.reverse()</hh></p>
<p>顺序遍历链表，获取链表节点的值，然后反转。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>printListFromTailToHead</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>listNode</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>res</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>listNode</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>res</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>listNode</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
        <span class=n>listNode</span> <span class=o>=</span> <span class=n>listNode</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=n>Collections</span><span class=o>.</span><span class=na>reverse</span><span class=o>(</span><span class=n>res</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>res</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="6">6. 重建二叉树<a class="headerlink" href="#6" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p> <div class=codehilite><pre>preorder = [3,9,20,15,7]
inorder =  [9,3,15,20,7]
</pre></div></p>
<p><img alt="" src="../figures/Q7-reconstruct-binary-tree.jpg" /></p>
<p><hh>解题思路</hh>见<a href="http://localhost/wiki/2017/10/30/Leetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/">LeetCode 105</a>.</p>
<h3 id="8">8. 二叉树的下一个结点<a class="headerlink" href="#8" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<p><C>TreeLinkNode</C>定义：</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>TreeLinkNode</span> <span class=o>{</span>

    <span class=kt>int</span> <span class=n>val</span><span class=o>;</span>
    <span class=n>TreeLinkNode</span> <span class=n>left</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
    <span class=n>TreeLinkNode</span> <span class=n>right</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
    <span class=n>TreeLinkNode</span> <span class=n>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>

    <span class=n>TreeLinkNode</span><span class=o>(</span><span class=kt>int</span> <span class=n>val</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>val</span> <span class=o>=</span> <span class=n>val</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<p><hh>解题思路</hh></p>
<p>① 如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点；</p>
<p><img alt="" src="../figures/Q8-1.jpg" /></p>
<p>② 否则，向上找第一个左链接指向的树包含该节点的祖先节点。</p>
<p><img alt="" src="../figures/Q8-2.jpg" /></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>TreeLinkNode</span> <span class=nf>GetNext</span><span class=o>(</span><span class=n>TreeLinkNode</span> <span class=n>root</span><span class=o>){</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
    <span class=c1>// 右子树的最左节点</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>root</span> <span class=o>=</span> <span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>;</span>
        <span class=k>while</span> <span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=n>root</span> <span class=o>=</span> <span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>;</span>
        <span class=k>return</span> <span class=n>root</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=c1>// 第一个左链接指向的树包含左子树</span>
    <span class=n>TreeLinkNode</span> <span class=n>parent</span> <span class=o>=</span> <span class=n>root</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=k>while</span><span class=o>(</span><span class=n>parent</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>root</span> <span class=o>!=</span> <span class=n>parent</span><span class=o>.</span><span class=na>left</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>root</span> <span class=o>=</span> <span class=n>parent</span><span class=o>;</span>
        <span class=n>parent</span> <span class=o>=</span> <span class=n>root</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>parent</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="7">7. 用两个栈实现队列<a class="headerlink" href="#7" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。</p>
<p><hh>解题思路</hh></p>
<p>in栈用来处理入栈(push)操作，out栈用来处理出栈(pop)操作。一个元素进入 in栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入out栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。</p>
<p>当out中不为空时，在out中的栈顶元素是最先进⼊队列的元素，可以弹出。如果 out为空时，我们把in中的元素逐个弹出并压⼊out。由于先进⼊队列的元素被压到in的底端，经过弹出和压⼊之后就处于out的顶端了，又可以直接弹出。</p>
<p><img alt="" src="../figures/Q9-yong-liang-ge-zhan-shi-xian-dui-lie.jpg" /></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Queue</span> <span class=o>{</span>
    <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>in</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;();</span>
    <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>out</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;();</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>push</span><span class=o>(</span><span class=kt>int</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>in</span><span class=o>.</span><span class=na>push</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>pop</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>Exception</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>out</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span>
            <span class=k>while</span> <span class=o>(!</span><span class=n>in</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span>
                <span class=n>out</span><span class=o>.</span><span class=na>push</span><span class=o>(</span><span class=n>in</span><span class=o>.</span><span class=na>pop</span><span class=o>());</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>out</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span> <span class=k>throw</span> <span class=k>new</span> <span class=n>Exception</span><span class=o>(</span><span class=s>&quot;Queue is Empty!&quot;</span><span class=o>);</span>
        <span class=k>return</span> <span class=n>out</span><span class=o>.</span><span class=na>pop</span><span class=o>();</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="8_1">8. 旋转数组的最小数字<a class="headerlink" href="#8_1" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p><hh>解题思路</hh>
如果数字不重复，见<a href="http://larryim.cc/wiki/2017/10/30/Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array/">LeetCode 153 Find Minimum in Rotated Sorted Array</a>.</p>
<p>如果数组元素允许重复的话，那么就会出现一个特殊的情况：nums<span><span class="MathJax_Preview">[lo]</span><script type="math/tex">[lo]</script></span> = nums<span><span class="MathJax_Preview">[mid]</span><script type="math/tex">[mid]</script></span> = nums<span><span class="MathJax_Preview">[hi]</span><script type="math/tex">[hi]</script></span>，那么此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，<span><span class="MathJax_Preview">lo、mid</span><script type="math/tex">lo、mid</script></span>和<span><span class="MathJax_Preview">hi</span><script type="math/tex">hi</script></span>指向的数都为1，此时无法知道最小数字0在哪个区间。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>minNumberInRotateArray</span><span class=o>(</span><span class=kt>int</span> <span class=o>[]</span> <span class=n>nums</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>nums</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>nums</span><span class=o>.</span><span class=na>length</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>lo</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>hi</span> <span class=o>=</span> <span class=n>nums</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=o>,</span> <span class=n>mid</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>lo</span> <span class=o>&lt;</span> <span class=n>hi</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>// 取中间的位置</span>
        <span class=n>mid</span> <span class=o>=</span> <span class=n>lo</span> <span class=o>+</span> <span class=o>(</span><span class=n>hi</span> <span class=o>-</span> <span class=n>lo</span><span class=o>)</span> <span class=o>/</span> <span class=mi>2</span><span class=o>;</span>
        <span class=c1>// 如果三个数都相等，则需要进行顺序处理，从头到尾找最小的值</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>nums</span><span class=o>[</span><span class=n>mid</span><span class=o>]</span> <span class=o>==</span> <span class=n>nums</span><span class=o>[</span><span class=n>hi</span><span class=o>]</span> <span class=o>&amp;&amp;</span> <span class=n>nums</span><span class=o>[</span><span class=n>mid</span><span class=o>]</span> <span class=o>==</span> <span class=n>nums</span><span class=o>[</span><span class=n>lo</span><span class=o>])</span> 
            <span class=k>return</span> <span class=n>findMin</span><span class=o>(</span><span class=n>nums</span><span class=o>,</span> <span class=n>lo</span> <span class=o>,</span> <span class=n>hi</span><span class=o>);</span>
        <span class=c1>// 如果中间位置对应的值在后一个排好序的部分，将hi设置为新的处理位置</span>
        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>nums</span><span class=o>[</span><span class=n>mid</span><span class=o>]</span> <span class=o>&gt;</span> <span class=n>nums</span><span class=o>[</span><span class=n>hi</span><span class=o>])</span> <span class=n>lo</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span><span class=o>;</span>
        <span class=k>else</span> <span class=n>hi</span> <span class=o>=</span> <span class=n>mid</span><span class=o>;</span> <span class=c1>// 不是 hi = mid - 1;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>nums</span><span class=o>[</span><span class=n>lo</span><span class=o>];</span>
<span class=o>}</span>
<span class=c1>// 找数组中的最小值</span>
<span class=kd>private</span> <span class=kt>int</span> <span class=nf>findMin</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>,</span> <span class=kt>int</span> <span class=n>lo</span><span class=o>,</span> <span class=kt>int</span> <span class=n>hi</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>min</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>lo</span><span class=o>];</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>lo</span> <span class=o>+</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>hi</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>&lt;</span> <span class=n>min</span><span class=o>)</span> <span class=n>min</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
    <span class=k>return</span> <span class=n>min</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="9">9 斐波那契数列<a class="headerlink" href="#9" title="Permanent link">&para;</a></h3>
<h4 id="_1">斐波那契数列<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h4>
<p><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;tqId=11160&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>求斐波那契数列的第<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>项，<span><span class="MathJax_Preview">n &lt;= 39</span><script type="math/tex">n <= 39</script></span>。</p>
<div align="center"><img src="https://latex.codecogs.com/gif.latex?f(n)=\left\{\begin{array}{rcl}0&&{n=0}\\1&&{n=1}\\f(n-1)+f(n-2)&&{n>1}\end{array}\right."/></div>

<p><hh>解题思路</hh></p>
<p>由于斐波那契数列可以用递归函数表示，最直接的方法是用递归来解决。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>Fibonacci</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=o>)</span> <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=o>)</span> <span class=k>return</span> <span class=mi>1</span><span class=o>;</span>
    <span class=k>return</span> <span class=n>Fibonacci</span><span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)</span> <span class=o>+</span> <span class=n>Fibonacci</span><span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>2</span><span class=o>);</span>
<span class=o>}</span>
</pre></div></p>
<p>但是如果使用递归求解，会重复计算一些子问题。例如，计算<span><span class="MathJax_Preview">f(10)</span><script type="math/tex">f(10)</script></span>需要计算 <span><span class="MathJax_Preview">f(9)</span><script type="math/tex">f(9)</script></span>和<span><span class="MathJax_Preview">f(8)</span><script type="math/tex">f(8)</script></span>，计算<span><span class="MathJax_Preview">f(9)</span><script type="math/tex">f(9)</script></span>需要计算<span><span class="MathJax_Preview">f(8)</span><script type="math/tex">f(8)</script></span>和<span><span class="MathJax_Preview">f(7)</span><script type="math/tex">f(7)</script></span>，可以看到<span><span class="MathJax_Preview">f(8)</span><script type="math/tex">f(8)</script></span>被重复计算了。事实上，⽤递归⽅法计算的时间复杂度是以<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>的指数的⽅式递增的。</p>
<p>使用动态规划的思想把子问题的解缓存起来，从而避免重复求解子问题。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>Fibonacci</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=o>)</span> <span class=k>return</span> <span class=n>n</span><span class=o>;</span>
    <span class=kt>int</span><span class=o>[]</span> <span class=n>fib</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=o>];</span>
    <span class=n>fib</span><span class=o>[</span><span class=mi>1</span><span class=o>]</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=n>fib</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>fib</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=o>]</span> <span class=o>+</span> <span class=n>fib</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>2</span><span class=o>];</span>
    <span class=k>return</span> <span class=n>fib</span><span class=o>[</span><span class=n>n</span><span class=o>];</span>
<span class=o>}</span>
</pre></div></p>
<p>考虑到第<span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>项只与第<span><span class="MathJax_Preview">i-1</span><script type="math/tex">i-1</script></span>和第<span><span class="MathJax_Preview">i-2</span><script type="math/tex">i-2</script></span>项有关，因此只需要存储前两项的值就能求解第<span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>项，从而将空间复杂度由<span><span class="MathJax_Preview">O(N)</span><script type="math/tex">O(N)</script></span>降低为<span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>Fibonacci</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span> <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&quot;n must be a non-negative integer&quot;</span><span class=o>);</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=o>)</span> <span class=k>return</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=mi>1</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>prev</span> <span class=o>=</span> <span class=mi>1</span><span class=o>,</span> <span class=n>before_prev</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>cur</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=n>cur</span> <span class=o>=</span> <span class=n>prev</span> <span class=o>+</span> <span class=n>before_prev</span><span class=o>;</span>
        <span class=n>before_prev</span> <span class=o>=</span> <span class=n>prev</span><span class=o>;</span>
        <span class=n>prev</span> <span class=o>=</span> <span class=n>cur</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>cur</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<p>由于待求解的<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>小于40，因此也可以将前40项的结果先进行计算，之后就能以 <span><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span>时间复杂度得到第<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>项的值了。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>

    <span class=kd>private</span> <span class=kt>int</span><span class=o>[]</span> <span class=n>fib</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=mi>40</span><span class=o>];</span>

    <span class=kd>public</span> <span class=nf>Solution</span><span class=o>()</span> <span class=o>{</span>
        <span class=n>fib</span><span class=o>[</span><span class=mi>1</span><span class=o>]</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>
        <span class=n>fib</span><span class=o>[</span><span class=mi>2</span><span class=o>]</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>fib</span><span class=o>.</span><span class=na>length</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
            <span class=n>fib</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>fib</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=o>]</span> <span class=o>+</span> <span class=n>fib</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>2</span><span class=o>];</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kt>int</span> <span class=nf>Fibonacci</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>fib</span><span class=o>[</span><span class=n>n</span><span class=o>];</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<h4 id="_2">跳台阶<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h4>
<p><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p><hh>解题思路</hh></p>
<p>题目类似于<a href="http://larryim.cc/wiki/2017/10/30/Leetcode-70-Climbing-Stairs/">LeetCode 70 climbing stairs</a>。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>JumpFloor</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>2</span><span class=o>)</span> <span class=k>return</span> <span class=n>n</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>last</span> <span class=o>=</span> <span class=mi>1</span><span class=o>,</span> <span class=n>secondLast</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=n>result</span> <span class=o>=</span> <span class=n>secondLast</span> <span class=o>+</span> <span class=n>last</span><span class=o>;</span>
        <span class=n>secondLast</span> <span class=o>=</span> <span class=n>last</span><span class=o>;</span>
        <span class=n>last</span> <span class=o>=</span> <span class=n>result</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>result</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h4 id="_3">矩形覆盖<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h4>
<p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>我们可以用<span><span class="MathJax_Preview">2\times 1</span><script type="math/tex">2\times 1</script></span>的小矩形横着或者竖着去覆盖更大的矩形。请问用<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>个<span><span class="MathJax_Preview">2\times 1</span><script type="math/tex">2\times 1</script></span>的小矩形无重叠地覆盖一个<span><span class="MathJax_Preview">2\times n</span><script type="math/tex">2\times n</script></span>的大矩形，总共有多少种方法？</p>
<p><img alt="" src="../figures/juxingfugai.jpg" /></p>
<p><hh>解题思路</hh></p>
<p>我们先把<span><span class="MathJax_Preview">2×8</span><script type="math/tex">2×8</script></span>的覆盖⽅法记为<span><span class="MathJax_Preview">f(8</span><script type="math/tex">f(8</script></span>。⽤第⼀个<span><span class="MathJax_Preview">1×2</span><script type="math/tex">1×2</script></span>⼩矩形去覆盖⼤矩形的最左边时有两个选择，竖着放或者横着放。当竖着放的时候，右边还剩下<span><span class="MathJax_Preview">2×7</span><script type="math/tex">2×7</script></span>的区域，这种情形下的覆盖⽅法记为<span><span class="MathJax_Preview">f(7)</span><script type="math/tex">f(7)</script></span>。接下来考虑横着放的情况。当<span><span class="MathJax_Preview">1×2</span><script type="math/tex">1×2</script></span>的⼩矩形横着放在左上⾓的时候，左下⾓必须和横着放⼀个<span><span class="MathJax_Preview">1×2</span><script type="math/tex">1×2</script></span>的⼩矩形，⽽在右边还还剩下<span><span class="MathJax_Preview">2×6</span><script type="math/tex">2×6</script></span>的区域，这种情形下的覆盖⽅法记为 <span><span class="MathJax_Preview">f(6)</span><script type="math/tex">f(6)</script></span>，因此<span><span class="MathJax_Preview">f(8)</span><script type="math/tex">f(8)</script></span>=<span><span class="MathJax_Preview">f(7)＋f(6)</span><script type="math/tex">f(7)＋f(6)</script></span>。此时我们可以看出，这仍然是斐波那契数列。</p>
<h4 id="_4">变态跳台阶<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h4>
<p><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tqId=11162&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级... 它也可以跳上<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>级。求该青蛙跳上一个<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>级的台阶总共有多少种跳法。</p>
<p><span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>个台阶总共有<span><span class="MathJax_Preview">2^{n-1}</span><script type="math/tex">2^{n-1}</script></span>种跳法。分析如下:</p>
<ul>
<li><span><span class="MathJax_Preview">f(1) = 1</span><script type="math/tex">f(1) = 1</script></span></li>
<li><span><span class="MathJax_Preview">f(2) = f(2-1) + f(2-2)</span><script type="math/tex">f(2) = f(2-1) + f(2-2)</script></span></li>
<li><span><span class="MathJax_Preview">f(3) = f(3-1) + f(3-2) + f(3-3)</span><script type="math/tex">f(3) = f(3-1) + f(3-2) + f(3-3)</script></span></li>
<li>...</li>
<li><span><span class="MathJax_Preview">f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)</span><script type="math/tex">f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(n-(n-1)) + f(n-n)</script></span></li>
</ul>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>JumpFloorII</span><span class=o>(</span><span class=kt>int</span> <span class=n>target</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>target</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=o>)</span> <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
    <span class=kt>int</span><span class=o>[]</span> <span class=n>dp</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>target</span> <span class=o>+</span> <span class=mi>1</span><span class=o>];</span>
    <span class=n>dp</span><span class=o>[</span><span class=mi>0</span><span class=o>]</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>target</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>i</span><span class=o>;</span> <span class=n>j</span><span class=o>++)</span>
            <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>+=</span> <span class=n>dp</span><span class=o>[</span><span class=n>j</span><span class=o>];</span>
        <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>+=</span> <span class=mi>1</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>dp</span><span class=o>[</span><span class=n>target</span><span class=o>];</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="10-1">10. 二进制中 1 的个数<a class="headerlink" href="#10-1" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&amp;tqId=11164&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p><hh>解题思路</hh></p>
<p>见<a href="http://larryim.cc/wiki/2017/10/30/Leetcode-191-Number-of-1-Bits/">LeetCode 191 Number of 1 bits</a>。</p>
<h3 id="11">11. 数值的整数次方<a class="headerlink" href="#11" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&amp;tqId=11165&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent，求 base 的 exponent 次方。</p>
<p><hh>解题思路</hh></p>
<p>见<a href="http://larryim.cc/wiki/2017/10/30/Leetcode-50-Pow-x-n/">LeetCode 50 Pow(x,n)</a></p>
<h3 id="12-1-n">12. 打印从 1 到最大的 n 位数<a class="headerlink" href="#12-1-n" title="Permanent link">&para;</a></h3>
<p><hh>题目描述</hh></p>
<p>输入数字<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>，按顺序打印出从1到最大的<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>位十进制数。比如输入3，则打印出 1、2、3 一直到最大的3位数即999。</p>
<p><hh>解题思路</hh></p>
<p>由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。</p>
<p>使用回溯法得到所有的数。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>void</span> <span class=nf>print1ToMaxOfNDigits</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=o>)</span>
        <span class=k>return</span><span class=o>;</span>
    <span class=kt>char</span><span class=o>[]</span> <span class=n>number</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=o>[</span><span class=n>n</span><span class=o>];</span>
    <span class=n>print1ToMaxOfNDigits</span><span class=o>(</span><span class=n>number</span><span class=o>,</span> <span class=mi>0</span><span class=o>);</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>print1ToMaxOfNDigits</span><span class=o>(</span><span class=kt>char</span><span class=o>[]</span> <span class=n>number</span><span class=o>,</span> <span class=kt>int</span> <span class=n>digit</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>digit</span> <span class=o>==</span> <span class=n>number</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>printNumber</span><span class=o>(</span><span class=n>number</span><span class=o>);</span>
        <span class=k>return</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=n>number</span><span class=o>[</span><span class=n>digit</span><span class=o>]</span> <span class=o>=</span> <span class=o>(</span><span class=kt>char</span><span class=o>)</span> <span class=o>(</span><span class=n>i</span> <span class=o>+</span> <span class=sc>&#39;0&#39;</span><span class=o>);</span>
        <span class=n>print1ToMaxOfNDigits</span><span class=o>(</span><span class=n>number</span><span class=o>,</span> <span class=n>digit</span> <span class=o>+</span> <span class=mi>1</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>printNumber</span><span class=o>(</span><span class=kt>char</span><span class=o>[]</span> <span class=n>number</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=n>number</span><span class=o>.</span><span class=na>length</span> <span class=o>&amp;&amp;</span> <span class=n>number</span><span class=o>[</span><span class=n>index</span><span class=o>]</span> <span class=o>==</span> <span class=sc>&#39;0&#39;</span><span class=o>)</span>
        <span class=n>index</span><span class=o>++;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=n>number</span><span class=o>.</span><span class=na>length</span><span class=o>)</span>
        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>print</span><span class=o>(</span><span class=n>number</span><span class=o>[</span><span class=n>index</span><span class=o>++]);</span>
    <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>();</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="12">12. 矩阵中的路径<a class="headerlink" href="#12" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&amp;tqId=11218&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p>
<p>例如下面的矩阵包含了一条 bfce 路径。</p>
<div align="center"> <img src="../pics//e31abb94-9201-4e06-9902-61101b92f475.png" width="300"/> </div>

<p><br></p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>private</span> <span class=kd>final</span> <span class=kd>static</span> <span class=kt>int</span><span class=o>[][]</span> <span class=n>next</span> <span class=o>=</span> <span class=o>{{</span><span class=mi>0</span><span class=o>,</span> <span class=o>-</span><span class=mi>1</span><span class=o>},</span> <span class=o>{</span><span class=mi>0</span><span class=o>,</span> <span class=mi>1</span><span class=o>},</span> <span class=o>{-</span><span class=mi>1</span><span class=o>,</span> <span class=mi>0</span><span class=o>},</span> <span class=o>{</span><span class=mi>1</span><span class=o>,</span> <span class=mi>0</span><span class=o>}};</span>
<span class=kd>private</span> <span class=kt>int</span> <span class=n>rows</span><span class=o>;</span>
<span class=kd>private</span> <span class=kt>int</span> <span class=n>cols</span><span class=o>;</span>

<span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>hasPath</span><span class=o>(</span><span class=kt>char</span><span class=o>[]</span> <span class=n>array</span><span class=o>,</span> <span class=kt>int</span> <span class=n>rows</span><span class=o>,</span> <span class=kt>int</span> <span class=n>cols</span><span class=o>,</span> <span class=kt>char</span><span class=o>[]</span> <span class=n>str</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>rows</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>cols</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>this</span><span class=o>.</span><span class=na>rows</span> <span class=o>=</span> <span class=n>rows</span><span class=o>;</span>
    <span class=k>this</span><span class=o>.</span><span class=na>cols</span> <span class=o>=</span> <span class=n>cols</span><span class=o>;</span>
    <span class=kt>boolean</span><span class=o>[][]</span> <span class=n>marked</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>rows</span><span class=o>][</span><span class=n>cols</span><span class=o>];</span>
    <span class=kt>char</span><span class=o>[][]</span> <span class=n>matrix</span> <span class=o>=</span> <span class=n>buildMatrix</span><span class=o>(</span><span class=n>array</span><span class=o>);</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>rows</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>cols</span><span class=o>;</span> <span class=n>j</span><span class=o>++)</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>backtracking</span><span class=o>(</span><span class=n>matrix</span><span class=o>,</span> <span class=n>str</span><span class=o>,</span> <span class=n>marked</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>i</span><span class=o>,</span> <span class=n>j</span><span class=o>))</span>
                <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
    <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>boolean</span> <span class=nf>backtracking</span><span class=o>(</span><span class=kt>char</span><span class=o>[][]</span> <span class=n>matrix</span><span class=o>,</span> <span class=kt>char</span><span class=o>[]</span> <span class=n>str</span><span class=o>,</span> <span class=kt>boolean</span><span class=o>[][]</span> <span class=n>marked</span><span class=o>,</span> <span class=kt>int</span> <span class=n>pathLen</span><span class=o>,</span> <span class=kt>int</span> <span class=n>r</span><span class=o>,</span> <span class=kt>int</span> <span class=n>c</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>pathLen</span> <span class=o>==</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>r</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>r</span> <span class=o>&gt;=</span> <span class=n>rows</span> <span class=o>||</span> <span class=n>c</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>c</span> <span class=o>&gt;=</span> <span class=n>cols</span> <span class=o>||</span> <span class=n>matrix</span><span class=o>[</span><span class=n>r</span><span class=o>][</span><span class=n>c</span><span class=o>]</span> <span class=o>!=</span> <span class=n>str</span><span class=o>[</span><span class=n>pathLen</span><span class=o>]</span> <span class=o>||</span> <span class=n>marked</span><span class=o>[</span><span class=n>r</span><span class=o>][</span><span class=n>c</span><span class=o>])</span>
        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=n>marked</span><span class=o>[</span><span class=n>r</span><span class=o>][</span><span class=n>c</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>n</span> <span class=o>:</span> <span class=n>next</span><span class=o>)</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>backtracking</span><span class=o>(</span><span class=n>matrix</span><span class=o>,</span> <span class=n>str</span><span class=o>,</span> <span class=n>marked</span><span class=o>,</span> <span class=n>pathLen</span> <span class=o>+</span> <span class=mi>1</span><span class=o>,</span> <span class=n>r</span> <span class=o>+</span> <span class=n>n</span><span class=o>[</span><span class=mi>0</span><span class=o>],</span> <span class=n>c</span> <span class=o>+</span> <span class=n>n</span><span class=o>[</span><span class=mi>1</span><span class=o>]))</span>
            <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
    <span class=n>marked</span><span class=o>[</span><span class=n>r</span><span class=o>][</span><span class=n>c</span><span class=o>]</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>char</span><span class=o>[][]</span> <span class=nf>buildMatrix</span><span class=o>(</span><span class=kt>char</span><span class=o>[]</span> <span class=n>array</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>char</span><span class=o>[][]</span> <span class=n>matrix</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>char</span><span class=o>[</span><span class=n>rows</span><span class=o>][</span><span class=n>cols</span><span class=o>];</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>idx</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>rows</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>cols</span><span class=o>;</span> <span class=n>j</span><span class=o>++)</span>
            <span class=n>matrix</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>j</span><span class=o>]</span> <span class=o>=</span> <span class=n>array</span><span class=o>[</span><span class=n>idx</span><span class=o>++];</span>
    <span class=k>return</span> <span class=n>matrix</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="13">13. 机器人的运动范围<a class="headerlink" href="#13" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&amp;tqId=11219&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。</p>
<p>例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span><span class=o>[][]</span> <span class=n>next</span> <span class=o>=</span> <span class=o>{{</span><span class=mi>0</span><span class=o>,</span> <span class=o>-</span><span class=mi>1</span><span class=o>},</span> <span class=o>{</span><span class=mi>0</span><span class=o>,</span> <span class=mi>1</span><span class=o>},</span> <span class=o>{-</span><span class=mi>1</span><span class=o>,</span> <span class=mi>0</span><span class=o>},</span> <span class=o>{</span><span class=mi>1</span><span class=o>,</span> <span class=mi>0</span><span class=o>}};</span>
<span class=kd>private</span> <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
<span class=kd>private</span> <span class=kt>int</span> <span class=n>rows</span><span class=o>;</span>
<span class=kd>private</span> <span class=kt>int</span> <span class=n>cols</span><span class=o>;</span>
<span class=kd>private</span> <span class=kt>int</span> <span class=n>threshold</span><span class=o>;</span>
<span class=kd>private</span> <span class=kt>int</span><span class=o>[][]</span> <span class=n>digitSum</span><span class=o>;</span>

<span class=kd>public</span> <span class=kt>int</span> <span class=nf>movingCount</span><span class=o>(</span><span class=kt>int</span> <span class=n>threshold</span><span class=o>,</span> <span class=kt>int</span> <span class=n>rows</span><span class=o>,</span> <span class=kt>int</span> <span class=n>cols</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>this</span><span class=o>.</span><span class=na>rows</span> <span class=o>=</span> <span class=n>rows</span><span class=o>;</span>
    <span class=k>this</span><span class=o>.</span><span class=na>cols</span> <span class=o>=</span> <span class=n>cols</span><span class=o>;</span>
    <span class=k>this</span><span class=o>.</span><span class=na>threshold</span> <span class=o>=</span> <span class=n>threshold</span><span class=o>;</span>
    <span class=n>initDigitSum</span><span class=o>();</span>
    <span class=kt>boolean</span><span class=o>[][]</span> <span class=n>marked</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>rows</span><span class=o>][</span><span class=n>cols</span><span class=o>];</span>
    <span class=n>dfs</span><span class=o>(</span><span class=n>marked</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=mi>0</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>cnt</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>dfs</span><span class=o>(</span><span class=kt>boolean</span><span class=o>[][]</span> <span class=n>marked</span><span class=o>,</span> <span class=kt>int</span> <span class=n>r</span><span class=o>,</span> <span class=kt>int</span> <span class=n>c</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>r</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>r</span> <span class=o>&gt;=</span> <span class=n>rows</span> <span class=o>||</span> <span class=n>c</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>c</span> <span class=o>&gt;=</span> <span class=n>cols</span> <span class=o>||</span> <span class=n>marked</span><span class=o>[</span><span class=n>r</span><span class=o>][</span><span class=n>c</span><span class=o>])</span>
        <span class=k>return</span><span class=o>;</span>
    <span class=n>marked</span><span class=o>[</span><span class=n>r</span><span class=o>][</span><span class=n>c</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>digitSum</span><span class=o>[</span><span class=n>r</span><span class=o>][</span><span class=n>c</span><span class=o>]</span> <span class=o>&gt;</span> <span class=k>this</span><span class=o>.</span><span class=na>threshold</span><span class=o>)</span>
        <span class=k>return</span><span class=o>;</span>
    <span class=n>cnt</span><span class=o>++;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>n</span> <span class=o>:</span> <span class=n>next</span><span class=o>)</span>
        <span class=n>dfs</span><span class=o>(</span><span class=n>marked</span><span class=o>,</span> <span class=n>r</span> <span class=o>+</span> <span class=n>n</span><span class=o>[</span><span class=mi>0</span><span class=o>],</span> <span class=n>c</span> <span class=o>+</span> <span class=n>n</span><span class=o>[</span><span class=mi>1</span><span class=o>]);</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>initDigitSum</span><span class=o>()</span> <span class=o>{</span>
    <span class=kt>int</span><span class=o>[]</span> <span class=n>digitSumOne</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>rows</span><span class=o>,</span> <span class=n>cols</span><span class=o>)];</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>digitSumOne</span><span class=o>.</span><span class=na>length</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>i</span><span class=o>;</span>
        <span class=k>while</span> <span class=o>(</span><span class=n>n</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>digitSumOne</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>+=</span> <span class=n>n</span> <span class=o>%</span> <span class=mi>10</span><span class=o>;</span>
            <span class=n>n</span> <span class=o>/=</span> <span class=mi>10</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=o>}</span>
    <span class=k>this</span><span class=o>.</span><span class=na>digitSum</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>rows</span><span class=o>][</span><span class=n>cols</span><span class=o>];</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=k>this</span><span class=o>.</span><span class=na>rows</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=k>this</span><span class=o>.</span><span class=na>cols</span><span class=o>;</span> <span class=n>j</span><span class=o>++)</span>
            <span class=k>this</span><span class=o>.</span><span class=na>digitSum</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>j</span><span class=o>]</span> <span class=o>=</span> <span class=n>digitSumOne</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>+</span> <span class=n>digitSumOne</span><span class=o>[</span><span class=n>j</span><span class=o>];</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="14">14. 剪绳子<a class="headerlink" href="#14" title="Permanent link">&para;</a></h3>
<p><a href="https://leetcode.com/problems/integer-break/description/">Leetcode</a></p>
<p><hh>题目描述</hh></p>
<p>把一根绳子剪成多段，并且使得每段的长度乘积最大。</p>
<p> <div class=codehilite><pre>n = 2
return 1 (2 = 1 + 1)

n = 10
return 36 (10 = 3 + 3 + 4)
</pre></div></p>
<p><hh>解题思路</hh></p>
<h4 id="_5">贪心<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h4>
<p>尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。</p>
<p>证明：当 n &gt;= 5 时，3(n - 3) - 2(n - 2) = n - 5 &gt;= 0。因此把长度大于 5 的绳子切成两段，令其中一段长度为 3 可以使得两段的乘积最大。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>integerBreak</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=o>)</span>
        <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>2</span><span class=o>)</span>
        <span class=k>return</span> <span class=mi>1</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>3</span><span class=o>)</span>
        <span class=k>return</span> <span class=mi>2</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>timesOf3</span> <span class=o>=</span> <span class=n>n</span> <span class=o>/</span> <span class=mi>3</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>timesOf3</span> <span class=o>*</span> <span class=mi>3</span> <span class=o>==</span> <span class=mi>1</span><span class=o>)</span>
        <span class=n>timesOf3</span><span class=o>--;</span>
    <span class=kt>int</span> <span class=n>timesOf2</span> <span class=o>=</span> <span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>timesOf3</span> <span class=o>*</span> <span class=mi>3</span><span class=o>)</span> <span class=o>/</span> <span class=mi>2</span><span class=o>;</span>
    <span class=k>return</span> <span class=o>(</span><span class=kt>int</span><span class=o>)</span> <span class=o>(</span><span class=n>Math</span><span class=o>.</span><span class=na>pow</span><span class=o>(</span><span class=mi>3</span><span class=o>,</span> <span class=n>timesOf3</span><span class=o>))</span> <span class=o>*</span> <span class=o>(</span><span class=kt>int</span><span class=o>)</span> <span class=o>(</span><span class=n>Math</span><span class=o>.</span><span class=na>pow</span><span class=o>(</span><span class=mi>2</span><span class=o>,</span> <span class=n>timesOf2</span><span class=o>));</span>
<span class=o>}</span>
</pre></div></p>
<h4 id="_6">动态规划<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h4>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>integerBreak</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span><span class=o>[]</span> <span class=n>dp</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=o>];</span>
    <span class=n>dp</span><span class=o>[</span><span class=mi>1</span><span class=o>]</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>i</span><span class=o>;</span> <span class=n>j</span><span class=o>++)</span>
            <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>],</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>j</span> <span class=o>*</span> <span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>j</span><span class=o>),</span> <span class=n>dp</span><span class=o>[</span><span class=n>j</span><span class=o>]</span> <span class=o>*</span> <span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>j</span><span class=o>)));</span>
    <span class=k>return</span> <span class=n>dp</span><span class=o>[</span><span class=n>n</span><span class=o>];</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="181-o1">18.1 在 O(1) 时间内删除链表节点<a class="headerlink" href="#181-o1" title="Permanent link">&para;</a></h3>
<p><hh>解题思路</hh></p>
<p>① 如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，然后令该节点指向下下个节点，再删除下一个节点，时间复杂度为 O(1)。</p>
<div align="center"> <img src="../pics//27ff9548-edb6-4465-92c8-7e6386e0b185.png" width="600"/> </div>

<p><br></p>
<p>② 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。</p>
<div align="center"> <img src="../pics//280f7728-594f-4811-a03a-fa8d32c013da.png" width="600"/> </div>

<p><br></p>
<p>综上，如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个尾节点以 O(N) 的时间复杂度操作节点的总次数。(2N-1)/N \~ 2，因此该算法的平均时间复杂度为 O(1)。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ListNode</span> <span class=nf>deleteNode</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>head</span><span class=o>,</span> <span class=n>ListNode</span> <span class=n>tobeDelete</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>head</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>tobeDelete</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>tobeDelete</span><span class=o>.</span><span class=na>next</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>// 要删除的节点不是尾节点</span>
        <span class=n>ListNode</span> <span class=n>next</span> <span class=o>=</span> <span class=n>tobeDelete</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
        <span class=n>tobeDelete</span><span class=o>.</span><span class=na>val</span> <span class=o>=</span> <span class=n>next</span><span class=o>.</span><span class=na>val</span><span class=o>;</span>
        <span class=n>tobeDelete</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>next</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
        <span class=n>ListNode</span> <span class=n>cur</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
        <span class=k>while</span> <span class=o>(</span><span class=n>cur</span><span class=o>.</span><span class=na>next</span> <span class=o>!=</span> <span class=n>tobeDelete</span><span class=o>)</span>
            <span class=n>cur</span> <span class=o>=</span> <span class=n>cur</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
        <span class=n>cur</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>head</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="182">18.2 删除链表中重复的结点<a class="headerlink" href="#182" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&amp;tqId=11209&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<div align="center"> <img src="../pics//8433fbb2-c35c-45ef-831d-e3ca42aebd51.png" width="500"/> </div>

<p><br></p>
<h4 id="_7">解题描述<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h4>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ListNode</span> <span class=nf>deleteDuplication</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>pHead</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>pHead</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>pHead</span><span class=o>.</span><span class=na>next</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span> <span class=n>pHead</span><span class=o>;</span>
    <span class=n>ListNode</span> <span class=n>next</span> <span class=o>=</span> <span class=n>pHead</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>pHead</span><span class=o>.</span><span class=na>val</span> <span class=o>==</span> <span class=n>next</span><span class=o>.</span><span class=na>val</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>while</span> <span class=o>(</span><span class=n>next</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>pHead</span><span class=o>.</span><span class=na>val</span> <span class=o>==</span> <span class=n>next</span><span class=o>.</span><span class=na>val</span><span class=o>)</span>
            <span class=n>next</span> <span class=o>=</span> <span class=n>next</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
        <span class=k>return</span> <span class=n>deleteDuplication</span><span class=o>(</span><span class=n>next</span><span class=o>);</span>
    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
        <span class=n>pHead</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>deleteDuplication</span><span class=o>(</span><span class=n>pHead</span><span class=o>.</span><span class=na>next</span><span class=o>);</span>
        <span class=k>return</span> <span class=n>pHead</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="19">19. 正则表达式匹配<a class="headerlink" href="#19" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&amp;tqId=11205&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>请实现一个函数用来匹配包括 '.' 和 '*' 的正则表达式。模式中的字符 '.' 表示任意一个字符，而 '*' 表示它前面的字符可以出现任意次（包含 0 次）。</p>
<p>在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 "aaa" 与模式 "a.a" 和 "ab*ac*a" 匹配，但是与 "aa.a" 和 "ab*a" 均不匹配。</p>
<p><hh>解题思路</hh></p>
<p>应该注意到，'.' 是用来当做一个任意字符，而 '*' 是用来重复前面的字符。这两个的作用不同，不能把 '.' 的作用和 '*' 进行类比，从而把它当成重复前面字符一次。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>match</span><span class=o>(</span><span class=kt>char</span><span class=o>[]</span> <span class=n>str</span><span class=o>,</span> <span class=kt>char</span><span class=o>[]</span> <span class=n>pattern</span><span class=o>)</span> <span class=o>{</span>

    <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>,</span> <span class=n>n</span> <span class=o>=</span> <span class=n>pattern</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
    <span class=kt>boolean</span><span class=o>[][]</span> <span class=n>dp</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=o>][</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=o>];</span>

    <span class=n>dp</span><span class=o>[</span><span class=mi>0</span><span class=o>][</span><span class=mi>0</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>pattern</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=o>]</span> <span class=o>==</span> <span class=sc>&#39;*&#39;</span><span class=o>)</span>
            <span class=n>dp</span><span class=o>[</span><span class=mi>0</span><span class=o>][</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>dp</span><span class=o>[</span><span class=mi>0</span><span class=o>][</span><span class=n>i</span> <span class=o>-</span> <span class=mi>2</span><span class=o>];</span>

    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>m</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=o>;</span> <span class=n>j</span><span class=o>++)</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>str</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=o>]</span> <span class=o>==</span> <span class=n>pattern</span><span class=o>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=o>]</span> <span class=o>||</span> <span class=n>pattern</span><span class=o>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=o>]</span> <span class=o>==</span> <span class=sc>&#39;.&#39;</span><span class=o>)</span>
                <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>j</span><span class=o>]</span> <span class=o>=</span> <span class=n>dp</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=o>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=o>];</span>
            <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>pattern</span><span class=o>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=o>]</span> <span class=o>==</span> <span class=sc>&#39;*&#39;</span><span class=o>)</span>
                <span class=k>if</span> <span class=o>(</span><span class=n>pattern</span><span class=o>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>2</span><span class=o>]</span> <span class=o>==</span> <span class=n>str</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=o>]</span> <span class=o>||</span> <span class=n>pattern</span><span class=o>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>2</span><span class=o>]</span> <span class=o>==</span> <span class=sc>&#39;.&#39;</span><span class=o>)</span> <span class=o>{</span>
                    <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>j</span><span class=o>]</span> <span class=o>|=</span> <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=o>];</span> <span class=c1>// a* counts as single a</span>
                    <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>j</span><span class=o>]</span> <span class=o>|=</span> <span class=n>dp</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=o>][</span><span class=n>j</span><span class=o>];</span> <span class=c1>// a* counts as multiple a</span>
                    <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>j</span><span class=o>]</span> <span class=o>|=</span> <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>2</span><span class=o>];</span> <span class=c1>// a* counts as empty</span>
                <span class=o>}</span> <span class=k>else</span>
                    <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>j</span><span class=o>]</span> <span class=o>=</span> <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>2</span><span class=o>];</span>   <span class=c1>// a* only counts as empty</span>

    <span class=k>return</span> <span class=n>dp</span><span class=o>[</span><span class=n>m</span><span class=o>][</span><span class=n>n</span><span class=o>];</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="20">20. 表示数值的字符串<a class="headerlink" href="#20" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&amp;tqId=11206&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p> <div class=codehilite><pre>true

&quot;+100&quot;
&quot;5e2&quot;
&quot;-123&quot;
&quot;3.1416&quot;
&quot;-1E-16&quot;

false

&quot;12e&quot;
&quot;1a3.14&quot;
&quot;1.2.3&quot;
&quot;+-5&quot;
&quot;12e+4.3&quot;
</pre></div></p>
<p><hh>解题思路</hh></p>
<p>使用正则表达式进行匹配。</p>
<div class=md-fenced-code-tabs id=tab-tab-group-32><input name=tab-group-32 type=radio id=tab-group-32-0_html checked=checked class=code-tab data-lang=html aria-controls=tab-group-32-0_html-panel role=tab><label for=tab-group-32-0_html class=code-tab-label data-lang=html id=tab-group-32-0_html-label>Html</label><div class=code-tabpanel role=tabpanel data-lang=html id=tab-group-32-0_html-panel aria-labelledby=tab-group-32-0_html-label><div class=codehilite><pre>[]  ： 字符集合
()  ： 分组
?   ： 重复 0 ~ 1
+   ： 重复 1 ~ n
*   ： 重复 0 ~ n
.   ： 任意字符
\\. ： 转义后的 .
\\d ： 数字
</pre></div></div><input name=tab-group-32 type=radio id=tab-group-32-1_java class=code-tab data-lang=java aria-controls=tab-group-32-1_java-panel role=tab><label for=tab-group-32-1_java class=code-tab-label data-lang=java id=tab-group-32-1_java-label>Java</label><div class=code-tabpanel role=tabpanel data-lang=java id=tab-group-32-1_java-panel aria-labelledby=tab-group-32-1_java-label><div class=codehilite><pre><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>isNumeric</span><span class=o>(</span><span class=kt>char</span><span class=o>[]</span> <span class=n>str</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>str</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>return</span> <span class=k>new</span> <span class=n>String</span><span class=o>(</span><span class=n>str</span><span class=o>).</span><span class=na>matches</span><span class=o>(</span><span class=s>&quot;[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?&quot;</span><span class=o>);</span>
<span class=o>}</span>
</pre></div></div></div>

<h3 id="21">21. 调整数组顺序使奇数位于偶数前面<a class="headerlink" href="#21" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&amp;tqId=11166&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>需要保证奇数和奇数，偶数和偶数之间的相对位置不变，这和书本不太一样。</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>void</span> <span class=nf>reOrderArray</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// 奇数个数</span>
    <span class=kt>int</span> <span class=n>oddCnt</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>val</span> <span class=o>:</span> <span class=n>nums</span><span class=o>)</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>val</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>1</span><span class=o>)</span>
            <span class=n>oddCnt</span><span class=o>++;</span>
    <span class=kt>int</span><span class=o>[]</span> <span class=n>copy</span> <span class=o>=</span> <span class=n>nums</span><span class=o>.</span><span class=na>clone</span><span class=o>();</span>
    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>j</span> <span class=o>=</span> <span class=n>oddCnt</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>num</span> <span class=o>:</span> <span class=n>copy</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>num</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>1</span><span class=o>)</span>
            <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>++]</span> <span class=o>=</span> <span class=n>num</span><span class=o>;</span>
        <span class=k>else</span>
            <span class=n>nums</span><span class=o>[</span><span class=n>j</span><span class=o>++]</span> <span class=o>=</span> <span class=n>num</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="22-k">22. 链表中倒数第 K 个结点<a class="headerlink" href="#22-k" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;tqId=11167&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>解题思路</hh></p>
<p>设链表的长度为 N。设两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到 N - K 个节点处，该位置就是倒数第 K 个节点。</p>
<div align="center"> <img src="../pics//ea2304ce-268b-4238-9486-4d8f8aea8ca4.png" width="500"/> </div>

<p><br></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ListNode</span> <span class=nf>FindKthToTail</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>head</span><span class=o>,</span> <span class=kt>int</span> <span class=n>k</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>head</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
    <span class=n>ListNode</span> <span class=n>P1</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>P1</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>k</span><span class=o>--</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span>
        <span class=n>P1</span> <span class=o>=</span> <span class=n>P1</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>k</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
    <span class=n>ListNode</span> <span class=n>P2</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>P1</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>P1</span> <span class=o>=</span> <span class=n>P1</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
        <span class=n>P2</span> <span class=o>=</span> <span class=n>P2</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>P2</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="23">23. 链表中环的入口结点<a class="headerlink" href="#23" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;tqId=11208&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>一个链表中包含环，请找出该链表的环的入口结点。要求不能使用额外的空间。</p>
<p><hh>解题思路</hh></p>
<p>使用双指针，一个指针 fast 每次移动两个节点，一个指针 slow 每次移动一个节点。因为存在环，所以两个指针必定相遇在环中的某个节点上。假设相遇点在下图的 y6 位置，此时 fast 移动的节点数为 x+2y+z，slow 为 x+y，由于 fast 速度比 slow 快一倍，因此 x+2y+z=2(x+y)，得到 x=z。</p>
<p>在相遇点，slow 要到环的入口点还需要移动 z 个节点，如果让 fast 重新从头开始移动，并且速度变为每次移动一个节点，那么它到环入口点还需要移动 x 个节点。在上面已经推导出 x=z，因此 fast 和 slow 将在环入口点相遇。</p>
<div align="center"> <img src="../pics//70fa1f83-dae7-456d-b94b-ce28963b2ba1.png" width="500"/> </div>

<p><br></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ListNode</span> <span class=nf>EntryNodeOfLoop</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>pHead</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>pHead</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>pHead</span><span class=o>.</span><span class=na>next</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
    <span class=n>ListNode</span> <span class=n>slow</span> <span class=o>=</span> <span class=n>pHead</span><span class=o>,</span> <span class=n>fast</span> <span class=o>=</span> <span class=n>pHead</span><span class=o>;</span>
    <span class=k>do</span> <span class=o>{</span>
        <span class=n>fast</span> <span class=o>=</span> <span class=n>fast</span><span class=o>.</span><span class=na>next</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
        <span class=n>slow</span> <span class=o>=</span> <span class=n>slow</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=o>}</span> <span class=k>while</span> <span class=o>(</span><span class=n>slow</span> <span class=o>!=</span> <span class=n>fast</span><span class=o>);</span>
    <span class=n>fast</span> <span class=o>=</span> <span class=n>pHead</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>slow</span> <span class=o>!=</span> <span class=n>fast</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>slow</span> <span class=o>=</span> <span class=n>slow</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
        <span class=n>fast</span> <span class=o>=</span> <span class=n>fast</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>slow</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="24">24. 反转链表<a class="headerlink" href="#24" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;tqId=11168&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>解题思路</hh></p>
<h3 id="_8">递归<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ListNode</span> <span class=nf>ReverseList</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>head</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>head</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>head</span><span class=o>.</span><span class=na>next</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span> <span class=n>head</span><span class=o>;</span>
    <span class=n>ListNode</span> <span class=n>next</span> <span class=o>=</span> <span class=n>head</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=n>head</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
    <span class=n>ListNode</span> <span class=n>newHead</span> <span class=o>=</span> <span class=n>ReverseList</span><span class=o>(</span><span class=n>next</span><span class=o>);</span>
    <span class=n>next</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
    <span class=k>return</span> <span class=n>newHead</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="_9">迭代<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h3>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ListNode</span> <span class=nf>ReverseList</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>head</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>ListNode</span> <span class=n>newList</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ListNode</span><span class=o>(-</span><span class=mi>1</span><span class=o>);</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>head</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>ListNode</span> <span class=n>next</span> <span class=o>=</span> <span class=n>head</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
        <span class=n>head</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>newList</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
        <span class=n>newList</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
        <span class=n>head</span> <span class=o>=</span> <span class=n>next</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>newList</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="25">25. 合并两个排序的链表<a class="headerlink" href="#25" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<div align="center"> <img src="../pics//43f2cafa-3568-4a89-a895-4725666b94a6.png" width="500"/> </div>

<p><br></p>
<p><hh>解题思路</hh></p>
<h4 id="_10">递归<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h4>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ListNode</span> <span class=nf>Merge</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>list1</span><span class=o>,</span> <span class=n>ListNode</span> <span class=n>list2</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>list1</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span> <span class=n>list2</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>list2</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span> <span class=n>list1</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>list1</span><span class=o>.</span><span class=na>val</span> <span class=o>&lt;=</span> <span class=n>list2</span><span class=o>.</span><span class=na>val</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>list1</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>Merge</span><span class=o>(</span><span class=n>list1</span><span class=o>.</span><span class=na>next</span><span class=o>,</span> <span class=n>list2</span><span class=o>);</span>
        <span class=k>return</span> <span class=n>list1</span><span class=o>;</span>
    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
        <span class=n>list2</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>Merge</span><span class=o>(</span><span class=n>list1</span><span class=o>,</span> <span class=n>list2</span><span class=o>.</span><span class=na>next</span><span class=o>);</span>
        <span class=k>return</span> <span class=n>list2</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<h4 id="_11">迭代<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h4>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ListNode</span> <span class=nf>Merge</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>list1</span><span class=o>,</span> <span class=n>ListNode</span> <span class=n>list2</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>ListNode</span> <span class=n>head</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ListNode</span><span class=o>(-</span><span class=mi>1</span><span class=o>);</span>
    <span class=n>ListNode</span> <span class=n>cur</span> <span class=o>=</span> <span class=n>head</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>list1</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>list2</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>list1</span><span class=o>.</span><span class=na>val</span> <span class=o>&lt;=</span> <span class=n>list2</span><span class=o>.</span><span class=na>val</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>cur</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>list1</span><span class=o>;</span>
            <span class=n>list1</span> <span class=o>=</span> <span class=n>list1</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
            <span class=n>cur</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>list2</span><span class=o>;</span>
            <span class=n>list2</span> <span class=o>=</span> <span class=n>list2</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=n>cur</span> <span class=o>=</span> <span class=n>cur</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>list1</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
        <span class=n>cur</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>list1</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>list2</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
        <span class=n>cur</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>list2</span><span class=o>;</span>
    <span class=k>return</span> <span class=n>head</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="26">26. 树的子结构<a class="headerlink" href="#26" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;tqId=11170&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<div align="center"> <img src="../pics//4583e24f-424b-4d50-8a14-2c38a1827d4a.png" width="500"/> </div>

<p><br></p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>HasSubtree</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root1</span><span class=o>,</span> <span class=n>TreeNode</span> <span class=n>root2</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>root1</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>root2</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>return</span> <span class=n>isSubtreeWithRoot</span><span class=o>(</span><span class=n>root1</span><span class=o>,</span> <span class=n>root2</span><span class=o>)</span> <span class=o>||</span> <span class=n>HasSubtree</span><span class=o>(</span><span class=n>root1</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>root2</span><span class=o>)</span> <span class=o>||</span> <span class=n>HasSubtree</span><span class=o>(</span><span class=n>root1</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>root2</span><span class=o>);</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>boolean</span> <span class=nf>isSubtreeWithRoot</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root1</span><span class=o>,</span> <span class=n>TreeNode</span> <span class=n>root2</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>root2</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>root1</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>root1</span><span class=o>.</span><span class=na>val</span> <span class=o>!=</span> <span class=n>root2</span><span class=o>.</span><span class=na>val</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>return</span> <span class=n>isSubtreeWithRoot</span><span class=o>(</span><span class=n>root1</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>root2</span><span class=o>.</span><span class=na>left</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=n>isSubtreeWithRoot</span><span class=o>(</span><span class=n>root1</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>root2</span><span class=o>.</span><span class=na>right</span><span class=o>);</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="27">27. 二叉树的镜像<a class="headerlink" href="#27" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&amp;tqId=11171&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<div align="center"> <img src="../pics//a2d13178-f1ef-4811-a240-1fe95b55b1eb.png" width="300"/> </div>

<p><br></p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>void</span> <span class=nf>Mirror</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span><span class=o>;</span>
    <span class=n>swap</span><span class=o>(</span><span class=n>root</span><span class=o>);</span>
    <span class=n>Mirror</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>);</span>
    <span class=n>Mirror</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>);</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>swap</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>TreeNode</span> <span class=n>t</span> <span class=o>=</span> <span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>;</span>
    <span class=n>root</span><span class=o>.</span><span class=na>left</span> <span class=o>=</span> <span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>;</span>
    <span class=n>root</span><span class=o>.</span><span class=na>right</span> <span class=o>=</span> <span class=n>t</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="28">28 对称的二叉树<a class="headerlink" href="#28" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&amp;tqId=11211&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCder</a></p>
<p><hh>题目描述</hh></p>
<div align="center"> <img src="../pics//f42443e0-208d-41ea-be44-c7fd97d2e3bf.png" width="300"/> </div>

<p><br></p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kt>boolean</span> <span class=nf>isSymmetrical</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>pRoot</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>pRoot</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
    <span class=k>return</span> <span class=n>isSymmetrical</span><span class=o>(</span><span class=n>pRoot</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>pRoot</span><span class=o>.</span><span class=na>right</span><span class=o>);</span>
<span class=o>}</span>

<span class=kt>boolean</span> <span class=nf>isSymmetrical</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>t1</span><span class=o>,</span> <span class=n>TreeNode</span> <span class=n>t2</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>t1</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>t2</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>t1</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>t2</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>t1</span><span class=o>.</span><span class=na>val</span> <span class=o>!=</span> <span class=n>t2</span><span class=o>.</span><span class=na>val</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>return</span> <span class=n>isSymmetrical</span><span class=o>(</span><span class=n>t1</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>t2</span><span class=o>.</span><span class=na>right</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=n>isSymmetrical</span><span class=o>(</span><span class=n>t1</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>t2</span><span class=o>.</span><span class=na>left</span><span class=o>);</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="29">29. 顺时针打印矩阵<a class="headerlink" href="#29" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;tqId=11172&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>下图的矩阵顺时针打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10</p>
<div align="center"> <img src="../pics//6539b9a4-2b24-4d10-8c94-2eb5aba1e296.png" width="300"/> </div>

<p><br></p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>printMatrix</span><span class=o>(</span><span class=kt>int</span><span class=o>[][]</span> <span class=n>matrix</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>ret</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=kt>int</span> <span class=n>r1</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>r2</span> <span class=o>=</span> <span class=n>matrix</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=o>,</span> <span class=n>c1</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>c2</span> <span class=o>=</span> <span class=n>matrix</span><span class=o>[</span><span class=mi>0</span><span class=o>].</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>r1</span> <span class=o>&lt;=</span> <span class=n>r2</span> <span class=o>&amp;&amp;</span> <span class=n>c1</span> <span class=o>&lt;=</span> <span class=n>c2</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>c1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>c2</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
            <span class=n>ret</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>matrix</span><span class=o>[</span><span class=n>r1</span><span class=o>][</span><span class=n>i</span><span class=o>]);</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>r1</span> <span class=o>+</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>r2</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
            <span class=n>ret</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>matrix</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>c2</span><span class=o>]);</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>r1</span> <span class=o>!=</span> <span class=n>r2</span><span class=o>)</span>
            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>c2</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=n>c1</span><span class=o>;</span> <span class=n>i</span><span class=o>--)</span>
                <span class=n>ret</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>matrix</span><span class=o>[</span><span class=n>r2</span><span class=o>][</span><span class=n>i</span><span class=o>]);</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>c1</span> <span class=o>!=</span> <span class=n>c2</span><span class=o>)</span>
            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>r2</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=n>r1</span><span class=o>;</span> <span class=n>i</span><span class=o>--)</span>
                <span class=n>ret</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>matrix</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>c1</span><span class=o>]);</span>
        <span class=n>r1</span><span class=o>++;</span> <span class=n>r2</span><span class=o>--;</span> <span class=n>c1</span><span class=o>++;</span> <span class=n>c2</span><span class=o>--;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>ret</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="30-min">30. 包含 min 函数的栈<a class="headerlink" href="#30-min" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=11173&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>private</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>dataStack</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;&gt;();</span>
<span class=kd>private</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>minStack</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;&gt;();</span>

<span class=kd>public</span> <span class=kt>void</span> <span class=nf>push</span><span class=o>(</span><span class=kt>int</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>dataStack</span><span class=o>.</span><span class=na>push</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
    <span class=n>minStack</span><span class=o>.</span><span class=na>push</span><span class=o>(</span><span class=n>minStack</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>()</span> <span class=o>?</span> <span class=n>node</span> <span class=o>:</span> <span class=n>Math</span><span class=o>.</span><span class=na>min</span><span class=o>(</span><span class=n>minStack</span><span class=o>.</span><span class=na>peek</span><span class=o>(),</span> <span class=n>node</span><span class=o>));</span>
<span class=o>}</span>

<span class=kd>public</span> <span class=kt>void</span> <span class=nf>pop</span><span class=o>()</span> <span class=o>{</span>
    <span class=n>dataStack</span><span class=o>.</span><span class=na>pop</span><span class=o>();</span>
    <span class=n>minStack</span><span class=o>.</span><span class=na>pop</span><span class=o>();</span>
<span class=o>}</span>

<span class=kd>public</span> <span class=kt>int</span> <span class=nf>top</span><span class=o>()</span> <span class=o>{</span>
    <span class=k>return</span> <span class=n>dataStack</span><span class=o>.</span><span class=na>peek</span><span class=o>();</span>
<span class=o>}</span>

<span class=kd>public</span> <span class=kt>int</span> <span class=nf>min</span><span class=o>()</span> <span class=o>{</span>
    <span class=k>return</span> <span class=n>minStack</span><span class=o>.</span><span class=na>peek</span><span class=o>();</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="31">31. 栈的压入、弹出序列<a class="headerlink" href="#31" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=11174&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。</p>
<p>例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。</p>
<p><hh>解题思路</hh></p>
<p>使用一个栈来模拟压入弹出操作。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>IsPopOrder</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>pushSequence</span><span class=o>,</span> <span class=kt>int</span><span class=o>[]</span> <span class=n>popSequence</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>pushSequence</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
    <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>stack</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Stack</span><span class=o>&lt;&gt;();</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>pushIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>popIndex</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>pushIndex</span> <span class=o>&lt;</span> <span class=n>n</span><span class=o>;</span> <span class=n>pushIndex</span><span class=o>++)</span> <span class=o>{</span>
        <span class=n>stack</span><span class=o>.</span><span class=na>push</span><span class=o>(</span><span class=n>pushSequence</span><span class=o>[</span><span class=n>pushIndex</span><span class=o>]);</span>
        <span class=k>while</span> <span class=o>(</span><span class=n>popIndex</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>stack</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>()</span> 
                <span class=o>&amp;&amp;</span> <span class=n>stack</span><span class=o>.</span><span class=na>peek</span><span class=o>()</span> <span class=o>==</span> <span class=n>popSequence</span><span class=o>[</span><span class=n>popIndex</span><span class=o>])</span> <span class=o>{</span>
            <span class=n>stack</span><span class=o>.</span><span class=na>pop</span><span class=o>();</span>
            <span class=n>popIndex</span><span class=o>++;</span>
        <span class=o>}</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>stack</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>();</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="321">32.1 从上往下打印二叉树<a class="headerlink" href="#321" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&amp;tqId=11175&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>例如，以下二叉树层次遍历的结果为：1,2,3,4,5,6,7</p>
<div align="center"> <img src="../pics//348bc2db-582e-4aca-9f88-38c40e9a0e69.png" width="250"/> </div>

<p><br></p>
<p><hh>解题思路</hh></p>
<p>使用队列来进行层次遍历。</p>
<p>不需要使用两个队列分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>PrintFromTopToBottom</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>Queue</span><span class=o>&lt;</span><span class=n>TreeNode</span><span class=o>&gt;</span> <span class=n>queue</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span>
    <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>ret</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=n>queue</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>root</span><span class=o>);</span>
    <span class=k>while</span> <span class=o>(!</span><span class=n>queue</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=na>size</span><span class=o>();</span>
        <span class=k>while</span> <span class=o>(</span><span class=n>cnt</span><span class=o>--</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>TreeNode</span> <span class=n>t</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=na>poll</span><span class=o>();</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>t</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
                <span class=k>continue</span><span class=o>;</span>
            <span class=n>ret</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>t</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
            <span class=n>queue</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>t</span><span class=o>.</span><span class=na>left</span><span class=o>);</span>
            <span class=n>queue</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>t</span><span class=o>.</span><span class=na>right</span><span class=o>);</span>
        <span class=o>}</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>ret</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="322">32.2 把二叉树打印成多行<a class="headerlink" href="#322" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&amp;tqId=11213&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>和上题几乎一样。</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=nf>Print</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>pRoot</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>ret</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=n>Queue</span><span class=o>&lt;</span><span class=n>TreeNode</span><span class=o>&gt;</span> <span class=n>queue</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span>
    <span class=n>queue</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>pRoot</span><span class=o>);</span>
    <span class=k>while</span> <span class=o>(!</span><span class=n>queue</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span> <span class=o>{</span>
        <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
        <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=na>size</span><span class=o>();</span>
        <span class=k>while</span> <span class=o>(</span><span class=n>cnt</span><span class=o>--</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>TreeNode</span> <span class=n>node</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=na>poll</span><span class=o>();</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>node</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
                <span class=k>continue</span><span class=o>;</span>
            <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
            <span class=n>queue</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>left</span><span class=o>);</span>
            <span class=n>queue</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>right</span><span class=o>);</span>
        <span class=o>}</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>list</span><span class=o>.</span><span class=na>size</span><span class=o>()</span> <span class=o>!=</span> <span class=mi>0</span><span class=o>)</span>
            <span class=n>ret</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>list</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>ret</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="323">32.3 按之字形顺序打印二叉树<a class="headerlink" href="#323" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&amp;tqId=11212&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=nf>Print</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>pRoot</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>ret</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=n>Queue</span><span class=o>&lt;</span><span class=n>TreeNode</span><span class=o>&gt;</span> <span class=n>queue</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span>
    <span class=n>queue</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>pRoot</span><span class=o>);</span>
    <span class=kt>boolean</span> <span class=n>reverse</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(!</span><span class=n>queue</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>())</span> <span class=o>{</span>
        <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
        <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=na>size</span><span class=o>();</span>
        <span class=k>while</span> <span class=o>(</span><span class=n>cnt</span><span class=o>--</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>TreeNode</span> <span class=n>node</span> <span class=o>=</span> <span class=n>queue</span><span class=o>.</span><span class=na>poll</span><span class=o>();</span>
            <span class=k>if</span> <span class=o>(</span><span class=n>node</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
                <span class=k>continue</span><span class=o>;</span>
            <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
            <span class=n>queue</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>left</span><span class=o>);</span>
            <span class=n>queue</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>right</span><span class=o>);</span>
        <span class=o>}</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>reverse</span><span class=o>)</span>
            <span class=n>Collections</span><span class=o>.</span><span class=na>reverse</span><span class=o>(</span><span class=n>list</span><span class=o>);</span>
        <span class=n>reverse</span> <span class=o>=</span> <span class=o>!</span><span class=n>reverse</span><span class=o>;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>list</span><span class=o>.</span><span class=na>size</span><span class=o>()</span> <span class=o>!=</span> <span class=mi>0</span><span class=o>)</span>
            <span class=n>ret</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>list</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>ret</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="33">33. 二叉搜索树的后序遍历序列<a class="headerlink" href="#33" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=11176&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。</p>
<p>例如，下图是后序遍历序列 1,3,2 所对应的二叉搜索树。</p>
<div align="center"> <img src="../pics//836a4eaf-4798-4e48-b52a-a3dab9435ace.png" width="150"/> </div>

<p><br></p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>VerifySquenceOfBST</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>sequence</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>sequence</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>sequence</span><span class=o>.</span><span class=na>length</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>return</span> <span class=n>verify</span><span class=o>(</span><span class=n>sequence</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>sequence</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=o>);</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>boolean</span> <span class=nf>verify</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>sequence</span><span class=o>,</span> <span class=kt>int</span> <span class=n>first</span><span class=o>,</span> <span class=kt>int</span> <span class=n>last</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>last</span> <span class=o>-</span> <span class=n>first</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>rootVal</span> <span class=o>=</span> <span class=n>sequence</span><span class=o>[</span><span class=n>last</span><span class=o>];</span>
    <span class=kt>int</span> <span class=n>cutIndex</span> <span class=o>=</span> <span class=n>first</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>cutIndex</span> <span class=o>&lt;</span> <span class=n>last</span> <span class=o>&amp;&amp;</span> <span class=n>sequence</span><span class=o>[</span><span class=n>cutIndex</span><span class=o>]</span> <span class=o>&lt;=</span> <span class=n>rootVal</span><span class=o>)</span>
        <span class=n>cutIndex</span><span class=o>++;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>cutIndex</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>last</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>sequence</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>&lt;</span> <span class=n>rootVal</span><span class=o>)</span>
            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>return</span> <span class=n>verify</span><span class=o>(</span><span class=n>sequence</span><span class=o>,</span> <span class=n>first</span><span class=o>,</span> <span class=n>cutIndex</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=n>verify</span><span class=o>(</span><span class=n>sequence</span><span class=o>,</span> <span class=n>cutIndex</span><span class=o>,</span> <span class=n>last</span> <span class=o>-</span> <span class=mi>1</span><span class=o>);</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="34">34. 二叉树中和为某一值的路径<a class="headerlink" href="#34" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&amp;tqId=11177&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>下图的二叉树有两条和为 22 的路径：10, 5, 7 和 10, 12</p>
<div align="center"> <img src="../pics//f5477abd-c246-4851-89ab-6b1cde2549b1.png" width="200"/> </div>

<p><br></p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>private</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>ret</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>

<span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=nf>FindPath</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>,</span> <span class=kt>int</span> <span class=n>target</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>backtracking</span><span class=o>(</span><span class=n>root</span><span class=o>,</span> <span class=n>target</span><span class=o>,</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;());</span>
    <span class=k>return</span> <span class=n>ret</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>backtracking</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>node</span><span class=o>,</span> <span class=kt>int</span> <span class=n>target</span><span class=o>,</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>path</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>node</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span><span class=o>;</span>
    <span class=n>path</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>val</span><span class=o>);</span>
    <span class=n>target</span> <span class=o>-=</span> <span class=n>node</span><span class=o>.</span><span class=na>val</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>target</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>node</span><span class=o>.</span><span class=na>left</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span> <span class=n>node</span><span class=o>.</span><span class=na>right</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>ret</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;(</span><span class=n>path</span><span class=o>));</span>
    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
        <span class=n>backtracking</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>target</span><span class=o>,</span> <span class=n>path</span><span class=o>);</span>
        <span class=n>backtracking</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>target</span><span class=o>,</span> <span class=n>path</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=n>path</span><span class=o>.</span><span class=na>remove</span><span class=o>(</span><span class=n>path</span><span class=o>.</span><span class=na>size</span><span class=o>()</span> <span class=o>-</span> <span class=mi>1</span><span class=o>);</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="35">35. 复杂链表的复制<a class="headerlink" href="#35" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&amp;tqId=11178&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kd>class</span> <span class=nc>RandomListNode</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>label</span><span class=o>;</span>
    <span class=n>RandomListNode</span> <span class=n>next</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
    <span class=n>RandomListNode</span> <span class=n>random</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>

    <span class=n>RandomListNode</span><span class=o>(</span><span class=kt>int</span> <span class=n>label</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>this</span><span class=o>.</span><span class=na>label</span> <span class=o>=</span> <span class=n>label</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<div align="center"> <img src="../pics//a01d1516-8168-461a-a24b-620b9cfc40f4.png" width="300"/> </div>

<p><br></p>
<p><hh>解题思路</hh></p>
<p>第一步，在每个节点的后面插入复制的节点。</p>
<div align="center"> <img src="../pics//2e6c72f5-3b8e-4e32-b87b-9491322628fe.png" width="600"/> </div>

<p><br></p>
<p>第二步，对复制节点的 random 链接进行赋值。</p>
<div align="center"> <img src="../pics//323ffd6c-8b54-4f3e-b361-555a6c8bf218.png" width="600"/> </div>

<p><br></p>
<p>第三步，拆分。</p>
<div align="center"> <img src="../pics//8f3b9519-d705-48fe-87ad-2e4052fc81d2.png" width="600"/> </div>

<p><br></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>RandomListNode</span> <span class=nf>Clone</span><span class=o>(</span><span class=n>RandomListNode</span> <span class=n>pHead</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>pHead</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
    <span class=c1>// 插入新节点</span>
    <span class=n>RandomListNode</span> <span class=n>cur</span> <span class=o>=</span> <span class=n>pHead</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>cur</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>RandomListNode</span> <span class=n>clone</span> <span class=o>=</span> <span class=k>new</span> <span class=n>RandomListNode</span><span class=o>(</span><span class=n>cur</span><span class=o>.</span><span class=na>label</span><span class=o>);</span>
        <span class=n>clone</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>cur</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
        <span class=n>cur</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>clone</span><span class=o>;</span>
        <span class=n>cur</span> <span class=o>=</span> <span class=n>clone</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=c1>// 建立 random 链接</span>
    <span class=n>cur</span> <span class=o>=</span> <span class=n>pHead</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>cur</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>RandomListNode</span> <span class=n>clone</span> <span class=o>=</span> <span class=n>cur</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>cur</span><span class=o>.</span><span class=na>random</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
            <span class=n>clone</span><span class=o>.</span><span class=na>random</span> <span class=o>=</span> <span class=n>cur</span><span class=o>.</span><span class=na>random</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
        <span class=n>cur</span> <span class=o>=</span> <span class=n>clone</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=c1>// 拆分</span>
    <span class=n>cur</span> <span class=o>=</span> <span class=n>pHead</span><span class=o>;</span>
    <span class=n>RandomListNode</span> <span class=n>pCloneHead</span> <span class=o>=</span> <span class=n>pHead</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>cur</span><span class=o>.</span><span class=na>next</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>RandomListNode</span> <span class=n>next</span> <span class=o>=</span> <span class=n>cur</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
        <span class=n>cur</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>next</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
        <span class=n>cur</span> <span class=o>=</span> <span class=n>next</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>pCloneHead</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="36">36. 二叉搜索树与双向链表<a class="headerlink" href="#36" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=11179&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<div align="center"> <img src="../pics//79b12431-6d9d-4a7d-985b-1b79bc5bf5fb.png" width="400"/> </div>

<p><br></p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>private</span> <span class=n>TreeNode</span> <span class=n>pre</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
<span class=kd>private</span> <span class=n>TreeNode</span> <span class=n>head</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>

<span class=kd>public</span> <span class=n>TreeNode</span> <span class=nf>Convert</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>inOrder</span><span class=o>(</span><span class=n>root</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>head</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>inOrder</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>node</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>node</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span><span class=o>;</span>
    <span class=n>inOrder</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>left</span><span class=o>);</span>
    <span class=n>node</span><span class=o>.</span><span class=na>left</span> <span class=o>=</span> <span class=n>pre</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>pre</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>)</span>
        <span class=n>pre</span><span class=o>.</span><span class=na>right</span> <span class=o>=</span> <span class=n>node</span><span class=o>;</span>
    <span class=n>pre</span> <span class=o>=</span> <span class=n>node</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>head</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=n>head</span> <span class=o>=</span> <span class=n>node</span><span class=o>;</span>
    <span class=n>inOrder</span><span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>right</span><span class=o>);</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="37">37. 序列化二叉树<a class="headerlink" href="#37" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&amp;tqId=11214&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>private</span> <span class=n>String</span> <span class=n>deserializeStr</span><span class=o>;</span>

<span class=kd>public</span> <span class=n>String</span> <span class=nf>Serialize</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span> <span class=s>&quot;#&quot;</span><span class=o>;</span>
    <span class=k>return</span> <span class=n>root</span><span class=o>.</span><span class=na>val</span> <span class=o>+</span> <span class=s>&quot; &quot;</span> <span class=o>+</span> <span class=n>Serialize</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>)</span> <span class=o>+</span> <span class=s>&quot; &quot;</span> <span class=o>+</span> <span class=n>Serialize</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>);</span>
<span class=o>}</span>

<span class=kd>public</span> <span class=n>TreeNode</span> <span class=nf>Deserialize</span><span class=o>(</span><span class=n>String</span> <span class=n>str</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>deserializeStr</span> <span class=o>=</span> <span class=n>str</span><span class=o>;</span>
    <span class=k>return</span> <span class=n>Deserialize</span><span class=o>();</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=n>TreeNode</span> <span class=nf>Deserialize</span><span class=o>()</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>deserializeStr</span><span class=o>.</span><span class=na>length</span><span class=o>()</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=n>deserializeStr</span><span class=o>.</span><span class=na>indexOf</span><span class=o>(</span><span class=s>&quot; &quot;</span><span class=o>);</span>
    <span class=n>String</span> <span class=n>node</span> <span class=o>=</span> <span class=n>index</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=o>?</span> <span class=n>deserializeStr</span> <span class=o>:</span> <span class=n>deserializeStr</span><span class=o>.</span><span class=na>substring</span><span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=n>index</span><span class=o>);</span>
    <span class=n>deserializeStr</span> <span class=o>=</span> <span class=n>index</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=o>?</span> <span class=s>&quot;&quot;</span> <span class=o>:</span> <span class=n>deserializeStr</span><span class=o>.</span><span class=na>substring</span><span class=o>(</span><span class=n>index</span> <span class=o>+</span> <span class=mi>1</span><span class=o>);</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>node</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=s>&quot;#&quot;</span><span class=o>))</span>
        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>val</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>.</span><span class=na>valueOf</span><span class=o>(</span><span class=n>node</span><span class=o>);</span>
    <span class=n>TreeNode</span> <span class=n>t</span> <span class=o>=</span> <span class=k>new</span> <span class=n>TreeNode</span><span class=o>(</span><span class=n>val</span><span class=o>);</span>
    <span class=n>t</span><span class=o>.</span><span class=na>left</span> <span class=o>=</span> <span class=n>Deserialize</span><span class=o>();</span>
    <span class=n>t</span><span class=o>.</span><span class=na>right</span> <span class=o>=</span> <span class=n>Deserialize</span><span class=o>();</span>
    <span class=k>return</span> <span class=n>t</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="38">38. 字符串的排列<a class="headerlink" href="#38" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&amp;tqId=11180&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a, b, c 所能排列出来的所有字符串 abc, acb, bac, bca, cab 和 cba。</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>private</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>ret</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>

<span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=nf>Permutation</span><span class=o>(</span><span class=n>String</span> <span class=n>str</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>()</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=n>ret</span><span class=o>;</span>
    <span class=kt>char</span><span class=o>[]</span> <span class=n>chars</span> <span class=o>=</span> <span class=n>str</span><span class=o>.</span><span class=na>toCharArray</span><span class=o>();</span>
    <span class=n>Arrays</span><span class=o>.</span><span class=na>sort</span><span class=o>(</span><span class=n>chars</span><span class=o>);</span>
    <span class=n>backtracking</span><span class=o>(</span><span class=n>chars</span><span class=o>,</span> <span class=k>new</span> <span class=kt>boolean</span><span class=o>[</span><span class=n>chars</span><span class=o>.</span><span class=na>length</span><span class=o>],</span> <span class=k>new</span> <span class=n>StringBuilder</span><span class=o>());</span>
    <span class=k>return</span> <span class=n>ret</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>backtracking</span><span class=o>(</span><span class=kt>char</span><span class=o>[]</span> <span class=n>chars</span><span class=o>,</span> <span class=kt>boolean</span><span class=o>[]</span> <span class=n>hasUsed</span><span class=o>,</span> <span class=n>StringBuilder</span> <span class=n>s</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>s</span><span class=o>.</span><span class=na>length</span><span class=o>()</span> <span class=o>==</span> <span class=n>chars</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>ret</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>s</span><span class=o>.</span><span class=na>toString</span><span class=o>());</span>
        <span class=k>return</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>chars</span><span class=o>.</span><span class=na>length</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>hasUsed</span><span class=o>[</span><span class=n>i</span><span class=o>])</span>
            <span class=k>continue</span><span class=o>;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>i</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>chars</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>==</span> <span class=n>chars</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=o>]</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>hasUsed</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=o>])</span> <span class=cm>/* 保证不重复 */</span>
            <span class=k>continue</span><span class=o>;</span>
        <span class=n>hasUsed</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>
        <span class=n>s</span><span class=o>.</span><span class=na>append</span><span class=o>(</span><span class=n>chars</span><span class=o>[</span><span class=n>i</span><span class=o>]);</span>
        <span class=n>backtracking</span><span class=o>(</span><span class=n>chars</span><span class=o>,</span> <span class=n>hasUsed</span><span class=o>,</span> <span class=n>s</span><span class=o>);</span>
        <span class=n>s</span><span class=o>.</span><span class=na>deleteCharAt</span><span class=o>(</span><span class=n>s</span><span class=o>.</span><span class=na>length</span><span class=o>()</span> <span class=o>-</span> <span class=mi>1</span><span class=o>);</span>
        <span class=n>hasUsed</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="39">39. 数组中出现次数超过一半的数字<a class="headerlink" href="#39" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&amp;tqId=11181&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>解题思路</hh></p>
<p>多数投票问题，可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。</p>
<p>使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素相等时，令 cnt++，否则令 cnt--。如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2 ，因为如果多于 i / 2 的话 cnt 就一定不会为 0 。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>MoreThanHalfNum_Solution</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>majority</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=mi>0</span><span class=o>];</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=o>,</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nums</span><span class=o>.</span><span class=na>length</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=n>cnt</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>==</span> <span class=n>majority</span> <span class=o>?</span> <span class=n>cnt</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>:</span> <span class=n>cnt</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>cnt</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>majority</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
            <span class=n>cnt</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=o>}</span>
    <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>val</span> <span class=o>:</span> <span class=n>nums</span><span class=o>)</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>val</span> <span class=o>==</span> <span class=n>majority</span><span class=o>)</span>
            <span class=n>cnt</span><span class=o>++;</span>
    <span class=k>return</span> <span class=n>cnt</span> <span class=o>&gt;</span> <span class=n>nums</span><span class=o>.</span><span class=na>length</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>?</span> <span class=n>majority</span> <span class=o>:</span> <span class=mi>0</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="40-k">40. 最小的 K 个数<a class="headerlink" href="#40-k" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&amp;tqId=11182&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<h4 id="_12">快速选择<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h4>
<ul>
<li>复杂度：O(N) + O(1)</li>
<li>只有当允许修改数组元素时才可以使用</li>
</ul>
<p>快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>GetLeastNumbers_Solution</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>,</span> <span class=kt>int</span> <span class=n>k</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>ret</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>k</span> <span class=o>&gt;</span> <span class=n>nums</span><span class=o>.</span><span class=na>length</span> <span class=o>||</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=n>ret</span><span class=o>;</span>
    <span class=n>findKthSmallest</span><span class=o>(</span><span class=n>nums</span><span class=o>,</span> <span class=n>k</span> <span class=o>-</span> <span class=mi>1</span><span class=o>);</span>
    <span class=cm>/* findKthSmallest 会改变数组，使得前 k 个数都是最小的 k 个数 */</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>k</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=n>ret</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]);</span>
    <span class=k>return</span> <span class=n>ret</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>public</span> <span class=kt>void</span> <span class=nf>findKthSmallest</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>,</span> <span class=kt>int</span> <span class=n>k</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>l</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>h</span> <span class=o>=</span> <span class=n>nums</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>l</span> <span class=o>&lt;</span> <span class=n>h</span><span class=o>)</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>partition</span><span class=o>(</span><span class=n>nums</span><span class=o>,</span> <span class=n>l</span><span class=o>,</span> <span class=n>h</span><span class=o>);</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>j</span> <span class=o>==</span> <span class=n>k</span><span class=o>)</span>
            <span class=k>break</span><span class=o>;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>j</span> <span class=o>&gt;</span> <span class=n>k</span><span class=o>)</span>
            <span class=n>h</span> <span class=o>=</span> <span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span>
        <span class=k>else</span>
            <span class=n>l</span> <span class=o>=</span> <span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>int</span> <span class=nf>partition</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>,</span> <span class=kt>int</span> <span class=n>l</span><span class=o>,</span> <span class=kt>int</span> <span class=n>h</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>p</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>l</span><span class=o>];</span>     <span class=cm>/* 切分元素 */</span>
    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>l</span><span class=o>,</span> <span class=n>j</span> <span class=o>=</span> <span class=n>h</span> <span class=o>+</span> <span class=mi>1</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=kc>true</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>while</span> <span class=o>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>h</span> <span class=o>&amp;&amp;</span> <span class=n>nums</span><span class=o>[++</span><span class=n>i</span><span class=o>]</span> <span class=o>&lt;</span> <span class=n>p</span><span class=o>)</span> <span class=o>;</span>
        <span class=k>while</span> <span class=o>(</span><span class=n>j</span> <span class=o>!=</span> <span class=n>l</span> <span class=o>&amp;&amp;</span> <span class=n>nums</span><span class=o>[--</span><span class=n>j</span><span class=o>]</span> <span class=o>&gt;</span> <span class=n>p</span><span class=o>)</span> <span class=o>;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>i</span> <span class=o>&gt;=</span> <span class=n>j</span><span class=o>)</span>
            <span class=k>break</span><span class=o>;</span>
        <span class=n>swap</span><span class=o>(</span><span class=n>nums</span><span class=o>,</span> <span class=n>i</span><span class=o>,</span> <span class=n>j</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=n>swap</span><span class=o>(</span><span class=n>nums</span><span class=o>,</span> <span class=n>l</span><span class=o>,</span> <span class=n>j</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>j</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>swap</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>,</span> <span class=kt>int</span> <span class=n>i</span><span class=o>,</span> <span class=kt>int</span> <span class=n>j</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
    <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>j</span><span class=o>];</span>
    <span class=n>nums</span><span class=o>[</span><span class=n>j</span><span class=o>]</span> <span class=o>=</span> <span class=n>t</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h4 id="k">大小为 K 的最小堆<a class="headerlink" href="#k" title="Permanent link">&para;</a></h4>
<ul>
<li>复杂度：O(NlogK) + O(K)</li>
<li>特别适合处理海量数据</li>
</ul>
<p>应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。</p>
<p>维护一个大小为 K 的最小堆过程如下：在添加一个元素之后，如果大顶堆的大小大于 K，那么需要将大顶堆的堆顶元素去除。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>GetLeastNumbers_Solution</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>,</span> <span class=kt>int</span> <span class=n>k</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>k</span> <span class=o>&gt;</span> <span class=n>nums</span><span class=o>.</span><span class=na>length</span> <span class=o>||</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=n>PriorityQueue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>maxHeap</span> <span class=o>=</span> <span class=k>new</span> <span class=n>PriorityQueue</span><span class=o>&lt;&gt;((</span><span class=n>o1</span><span class=o>,</span> <span class=n>o2</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>o2</span> <span class=o>-</span> <span class=n>o1</span><span class=o>);</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>num</span> <span class=o>:</span> <span class=n>nums</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>maxHeap</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>num</span><span class=o>);</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>maxHeap</span><span class=o>.</span><span class=na>size</span><span class=o>()</span> <span class=o>&gt;</span> <span class=n>k</span><span class=o>)</span>
            <span class=n>maxHeap</span><span class=o>.</span><span class=na>poll</span><span class=o>();</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;(</span><span class=n>maxHeap</span><span class=o>);</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="411">41.1 数据流中的中位数<a class="headerlink" href="#411" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&amp;tqId=11216&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=cm>/* 大顶堆，存储左半边元素 */</span>
<span class=kd>private</span> <span class=n>PriorityQueue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>left</span> <span class=o>=</span> <span class=k>new</span> <span class=n>PriorityQueue</span><span class=o>&lt;&gt;((</span><span class=n>o1</span><span class=o>,</span> <span class=n>o2</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>o2</span> <span class=o>-</span> <span class=n>o1</span><span class=o>);</span>
<span class=cm>/* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */</span>
<span class=kd>private</span> <span class=n>PriorityQueue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>right</span> <span class=o>=</span> <span class=k>new</span> <span class=n>PriorityQueue</span><span class=o>&lt;&gt;();</span>
<span class=cm>/* 当前数据流读入的元素个数 */</span>
<span class=kd>private</span> <span class=kt>int</span> <span class=n>N</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>

<span class=kd>public</span> <span class=kt>void</span> <span class=nf>Insert</span><span class=o>(</span><span class=n>Integer</span> <span class=n>val</span><span class=o>)</span> <span class=o>{</span>
    <span class=cm>/* 插入要保证两个堆存于平衡状态 */</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>N</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span> <span class=o>{</span>
        <span class=cm>/* N 为偶数的情况下插入到右半边。</span>
<span class=cm>         * 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素来的大，</span>
<span class=cm>         * 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆顶元素即为最大元素，此时插入右半边 */</span>
        <span class=n>left</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>val</span><span class=o>);</span>
        <span class=n>right</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>left</span><span class=o>.</span><span class=na>poll</span><span class=o>());</span>
    <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
        <span class=n>right</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>val</span><span class=o>);</span>
        <span class=n>left</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>right</span><span class=o>.</span><span class=na>poll</span><span class=o>());</span>
    <span class=o>}</span>
    <span class=n>N</span><span class=o>++;</span>
<span class=o>}</span>

<span class=kd>public</span> <span class=n>Double</span> <span class=nf>GetMedian</span><span class=o>()</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>N</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=o>(</span><span class=n>left</span><span class=o>.</span><span class=na>peek</span><span class=o>()</span> <span class=o>+</span> <span class=n>right</span><span class=o>.</span><span class=na>peek</span><span class=o>())</span> <span class=o>/</span> <span class=mf>2.0</span><span class=o>;</span>
    <span class=k>else</span>
        <span class=k>return</span> <span class=o>(</span><span class=kt>double</span><span class=o>)</span> <span class=n>right</span><span class=o>.</span><span class=na>peek</span><span class=o>();</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="412">41.2 字符流中第一个不重复的字符<a class="headerlink" href="#412" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&amp;tqId=11207&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 "go" 时，第一个只出现一次的字符是 "g"。当从该字符流中读出前六个字符“google" 时，第一个只出现一次的字符是 "l"。</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>private</span> <span class=kt>int</span><span class=o>[]</span> <span class=n>cnts</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=mi>256</span><span class=o>];</span>
<span class=kd>private</span> <span class=n>Queue</span><span class=o>&lt;</span><span class=n>Character</span><span class=o>&gt;</span> <span class=n>queue</span> <span class=o>=</span> <span class=k>new</span> <span class=n>LinkedList</span><span class=o>&lt;&gt;();</span>

<span class=kd>public</span> <span class=kt>void</span> <span class=nf>Insert</span><span class=o>(</span><span class=kt>char</span> <span class=n>ch</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>cnts</span><span class=o>[</span><span class=n>ch</span><span class=o>]++;</span>
    <span class=n>queue</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>ch</span><span class=o>);</span>
    <span class=k>while</span> <span class=o>(!</span><span class=n>queue</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>()</span> <span class=o>&amp;&amp;</span> <span class=n>cnts</span><span class=o>[</span><span class=n>queue</span><span class=o>.</span><span class=na>peek</span><span class=o>()]</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=o>)</span>
        <span class=n>queue</span><span class=o>.</span><span class=na>poll</span><span class=o>();</span>
<span class=o>}</span>

<span class=kd>public</span> <span class=kt>char</span> <span class=nf>FirstAppearingOnce</span><span class=o>()</span> <span class=o>{</span>
    <span class=k>return</span> <span class=n>queue</span><span class=o>.</span><span class=na>isEmpty</span><span class=o>()</span> <span class=o>?</span> <span class=sc>&#39;#&#39;</span> <span class=o>:</span> <span class=n>queue</span><span class=o>.</span><span class=na>peek</span><span class=o>();</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="42">42. 连续子数组的最大和<a class="headerlink" href="#42" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&amp;tqId=11183&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>{6, -3, -2, 7, -15, 1, 2, 2}，连续子数组的最大和为 8（从第 0 个开始，到第 3 个为止）。</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>FindGreatestSumOfSubArray</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>nums</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>nums</span><span class=o>.</span><span class=na>length</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>greatestSum</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>.</span><span class=na>MIN_VALUE</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>val</span> <span class=o>:</span> <span class=n>nums</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>sum</span> <span class=o>=</span> <span class=n>sum</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=o>?</span> <span class=n>val</span> <span class=o>:</span> <span class=n>sum</span> <span class=o>+</span> <span class=n>val</span><span class=o>;</span>
        <span class=n>greatestSum</span> <span class=o>=</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>greatestSum</span><span class=o>,</span> <span class=n>sum</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>greatestSum</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="43-1-n-1">43. 从 1 到 n 整数中 1 出现的次数<a class="headerlink" href="#43-1-n-1" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&amp;tqId=11184&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>NumberOf1Between1AndN_Solution</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>m</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=o>;</span> <span class=n>m</span> <span class=o>*=</span> <span class=mi>10</span><span class=o>)</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=n>n</span> <span class=o>/</span> <span class=n>m</span><span class=o>,</span> <span class=n>b</span> <span class=o>=</span> <span class=n>n</span> <span class=o>%</span> <span class=n>m</span><span class=o>;</span>
        <span class=n>cnt</span> <span class=o>+=</span> <span class=o>(</span><span class=n>a</span> <span class=o>+</span> <span class=mi>8</span><span class=o>)</span> <span class=o>/</span> <span class=mi>10</span> <span class=o>*</span> <span class=n>m</span> <span class=o>+</span> <span class=o>(</span><span class=n>a</span> <span class=o>%</span> <span class=mi>10</span> <span class=o>==</span> <span class=mi>1</span> <span class=o>?</span> <span class=n>b</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>:</span> <span class=mi>0</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>cnt</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<blockquote>
<p><a href="https://leetcode.com/problems/number-of-digit-one/discuss/64381/4+-lines-O(log-n)-C++JavaPython">Leetcode : 233. Number of Digit One</a></p>
</blockquote>
<h3 id="44">44. 数字序列中的某一位数字<a class="headerlink" href="#44" title="Permanent link">&para;</a></h3>
<p><hh>题目描述</hh></p>
<p>数字以 0123456789101112131415... 的格式序列化到一个字符串中，求这个字符串的第 index 位。</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>getDigitAtIndex</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>place</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>  <span class=c1>// 1 表示个位，2 表示 十位...</span>
    <span class=k>while</span> <span class=o>(</span><span class=kc>true</span><span class=o>)</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>amount</span> <span class=o>=</span> <span class=n>getAmountOfPlace</span><span class=o>(</span><span class=n>place</span><span class=o>);</span>
        <span class=kt>int</span> <span class=n>totalAmount</span> <span class=o>=</span> <span class=n>amount</span> <span class=o>*</span> <span class=n>place</span><span class=o>;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=n>totalAmount</span><span class=o>)</span>
            <span class=k>return</span> <span class=n>getDigitAtIndex</span><span class=o>(</span><span class=n>index</span><span class=o>,</span> <span class=n>place</span><span class=o>);</span>
        <span class=n>index</span> <span class=o>-=</span> <span class=n>totalAmount</span><span class=o>;</span>
        <span class=n>place</span><span class=o>++;</span>
    <span class=o>}</span>
<span class=o>}</span>

<span class=cm>/**</span>
<span class=cm> * place 位数的数字组成的字符串长度</span>
<span class=cm> * 10, 90, 900, ...</span>
<span class=cm> */</span>
<span class=kd>private</span> <span class=kt>int</span> <span class=nf>getAmountOfPlace</span><span class=o>(</span><span class=kt>int</span> <span class=n>place</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>place</span> <span class=o>==</span> <span class=mi>1</span><span class=o>)</span>
        <span class=k>return</span> <span class=mi>10</span><span class=o>;</span>
    <span class=k>return</span> <span class=o>(</span><span class=kt>int</span><span class=o>)</span> <span class=n>Math</span><span class=o>.</span><span class=na>pow</span><span class=o>(</span><span class=mi>10</span><span class=o>,</span> <span class=n>place</span> <span class=o>-</span> <span class=mi>1</span><span class=o>)</span> <span class=o>*</span> <span class=mi>9</span><span class=o>;</span>
<span class=o>}</span>

<span class=cm>/**</span>
<span class=cm> * place 位数的起始数字</span>
<span class=cm> * 0, 10, 100, ...</span>
<span class=cm> */</span>
<span class=kd>private</span> <span class=kt>int</span> <span class=nf>getBeginNumberOfPlace</span><span class=o>(</span><span class=kt>int</span> <span class=n>place</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>place</span> <span class=o>==</span> <span class=mi>1</span><span class=o>)</span>
        <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>return</span> <span class=o>(</span><span class=kt>int</span><span class=o>)</span> <span class=n>Math</span><span class=o>.</span><span class=na>pow</span><span class=o>(</span><span class=mi>10</span><span class=o>,</span> <span class=n>place</span> <span class=o>-</span> <span class=mi>1</span><span class=o>);</span>
<span class=o>}</span>

<span class=cm>/**</span>
<span class=cm> * 在 place 位数组成的字符串中，第 index 个数</span>
<span class=cm> */</span>
<span class=kd>private</span> <span class=kt>int</span> <span class=nf>getDigitAtIndex</span><span class=o>(</span><span class=kt>int</span> <span class=n>index</span><span class=o>,</span> <span class=kt>int</span> <span class=n>place</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>beginNumber</span> <span class=o>=</span> <span class=n>getBeginNumberOfPlace</span><span class=o>(</span><span class=n>place</span><span class=o>);</span>
    <span class=kt>int</span> <span class=n>shiftNumber</span> <span class=o>=</span> <span class=n>index</span> <span class=o>/</span> <span class=n>place</span><span class=o>;</span>
    <span class=n>String</span> <span class=n>number</span> <span class=o>=</span> <span class=o>(</span><span class=n>beginNumber</span> <span class=o>+</span> <span class=n>shiftNumber</span><span class=o>)</span> <span class=o>+</span> <span class=s>&quot;&quot;</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=n>index</span> <span class=o>%</span> <span class=n>place</span><span class=o>;</span>
    <span class=k>return</span> <span class=n>number</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>count</span><span class=o>)</span> <span class=o>-</span> <span class=sc>&#39;0&#39;</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="45">45. 把数组排成最小的数<a class="headerlink" href="#45" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&amp;tqId=11185&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。</p>
<p><hh>解题思路</hh></p>
<p>可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 &lt; S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>String</span> <span class=nf>PrintMinNumber</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>numbers</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>numbers</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>numbers</span><span class=o>.</span><span class=na>length</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=s>&quot;&quot;</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>numbers</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
    <span class=n>String</span><span class=o>[]</span> <span class=n>nums</span> <span class=o>=</span> <span class=k>new</span> <span class=n>String</span><span class=o>[</span><span class=n>n</span><span class=o>];</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>numbers</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>+</span> <span class=s>&quot;&quot;</span><span class=o>;</span>
    <span class=n>Arrays</span><span class=o>.</span><span class=na>sort</span><span class=o>(</span><span class=n>nums</span><span class=o>,</span> <span class=o>(</span><span class=n>s1</span><span class=o>,</span> <span class=n>s2</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>(</span><span class=n>s1</span> <span class=o>+</span> <span class=n>s2</span><span class=o>).</span><span class=na>compareTo</span><span class=o>(</span><span class=n>s2</span> <span class=o>+</span> <span class=n>s1</span><span class=o>));</span>
    <span class=n>String</span> <span class=n>ret</span> <span class=o>=</span> <span class=s>&quot;&quot;</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=n>String</span> <span class=n>str</span> <span class=o>:</span> <span class=n>nums</span><span class=o>)</span>
        <span class=n>ret</span> <span class=o>+=</span> <span class=n>str</span><span class=o>;</span>
    <span class=k>return</span> <span class=n>ret</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="46">46. 把数字翻译成字符串<a class="headerlink" href="#46" title="Permanent link">&para;</a></h3>
<p><a href="https://leetcode.com/problems/decode-ways/description/">Leetcode</a></p>
<p><hh>题目描述</hh></p>
<p>给定一个数字，按照如下规则翻译成字符串：0 翻译成“a”，1 翻译成“b”... 25 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 bccfi，bwfi，bczi，mcfi，mzi。实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>numDecodings</span><span class=o>(</span><span class=n>String</span> <span class=n>s</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>s</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>s</span><span class=o>.</span><span class=na>length</span><span class=o>()</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>s</span><span class=o>.</span><span class=na>length</span><span class=o>();</span>
    <span class=kt>int</span><span class=o>[]</span> <span class=n>dp</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=o>];</span>
    <span class=n>dp</span><span class=o>[</span><span class=mi>0</span><span class=o>]</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>
    <span class=n>dp</span><span class=o>[</span><span class=mi>1</span><span class=o>]</span> <span class=o>=</span> <span class=n>s</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=mi>0</span><span class=o>)</span> <span class=o>==</span> <span class=sc>&#39;0&#39;</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=mi>1</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>one</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>.</span><span class=na>valueOf</span><span class=o>(</span><span class=n>s</span><span class=o>.</span><span class=na>substring</span><span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=o>,</span> <span class=n>i</span><span class=o>));</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>one</span> <span class=o>!=</span> <span class=mi>0</span><span class=o>)</span>
            <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>+=</span> <span class=n>dp</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=o>];</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>s</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=mi>2</span><span class=o>)</span> <span class=o>==</span> <span class=sc>&#39;0&#39;</span><span class=o>)</span>
            <span class=k>continue</span><span class=o>;</span>
        <span class=kt>int</span> <span class=n>two</span> <span class=o>=</span> <span class=n>Integer</span><span class=o>.</span><span class=na>valueOf</span><span class=o>(</span><span class=n>s</span><span class=o>.</span><span class=na>substring</span><span class=o>(</span><span class=n>i</span> <span class=o>-</span> <span class=mi>2</span><span class=o>,</span> <span class=n>i</span><span class=o>));</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>two</span> <span class=o>&lt;=</span> <span class=mi>26</span><span class=o>)</span>
            <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>+=</span> <span class=n>dp</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>2</span><span class=o>];</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>dp</span><span class=o>[</span><span class=n>n</span><span class=o>];</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="47">47. 礼物的最大价值<a class="headerlink" href="#47" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/questionTerminal/72a99e28381a407991f2c96d8cb238ab">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>在一个 m*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘</p>
<p> <div class=codehilite><pre>1    10   3    8
12   2    9    6
5    7    4    11
3    7    16   5
</pre></div></p>
<p>礼物的最大价值为 1+12+5+7+7+16+5=53。</p>
<p><hh>解题思路</hh></p>
<p>应该用动态规划求解，而不是深度优先搜索，深度优先搜索过于复杂，不是最优解。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>getMost</span><span class=o>(</span><span class=kt>int</span><span class=o>[][]</span> <span class=n>values</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>values</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>values</span><span class=o>.</span><span class=na>length</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>values</span><span class=o>[</span><span class=mi>0</span><span class=o>].</span><span class=na>length</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>values</span><span class=o>[</span><span class=mi>0</span><span class=o>].</span><span class=na>length</span><span class=o>;</span>
    <span class=kt>int</span><span class=o>[]</span> <span class=n>dp</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>n</span><span class=o>];</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>value</span> <span class=o>:</span> <span class=n>values</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>dp</span><span class=o>[</span><span class=mi>0</span><span class=o>]</span> <span class=o>+=</span> <span class=n>value</span><span class=o>[</span><span class=mi>0</span><span class=o>];</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
            <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>],</span> <span class=n>dp</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=o>])</span> <span class=o>+</span> <span class=n>value</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>dp</span><span class=o>[</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=o>];</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="48">48. 最长不含重复字符的子字符串<a class="headerlink" href="#48" title="Permanent link">&para;</a></h3>
<p><hh>题目描述</hh></p>
<p>输入一个字符串（只包含 a\~z 的字符），求其最长不含重复字符的子字符串的长度。例如对于 arabcacfr，最长不含重复字符的子字符串为 acfr，长度为 4。</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>longestSubStringWithoutDuplication</span><span class=o>(</span><span class=n>String</span> <span class=n>str</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>curLen</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>maxLen</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=kt>int</span><span class=o>[]</span> <span class=n>preIndexs</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=mi>26</span><span class=o>];</span>
    <span class=n>Arrays</span><span class=o>.</span><span class=na>fill</span><span class=o>(</span><span class=n>preIndexs</span><span class=o>,</span> <span class=o>-</span><span class=mi>1</span><span class=o>);</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>curI</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>curI</span> <span class=o>&lt;</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>();</span> <span class=n>curI</span><span class=o>++)</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>c</span> <span class=o>=</span> <span class=n>str</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>curI</span><span class=o>)</span> <span class=o>-</span> <span class=sc>&#39;a&#39;</span><span class=o>;</span>
        <span class=kt>int</span> <span class=n>preI</span> <span class=o>=</span> <span class=n>preIndexs</span><span class=o>[</span><span class=n>c</span><span class=o>];</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>preI</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=o>||</span> <span class=n>curI</span> <span class=o>-</span> <span class=n>preI</span> <span class=o>&gt;</span> <span class=n>curLen</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>curLen</span><span class=o>++;</span>
        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
            <span class=n>maxLen</span> <span class=o>=</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>maxLen</span><span class=o>,</span> <span class=n>curLen</span><span class=o>);</span>
            <span class=n>curLen</span> <span class=o>=</span> <span class=n>curI</span> <span class=o>-</span> <span class=n>preI</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=n>preIndexs</span><span class=o>[</span><span class=n>c</span><span class=o>]</span> <span class=o>=</span> <span class=n>curI</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=n>maxLen</span> <span class=o>=</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>maxLen</span><span class=o>,</span> <span class=n>curLen</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>maxLen</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="49">49. 丑数<a class="headerlink" href="#49" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&amp;tqId=11186&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>GetUglyNumber_Solution</span><span class=o>(</span><span class=kt>int</span> <span class=n>N</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>N</span> <span class=o>&lt;=</span> <span class=mi>6</span><span class=o>)</span>
        <span class=k>return</span> <span class=n>N</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>i2</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>i3</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>i5</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=kt>int</span><span class=o>[]</span> <span class=n>dp</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>N</span><span class=o>];</span>
    <span class=n>dp</span><span class=o>[</span><span class=mi>0</span><span class=o>]</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>next2</span> <span class=o>=</span> <span class=n>dp</span><span class=o>[</span><span class=n>i2</span><span class=o>]</span> <span class=o>*</span> <span class=mi>2</span><span class=o>,</span> <span class=n>next3</span> <span class=o>=</span> <span class=n>dp</span><span class=o>[</span><span class=n>i3</span><span class=o>]</span> <span class=o>*</span> <span class=mi>3</span><span class=o>,</span> <span class=n>next5</span> <span class=o>=</span> <span class=n>dp</span><span class=o>[</span><span class=n>i5</span><span class=o>]</span> <span class=o>*</span> <span class=mi>5</span><span class=o>;</span>
        <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>Math</span><span class=o>.</span><span class=na>min</span><span class=o>(</span><span class=n>next2</span><span class=o>,</span> <span class=n>Math</span><span class=o>.</span><span class=na>min</span><span class=o>(</span><span class=n>next3</span><span class=o>,</span> <span class=n>next5</span><span class=o>));</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>==</span> <span class=n>next2</span><span class=o>)</span>
            <span class=n>i2</span><span class=o>++;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>==</span> <span class=n>next3</span><span class=o>)</span>
            <span class=n>i3</span><span class=o>++;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>==</span> <span class=n>next5</span><span class=o>)</span>
            <span class=n>i5</span><span class=o>++;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>dp</span><span class=o>[</span><span class=n>N</span> <span class=o>-</span> <span class=mi>1</span><span class=o>];</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="50">50. 第一个只出现一次的字符位置<a class="headerlink" href="#50" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&amp;tqId=11187&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>在一个字符串中找到第一个只出现一次的字符，并返回它的位置。</p>
<p><hh>解题思路</hh></p>
<p>最直观的解法是使用 HashMap 对出现次数进行统计，但是考虑到要统计的字符范围有限，因此可以使用整型数组代替 HashMap。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>FirstNotRepeatingChar</span><span class=o>(</span><span class=n>String</span> <span class=n>str</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span><span class=o>[]</span> <span class=n>cnts</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=mi>256</span><span class=o>];</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>();</span> <span class=n>i</span><span class=o>++)</span>
        <span class=n>cnts</span><span class=o>[</span><span class=n>str</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>i</span><span class=o>)]++;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>();</span> <span class=n>i</span><span class=o>++)</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>cnts</span><span class=o>[</span><span class=n>str</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>i</span><span class=o>)]</span> <span class=o>==</span> <span class=mi>1</span><span class=o>)</span>
            <span class=k>return</span> <span class=n>i</span><span class=o>;</span>
    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<p>以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>FirstNotRepeatingChar2</span><span class=o>(</span><span class=n>String</span> <span class=n>str</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>BitSet</span> <span class=n>bs1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BitSet</span><span class=o>(</span><span class=mi>256</span><span class=o>);</span>
    <span class=n>BitSet</span> <span class=n>bs2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BitSet</span><span class=o>(</span><span class=mi>256</span><span class=o>);</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>char</span> <span class=n>c</span> <span class=o>:</span> <span class=n>str</span><span class=o>.</span><span class=na>toCharArray</span><span class=o>())</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(!</span><span class=n>bs1</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>c</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>bs2</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>c</span><span class=o>))</span>
            <span class=n>bs1</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=n>c</span><span class=o>);</span>     <span class=c1>// 0 0 -&gt; 0 1</span>
        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>bs1</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>c</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>bs2</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>c</span><span class=o>))</span>
            <span class=n>bs2</span><span class=o>.</span><span class=na>set</span><span class=o>(</span><span class=n>c</span><span class=o>);</span>     <span class=c1>// 0 1 -&gt; 1 1</span>
    <span class=o>}</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>();</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=kt>char</span> <span class=n>c</span> <span class=o>=</span> <span class=n>str</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>i</span><span class=o>);</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>bs1</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>c</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>bs2</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>c</span><span class=o>))</span>  <span class=c1>// 0 1</span>
            <span class=k>return</span> <span class=n>i</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="51">51. 数组中的逆序对<a class="headerlink" href="#51" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=11188&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>private</span> <span class=kt>long</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
<span class=kd>private</span> <span class=kt>int</span><span class=o>[]</span> <span class=n>tmp</span><span class=o>;</span>  <span class=c1>// 在这里声明辅助数组，而不是在 merge() 递归函数中声明</span>

<span class=kd>public</span> <span class=kt>int</span> <span class=nf>InversePairs</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>tmp</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>nums</span><span class=o>.</span><span class=na>length</span><span class=o>];</span>
    <span class=n>mergeSort</span><span class=o>(</span><span class=n>nums</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>nums</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=o>);</span>
    <span class=k>return</span> <span class=o>(</span><span class=kt>int</span><span class=o>)</span> <span class=o>(</span><span class=n>cnt</span> <span class=o>%</span> <span class=mi>1000000007</span><span class=o>);</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>mergeSort</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>,</span> <span class=kt>int</span> <span class=n>l</span><span class=o>,</span> <span class=kt>int</span> <span class=n>h</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>h</span> <span class=o>-</span> <span class=n>l</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=o>)</span>
        <span class=k>return</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=n>l</span> <span class=o>+</span> <span class=o>(</span><span class=n>h</span> <span class=o>-</span> <span class=n>l</span><span class=o>)</span> <span class=o>/</span> <span class=mi>2</span><span class=o>;</span>
    <span class=n>mergeSort</span><span class=o>(</span><span class=n>nums</span><span class=o>,</span> <span class=n>l</span><span class=o>,</span> <span class=n>m</span><span class=o>);</span>
    <span class=n>mergeSort</span><span class=o>(</span><span class=n>nums</span><span class=o>,</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=o>,</span> <span class=n>h</span><span class=o>);</span>
    <span class=n>merge</span><span class=o>(</span><span class=n>nums</span><span class=o>,</span> <span class=n>l</span><span class=o>,</span> <span class=n>m</span><span class=o>,</span> <span class=n>h</span><span class=o>);</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>merge</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>,</span> <span class=kt>int</span> <span class=n>l</span><span class=o>,</span> <span class=kt>int</span> <span class=n>m</span><span class=o>,</span> <span class=kt>int</span> <span class=n>h</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>l</span><span class=o>,</span> <span class=n>j</span> <span class=o>=</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=o>,</span> <span class=n>k</span> <span class=o>=</span> <span class=n>l</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>i</span> <span class=o>&lt;=</span> <span class=n>m</span> <span class=o>||</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>h</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>i</span> <span class=o>&gt;</span> <span class=n>m</span><span class=o>)</span>
            <span class=n>tmp</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>j</span><span class=o>++];</span>
        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>j</span> <span class=o>&gt;</span> <span class=n>h</span><span class=o>)</span>
            <span class=n>tmp</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>++];</span>
        <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>&lt;</span> <span class=n>nums</span><span class=o>[</span><span class=n>j</span><span class=o>])</span>
            <span class=n>tmp</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>++];</span>
        <span class=k>else</span> <span class=o>{</span>
            <span class=n>tmp</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>nums</span><span class=o>[</span><span class=n>j</span><span class=o>++];</span>
            <span class=k>this</span><span class=o>.</span><span class=na>cnt</span> <span class=o>+=</span> <span class=n>m</span> <span class=o>-</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=o>;</span>  <span class=c1>// nums[i] &gt;= nums[j]，说明 nums[i...mid] 都大于 nums[j]</span>
        <span class=o>}</span>
        <span class=n>k</span><span class=o>++;</span>
    <span class=o>}</span>
    <span class=k>for</span> <span class=o>(</span><span class=n>k</span> <span class=o>=</span> <span class=n>l</span><span class=o>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>h</span><span class=o>;</span> <span class=n>k</span><span class=o>++)</span>
        <span class=n>nums</span><span class=o>[</span><span class=n>k</span><span class=o>]</span> <span class=o>=</span> <span class=n>tmp</span><span class=o>[</span><span class=n>k</span><span class=o>];</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="52">52. 两个链表的第一个公共结点<a class="headerlink" href="#52" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=11189&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<div align="center"> <img src="../pics//8f6f9dc9-9ecd-47c8-b50e-2814f0219056.png" width="500"/> </div>

<p><br></p>
<p><hh>解题思路</hh></p>
<p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p>
<p>当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ListNode</span> <span class=nf>FindFirstCommonNode</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>pHead1</span><span class=o>,</span> <span class=n>ListNode</span> <span class=n>pHead2</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>ListNode</span> <span class=n>l1</span> <span class=o>=</span> <span class=n>pHead1</span><span class=o>,</span> <span class=n>l2</span> <span class=o>=</span> <span class=n>pHead2</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>l1</span> <span class=o>!=</span> <span class=n>l2</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>l1</span> <span class=o>=</span> <span class=o>(</span><span class=n>l1</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>?</span> <span class=n>pHead2</span> <span class=o>:</span> <span class=n>l1</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
        <span class=n>l2</span> <span class=o>=</span> <span class=o>(</span><span class=n>l2</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>?</span> <span class=n>pHead1</span> <span class=o>:</span> <span class=n>l2</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>l1</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="53">53. 数字在排序数组中出现的次数<a class="headerlink" href="#53" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&amp;tqId=11190&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p> <div class=codehilite><pre>Input:
nums = 1, 2, 3, 3, 3, 3, 4, 6
K = 3

Output:
4
</pre></div></p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>GetNumberOfK</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>,</span> <span class=kt>int</span> <span class=n>K</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>first</span> <span class=o>=</span> <span class=n>binarySearch</span><span class=o>(</span><span class=n>nums</span><span class=o>,</span> <span class=n>K</span><span class=o>);</span>
    <span class=kt>int</span> <span class=n>last</span> <span class=o>=</span> <span class=n>binarySearch</span><span class=o>(</span><span class=n>nums</span><span class=o>,</span> <span class=n>K</span> <span class=o>+</span> <span class=mi>1</span><span class=o>);</span>
    <span class=k>return</span> <span class=o>(</span><span class=n>first</span> <span class=o>==</span> <span class=n>nums</span><span class=o>.</span><span class=na>length</span> <span class=o>||</span> <span class=n>nums</span><span class=o>[</span><span class=n>first</span><span class=o>]</span> <span class=o>!=</span> <span class=n>K</span><span class=o>)</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=n>last</span> <span class=o>-</span> <span class=n>first</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>int</span> <span class=nf>binarySearch</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>,</span> <span class=kt>int</span> <span class=n>K</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>l</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>h</span> <span class=o>=</span> <span class=n>nums</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>l</span> <span class=o>&lt;</span> <span class=n>h</span><span class=o>)</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=n>l</span> <span class=o>+</span> <span class=o>(</span><span class=n>h</span> <span class=o>-</span> <span class=n>l</span><span class=o>)</span> <span class=o>/</span> <span class=mi>2</span><span class=o>;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>nums</span><span class=o>[</span><span class=n>m</span><span class=o>]</span> <span class=o>&gt;=</span> <span class=n>K</span><span class=o>)</span>
            <span class=n>h</span> <span class=o>=</span> <span class=n>m</span><span class=o>;</span>
        <span class=k>else</span>
            <span class=n>l</span> <span class=o>=</span> <span class=n>m</span> <span class=o>+</span> <span class=mi>1</span><span class=o>;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>l</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="54-k">54. 二叉查找树的第 K 个结点<a class="headerlink" href="#54-k" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&amp;tqId=11215&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>解题思路</hh></p>
<p>利用二叉查找树中序遍历有序的特点。</p>
<p> <div class=codehilite><pre><span class=kd>private</span> <span class=n>TreeNode</span> <span class=n>ret</span><span class=o>;</span>
<span class=kd>private</span> <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>

<span class=kd>public</span> <span class=n>TreeNode</span> <span class=nf>KthNode</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>pRoot</span><span class=o>,</span> <span class=kt>int</span> <span class=n>k</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>inOrder</span><span class=o>(</span><span class=n>pRoot</span><span class=o>,</span> <span class=n>k</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>ret</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>inOrder</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>,</span> <span class=kt>int</span> <span class=n>k</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>cnt</span> <span class=o>&gt;=</span> <span class=n>k</span><span class=o>)</span>
        <span class=k>return</span><span class=o>;</span>
    <span class=n>inOrder</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>k</span><span class=o>);</span>
    <span class=n>cnt</span><span class=o>++;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>cnt</span> <span class=o>==</span> <span class=n>k</span><span class=o>)</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=n>root</span><span class=o>;</span>
    <span class=n>inOrder</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>k</span><span class=o>);</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="551">55.1 二叉树的深度<a class="headerlink" href="#551" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&amp;tqId=11191&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<div align="center"> <img src="../pics//b29f8971-9cb8-480d-b986-0e60c2ece069.png" width="350"/> </div>

<p><br></p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>TreeDepth</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>return</span> <span class=n>root</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=mi>1</span> <span class=o>+</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>TreeDepth</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>),</span> <span class=n>TreeDepth</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>));</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="552">55.2 平衡二叉树<a class="headerlink" href="#552" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&amp;tqId=11192&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>平衡二叉树左右子树高度差不超过 1。</p>
<div align="center"> <img src="../pics//e026c24d-00fa-4e7c-97a8-95a98cdc383a.png" width="300"/> </div>

<p><br></p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>private</span> <span class=kt>boolean</span> <span class=n>isBalanced</span> <span class=o>=</span> <span class=kc>true</span><span class=o>;</span>

<span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>IsBalanced_Solution</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>height</span><span class=o>(</span><span class=n>root</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>isBalanced</span><span class=o>;</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>int</span> <span class=nf>height</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=o>!</span><span class=n>isBalanced</span><span class=o>)</span>
        <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>left</span> <span class=o>=</span> <span class=n>height</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>);</span>
    <span class=kt>int</span> <span class=n>right</span> <span class=o>=</span> <span class=n>height</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>);</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>Math</span><span class=o>.</span><span class=na>abs</span><span class=o>(</span><span class=n>left</span> <span class=o>-</span> <span class=n>right</span><span class=o>)</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=o>)</span>
        <span class=n>isBalanced</span> <span class=o>=</span> <span class=kc>false</span><span class=o>;</span>
    <span class=k>return</span> <span class=mi>1</span> <span class=o>+</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>left</span><span class=o>,</span> <span class=n>right</span><span class=o>);</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="56">56. 数组中只出现一次的数字<a class="headerlink" href="#56" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&amp;tqId=11193&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次，找出这两个数。</p>
<p><hh>解题思路</hh></p>
<p>两个不相等的元素在位级表示上必定会有一位存在不同，将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。</p>
<p>diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>void</span> <span class=nf>FindNumsAppearOnce</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>,</span> <span class=kt>int</span> <span class=n>num1</span><span class=o>[],</span> <span class=kt>int</span> <span class=n>num2</span><span class=o>[])</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>diff</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>num</span> <span class=o>:</span> <span class=n>nums</span><span class=o>)</span>
        <span class=n>diff</span> <span class=o>^=</span> <span class=n>num</span><span class=o>;</span>
    <span class=n>diff</span> <span class=o>&amp;=</span> <span class=o>-</span><span class=n>diff</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>num</span> <span class=o>:</span> <span class=n>nums</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>((</span><span class=n>num</span> <span class=o>&amp;</span> <span class=n>diff</span><span class=o>)</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
            <span class=n>num1</span><span class=o>[</span><span class=mi>0</span><span class=o>]</span> <span class=o>^=</span> <span class=n>num</span><span class=o>;</span>
        <span class=k>else</span>
            <span class=n>num2</span><span class=o>[</span><span class=mi>0</span><span class=o>]</span> <span class=o>^=</span> <span class=n>num</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="571-s">57.1 和为 S 的两个数字<a class="headerlink" href="#571-s" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&amp;tqId=11195&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S。如果有多对数字的和等于 S，输出两个数的乘积最小的。</p>
<p><hh>解题思路</hh></p>
<p>使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p>
<ul>
<li>如果两个指针指向元素的和 sum == target，那么得到要求的结果；</li>
<li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li>
<li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li>
</ul>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>FindNumbersWithSum</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>array</span><span class=o>,</span> <span class=kt>int</span> <span class=n>sum</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>j</span> <span class=o>=</span> <span class=n>array</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>j</span><span class=o>)</span> <span class=o>{</span>
        <span class=kt>int</span> <span class=n>cur</span> <span class=o>=</span> <span class=n>array</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>+</span> <span class=n>array</span><span class=o>[</span><span class=n>j</span><span class=o>];</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>cur</span> <span class=o>==</span> <span class=n>sum</span><span class=o>)</span>
            <span class=k>return</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;(</span><span class=n>Arrays</span><span class=o>.</span><span class=na>asList</span><span class=o>(</span><span class=n>array</span><span class=o>[</span><span class=n>i</span><span class=o>],</span> <span class=n>array</span><span class=o>[</span><span class=n>j</span><span class=o>]));</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>cur</span> <span class=o>&lt;</span> <span class=n>sum</span><span class=o>)</span>
            <span class=n>i</span><span class=o>++;</span>
        <span class=k>else</span>
            <span class=n>j</span><span class=o>--;</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="572-s">57.2 和为 S 的连续正数序列<a class="headerlink" href="#572-s" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&amp;tqId=11194&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>输出所有和为 S 的连续正数序列。</p>
<p>例如和为 100 的连续序列有：</p>
<p> <div class=codehilite><pre><span class=k>[9, 10, 11, 12, 13, 14, 15, 16]</span>
<span class=err>[18,</span> <span class=err>19,</span> <span class=err>20,</span> <span class=err>21,</span> <span class=err>22]。</span>
</pre></div></p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=nf>FindContinuousSequence</span><span class=o>(</span><span class=kt>int</span> <span class=n>sum</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span> <span class=n>ret</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=kt>int</span> <span class=n>start</span> <span class=o>=</span> <span class=mi>1</span><span class=o>,</span> <span class=n>end</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>curSum</span> <span class=o>=</span> <span class=mi>3</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>end</span> <span class=o>&lt;</span> <span class=n>sum</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>curSum</span> <span class=o>&gt;</span> <span class=n>sum</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>curSum</span> <span class=o>-=</span> <span class=n>start</span><span class=o>;</span>
            <span class=n>start</span><span class=o>++;</span>
        <span class=o>}</span> <span class=k>else</span> <span class=k>if</span> <span class=o>(</span><span class=n>curSum</span> <span class=o>&lt;</span> <span class=n>sum</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>end</span><span class=o>++;</span>
            <span class=n>curSum</span> <span class=o>+=</span> <span class=n>end</span><span class=o>;</span>
        <span class=o>}</span> <span class=k>else</span> <span class=o>{</span>
            <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>start</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>end</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
                <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>i</span><span class=o>);</span>
            <span class=n>ret</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>list</span><span class=o>);</span>
            <span class=n>curSum</span> <span class=o>-=</span> <span class=n>start</span><span class=o>;</span>
            <span class=n>start</span><span class=o>++;</span>
            <span class=n>end</span><span class=o>++;</span>
            <span class=n>curSum</span> <span class=o>+=</span> <span class=n>end</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>ret</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="581">58.1 翻转单词顺序列<a class="headerlink" href="#581" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&amp;tqId=11197&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p> <div class=codehilite><pre>Input:
&quot;I am a student.&quot;

Output:
&quot;student. a am I&quot;
</pre></div></p>
<p><hh>解题思路</hh></p>
<p>题目应该有一个隐含条件，就是不能用额外的空间。虽然 Java 的题目输入参数为 String 类型，需要先创建一个字符数组使得空间复杂度为 O(N)，但是正确的参数类型应该和原书一样，为字符数组，并且只能使用该字符数组的空间。任何使用了额外空间的解法在面试时都会大打折扣，包括递归解法。</p>
<p>正确的解法应该是和书上一样，先旋转每个单词，再旋转整个字符串。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>String</span> <span class=nf>ReverseSentence</span><span class=o>(</span><span class=n>String</span> <span class=n>str</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>();</span>
    <span class=kt>char</span><span class=o>[]</span> <span class=n>chars</span> <span class=o>=</span> <span class=n>str</span><span class=o>.</span><span class=na>toCharArray</span><span class=o>();</span>
    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>j</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>j</span> <span class=o>==</span> <span class=n>n</span> <span class=o>||</span> <span class=n>chars</span><span class=o>[</span><span class=n>j</span><span class=o>]</span> <span class=o>==</span> <span class=sc>&#39; &#39;</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>reverse</span><span class=o>(</span><span class=n>chars</span><span class=o>,</span> <span class=n>i</span><span class=o>,</span> <span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=o>);</span>
            <span class=n>i</span> <span class=o>=</span> <span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=n>j</span><span class=o>++;</span>
    <span class=o>}</span>
    <span class=n>reverse</span><span class=o>(</span><span class=n>chars</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=o>);</span>
    <span class=k>return</span> <span class=k>new</span> <span class=n>String</span><span class=o>(</span><span class=n>chars</span><span class=o>);</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>reverse</span><span class=o>(</span><span class=kt>char</span><span class=o>[]</span> <span class=n>c</span><span class=o>,</span> <span class=kt>int</span> <span class=n>i</span><span class=o>,</span> <span class=kt>int</span> <span class=n>j</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>j</span><span class=o>)</span>
        <span class=n>swap</span><span class=o>(</span><span class=n>c</span><span class=o>,</span> <span class=n>i</span><span class=o>++,</span> <span class=n>j</span><span class=o>--);</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>swap</span><span class=o>(</span><span class=kt>char</span><span class=o>[]</span> <span class=n>c</span><span class=o>,</span> <span class=kt>int</span> <span class=n>i</span><span class=o>,</span> <span class=kt>int</span> <span class=n>j</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>char</span> <span class=n>t</span> <span class=o>=</span> <span class=n>c</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
    <span class=n>c</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>c</span><span class=o>[</span><span class=n>j</span><span class=o>];</span>
    <span class=n>c</span><span class=o>[</span><span class=n>j</span><span class=o>]</span> <span class=o>=</span> <span class=n>t</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="582">58.2 左旋转字符串<a class="headerlink" href="#582" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&amp;tqId=11196&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p> <div class=codehilite><pre>Input:
S=&quot;abcXYZdef&quot;
K=3

Output:
&quot;XYZdefabc&quot;
</pre></div></p>
<p><hh>解题思路</hh></p>
<p>先将 "abc" 和 "XYZdef" 分别翻转，得到 "cbafedZYX"，然后再把整个字符串翻转得到 "XYZdefabc"。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>String</span> <span class=nf>LeftRotateString</span><span class=o>(</span><span class=n>String</span> <span class=n>str</span><span class=o>,</span> <span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>&gt;=</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>())</span>
        <span class=k>return</span> <span class=n>str</span><span class=o>;</span>
    <span class=kt>char</span><span class=o>[]</span> <span class=n>chars</span> <span class=o>=</span> <span class=n>str</span><span class=o>.</span><span class=na>toCharArray</span><span class=o>();</span>
    <span class=n>reverse</span><span class=o>(</span><span class=n>chars</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=o>);</span>
    <span class=n>reverse</span><span class=o>(</span><span class=n>chars</span><span class=o>,</span> <span class=n>n</span><span class=o>,</span> <span class=n>chars</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=o>);</span>
    <span class=n>reverse</span><span class=o>(</span><span class=n>chars</span><span class=o>,</span> <span class=mi>0</span><span class=o>,</span> <span class=n>chars</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=o>);</span>
    <span class=k>return</span> <span class=k>new</span> <span class=n>String</span><span class=o>(</span><span class=n>chars</span><span class=o>);</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>reverse</span><span class=o>(</span><span class=kt>char</span><span class=o>[]</span> <span class=n>chars</span><span class=o>,</span> <span class=kt>int</span> <span class=n>i</span><span class=o>,</span> <span class=kt>int</span> <span class=n>j</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>while</span> <span class=o>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>j</span><span class=o>)</span>
        <span class=n>swap</span><span class=o>(</span><span class=n>chars</span><span class=o>,</span> <span class=n>i</span><span class=o>++,</span> <span class=n>j</span><span class=o>--);</span>
<span class=o>}</span>

<span class=kd>private</span> <span class=kt>void</span> <span class=nf>swap</span><span class=o>(</span><span class=kt>char</span><span class=o>[]</span> <span class=n>chars</span><span class=o>,</span> <span class=kt>int</span> <span class=n>i</span><span class=o>,</span> <span class=kt>int</span> <span class=n>j</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>char</span> <span class=n>t</span> <span class=o>=</span> <span class=n>chars</span><span class=o>[</span><span class=n>i</span><span class=o>];</span>
    <span class=n>chars</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>chars</span><span class=o>[</span><span class=n>j</span><span class=o>];</span>
    <span class=n>chars</span><span class=o>[</span><span class=n>j</span><span class=o>]</span> <span class=o>=</span> <span class=n>t</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="59">59. 滑动窗口的最大值<a class="headerlink" href="#59" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&amp;tqId=11217&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。</p>
<p>例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}。</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=nf>maxInWindows</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>num</span><span class=o>,</span> <span class=kt>int</span> <span class=n>size</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>ret</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>size</span> <span class=o>&gt;</span> <span class=n>num</span><span class=o>.</span><span class=na>length</span> <span class=o>||</span> <span class=n>size</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=o>)</span>
        <span class=k>return</span> <span class=n>ret</span><span class=o>;</span>
    <span class=n>PriorityQueue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>heap</span> <span class=o>=</span> <span class=k>new</span> <span class=n>PriorityQueue</span><span class=o>&lt;&gt;((</span><span class=n>o1</span><span class=o>,</span> <span class=n>o2</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=n>o2</span> <span class=o>-</span> <span class=n>o1</span><span class=o>);</span>  <span class=cm>/* 大顶堆 */</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=n>heap</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>num</span><span class=o>[</span><span class=n>i</span><span class=o>]);</span>
    <span class=n>ret</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>heap</span><span class=o>.</span><span class=na>peek</span><span class=o>());</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=n>size</span><span class=o>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>num</span><span class=o>.</span><span class=na>length</span><span class=o>;</span> <span class=n>i</span><span class=o>++,</span> <span class=n>j</span><span class=o>++)</span> <span class=o>{</span>            <span class=cm>/* 维护一个大小为 size 的大顶堆 */</span>
        <span class=n>heap</span><span class=o>.</span><span class=na>remove</span><span class=o>(</span><span class=n>num</span><span class=o>[</span><span class=n>i</span><span class=o>]);</span>
        <span class=n>heap</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>num</span><span class=o>[</span><span class=n>j</span><span class=o>]);</span>
        <span class=n>ret</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>heap</span><span class=o>.</span><span class=na>peek</span><span class=o>());</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>ret</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="60-n">60. n 个骰子的点数<a class="headerlink" href="#60-n" title="Permanent link">&para;</a></h3>
<p><a href="https://www.lintcode.com/en/problem/dices-sum/">Lintcode</a></p>
<p><hh>题目描述</hh></p>
<p>把 n 个骰子仍在地上，求点数和为 s 的概率。</p>
<h4 id="_13">动态规划解法<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h4>
<p>使用一个二维数组 dp 存储点数出现的次数，其中 dp[i][j] 表示前 i 个骰子产生点数 j 的次数。</p>
<p>空间复杂度：O(N<sup>2</sup>)</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>Map</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Double</span><span class=o>&gt;&gt;</span> <span class=nf>dicesSum</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
    <span class=kd>final</span> <span class=kt>int</span> <span class=n>face</span> <span class=o>=</span> <span class=mi>6</span><span class=o>;</span>
    <span class=kd>final</span> <span class=kt>int</span> <span class=n>pointNum</span> <span class=o>=</span> <span class=n>face</span> <span class=o>*</span> <span class=n>n</span><span class=o>;</span>
    <span class=kt>long</span><span class=o>[][]</span> <span class=n>dp</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>long</span><span class=o>[</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=o>][</span><span class=n>pointNum</span> <span class=o>+</span> <span class=mi>1</span><span class=o>];</span>

    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>face</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=n>dp</span><span class=o>[</span><span class=mi>1</span><span class=o>][</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>

    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span><span class=o>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>pointNum</span><span class=o>;</span> <span class=n>j</span><span class=o>++)</span>     <span class=cm>/* 使用 i 个骰子最小点数为 i */</span>
            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>face</span> <span class=o>&amp;&amp;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>j</span><span class=o>;</span> <span class=n>k</span><span class=o>++)</span>
                <span class=n>dp</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>j</span><span class=o>]</span> <span class=o>+=</span> <span class=n>dp</span><span class=o>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=o>][</span><span class=n>j</span> <span class=o>-</span> <span class=n>k</span><span class=o>];</span>

    <span class=kd>final</span> <span class=kt>double</span> <span class=n>totalNum</span> <span class=o>=</span> <span class=n>Math</span><span class=o>.</span><span class=na>pow</span><span class=o>(</span><span class=mi>6</span><span class=o>,</span> <span class=n>n</span><span class=o>);</span>
    <span class=n>List</span><span class=o>&lt;</span><span class=n>Map</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Double</span><span class=o>&gt;&gt;</span> <span class=n>ret</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>n</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>pointNum</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=n>ret</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>AbstractMap</span><span class=o>.</span><span class=na>SimpleEntry</span><span class=o>&lt;&gt;(</span><span class=n>i</span><span class=o>,</span> <span class=n>dp</span><span class=o>[</span><span class=n>n</span><span class=o>][</span><span class=n>i</span><span class=o>]</span> <span class=o>/</span> <span class=n>totalNum</span><span class=o>));</span>

    <span class=k>return</span> <span class=n>ret</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="_14">动态规划解法 + 旋转数组<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h3>
<p>空间复杂度：O(N)</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>Map</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Double</span><span class=o>&gt;&gt;</span> <span class=nf>dicesSum</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
    <span class=kd>final</span> <span class=kt>int</span> <span class=n>face</span> <span class=o>=</span> <span class=mi>6</span><span class=o>;</span>
    <span class=kd>final</span> <span class=kt>int</span> <span class=n>pointNum</span> <span class=o>=</span> <span class=n>face</span> <span class=o>*</span> <span class=n>n</span><span class=o>;</span>
    <span class=kt>long</span><span class=o>[][]</span> <span class=n>dp</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>long</span><span class=o>[</span><span class=mi>2</span><span class=o>][</span><span class=n>pointNum</span> <span class=o>+</span> <span class=mi>1</span><span class=o>];</span>

    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>face</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=n>dp</span><span class=o>[</span><span class=mi>0</span><span class=o>][</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>

    <span class=kt>int</span> <span class=n>flag</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>                                     <span class=cm>/* 旋转标记 */</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=o>;</span> <span class=n>i</span><span class=o>++,</span> <span class=n>flag</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>-</span> <span class=n>flag</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>pointNum</span><span class=o>;</span> <span class=n>j</span><span class=o>++)</span>
            <span class=n>dp</span><span class=o>[</span><span class=n>flag</span><span class=o>][</span><span class=n>j</span><span class=o>]</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>                          <span class=cm>/* 旋转数组清零 */</span>

        <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span><span class=o>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>pointNum</span><span class=o>;</span> <span class=n>j</span><span class=o>++)</span>
            <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>face</span> <span class=o>&amp;&amp;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>j</span><span class=o>;</span> <span class=n>k</span><span class=o>++)</span>
                <span class=n>dp</span><span class=o>[</span><span class=n>flag</span><span class=o>][</span><span class=n>j</span><span class=o>]</span> <span class=o>+=</span> <span class=n>dp</span><span class=o>[</span><span class=mi>1</span> <span class=o>-</span> <span class=n>flag</span><span class=o>][</span><span class=n>j</span> <span class=o>-</span> <span class=n>k</span><span class=o>];</span>
    <span class=o>}</span>

    <span class=kd>final</span> <span class=kt>double</span> <span class=n>totalNum</span> <span class=o>=</span> <span class=n>Math</span><span class=o>.</span><span class=na>pow</span><span class=o>(</span><span class=mi>6</span><span class=o>,</span> <span class=n>n</span><span class=o>);</span>
    <span class=n>List</span><span class=o>&lt;</span><span class=n>Map</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>,</span> <span class=n>Double</span><span class=o>&gt;&gt;</span> <span class=n>ret</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>n</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>pointNum</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span>
        <span class=n>ret</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>AbstractMap</span><span class=o>.</span><span class=na>SimpleEntry</span><span class=o>&lt;&gt;(</span><span class=n>i</span><span class=o>,</span> <span class=n>dp</span><span class=o>[</span><span class=mi>1</span> <span class=o>-</span> <span class=n>flag</span><span class=o>][</span><span class=n>i</span><span class=o>]</span> <span class=o>/</span> <span class=n>totalNum</span><span class=o>));</span>

    <span class=k>return</span> <span class=n>ret</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="61">61. 扑克牌顺子<a class="headerlink" href="#61" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&amp;tqId=11198&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>五张牌，其中大小鬼为癞子，牌面大小为 0。判断这五张牌是否能组成顺子。</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>isContinuous</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>nums</span><span class=o>)</span> <span class=o>{</span>

    <span class=k>if</span> <span class=o>(</span><span class=n>nums</span><span class=o>.</span><span class=na>length</span> <span class=o>&lt;</span> <span class=mi>5</span><span class=o>)</span>
        <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>

    <span class=n>Arrays</span><span class=o>.</span><span class=na>sort</span><span class=o>(</span><span class=n>nums</span><span class=o>);</span>

    <span class=c1>// 统计癞子数量</span>
    <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>num</span> <span class=o>:</span> <span class=n>nums</span><span class=o>)</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>num</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
            <span class=n>cnt</span><span class=o>++;</span>

    <span class=c1>// 使用癞子去补全不连续的顺子</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>cnt</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nums</span><span class=o>.</span><span class=na>length</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>nums</span><span class=o>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=o>]</span> <span class=o>==</span> <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>])</span>
            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
        <span class=n>cnt</span> <span class=o>-=</span> <span class=n>nums</span><span class=o>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=o>]</span> <span class=o>-</span> <span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>-</span> <span class=mi>1</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=k>return</span> <span class=n>cnt</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="62">62. 圆圈中最后剩下的数<a class="headerlink" href="#62" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>让小朋友们围成一个大圈。然后，随机指定一个数 m，让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续 0...m-1 报数 .... 这样下去 .... 直到剩下最后一个小朋友，可以不用表演。</p>
<p><hh>解题思路</hh></p>
<p>约瑟夫环，圆圈长度为 n 的解可以看成长度为 n-1 的解再加上报数的长度 m。因为是圆圈，所以最后需要对 n 取余。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>LastRemaining_Solution</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>,</span> <span class=kt>int</span> <span class=n>m</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>     <span class=cm>/* 特殊输入的处理 */</span>
        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=o>)</span>     <span class=cm>/* 递归返回条件 */</span>
        <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>return</span> <span class=o>(</span><span class=n>LastRemaining_Solution</span><span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=o>,</span> <span class=n>m</span><span class=o>)</span> <span class=o>+</span> <span class=n>m</span><span class=o>)</span> <span class=o>%</span> <span class=n>n</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="63">63. 股票的最大利润<a class="headerlink" href="#63" title="Permanent link">&para;</a></h3>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/">Leetcode</a></p>
<p><hh>题目描述</hh></p>
<p>可以有一次买入和一次卖出，那么买入必须在前。求最大收益。</p>
<p><hh>解题思路</hh></p>
<p>使用贪心策略，假设第 i 轮进行卖出操作，买入操作价格应该在 i 之前并且价格最低。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>maxProfit</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>prices</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>prices</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>prices</span><span class=o>.</span><span class=na>length</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>soFarMin</span> <span class=o>=</span> <span class=n>prices</span><span class=o>[</span><span class=mi>0</span><span class=o>];</span>
    <span class=kt>int</span> <span class=n>maxProfit</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>prices</span><span class=o>.</span><span class=na>length</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=n>soFarMin</span> <span class=o>=</span> <span class=n>Math</span><span class=o>.</span><span class=na>min</span><span class=o>(</span><span class=n>soFarMin</span><span class=o>,</span> <span class=n>prices</span><span class=o>[</span><span class=n>i</span><span class=o>]);</span>
        <span class=n>maxProfit</span> <span class=o>=</span> <span class=n>Math</span><span class=o>.</span><span class=na>max</span><span class=o>(</span><span class=n>maxProfit</span><span class=o>,</span> <span class=n>prices</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>-</span> <span class=n>soFarMin</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>maxProfit</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="64-123n">64. 求 1+2+3+...+n<a class="headerlink" href="#64-123n" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&amp;tqId=11200&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句 A ? B : C。</p>
<p><hh>解题思路</hh></p>
<p>使用递归解法最重要的是指定返回条件，但是本题无法直接使用 if 语句来指定返回条件。</p>
<p>条件与 &amp;&amp; 具有短路原则，即在第一个条件语句为 false 的情况下不会去执行第二个条件语句。利用这一特性，将递归的返回条件取非然后作为 &amp;&amp; 的第一个条件语句，递归的主体转换为第二个条件语句，那么当递归的返回条件为 true 的情况下就不会执行递归的主体部分，递归返回。</p>
<p>本题的递归返回条件为 n &lt;= 0，取非后就是 n &gt; 0；递归的主体部分为 sum += Sum_Solution(n - 1)，转换为条件语句后就是 (sum += Sum_Solution(n - 1)) &gt; 0。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>Sum_Solution</span><span class=o>(</span><span class=kt>int</span> <span class=n>n</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=n>n</span><span class=o>;</span>
    <span class=kt>boolean</span> <span class=n>b</span> <span class=o>=</span> <span class=o>(</span><span class=n>n</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>)</span> <span class=o>&amp;&amp;</span> <span class=o>((</span><span class=n>sum</span> <span class=o>+=</span> <span class=n>Sum_Solution</span><span class=o>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=o>))</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>sum</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="65">65. 不用加减乘除做加法<a class="headerlink" href="#65" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&amp;tqId=11201&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>写一个函数，求两个整数之和，要求不得使用 +、-、*、/ 四则运算符号。</p>
<p><hh>解题思路</hh></p>
<p>a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。</p>
<p>递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>Add</span><span class=o>(</span><span class=kt>int</span> <span class=n>a</span><span class=o>,</span> <span class=kt>int</span> <span class=n>b</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>return</span> <span class=n>b</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>?</span> <span class=n>a</span> <span class=o>:</span> <span class=n>Add</span><span class=o>(</span><span class=n>a</span> <span class=o>^</span> <span class=n>b</span><span class=o>,</span> <span class=o>(</span><span class=n>a</span> <span class=o>&amp;</span> <span class=n>b</span><span class=o>)</span> <span class=o>&lt;&lt;</span> <span class=mi>1</span><span class=o>);</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="66">66. 构建乘积数组<a class="headerlink" href="#66" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&amp;tqId=11204&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>给定一个数组 A[0, 1,..., n-1]，请构建一个数组 B[0, 1,..., n-1]，其中 B 中的元素 B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。要求不能使用除法。</p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span><span class=o>[]</span> <span class=nf>multiply</span><span class=o>(</span><span class=kt>int</span><span class=o>[]</span> <span class=n>A</span><span class=o>)</span> <span class=o>{</span>
    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>A</span><span class=o>.</span><span class=na>length</span><span class=o>;</span>
    <span class=kt>int</span><span class=o>[]</span> <span class=n>B</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=o>[</span><span class=n>n</span><span class=o>];</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>,</span> <span class=n>product</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=o>;</span> <span class=n>product</span> <span class=o>*=</span> <span class=n>A</span><span class=o>[</span><span class=n>i</span><span class=o>],</span> <span class=n>i</span><span class=o>++)</span>       <span class=cm>/* 从左往右累乘 */</span>
        <span class=n>B</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>=</span> <span class=n>product</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=o>,</span> <span class=n>product</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>product</span> <span class=o>*=</span> <span class=n>A</span><span class=o>[</span><span class=n>i</span><span class=o>],</span> <span class=n>i</span><span class=o>--)</span>  <span class=cm>/* 从右往左累乘 */</span>
        <span class=n>B</span><span class=o>[</span><span class=n>i</span><span class=o>]</span> <span class=o>*=</span> <span class=n>product</span><span class=o>;</span>
    <span class=k>return</span> <span class=n>B</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="67">67. 把字符串转换成整数<a class="headerlink" href="#67" title="Permanent link">&para;</a></h3>
<p><a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&amp;tqId=11202&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">NowCoder</a></p>
<p><hh>题目描述</hh></p>
<p>将一个字符串转换成一个整数，字符串不是一个合法的数值则返回 0，要求不能使用字符串转换整数的库函数。</p>
<p> <div class=codehilite><pre>Iuput:
+2147483647
1a33

Output:
2147483647
0
</pre></div></p>
<p><hh>解题思路</hh></p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=kt>int</span> <span class=nf>StrToInt</span><span class=o>(</span><span class=n>String</span> <span class=n>str</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>str</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>()</span> <span class=o>==</span> <span class=mi>0</span><span class=o>)</span>
        <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
    <span class=kt>boolean</span> <span class=n>isNegative</span> <span class=o>=</span> <span class=n>str</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=mi>0</span><span class=o>)</span> <span class=o>==</span> <span class=sc>&#39;-&#39;</span><span class=o>;</span>
    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
    <span class=k>for</span> <span class=o>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>str</span><span class=o>.</span><span class=na>length</span><span class=o>();</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
        <span class=kt>char</span> <span class=n>c</span> <span class=o>=</span> <span class=n>str</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>i</span><span class=o>);</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>i</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=o>(</span><span class=n>c</span> <span class=o>==</span> <span class=sc>&#39;+&#39;</span> <span class=o>||</span> <span class=n>c</span> <span class=o>==</span> <span class=sc>&#39;-&#39;</span><span class=o>))</span>  <span class=cm>/* 符号判定 */</span>
            <span class=k>continue</span><span class=o>;</span>
        <span class=k>if</span> <span class=o>(</span><span class=n>c</span> <span class=o>&lt;</span> <span class=sc>&#39;0&#39;</span> <span class=o>||</span> <span class=n>c</span> <span class=o>&gt;</span> <span class=sc>&#39;9&#39;</span><span class=o>)</span>                <span class=cm>/* 非法输入 */</span>
            <span class=k>return</span> <span class=mi>0</span><span class=o>;</span>
        <span class=n>ret</span> <span class=o>=</span> <span class=n>ret</span> <span class=o>*</span> <span class=mi>10</span> <span class=o>+</span> <span class=o>(</span><span class=n>c</span> <span class=o>-</span> <span class=sc>&#39;0&#39;</span><span class=o>);</span>
    <span class=o>}</span>
    <span class=k>return</span> <span class=n>isNegative</span> <span class=o>?</span> <span class=o>-</span><span class=n>ret</span> <span class=o>:</span> <span class=n>ret</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h3 id="68">68. 树中两个节点的最低公共祖先<a class="headerlink" href="#68" title="Permanent link">&para;</a></h3>
<h4 id="_15">二叉查找树<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h4>
<div align="center"> <img src="../pics//293d2af9-de1d-403e-bed0-85d029383528.png" width="300"/> </div>

<p><br></p>
<p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">Leetcode : 235. Lowest Common Ancestor of a Binary Search Tree</a></p>
<p>二叉查找树中，两个节点 p, q 的公共祖先 root 满足 root.val &gt;= p.val &amp;&amp; root.val &lt;= q.val。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>TreeNode</span> <span class=nf>lowestCommonAncestor</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>,</span> <span class=n>TreeNode</span> <span class=n>p</span><span class=o>,</span> <span class=n>TreeNode</span> <span class=n>q</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span>
        <span class=k>return</span> <span class=n>root</span><span class=o>;</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>val</span> <span class=o>&gt;</span> <span class=n>p</span><span class=o>.</span><span class=na>val</span> <span class=o>&amp;&amp;</span> <span class=n>root</span><span class=o>.</span><span class=na>val</span> <span class=o>&gt;</span> <span class=n>q</span><span class=o>.</span><span class=na>val</span><span class=o>)</span>
        <span class=k>return</span> <span class=n>lowestCommonAncestor</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>p</span><span class=o>,</span> <span class=n>q</span><span class=o>);</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>val</span> <span class=o>&lt;</span> <span class=n>p</span><span class=o>.</span><span class=na>val</span> <span class=o>&amp;&amp;</span> <span class=n>root</span><span class=o>.</span><span class=na>val</span> <span class=o>&lt;</span> <span class=n>q</span><span class=o>.</span><span class=na>val</span><span class=o>)</span>
        <span class=k>return</span> <span class=n>lowestCommonAncestor</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>p</span><span class=o>,</span> <span class=n>q</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>root</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h4 id="_16">普通二叉树<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h4>
<div align="center"> <img src="../pics//37a72755-4890-4b42-9eab-b0084e0c54d9.png" width="300"/> </div>

<p><br></p>
<p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/">Leetcode : 236. Lowest Common Ancestor of a Binary Tree</a></p>
<p>在左右子树中查找是否存在 p 或者 q，如果 p 和 q 分别在两个子树中，那么就说明根节点就是最低公共祖先。</p>
<p> <div class=codehilite><pre><span class=kd>public</span> <span class=n>TreeNode</span> <span class=nf>lowestCommonAncestor</span><span class=o>(</span><span class=n>TreeNode</span> <span class=n>root</span><span class=o>,</span> <span class=n>TreeNode</span> <span class=n>p</span><span class=o>,</span> <span class=n>TreeNode</span> <span class=n>q</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>if</span> <span class=o>(</span><span class=n>root</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>root</span> <span class=o>==</span> <span class=n>p</span> <span class=o>||</span> <span class=n>root</span> <span class=o>==</span> <span class=n>q</span><span class=o>)</span>
        <span class=k>return</span> <span class=n>root</span><span class=o>;</span>
    <span class=n>TreeNode</span> <span class=n>left</span> <span class=o>=</span> <span class=n>lowestCommonAncestor</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>left</span><span class=o>,</span> <span class=n>p</span><span class=o>,</span> <span class=n>q</span><span class=o>);</span>
    <span class=n>TreeNode</span> <span class=n>right</span> <span class=o>=</span> <span class=n>lowestCommonAncestor</span><span class=o>(</span><span class=n>root</span><span class=o>.</span><span class=na>right</span><span class=o>,</span> <span class=n>p</span><span class=o>,</span> <span class=n>q</span><span class=o>);</span>
    <span class=k>return</span> <span class=n>left</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>?</span> <span class=n>right</span> <span class=o>:</span> <span class=n>right</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>?</span> <span class=n>left</span> <span class=o>:</span> <span class=n>root</span><span class=o>;</span>
<span class=o>}</span>
</pre></div></p>
<h4 id="reference">Reference<a class="headerlink" href="#reference" title="Permanent link">&para;</a></h4>
<ol>
<li>剑指Offer</li>
<li><a href="https://github.com/Wang-Jun-Chao/coding-interviews">剑指Offer的Java实现</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20offer%20%E9%A2%98%E8%A7%A3.md">剑指Offer题解</a></li>
</ol></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../../..",
                shortcuts = {"search": 83, "next": 78, "help": 191, "previous": 80};
        </script>
        <script src="../../../js/base.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
        <script src="../../../extra_javascript/tabhack.js" defer></script>
        <script src="../../../extra_javascript/baidu.js" defer></script>
        <script src="../../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
