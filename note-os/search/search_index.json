{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"algorithm/algorithmPrinceton/sort/","text":"Topic 3: Sorting Selection Sort In iteration i i , find index min min of smallest remaining entry. Swap a[i] a[i] and a[min] a[min] . Animation: public class Selection { public static void sort ( Comparable [] a ) { int N = a . length ; for ( int i = 0 ; i N ; i ++) { int min = i ; for ( int j = i + 1 ; j N ; j ++) if ( less ( a [ j ], a [ min ])) min = j ; exch ( a , i , min ); } } } Analysis Selection sort uses (N-1)+(N-2)+...+1\\sim N^2/2 (N-1)+(N-2)+...+1\\sim N^2/2 compares and N N exchanges. Insertion Sort Animation: In iteration i i , swap a[i] a[i] with each larger entry to its left. Invariants. \u2191 scans from left to right. Entries to the left of \u2191 (including \u2191) are in ascending order. Entries to the right of \u2191 have not yet been seen. public class Insertion { public static void sort ( Comparable [] a ) { for ( int i = 1 ; i a . length ; i ++) { int j = i ; while ( j 0 less ( a [ j ], a [ j - 1 ])) { exch ( a , j , j - 1 ); j --; } } } @SuppressWarnings ( unchecked ) private static boolean less ( Comparable a , Comparable b ) { return a . compareTo ( b ) 0 ; } private static void exch ( Comparable [] a , int i , int j ) { Comparable temp = a [ i ]; a [ i ] = a [ j ]; a [ j ] = temp ; } } Analysis Insertion sort uses \\sim N^2/4 \\sim N^2/4 compares and \\sim N^2/4 \\sim N^2/4 exchanges to sort a randomly ordered array of length N N with distinct keys, on the average. The worst case is \\sim N^2/2 \\sim N^2/2 compares and \\sim N ^2/2 \\sim N ^2/2 exchanges and the best case is N-1 N-1 compares and 0 exchanges. Shell Sort Shuffling Our goal is to rearrange array so that result is a uniformly random permutation. Shuffle sort Generate a random real number for each array entry. Sort the array based on generated random numbers. Knuth shuffle In iteration i i , pick integer r r between 0 and i i uniformly at random. Swap a[i] a[i] and a[r] a[r] . public class KnuthShuffle { public static void shuffle ( Object [] a ) { Random random = new Random (); for ( int i = 0 ; i a . length ; i ++) { //In iteration i, pick integer r between 0 and i uniformly at random. int r = random . nextInt ( i + 1 ); // Swap a[i] and a[r]. exch ( a , i , r ); } } } Knuth shuffling algorithm produces a uniformly random permutation of the input array in linear time. Merge Sort Mergesort : to sort an array, divide it into two halves, sort the two halves (recursively), and then merge the results. Basic plan: Divide array into two halves. Recursively sort each half. Merge two halves. public static void sort ( Comparable [] a ) { Comparable [] aux = new Comparable [ a . length ]; sort ( a , aux , 0 , a . length - 1 ); } private static void sort ( Comparable [] a , Comparable [] aux , int lo , int hi ) { if ( hi = lo ) return ; int mid = lo + ( hi - lo ) / 2 ; sort ( a , aux , lo , mid ); // Sort left half. sort ( a , aux , mid + 1 , hi ); // Sort right half. merge ( a , aux , lo , mid , hi ); // Merge results } In-place Merge merge(a, lo, mid, hi) puts the result of merging the subarrays a[lo..mid] with a[mid+1..hi] into a single ordered array, leaving the result in a[lo..hi]. // Merge a[lo..mid] with a[mid+1..hi]. private static void merge ( Comparable [] a , Comparable [] aux , int lo , int mid , int hi ) { for ( int k = lo ; k = hi ; k ++) // Copy a[lo..hi] to aux[lo..hi]. aux [ k ] = a [ k ]; int i = lo , j = mid + 1 ; for ( int k = lo ; k = hi ; k ++) { // Merge back to a[lo..hi]. if ( i mid ) a [ k ] = aux [ j ++]; else if ( j hi ) a [ k ] = aux [ i ++]; else if ( aux [ j ]. compareTo ( aux [ i ]) 0 ) a [ k ] = aux [ j ++]; else a [ k ] = aux [ i ++]; } } Top-down mergesort Algorithm described so far is a recursive mergesort implementation based on in-place merge. It is one of the best-known examples of the utility of the divide-and-conquer paradigm for efficient algorithm design. To understand Top-down mergesort, it is worthwhile to consider carefully the dynamics of the method calls, shown in the trace below. To sort a[0..7], the sort() method calls itself to sort a[0..3] then calls itself to sort a[0..1] before finally doing the first merge of a[0] with a[1] after calling itself to sort a[0] and then a[1]\uff08for brevity, we omit the calls for the base-case 1-entry sorts in the trace\uff09. Then the next merge is a[2] with a[3] and then a[0..1] with a[2..3] and so forth. From this trace, we see that the sort code simply provides an organized way to sequence the calls to the merge() method. Top-down mergesort uses N\\lg N N\\lg N compares to sort any array of length N N . Practical Improvements Use insertion sort for small subarrays. Mergesort has too much overhead for tiny subarrays. Cutoff to insertion sort for \u2248 7 items if ( hi = lo + CUTOFF - 1 ) { Insertion . sort ( a , lo , hi ); return ; } Stop merging if already sorted. Is biggest item in first half \u2264 smallest item in second half? Helps for partially-ordered arrays. if ( a [ mid + 1 ]. compareTo ( a [ mid ]) = 0 ) return ; Eliminate the copy to the auxiliary array. Save time (but not space) by switching the role of the input and auxiliary array in each recursive call. Bottom-up mergesort Bottom-up mergesort is a simple and non-recursive version of mergesort. Basic plan: Pass through array, merging subarrays of size 1. Repeat for subarrays of size 2, 4, 8, 16, .... public static void sort ( Comparable [] a ) { int n = a . length ; Comparable [] aux = new Comparable [ n ]; for ( int len = 1 ; len n ; len += len ) { //len: subarray size for ( int lo = 0 ; lo n - len ; lo += len + len ) { int mid = lo + len - 1 ; int hi = Math . min ( lo + len + len - 1 , n - 1 ); merge ( a , aux , lo , mid , hi ); } } } Quick Sort Quicksort honored as one of top 10 algorithms of 20th century in science and engineering. Quicksort is popular because it is not difficult to implement, works well for a variety of different kinds of input data, and is substantially faster than any other sorting method in typical applications. Basic plan. Shuffle the array. Partition so that, for some j j entry a[j] a[j] is in place no larger entry to the left of j j no smaller entry to the right of j j Sort each piece recursively. public class Quick { public static void sort ( Comparable [] a ) { // shuffle needed for performance guarantee StdRandom . shuffle ( a ); sort ( a , 0 , a . length - 1 ); } private static void sort ( Comparable [] a , int lo , int hi ) { if ( hi = lo ) return ; int j = partition ( a , lo , hi ); sort ( a , lo , j - 1 ); sort ( a , j + 1 , hi ); } } ANIMATION: Note Quicksort and Mergesort Quicksort is a divide-and-conquer method for sorting. Quicksort is complementary to mergesort: for mergesort, we break the array into two subarrays to be sorted and then combine the ordered subarrays to make the whole ordered array; for quicksort, we rearrange the array such that, when the two subarrays are sorted, the whole array is ordered. for mergesort, we do the two recursive calls before working on the whole array; for quicksort, we do the two recursive calls after working on the whole array. for mergesort, the array is divided in half; for quicksort, the position of the partition depends on the contents of the array. Partitioning The crux of the quick sort is the partitioning process, which rearranges the array to make the following three conditions hold: The entry a[j] a[j] is in its final place in the array, for some j j . No entry in a[lo] a[lo] through a[j-1] a[j-1] is greater than a[j] a[j] . No entry in a[j+1] a[j+1] through a[hi] a[hi] is less than a[j] a[j] . First, we arbitrarily choose a[lo] a[lo] to be the partitioning item\u2014the one that will go into its final position. Next, we scan from the left end of the array until we find an entry greater than (or equal to) the partitioning item, and we scan from the right end of the array until we find an entry less than (or equal to) the partitioning item. The two items that stopped the scans are out of place in the final partitioned array, so we exchange them. Continuing in this way, when the scan indices cross, all that we need to do is to exchange the partitioning item a[lo] a[lo] with the rightmost entry of the left subarray ( a[j] a[j] ) and return its index j j . private static int partition ( Comparable a [], int lo , int hi ) { int i = lo , j = hi + 1 ; while ( true ) { // find item on left to swap while ( less ( a [++ i ], a [ lo ])) if ( i == hi ) break ; // find item on right to swap while ( less ( a [ lo ], a [-- j ])) if ( j == lo ) break ; // check if pointers cross if ( i = j ) break ; // swap exch ( a , i , j ); } // swap with partitioning item exch ( a , lo , j ); // return index of item now known to be in place. return j ; // with a[lo..j-1] = a[j] = a[j+1..hi]. } Analysis Best case. Number of compares is \\sim N \\lg N \\sim N \\lg N . Worst case. Number of compares is \\sim \\frac{1}{2} N^2 \\sim \\frac{1}{2} N^2 . The average number of compares C_N C_N to quicksort an array of N N distinct keys is ~ 2N\\ln N 2N\\ln N (and the number of exchanges is \\sim\\frac{1}{3}N \\ln N \\sim\\frac{1}{3}N \\ln N ). Quicksort is an in-place sorting algorithm, but is not stable . Note Quicksort is the fastest general-purpose sort. Evidence: This hypothesis is supported by countless implementations of quicksort on countless computer systems since its invention decades ago. Generally, the reason that quicksort is fastest is that it has only a few instructions in its inner loop (and it does well with cache memories because it most often references data sequentially) so that its running time is \\sim c N \\lg N \\sim c N \\lg N with the value of c smaller than the corresponding constants for other linearithmic sorts. With 3-way partitioning, quicksort becomes linear for certain key distributions likely to arise in practice, where other sorts are linearithmic. Java System Sorts Arrays.sort() Has different method for each primitive type. Has a method for data types that implement Comparable . Has a method that uses a Comparator . Uses tuned quicksort for primitive types; tuned mergesort for objects. Which Algorithms should I use? Application: Line Recognition Given a set of n n distinct points in the plane, find every (maximal) line segment that connects a subset of 4 or more of the points. A faster, sorting-based solution . Given a point p p , the following method determines whether p p participates in a set of 4 or more collinear points. Think of p p as the origin. For each other point q q , determine the slope it makes with p p . Sort the points according to the slopes they makes with p p . Check if any 3 (or more) adjacent points in the sorted order have equal slopes with respect to p p . If so, these points, together with p p , are collinear. An immutable data type Point that represents a point in the plane. public class Point implements Comparable Point { private final int x ; // x-coordinate of this point private final int y ; // y-coordinate of this point // Initializes a new point. public Point ( int x , int y ) { this . x = x ; this . y = y ; } // Returns the slope between this point and the specified point. public double slopeTo ( Point that ) { // points are equal if (( x == that . x ) ( y == that . y )) return Double . NEGATIVE_INFINITY ; // line segment connecting the two points is horizontal if ( y == that . y ) return ( 1 - 1 )/ 1 ; // positive zero // line segment connecting the two points is vertical if ( x == that . x ) return Double . POSITIVE_INFINITY ; return (( double ) that . y - y )/( that . x - x ); } // Compares two points by y-coordinate, breaking ties by x-coordinate. // Formally, the invoking point (x0, y0) is less than the argument point // (x1, y1) if and only if either y0 y1 or if y0 = y1 and x0 x1. public int compareTo ( Point that ) { if (( x == that . x ) ( y == that . y )) return 0 ; if (( y that . y ) || (( y == that . y ) ( x that . x ))) return - 1 ; return 1 ; } // Compares two points by the slope they make with this point. public Comparator Point slopeOrder () { return Comparator . comparing ( this :: slopeTo ); } } To represent line segments in the plane, use the data type LineSegment . public class LineSegment { private final Point p ; // one endpoint of this line segment private final Point q ; // the other endpoint of this line segment // Initializes a new line segment. public LineSegment ( Point p , Point q ) { this . p = p ; this . q = q ; } } FastCollinearPoints implements the algorithm. public class FastCollinearPoints { private Point [] points ; // array for points; private List LineSegment lineSegments ; //line segments // Finds all line segments containing 4 points. public FastCollinearPoints ( Point [] pointsIn ) { // make a copy of points, make it immutable points = pointsIn . clone (); // check null for ( Point point : points ) if ( point == null ) throw new IllegalArgumentException (); // check for duplicity Arrays . sort ( points ); for ( int i = 0 ; i points . length - 1 ; i ++) if ( points [ i ]. compareTo ( points [ i + 1 ]) == 0 ) throw new IllegalArgumentException ( Some of Points are repeat. ); // find line segments lineSegments = new ArrayList (); // array used for points sort by slope Point [] pointsSortedBySlope ; // for every point p, find line segments containing p. for ( Point p : points ) { // initialize pointSort pointsSortedBySlope = points . clone (); // sort by Comparator based on slopes Arrays . sort ( pointsSortedBySlope , p . slopeOrder ()); findLineSegment ( lineSegments , pointsSortedBySlope , p ); } } // For point p, find line Segment containing p. private void findLineSegment ( List LineSegment lineSegments , Point [] pointsSortedBySlope , Point p ) { // sliding window (start, end), where start, end is inclusive int start = 0 , end ; while ( start pointsSortedBySlope . length - 2 ) { end = start + 1 ; // when the slope is the same, keep extending the sliding window while ( end pointsSortedBySlope . length p . slopeTo ( pointsSortedBySlope [ start ]) == p . slopeTo ( pointsSortedBySlope [ end ])) end ++; // find line segments which have at leat 4 points if ( end - start = 3 ) { // sort points based on their x, y coordinates Arrays . sort ( pointsSortedBySlope , start , end ); // We store a linesegment in the array // only if the point which is iterating in the outside loop // is the smallest point in the line segment. // And this solve the problem without extra memory // or the use of hash set. if ( p . compareTo ( pointsSortedBySlope [ start ]) 0 ) lineSegments . add ( new LineSegment ( p , pointsSortedBySlope [ end - 1 ])); // jump to unvisited points start = end - 3 ; } // end if start ++; } // end while } // Return the number of line segments public int numberOfSegments () { return lineSegments . size (); // Return line segments. public LineSegment [] segments () { return lineSegments . toArray ( new LineSegment [ 0 ]); } }","title":"Topic 3: Sort"},{"location":"algorithm/algorithmPrinceton/sort/#topic-3-sorting","text":"","title":"Topic 3: Sorting"},{"location":"algorithm/algorithmPrinceton/sort/#selection-sort","text":"In iteration i i , find index min min of smallest remaining entry. Swap a[i] a[i] and a[min] a[min] . Animation: public class Selection { public static void sort ( Comparable [] a ) { int N = a . length ; for ( int i = 0 ; i N ; i ++) { int min = i ; for ( int j = i + 1 ; j N ; j ++) if ( less ( a [ j ], a [ min ])) min = j ; exch ( a , i , min ); } } }","title":"Selection Sort"},{"location":"algorithm/algorithmPrinceton/sort/#analysis","text":"Selection sort uses (N-1)+(N-2)+...+1\\sim N^2/2 (N-1)+(N-2)+...+1\\sim N^2/2 compares and N N exchanges.","title":"Analysis"},{"location":"algorithm/algorithmPrinceton/sort/#insertion-sort","text":"Animation: In iteration i i , swap a[i] a[i] with each larger entry to its left. Invariants. \u2191 scans from left to right. Entries to the left of \u2191 (including \u2191) are in ascending order. Entries to the right of \u2191 have not yet been seen. public class Insertion { public static void sort ( Comparable [] a ) { for ( int i = 1 ; i a . length ; i ++) { int j = i ; while ( j 0 less ( a [ j ], a [ j - 1 ])) { exch ( a , j , j - 1 ); j --; } } } @SuppressWarnings ( unchecked ) private static boolean less ( Comparable a , Comparable b ) { return a . compareTo ( b ) 0 ; } private static void exch ( Comparable [] a , int i , int j ) { Comparable temp = a [ i ]; a [ i ] = a [ j ]; a [ j ] = temp ; } }","title":"Insertion Sort"},{"location":"algorithm/algorithmPrinceton/sort/#analysis_1","text":"Insertion sort uses \\sim N^2/4 \\sim N^2/4 compares and \\sim N^2/4 \\sim N^2/4 exchanges to sort a randomly ordered array of length N N with distinct keys, on the average. The worst case is \\sim N^2/2 \\sim N^2/2 compares and \\sim N ^2/2 \\sim N ^2/2 exchanges and the best case is N-1 N-1 compares and 0 exchanges.","title":"Analysis"},{"location":"algorithm/algorithmPrinceton/sort/#shell-sort","text":"","title":"Shell Sort"},{"location":"algorithm/algorithmPrinceton/sort/#shuffling","text":"Our goal is to rearrange array so that result is a uniformly random permutation.","title":"Shuffling"},{"location":"algorithm/algorithmPrinceton/sort/#shuffle-sort","text":"Generate a random real number for each array entry. Sort the array based on generated random numbers.","title":"Shuffle sort"},{"location":"algorithm/algorithmPrinceton/sort/#knuth-shuffle","text":"In iteration i i , pick integer r r between 0 and i i uniformly at random. Swap a[i] a[i] and a[r] a[r] . public class KnuthShuffle { public static void shuffle ( Object [] a ) { Random random = new Random (); for ( int i = 0 ; i a . length ; i ++) { //In iteration i, pick integer r between 0 and i uniformly at random. int r = random . nextInt ( i + 1 ); // Swap a[i] and a[r]. exch ( a , i , r ); } } } Knuth shuffling algorithm produces a uniformly random permutation of the input array in linear time.","title":"Knuth shuffle"},{"location":"algorithm/algorithmPrinceton/sort/#merge-sort","text":"Mergesort : to sort an array, divide it into two halves, sort the two halves (recursively), and then merge the results. Basic plan: Divide array into two halves. Recursively sort each half. Merge two halves. public static void sort ( Comparable [] a ) { Comparable [] aux = new Comparable [ a . length ]; sort ( a , aux , 0 , a . length - 1 ); } private static void sort ( Comparable [] a , Comparable [] aux , int lo , int hi ) { if ( hi = lo ) return ; int mid = lo + ( hi - lo ) / 2 ; sort ( a , aux , lo , mid ); // Sort left half. sort ( a , aux , mid + 1 , hi ); // Sort right half. merge ( a , aux , lo , mid , hi ); // Merge results }","title":"Merge Sort"},{"location":"algorithm/algorithmPrinceton/sort/#in-place-merge","text":"merge(a, lo, mid, hi) puts the result of merging the subarrays a[lo..mid] with a[mid+1..hi] into a single ordered array, leaving the result in a[lo..hi]. // Merge a[lo..mid] with a[mid+1..hi]. private static void merge ( Comparable [] a , Comparable [] aux , int lo , int mid , int hi ) { for ( int k = lo ; k = hi ; k ++) // Copy a[lo..hi] to aux[lo..hi]. aux [ k ] = a [ k ]; int i = lo , j = mid + 1 ; for ( int k = lo ; k = hi ; k ++) { // Merge back to a[lo..hi]. if ( i mid ) a [ k ] = aux [ j ++]; else if ( j hi ) a [ k ] = aux [ i ++]; else if ( aux [ j ]. compareTo ( aux [ i ]) 0 ) a [ k ] = aux [ j ++]; else a [ k ] = aux [ i ++]; } }","title":"In-place Merge"},{"location":"algorithm/algorithmPrinceton/sort/#top-down-mergesort","text":"Algorithm described so far is a recursive mergesort implementation based on in-place merge. It is one of the best-known examples of the utility of the divide-and-conquer paradigm for efficient algorithm design. To understand Top-down mergesort, it is worthwhile to consider carefully the dynamics of the method calls, shown in the trace below. To sort a[0..7], the sort() method calls itself to sort a[0..3] then calls itself to sort a[0..1] before finally doing the first merge of a[0] with a[1] after calling itself to sort a[0] and then a[1]\uff08for brevity, we omit the calls for the base-case 1-entry sorts in the trace\uff09. Then the next merge is a[2] with a[3] and then a[0..1] with a[2..3] and so forth. From this trace, we see that the sort code simply provides an organized way to sequence the calls to the merge() method. Top-down mergesort uses N\\lg N N\\lg N compares to sort any array of length N N . Practical Improvements Use insertion sort for small subarrays. Mergesort has too much overhead for tiny subarrays. Cutoff to insertion sort for \u2248 7 items if ( hi = lo + CUTOFF - 1 ) { Insertion . sort ( a , lo , hi ); return ; } Stop merging if already sorted. Is biggest item in first half \u2264 smallest item in second half? Helps for partially-ordered arrays. if ( a [ mid + 1 ]. compareTo ( a [ mid ]) = 0 ) return ; Eliminate the copy to the auxiliary array. Save time (but not space) by switching the role of the input and auxiliary array in each recursive call.","title":"Top-down mergesort"},{"location":"algorithm/algorithmPrinceton/sort/#bottom-up-mergesort","text":"Bottom-up mergesort is a simple and non-recursive version of mergesort. Basic plan: Pass through array, merging subarrays of size 1. Repeat for subarrays of size 2, 4, 8, 16, .... public static void sort ( Comparable [] a ) { int n = a . length ; Comparable [] aux = new Comparable [ n ]; for ( int len = 1 ; len n ; len += len ) { //len: subarray size for ( int lo = 0 ; lo n - len ; lo += len + len ) { int mid = lo + len - 1 ; int hi = Math . min ( lo + len + len - 1 , n - 1 ); merge ( a , aux , lo , mid , hi ); } } }","title":"Bottom-up mergesort"},{"location":"algorithm/algorithmPrinceton/sort/#quick-sort","text":"Quicksort honored as one of top 10 algorithms of 20th century in science and engineering. Quicksort is popular because it is not difficult to implement, works well for a variety of different kinds of input data, and is substantially faster than any other sorting method in typical applications. Basic plan. Shuffle the array. Partition so that, for some j j entry a[j] a[j] is in place no larger entry to the left of j j no smaller entry to the right of j j Sort each piece recursively. public class Quick { public static void sort ( Comparable [] a ) { // shuffle needed for performance guarantee StdRandom . shuffle ( a ); sort ( a , 0 , a . length - 1 ); } private static void sort ( Comparable [] a , int lo , int hi ) { if ( hi = lo ) return ; int j = partition ( a , lo , hi ); sort ( a , lo , j - 1 ); sort ( a , j + 1 , hi ); } } ANIMATION: Note Quicksort and Mergesort Quicksort is a divide-and-conquer method for sorting. Quicksort is complementary to mergesort: for mergesort, we break the array into two subarrays to be sorted and then combine the ordered subarrays to make the whole ordered array; for quicksort, we rearrange the array such that, when the two subarrays are sorted, the whole array is ordered. for mergesort, we do the two recursive calls before working on the whole array; for quicksort, we do the two recursive calls after working on the whole array. for mergesort, the array is divided in half; for quicksort, the position of the partition depends on the contents of the array.","title":"Quick Sort"},{"location":"algorithm/algorithmPrinceton/sort/#partitioning","text":"The crux of the quick sort is the partitioning process, which rearranges the array to make the following three conditions hold: The entry a[j] a[j] is in its final place in the array, for some j j . No entry in a[lo] a[lo] through a[j-1] a[j-1] is greater than a[j] a[j] . No entry in a[j+1] a[j+1] through a[hi] a[hi] is less than a[j] a[j] . First, we arbitrarily choose a[lo] a[lo] to be the partitioning item\u2014the one that will go into its final position. Next, we scan from the left end of the array until we find an entry greater than (or equal to) the partitioning item, and we scan from the right end of the array until we find an entry less than (or equal to) the partitioning item. The two items that stopped the scans are out of place in the final partitioned array, so we exchange them. Continuing in this way, when the scan indices cross, all that we need to do is to exchange the partitioning item a[lo] a[lo] with the rightmost entry of the left subarray ( a[j] a[j] ) and return its index j j . private static int partition ( Comparable a [], int lo , int hi ) { int i = lo , j = hi + 1 ; while ( true ) { // find item on left to swap while ( less ( a [++ i ], a [ lo ])) if ( i == hi ) break ; // find item on right to swap while ( less ( a [ lo ], a [-- j ])) if ( j == lo ) break ; // check if pointers cross if ( i = j ) break ; // swap exch ( a , i , j ); } // swap with partitioning item exch ( a , lo , j ); // return index of item now known to be in place. return j ; // with a[lo..j-1] = a[j] = a[j+1..hi]. }","title":"Partitioning"},{"location":"algorithm/algorithmPrinceton/sort/#analysis_2","text":"Best case. Number of compares is \\sim N \\lg N \\sim N \\lg N . Worst case. Number of compares is \\sim \\frac{1}{2} N^2 \\sim \\frac{1}{2} N^2 . The average number of compares C_N C_N to quicksort an array of N N distinct keys is ~ 2N\\ln N 2N\\ln N (and the number of exchanges is \\sim\\frac{1}{3}N \\ln N \\sim\\frac{1}{3}N \\ln N ). Quicksort is an in-place sorting algorithm, but is not stable . Note Quicksort is the fastest general-purpose sort. Evidence: This hypothesis is supported by countless implementations of quicksort on countless computer systems since its invention decades ago. Generally, the reason that quicksort is fastest is that it has only a few instructions in its inner loop (and it does well with cache memories because it most often references data sequentially) so that its running time is \\sim c N \\lg N \\sim c N \\lg N with the value of c smaller than the corresponding constants for other linearithmic sorts. With 3-way partitioning, quicksort becomes linear for certain key distributions likely to arise in practice, where other sorts are linearithmic.","title":"Analysis"},{"location":"algorithm/algorithmPrinceton/sort/#java-system-sorts","text":"Arrays.sort() Has different method for each primitive type. Has a method for data types that implement Comparable . Has a method that uses a Comparator . Uses tuned quicksort for primitive types; tuned mergesort for objects.","title":"Java System Sorts"},{"location":"algorithm/algorithmPrinceton/sort/#which-algorithms-should-i-use","text":"","title":"Which Algorithms should I use?"},{"location":"algorithm/algorithmPrinceton/sort/#application-line-recognition","text":"Given a set of n n distinct points in the plane, find every (maximal) line segment that connects a subset of 4 or more of the points. A faster, sorting-based solution . Given a point p p , the following method determines whether p p participates in a set of 4 or more collinear points. Think of p p as the origin. For each other point q q , determine the slope it makes with p p . Sort the points according to the slopes they makes with p p . Check if any 3 (or more) adjacent points in the sorted order have equal slopes with respect to p p . If so, these points, together with p p , are collinear. An immutable data type Point that represents a point in the plane. public class Point implements Comparable Point { private final int x ; // x-coordinate of this point private final int y ; // y-coordinate of this point // Initializes a new point. public Point ( int x , int y ) { this . x = x ; this . y = y ; } // Returns the slope between this point and the specified point. public double slopeTo ( Point that ) { // points are equal if (( x == that . x ) ( y == that . y )) return Double . NEGATIVE_INFINITY ; // line segment connecting the two points is horizontal if ( y == that . y ) return ( 1 - 1 )/ 1 ; // positive zero // line segment connecting the two points is vertical if ( x == that . x ) return Double . POSITIVE_INFINITY ; return (( double ) that . y - y )/( that . x - x ); } // Compares two points by y-coordinate, breaking ties by x-coordinate. // Formally, the invoking point (x0, y0) is less than the argument point // (x1, y1) if and only if either y0 y1 or if y0 = y1 and x0 x1. public int compareTo ( Point that ) { if (( x == that . x ) ( y == that . y )) return 0 ; if (( y that . y ) || (( y == that . y ) ( x that . x ))) return - 1 ; return 1 ; } // Compares two points by the slope they make with this point. public Comparator Point slopeOrder () { return Comparator . comparing ( this :: slopeTo ); } } To represent line segments in the plane, use the data type LineSegment . public class LineSegment { private final Point p ; // one endpoint of this line segment private final Point q ; // the other endpoint of this line segment // Initializes a new line segment. public LineSegment ( Point p , Point q ) { this . p = p ; this . q = q ; } } FastCollinearPoints implements the algorithm. public class FastCollinearPoints { private Point [] points ; // array for points; private List LineSegment lineSegments ; //line segments // Finds all line segments containing 4 points. public FastCollinearPoints ( Point [] pointsIn ) { // make a copy of points, make it immutable points = pointsIn . clone (); // check null for ( Point point : points ) if ( point == null ) throw new IllegalArgumentException (); // check for duplicity Arrays . sort ( points ); for ( int i = 0 ; i points . length - 1 ; i ++) if ( points [ i ]. compareTo ( points [ i + 1 ]) == 0 ) throw new IllegalArgumentException ( Some of Points are repeat. ); // find line segments lineSegments = new ArrayList (); // array used for points sort by slope Point [] pointsSortedBySlope ; // for every point p, find line segments containing p. for ( Point p : points ) { // initialize pointSort pointsSortedBySlope = points . clone (); // sort by Comparator based on slopes Arrays . sort ( pointsSortedBySlope , p . slopeOrder ()); findLineSegment ( lineSegments , pointsSortedBySlope , p ); } } // For point p, find line Segment containing p. private void findLineSegment ( List LineSegment lineSegments , Point [] pointsSortedBySlope , Point p ) { // sliding window (start, end), where start, end is inclusive int start = 0 , end ; while ( start pointsSortedBySlope . length - 2 ) { end = start + 1 ; // when the slope is the same, keep extending the sliding window while ( end pointsSortedBySlope . length p . slopeTo ( pointsSortedBySlope [ start ]) == p . slopeTo ( pointsSortedBySlope [ end ])) end ++; // find line segments which have at leat 4 points if ( end - start = 3 ) { // sort points based on their x, y coordinates Arrays . sort ( pointsSortedBySlope , start , end ); // We store a linesegment in the array // only if the point which is iterating in the outside loop // is the smallest point in the line segment. // And this solve the problem without extra memory // or the use of hash set. if ( p . compareTo ( pointsSortedBySlope [ start ]) 0 ) lineSegments . add ( new LineSegment ( p , pointsSortedBySlope [ end - 1 ])); // jump to unvisited points start = end - 3 ; } // end if start ++; } // end while } // Return the number of line segments public int numberOfSegments () { return lineSegments . size (); // Return line segments. public LineSegment [] segments () { return lineSegments . toArray ( new LineSegment [ 0 ]); } }","title":"Application: Line Recognition"}]}