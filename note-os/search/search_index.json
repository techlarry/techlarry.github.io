{
    "docs": [
        {
            "location": "/hfdp/ch1/", 
            "text": "Head First Design Patterns 1 - Strategy Pattern\n\n\nInstead of \ncode\n reuse, with patterns you get \nexperience\n reuse.\n\n\n1 Problem statement\n\n\nA \nDuck\n pond simulation game, \nSimUDuck\n, which can show a large variety of \nDuck\n species swimming and making quacking sounds. The initial designers of the system used standard OO techniques and created one \nDuck\n superclass from which all other \nDuck\n types inherit. Now the executives decides that ducks shall fly in the simulator.\n\n\n\n\nONE OPTION: inheritance, add a \nfly\n method in the \nDuck\n class and then all the ducks will inherit it. HOWEVER, by putting \nfly\n in the superclass, you give flying ability to ALL ducks, including those that shouldn't.\n\n\n-\n you may want to override the \nfly\n method in the objects that shouldn't fly, such as rubber duck. HOWEVER, if you add many objects that can't fly\n\n\nANOTHER OPTION: interface, make a \nFlyable()\n interface with a \n\ufb02y()\n method, make a \nQuackable()\n interface with a quack() method, override \n\ufb02y()\n and \nquack()\n for every new \nDuck\n subclass that\u2019s ever added to the program. HOWEVER, how are you gonna feel when you need to make a little change to the flying behavior... in all of the flying \nDuck\n subclasses.\n\n\n2 Strategy Pattern\n\n\n\n\nThe Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.\n\n\n\u7b56\u7565\u6a21\u5f0f\u5b9a\u4e49\u4e86\u7b97\u6cd5\u7c07\uff0c\u5206\u522b\u5c01\u88c5\u8d77\u6765\uff0c\u8ba9\u4ed6\u4eec\u4e4b\u95f4\u53ef\u4ee5\u76f8\u4e92\u66ff\u6362\u3002\u7b56\u7565\u6a21\u5f0f\u8ba9\u7b97\u6cd5\u7684\u53d8\u5316\u72ec\u7acb\u4e8e\u4f7f\u7528\u7b97\u6cd5\u7684\u5ba2\u6237\u3002\n\n\nDesign Principle\n: identify the aspects of your application that vary and separate them from what stays the same.\n\n\n\u8bbe\u8ba1\u539f\u5219\uff1a\u627e\u51fa\u5e94\u7528\u4e2d\u53ef\u80fd\u9700\u8981\u53d8\u5316\u4e4b\u5904\uff0c\u628a\u4ed6\u4eec\u72ec\u7acb\u51fa\u6765\uff0c\u4e0d\u8981\u548c\u90a3\u4e9b\u4e0d\u9700\u8981\u53d8\u5316\u7684\u4ee3\u7801\u6df7\u5728\u4e00\u8d77\u3002 \n\n\n\n\nAll patterns provide a way to let \nsome part of a system vary independently of all other parts\n.\n\n\nWe know that \n\ufb02y()\n and \nquack()\n are the parts of the \nDuck\n class that vary across ducks.\n\n\nTo separate these behaviors from the \nDuck\n class, we\u2019ll pull both methods out of the \nDuck\n class and create a new set of classes to represent each behavior.\n\n\nSo how are we going to design the set of classes that implement the \ufb02y and quack behaviors?\n\n\n\n\nDesign Principle\n: Program to an interface, not an implementation.\n\n\n\n\nAn Example: SimUDuck\n\n\nWe\u2019ll use an interface to represent each behavior \u2013 for instance, \nFlyBehavior\n and \nQuackBehavior\n \u2013 and each implementation of a behavior will implement one of those interfaces.\n\n\n\n\nWith this design, other types of objects can reuse our \ufb02y and quack behaviors because these behaviors are no longer hidden away in our \nDuck\n classes!\n\n\nAnd we can add new behaviors without modifying any of our existing behavior classes or touching any of the Duck classes that use flying behaviors.\n\n\nDuck\npublic\n \nabstract\n \nclass\n \nDuck\n \n{\n\n    \nFlyBehavior\n \nflyBehavior\n;\n\n    \nQuackBehavior\n \nquackBehavior\n;\n\n\n    \npublic\n \nDuck\n()\n \n{\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nsetFlyBehavior\n(\nFlyBehavior\n \nfb\n)\n \n{\n\n        \nflyBehavior\n \n=\n \nfb\n;\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nsetQuackBehavior\n(\nQuackBehavior\n \nqb\n)\n \n{\n\n        \nquackBehavior\n \n=\n \nqb\n;\n\n    \n}\n\n\n    \nabstract\n \nvoid\n \ndisplay\n();\n\n\n    \npublic\n \nvoid\n \nperformFly\n()\n \n{\n\n        \nflyBehavior\n.\nfly\n();\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nperformQuack\n()\n \n{\n\n        \nquackBehavior\n.\nquack\n();\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nswim\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nAll ducks float, even decoys!\n);\n\n    \n}\n\n\n}\n\n\nFlybehavior\npublic\n \ninterface\n \nFlyBehavior\n \n{\n\n    \npublic\n \nvoid\n \nfly\n();\n\n\n}\n\n\n\npublic\n \nclass\n \nFlyNoWay\n \nimplements\n \nFlyBehavior\n \n{\n\n    \npublic\n \nvoid\n \nfly\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nI can\nt fly\n);\n\n    \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nFlyWithWings\n \nimplements\n \nFlyBehavior\n \n{\n\n    \npublic\n \nvoid\n \nfly\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nI\nm flying!!\n);\n\n    \n}\n\n\n}\n\n\nQuackbehavior\npublic\n \ninterface\n \nQuackBehavior\n \n{\n\n    \npublic\n \nvoid\n \nquack\n();\n\n\n}\n\n\n\npublic\n \nclass\n \nQuack\n \nimplements\n \nQuackBehavior\n \n{\n\n    \npublic\n \nvoid\n \nquack\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nQuack\n);\n\n    \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nMuteQuack\n \nimplements\n \nQuackBehavior\n \n{\n\n    \npublic\n \nvoid\n \nquack\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\n Silence \n);\n\n    \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nSqueak\n \nimplements\n \nQuackBehavior\n \n{\n\n    \npublic\n \nvoid\n \nquack\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nSqueak\n);\n\n    \n}\n\n\n}\n\n\nMallardduck\npublic\n \nclass\n \nMallardDuck\n \nextends\n \nDuck\n \n{\n\n\n    \npublic\n \nMallardDuck\n()\n \n{\n\n\n        \nquackBehavior\n \n=\n \nnew\n \nQuack\n();\n\n        \nflyBehavior\n \n=\n \nnew\n \nFlyWithWings\n();\n\n\n    \n}\n\n\n    \npublic\n \nvoid\n \ndisplay\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nI\nm a real Mallard duck\n);\n\n    \n}\n\n\n}\n\n\nDucksimulator\npublic\n \nclass\n \nMiniDuckSimulator\n \n{\n\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n\n        \nMallardDuck\n \nmallard\n \n=\n \nnew\n \nMallardDuck\n();\n\n        \nRubberDuck\n  \nrubberDuckie\n \n=\n \nnew\n \nRubberDuck\n();\n\n        \nDecoyDuck\n   \ndecoy\n \n=\n \nnew\n \nDecoyDuck\n();\n\n\n        \nDuck\n     \nmodel\n \n=\n \nnew\n \nModelDuck\n();\n\n\n        \nmallard\n.\nperformQuack\n();\n\n        \nrubberDuckie\n.\nperformQuack\n();\n\n        \ndecoy\n.\nperformQuack\n();\n\n\n        \nmodel\n.\nperformFly\n();\n \n        \nmodel\n.\nsetFlyBehavior\n(\nnew\n \nFlyRocketPowered\n());\n\n        \nmodel\n.\nperformFly\n();\n\n    \n}\n\n\n}\n\n\n\n\n\nThe big picture\n\n\nThe Big Picture on encapsulated behaviors:\n\n\n\n\nHAS-A can be better than IS-A\n\n\nHAS-A can be better than IS-A: The HAS-A relationship is an interesting one: each duck has a \nFlyBehavior\n and a \nQuackBehavior\n to which it delegates flying and quacking.\n\n\nWhen you put two classes together like this you\u2019re using \ncomposition\n . Instead of inheriting their behavior, the ducks get their behavior by being \ncomposed\n with the right behavior object.\n\n\n\n\nDesign Principle\n: Favor composition over inheritance.\n\n\n\n\nAn Example: GameCar\n\n\n\n\nCar\n/* Client that can use the algorithms above interchangeably */\n\n\npublic\n \nabstract\n \nclass\n \nCar\n \n{\n\n    \nprotected\n \nIBrakeBehavior\n \nbrakeBehavior\n;\n\n\n    \npublic\n \nvoid\n \napplyBrake\n()\n \n{\n\n        \nbrakeBehavior\n.\nbrake\n();\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nsetBrakeBehavior\n(\nfinal\n \nIBrakeBehavior\n \nbrakeType\n)\n \n{\n\n        \nthis\n.\nbrakeBehavior\n \n=\n \nbrakeType\n;\n\n    \n}\n\n\n}\n\n\n\n/* Client 1 uses one algorithm (Brake) in the constructor */\n\n\npublic\n \nclass\n \nSedan\n \nextends\n \nCar\n \n{\n\n    \npublic\n \nSedan\n()\n \n{\n\n        \nthis\n.\nbrakeBehavior\n \n=\n \nnew\n \nBrake\n();\n\n    \n}\n\n\n}\n\n\n\n/* Client 2 uses another algorithm (BrakeWithABS) in the constructor */\n\n\npublic\n \nclass\n \nSUV\n \nextends\n \nCar\n \n{\n\n    \npublic\n \nSUV\n()\n \n{\n\n        \nthis\n.\nbrakeBehavior\n \n=\n \nnew\n \nBrakeWithABS\n();\n\n    \n}\n\n\n}\n\n\nIbrakebehavior\n/* Encapsulated family of Algorithms\n\n\n * Interface and its implementations\n\n\n */\n\n\npublic\n \ninterface\n \nIBrakeBehavior\n \n{\n\n    \npublic\n \nvoid\n \nbrake\n();\n\n\n}\n\n\n\npublic\n \nclass\n \nBrakeWithABS\n \nimplements\n \nIBrakeBehavior\n \n{\n\n    \npublic\n \nvoid\n \nbrake\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nBrake with ABS applied\n);\n\n    \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nBrake\n \nimplements\n \nIBrakeBehavior\n \n{\n\n    \npublic\n \nvoid\n \nbrake\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nSimple Brake applied\n);\n\n    \n}\n\n\n}\n\n\nCarexample\n/* Using the Car example */\n\n\npublic\n \nclass\n \nCarExample\n \n{\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nfinal\n \nString\n[]\n \narguments\n)\n \n{\n\n        \nCar\n \nsedanCar\n \n=\n \nnew\n \nSedan\n();\n\n        \nsedanCar\n.\napplyBrake\n();\n  \n// This will invoke class \nBrake\n\n\n        \nCar\n \nsuvCar\n \n=\n \nnew\n \nSUV\n();\n\n        \nsuvCar\n.\napplyBrake\n();\n    \n// This will invoke class \nBrakeWithABS\n\n\n        \n// set brake behavior dynamically\n\n        \nsuvCar\n.\nsetBrakeBehavior\n(\n \nnew\n \nBrake\n()\n \n);\n\n        \nsuvCar\n.\napplyBrake\n();\n    \n// This will invoke class \nBrake\n\n    \n}\n\n\n}\n\n\n\n\n\nUML\n\n\n\n\nExample: Collections.sort()\n\n\nCollection.sort(List, Comparator)\n method, where \nComparator\n is Strategy and \nCollections.sort()\n is Context. Because of this pattern your sort method can sort any object, the object which doesn't exists when this method was written. As long as, Object will implement \nComparator\n interface (Strategy interface), \nCollections.sort()\n method will sort it.", 
            "title": "Chapter 1: Strategy Pattern "
        }, 
        {
            "location": "/hfdp/ch1/#head-first-design-patterns-1-strategy-pattern", 
            "text": "Instead of  code  reuse, with patterns you get  experience  reuse.", 
            "title": "Head First Design Patterns 1 - Strategy Pattern"
        }, 
        {
            "location": "/hfdp/ch1/#1-problem-statement", 
            "text": "A  Duck  pond simulation game,  SimUDuck , which can show a large variety of  Duck  species swimming and making quacking sounds. The initial designers of the system used standard OO techniques and created one  Duck  superclass from which all other  Duck  types inherit. Now the executives decides that ducks shall fly in the simulator.   ONE OPTION: inheritance, add a  fly  method in the  Duck  class and then all the ducks will inherit it. HOWEVER, by putting  fly  in the superclass, you give flying ability to ALL ducks, including those that shouldn't.  -  you may want to override the  fly  method in the objects that shouldn't fly, such as rubber duck. HOWEVER, if you add many objects that can't fly  ANOTHER OPTION: interface, make a  Flyable()  interface with a  \ufb02y()  method, make a  Quackable()  interface with a quack() method, override  \ufb02y()  and  quack()  for every new  Duck  subclass that\u2019s ever added to the program. HOWEVER, how are you gonna feel when you need to make a little change to the flying behavior... in all of the flying  Duck  subclasses.", 
            "title": "1 Problem statement"
        }, 
        {
            "location": "/hfdp/ch1/#2-strategy-pattern", 
            "text": "The Strategy Pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.  \u7b56\u7565\u6a21\u5f0f\u5b9a\u4e49\u4e86\u7b97\u6cd5\u7c07\uff0c\u5206\u522b\u5c01\u88c5\u8d77\u6765\uff0c\u8ba9\u4ed6\u4eec\u4e4b\u95f4\u53ef\u4ee5\u76f8\u4e92\u66ff\u6362\u3002\u7b56\u7565\u6a21\u5f0f\u8ba9\u7b97\u6cd5\u7684\u53d8\u5316\u72ec\u7acb\u4e8e\u4f7f\u7528\u7b97\u6cd5\u7684\u5ba2\u6237\u3002  Design Principle : identify the aspects of your application that vary and separate them from what stays the same.  \u8bbe\u8ba1\u539f\u5219\uff1a\u627e\u51fa\u5e94\u7528\u4e2d\u53ef\u80fd\u9700\u8981\u53d8\u5316\u4e4b\u5904\uff0c\u628a\u4ed6\u4eec\u72ec\u7acb\u51fa\u6765\uff0c\u4e0d\u8981\u548c\u90a3\u4e9b\u4e0d\u9700\u8981\u53d8\u5316\u7684\u4ee3\u7801\u6df7\u5728\u4e00\u8d77\u3002    All patterns provide a way to let  some part of a system vary independently of all other parts .  We know that  \ufb02y()  and  quack()  are the parts of the  Duck  class that vary across ducks.  To separate these behaviors from the  Duck  class, we\u2019ll pull both methods out of the  Duck  class and create a new set of classes to represent each behavior.  So how are we going to design the set of classes that implement the \ufb02y and quack behaviors?   Design Principle : Program to an interface, not an implementation.", 
            "title": "2 Strategy Pattern"
        }, 
        {
            "location": "/hfdp/ch1/#an-example-simuduck", 
            "text": "We\u2019ll use an interface to represent each behavior \u2013 for instance,  FlyBehavior  and  QuackBehavior  \u2013 and each implementation of a behavior will implement one of those interfaces.   With this design, other types of objects can reuse our \ufb02y and quack behaviors because these behaviors are no longer hidden away in our  Duck  classes!  And we can add new behaviors without modifying any of our existing behavior classes or touching any of the Duck classes that use flying behaviors.  Duck public   abstract   class   Duck   { \n     FlyBehavior   flyBehavior ; \n     QuackBehavior   quackBehavior ; \n\n     public   Duck ()   { \n     } \n\n     public   void   setFlyBehavior ( FlyBehavior   fb )   { \n         flyBehavior   =   fb ; \n     } \n\n     public   void   setQuackBehavior ( QuackBehavior   qb )   { \n         quackBehavior   =   qb ; \n     } \n\n     abstract   void   display (); \n\n     public   void   performFly ()   { \n         flyBehavior . fly (); \n     } \n\n     public   void   performQuack ()   { \n         quackBehavior . quack (); \n     } \n\n     public   void   swim ()   { \n         System . out . println ( All ducks float, even decoys! ); \n     }  }  Flybehavior public   interface   FlyBehavior   { \n     public   void   fly ();  }  public   class   FlyNoWay   implements   FlyBehavior   { \n     public   void   fly   { \n         System . out . println ( I can t fly ); \n     }  }  public   class   FlyWithWings   implements   FlyBehavior   { \n     public   void   fly   { \n         System . out . println ( I m flying!! ); \n     }  }  Quackbehavior public   interface   QuackBehavior   { \n     public   void   quack ();  }  public   class   Quack   implements   QuackBehavior   { \n     public   void   quack ()   { \n         System . out . println ( Quack ); \n     }  }  public   class   MuteQuack   implements   QuackBehavior   { \n     public   void   quack ()   { \n         System . out . println (  Silence  ); \n     }  }  public   class   Squeak   implements   QuackBehavior   { \n     public   void   quack ()   { \n         System . out . println ( Squeak ); \n     }  }  Mallardduck public   class   MallardDuck   extends   Duck   { \n\n     public   MallardDuck ()   { \n\n         quackBehavior   =   new   Quack (); \n         flyBehavior   =   new   FlyWithWings (); \n\n     } \n\n     public   void   display ()   { \n         System . out . println ( I m a real Mallard duck ); \n     }  }  Ducksimulator public   class   MiniDuckSimulator   { \n\n     public   static   void   main ( String []   args )   { \n\n         MallardDuck   mallard   =   new   MallardDuck (); \n         RubberDuck    rubberDuckie   =   new   RubberDuck (); \n         DecoyDuck     decoy   =   new   DecoyDuck (); \n\n         Duck       model   =   new   ModelDuck (); \n\n         mallard . performQuack (); \n         rubberDuckie . performQuack (); \n         decoy . performQuack (); \n\n         model . performFly ();  \n         model . setFlyBehavior ( new   FlyRocketPowered ()); \n         model . performFly (); \n     }  }", 
            "title": "An Example: SimUDuck"
        }, 
        {
            "location": "/hfdp/ch1/#the-big-picture", 
            "text": "The Big Picture on encapsulated behaviors:", 
            "title": "The big picture"
        }, 
        {
            "location": "/hfdp/ch1/#has-a-can-be-better-than-is-a", 
            "text": "HAS-A can be better than IS-A: The HAS-A relationship is an interesting one: each duck has a  FlyBehavior  and a  QuackBehavior  to which it delegates flying and quacking.  When you put two classes together like this you\u2019re using  composition  . Instead of inheriting their behavior, the ducks get their behavior by being  composed  with the right behavior object.   Design Principle : Favor composition over inheritance.", 
            "title": "HAS-A can be better than IS-A"
        }, 
        {
            "location": "/hfdp/ch1/#an-example-gamecar", 
            "text": "Car /* Client that can use the algorithms above interchangeably */  public   abstract   class   Car   { \n     protected   IBrakeBehavior   brakeBehavior ; \n\n     public   void   applyBrake ()   { \n         brakeBehavior . brake (); \n     } \n\n     public   void   setBrakeBehavior ( final   IBrakeBehavior   brakeType )   { \n         this . brakeBehavior   =   brakeType ; \n     }  }  /* Client 1 uses one algorithm (Brake) in the constructor */  public   class   Sedan   extends   Car   { \n     public   Sedan ()   { \n         this . brakeBehavior   =   new   Brake (); \n     }  }  /* Client 2 uses another algorithm (BrakeWithABS) in the constructor */  public   class   SUV   extends   Car   { \n     public   SUV ()   { \n         this . brakeBehavior   =   new   BrakeWithABS (); \n     }  }  Ibrakebehavior /* Encapsulated family of Algorithms   * Interface and its implementations   */  public   interface   IBrakeBehavior   { \n     public   void   brake ();  }  public   class   BrakeWithABS   implements   IBrakeBehavior   { \n     public   void   brake ()   { \n         System . out . println ( Brake with ABS applied ); \n     }  }  public   class   Brake   implements   IBrakeBehavior   { \n     public   void   brake ()   { \n         System . out . println ( Simple Brake applied ); \n     }  }  Carexample /* Using the Car example */  public   class   CarExample   { \n     public   static   void   main ( final   String []   arguments )   { \n         Car   sedanCar   =   new   Sedan (); \n         sedanCar . applyBrake ();    // This will invoke class  Brake \n\n         Car   suvCar   =   new   SUV (); \n         suvCar . applyBrake ();      // This will invoke class  BrakeWithABS \n\n         // set brake behavior dynamically \n         suvCar . setBrakeBehavior (   new   Brake ()   ); \n         suvCar . applyBrake ();      // This will invoke class  Brake \n     }  }", 
            "title": "An Example: GameCar"
        }, 
        {
            "location": "/hfdp/ch1/#uml", 
            "text": "", 
            "title": "UML"
        }, 
        {
            "location": "/hfdp/ch1/#example-collectionssort", 
            "text": "Collection.sort(List, Comparator)  method, where  Comparator  is Strategy and  Collections.sort()  is Context. Because of this pattern your sort method can sort any object, the object which doesn't exists when this method was written. As long as, Object will implement  Comparator  interface (Strategy interface),  Collections.sort()  method will sort it.", 
            "title": "Example: Collections.sort()"
        }
    ]
}