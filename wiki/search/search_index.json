{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"Algorithm/\u5176\u4ed6/Bucket Sort/","text":"Algorithms in a Nutshell Given a set of n n elements, Bucket Sort constructs a set of n n buckets into which the elements of the input set are partitioned; If a hash function, hash(A_i) hash(A_i) , is provided that uniformly partitions the input set of n n elements into these n n buckets, then Bucket Sort can sort, in the worst case, in O(n) O(n) time. You can use Bucket Sort if the following two properties hold: Uniform distribution: The input data must be uniformly distributed for a given range. Based on this distribution, n n buckets are created to evenly partition the input range. Ordered hash function: The buckets must be ordered. That is, if i < j i < j , then elements inserted into bucket b_i b_i are lexicographically smaller than elements in bucket b_j b_j . // Performs a bucket sort of an array in which all the elements are // bounded in the range [min, max]. For bucket sort to give linear // performance the elements need to be uniformly distributed public static void bucketSort ( int [] nums , final int min , final int max ) { if ( nums == null || nums . length == 0 || min == max ) return ; // N is number elements and M is the range of values final int N = nums . length , M = max - min , NUM_BUCKETS = M / N + 1 ; List < List < Integer >> buckets = new ArrayList <>( NUM_BUCKETS ); for ( int i = 0 ; i < NUM_BUCKETS ; i ++) buckets . add ( new ArrayList <>()); // Place each element in a bucket for ( int i = 0 ; i < N ; i ++) { int bi = ( ar [ i ] - min ) / M ; buckets . get ( bi ). add ( nums [ i ]); } // Sort buckets and stitch together answer for ( int bi = 0 , j = 0 ; bi < NUM_BUCKETS ; bi ++){ List < Integer > bucket = buckets . get ( bi ); if ( bucket != null ) Collections . sort ( bucket ); for ( int num : bucket ) nums [ j ++] = num ; } }","title":"Bucket Sort"},{"location":"Algorithm/\u5176\u4ed6/\u6c34\u5858\u62bd\u6837/","text":"Reservoir sampling(\u6c34\u5858\u62bd\u6837) is a family of randomized algorithms for randomly choosing k samples from a list of n items, where n is either a very large or unknown number. Typically n is large enough that the list doesn\u2019t fit into main memory. For example, a list of search queries in Google and Facebook. So we are given a big array (or stream) of numbers (to simplify), and we need to write an efficient function to randomly select k numbers where 1 <= k <= n. Let the input array be stream[]. A simple solution is to create an array reservoir[] of maximum size k . One by one randomly select an item from stream[0..n-1] . If the selected item is not previously selected, then put it in reservoir[] . To check if an item is previously selected or not, we need to search the item in reservoir[] . The time complexity of this algorithm will be O(k^2) O(k^2) . This can be costly if k is big. Also, this is not efficient if the input is in the form of a stream. Problem \u00b6 Choose k entries from n numbers. Make sure each number is selected with the probability of k/n Basic idea : Choose 1, 2, 3, ..., k first and put them into the reservoir. For k+1 , pick it with a probability of k/(k+1) , and randomly replace a number in the reservoir. For k+i , pick it with a probability of k/(k+i) , and randomly replace a number in the reservoir. Repeat until k+i reaches n Proof \u00b6 For k+i , the probability that it is selected and will replace a number in the reservoir is k/(k+i) For a number in the reservoir before (let's say X ), the probability that it keeps staying in the reservoir is P(X was in the reservoir last time) \u00d7 P(X is not replaced by k+i) = P(X was in the reservoir last time) \u00d7 ( 1 - P(k+i is selected and replaces X) ) = k/(k+i-1) \u00d7 \uff08 1 - k/(k+i) \u00d7 1/k \uff09 = k/(k+i) When k+i reaches n , the probability of each number staying in the reservoir is k/n Example \u00b6 Choose 3 numbers from [111, 222, 333, 444] . Make sure each number is selected with a probability of 3/4 First, choose [111, 222, 333] as the initial reservior Then choose 444 with a probability of 3/4 For 111 , it stays with a probability of P(444 is not selected) + P(444 is selected but it replaces 222 or 333) = 1/4 + 3/4 * 2/3 = 3/4 The same case with 222 and 333 . Now all the numbers have the probability of 3/4 to be picked. Java \u00b6 \u5177\u4f53\u7684Java\u4ee3\u7801\u5982\u4e0b\uff1a // A function to randomly select k items from stream[0..n-1]. static void selectKItems ( int stream [], int n , int k ) { int i ; // index for elements in stream[] // reservoir[] is the output array. Initialize it with // first k elements from stream[] int reservoir [] = new int [ k ]; for ( i = 0 ; i < k ; i ++) reservoir [ i ] = stream [ i ]; Random r = new Random (); // Iterate from the (k+1)th element to nth element for (; i < n ; i ++) { // Pick a random index from 0 to i. int j = r . nextInt ( i + 1 ); // If the randomly picked index is smaller than k, // then replace the element present at the index // with new element from stream if ( j < k ) reservoir [ j ] = stream [ i ]; } } Reference \u00b6 Reservoir Sampling","title":"\u6c34\u5858\u62bd\u6837"},{"location":"Algorithm/\u5176\u4ed6/\u6c34\u5858\u62bd\u6837/#problem","text":"Choose k entries from n numbers. Make sure each number is selected with the probability of k/n Basic idea : Choose 1, 2, 3, ..., k first and put them into the reservoir. For k+1 , pick it with a probability of k/(k+1) , and randomly replace a number in the reservoir. For k+i , pick it with a probability of k/(k+i) , and randomly replace a number in the reservoir. Repeat until k+i reaches n","title":"Problem"},{"location":"Algorithm/\u5176\u4ed6/\u6c34\u5858\u62bd\u6837/#proof","text":"For k+i , the probability that it is selected and will replace a number in the reservoir is k/(k+i) For a number in the reservoir before (let's say X ), the probability that it keeps staying in the reservoir is P(X was in the reservoir last time) \u00d7 P(X is not replaced by k+i) = P(X was in the reservoir last time) \u00d7 ( 1 - P(k+i is selected and replaces X) ) = k/(k+i-1) \u00d7 \uff08 1 - k/(k+i) \u00d7 1/k \uff09 = k/(k+i) When k+i reaches n , the probability of each number staying in the reservoir is k/n","title":"Proof"},{"location":"Algorithm/\u5176\u4ed6/\u6c34\u5858\u62bd\u6837/#example","text":"Choose 3 numbers from [111, 222, 333, 444] . Make sure each number is selected with a probability of 3/4 First, choose [111, 222, 333] as the initial reservior Then choose 444 with a probability of 3/4 For 111 , it stays with a probability of P(444 is not selected) + P(444 is selected but it replaces 222 or 333) = 1/4 + 3/4 * 2/3 = 3/4 The same case with 222 and 333 . Now all the numbers have the probability of 3/4 to be picked.","title":"Example"},{"location":"Algorithm/\u5176\u4ed6/\u6c34\u5858\u62bd\u6837/#java","text":"\u5177\u4f53\u7684Java\u4ee3\u7801\u5982\u4e0b\uff1a // A function to randomly select k items from stream[0..n-1]. static void selectKItems ( int stream [], int n , int k ) { int i ; // index for elements in stream[] // reservoir[] is the output array. Initialize it with // first k elements from stream[] int reservoir [] = new int [ k ]; for ( i = 0 ; i < k ; i ++) reservoir [ i ] = stream [ i ]; Random r = new Random (); // Iterate from the (k+1)th element to nth element for (; i < n ; i ++) { // Pick a random index from 0 to i. int j = r . nextInt ( i + 1 ); // If the randomly picked index is smaller than k, // then replace the element present at the index // with new element from stream if ( j < k ) reservoir [ j ] = stream [ i ]; } }","title":"Java"},{"location":"Algorithm/\u5176\u4ed6/\u6c34\u5858\u62bd\u6837/#reference","text":"Reservoir Sampling","title":"Reference"}]}