<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  techlarry
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="techlarry" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:larryim.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">HomePage</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_blank" href="wiki">WIKI</a></li>
        
        <li id=""><a target="_self" href="notebook.html">NOTEBOOK</a></li>
        
        <li id=""><a target="_self" href="about.html">About</a></li>
        
        <li id=""><a target="_blank" href="note">NOTE</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; techlarry</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">HomePage</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        
        <li><a target="_blank" href="wiki">WIKI</a></li>
        
        <li><a target="_self" href="notebook.html">NOTEBOOK</a></li>
        
        <li><a target="_self" href="about.html">About</a></li>
        
        <li><a target="_blank" href="note">NOTE</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Leetcode.html">Leetcode</a></li>
        
            <li><a href="programming_language.html">编程语言</a></li>
        
            <li><a href="data_structure_and_algorithm.html">数据结构和算法</a></li>
        
            <li><a href="Python%E7%89%B9%E6%80%A7.html">Python特性</a></li>
        
            <li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html">机器学习</a></li>
        
            <li><a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html">Python科学计算三维可视化</a></li>
        
            <li><a href="English.html">English</a></li>
        
            <li><a href="Computer%20System.html">Computer System</a></li>
        
            <li><a href="Deep%20Learning.html">Deep Learning</a></li>
        
            <li><a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html">Linux 系统编程</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a></li>
        
            <li><a href="Tensorflow.html">Tensorflow</a></li>
        
            <li><a href="Big%20Data.html">Big Data</a></li>
        
            <li><a href="%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB.html">文献阅读</a></li>
        
            <li><a href="Tools.html">Tools</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="head-first_java_note.html">
                
                  <h1>Head first Java</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Notes, Head first Java, 2nd Edition</p>

<ul>
<li>
<a href="#toc_0">1 Dive in A Quick Dip</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_1">main method</a>
</li>
<li>
<a href="#toc_2">Looping</a>
</li>
<li>
<a href="#toc_3">Conditional branching</a>
</li>
<li>
<a href="#toc_4">Strongly-typed language</a>
</li>
<li>
<a href="#toc_5">Dynamic Binding</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_6">2 Classes and objects</a>
<ul>
<li>
<a href="#toc_7">2.1 Object Oriented</a>
</li>
<li>
<a href="#toc_8">2.2 Class</a>
</li>
<li>
<a href="#toc_9">2.3 main</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">3 Primitives and references</a>
<ul>
<li>
<a href="#toc_11">3.1 primitive variable</a>
</li>
<li>
<a href="#toc_12">3.2 Reference variable</a>
</li>
<li>
<a href="#toc_13">3.3 Array</a>
</li>
</ul>
</li>
<li>
<a href="#toc_14">4 Methods use instance variables</a>
<ul>
<li>
<a href="#toc_15">4.1 Methods</a>
</li>
<li>
<a href="#toc_16">4.2 Getters and setters</a>
</li>
<li>
<a href="#toc_17">4.3 Encapsulation</a>
</li>
<li>
<a href="#toc_18">4.4 Instance variables</a>
</li>
<li>
<a href="#toc_19">4.5 Instance and local variables</a>
</li>
<li>
<a href="#toc_20">4.6 Comparing variables</a>
</li>
</ul>
</li>
<li>
<a href="#toc_21">5 Writing a Program</a>
</li>
<li>
<a href="#toc_22">6  Get to know the Java API</a>
</li>
<li>
<a href="#toc_23">7 Inheritance and polymorphism</a>
<ul>
<li>
<a href="#toc_24">7.1 overriding</a>
</li>
<li>
<a href="#toc_25">7.2 Polymorphism</a>
</li>
<li>
<a href="#toc_26">7.3 Method overloading</a>
</li>
</ul>
</li>
<li>
<a href="#toc_27">8 Interfaces and abstract classes</a>
<ul>
<li>
<a href="#toc_28">8.1 Abstract classes</a>
</li>
<li>
<a href="#toc_29">8.2 Abstract methods</a>
</li>
<li>
<a href="#toc_30">8.3 The ultimate superclass: Object</a>
</li>
<li>
<a href="#toc_31">8.4 Using polymorphic references of type Object has a price</a>
</li>
<li>
<a href="#toc_32">8.5 Interface</a>
</li>
<li>
<a href="#toc_33">8.6 Using <code>super</code></a>
</li>
</ul>
</li>
<li>
<a href="#toc_34">9 Constructors and garbage collection</a>
</li>
<li>
<a href="#toc_35">10 Numbers and statics</a>
</li>
</ul>


<h2 id="toc_0">1 Dive in A Quick Dip</h2>

<p>Java has friendly syntax, object-oriented features, memory management, and best of all - the promise of probability ( <u>write-one/run-anywhere</u> ).</p>

<p>You type a source code file(<code>.java</code>). compile it using the <code>javac</code> compiler, then run(<code>java</code>) the compiled bytecode(<code>.class</code>) on a java virtual machine.</p>

<p><img src="media/15321391987415/code_structure.png" alt="code_structure"/></p>

<h4 id="toc_1">main method</h4>

<p>Every Java application has to have at least one class, and at least one <code>main</code> method.</p>

<p>The <code>main</code> method is where your program starts running.</p>

<pre><code class="language-java">public static void main(String[] args){
    //your code goes here
}
</code></pre>

<h4 id="toc_2">Looping</h4>

<p>Java has three standard looping constructs: <code>while</code>, <code>do-while</code>, and <code>for</code>.</p>

<pre><code class="language-java">while ( ) {

}


</code></pre>

<p>A boolean and an integer are not compatible types in Java.</p>

<pre><code class="language-text">int x=1;
while (x) {} //wrong
</code></pre>

<h4 id="toc_3">Conditional branching</h4>

<pre><code class="language-java">if (conditional test) {
} else {
}
</code></pre>

<p><strong>Note</strong>: <code>System.out.println</code> inserts a newline, <code>System.out.print</code> keeps printing to the same line.</p>

<h4 id="toc_4">Strongly-typed language</h4>

<p>Java is a <strong>strongly typed language</strong>(强类型语言) and that means I can&#39;t allow variables to hold data of the wrong type.</p>

<h4 id="toc_5">Dynamic Binding</h4>

<p>However, There are some datatype exceptions that can emerge at runtime, but some of those have to be allowed to support one of Java&#39;s other important features -- <strong>dynamic binding</strong>(动态绑定).</p>

<p>Here are a few important differences between <strong>static</strong> and <strong>dynamic</strong> binding in Java [<a href="https://stackoverflow.com/questions/19017258/static-vs-dynamic-binding-in-java">ref</a>]:</p>

<ol>
<li>Static binding in Java occurs during <strong>compile</strong> time while dynamic binding occurs during <strong>runtime</strong>.</li>
<li><code>private</code>, <code>final</code> and <code>static</code> methods and variables use static binding and are bonded by compiler while virtual methods are bonded during runtime based upon runtime object.</li>
<li>Static binding uses Type (class in Java) information for binding while dynamic binding uses object to resolve binding.</li>
<li>Overloaded methods are bonded using static binding while overridden methods are bonded using dynamic binding at runtime.</li>
</ol>

<p>Static Binding Example in Java:</p>

<pre><code class="language-java">public class StaticBindingTest {  
    public static void main(String args[]) {
        Collection c = new HashSet();
        StaticBindingTest et = new StaticBindingTest();
        et.sort(c);
    }
    //overloaded method takes Collection argument
    public Collection sort(Collection c) {
        System.out.println(&quot;Inside Collection sort method&quot;);
        return c;
    }
    //another overloaded method which takes HashSet argument which is sub class
    public Collection sort(HashSet hs) {
        System.out.println(&quot;Inside HashSet sort method&quot;);
        return hs;
    }
}
</code></pre>

<p>Example of Dynamic Binding in Java:</p>

<pre><code class="language-java">public class DynamicBindingTest {   
    public static void main(String args[]) {
        Vehicle vehicle = new Car(); //here Type is vehicle but object will be Car
        vehicle.start(); //Car&#39;s start called because start() is overridden method
    }
}

class Vehicle {
    public void start() {
        System.out.println(&quot;Inside start method of Vehicle&quot;);
    }
}

class Car extends Vehicle {
    @Override
    public void start() {
        System.out.println(&quot;Inside start method of Car&quot;);
    }
}
</code></pre>

<h2 id="toc_6">2 Classes and objects</h2>

<h3 id="toc_7">2.1 Object Oriented</h3>

<p>What do you like about OO? Some people say...</p>

<ul>
<li>It helps me design in a more natural way. Things have a way of evolving.</li>
<li>Not messing around with the code I&#39;ve already tested, just to add a new feature.</li>
<li>Reusing code in other applications. When I write a new class, I can make it flexible enough to be used in something new, later</li>
</ul>

<h3 id="toc_8">2.2 Class</h3>

<p>A class describes what an object <strong>knows</strong>(instance variables) and what an object <strong>does</strong>(methods).</p>

<p><img src="media/15321391987415/class.png" alt="class"/></p>

<p>What&#39;s the <strong>difference</strong> between a class and an object?</p>

<ul>
<li>A class is not an object. A class is the blueprint for an object. It tells the JVM <em>how</em> to make an object of that particular type. Each object made from that class have its <em>own</em> values for the instance variables of that class.</li>
</ul>

<p><img src="media/15321391987415/one_class_many_objects.png" alt="one_class_many_objects"/></p>

<h3 id="toc_9">2.3 main</h3>

<p>The two uses of main:</p>

<ul>
<li>to <strong><em>test</em></strong> your real class</li>
<li>to <strong><em>launch/start</em></strong> your Java application.</li>
</ul>

<h2 id="toc_10">3 Primitives and references</h2>

<p>Variables must always be declared with a name and a type. Variables come in two flavors: <strong>primitive</strong> and <strong>reference</strong>.(变量的生命必须有类型和名称。变量有两种：primitive和引用)</p>

<h3 id="toc_11">3.1 primitive variable</h3>

<p>A <em>primitive variable</em> value is the bits representing the value. primitive变量的值是表示该值的位。</p>

<h3 id="toc_12">3.2 Reference variable</h3>

<ul>
<li>A reference variable value is the bits representing a way to get to an object on the heap.引用变量的值是表示一种到达堆上的对象的方法的位。</li>
<li>A reference variable is like a remote control. Using the dot operator(<code>.</code>) on a reference variable is like pressing a button on the remote control to access a method or instance variables.</li>
<li>A reference variable has a value of <code>null</code> when it is not referencing any object.</li>
</ul>

<h3 id="toc_13">3.3 Array</h3>

<ul>
<li>An array is always an object, even if the array is declared to hold primitives. </li>
<li>Every element in an array is just a variable.</li>
</ul>

<p><u>The three steps of <strong>object declaration, creation and assignment</strong>.</u></p>

<p>(e.g. <code>Dog myDog = new Dog()</code>);</p>

<ul>
<li><strong>declare</strong> a reference variable: tell the JVM to allocate space for a reference variable, and names that variable myDog</li>
<li><strong>create</strong> an object: tells the JCM to allocate space for a new Dog object on the heap.</li>
<li><strong>Assigns</strong> the object to the reference variable.</li>
</ul>

<p><img src="media/15321391987415/three%20steps%20of%20object%20declaration,%20creation,%20and%20assignment.png" alt="three steps of object declaration, creation, and assignment"/></p>

<h2 id="toc_14">4 Methods use instance variables</h2>

<h3 id="toc_15">4.1 Methods</h3>

<p><strong>Class define what an object knows and what an object does.</strong> Things an object knows are its <em>instance variables</em>(state), things an object does are its <em>methods</em>(behavior).</p>

<p><strong>Methods</strong>:<br/>
<strong>A method uses parameters. A caller passes arguments.</strong></p>

<ul>
<li>Arguments are the things you pass into the methods.</li>
<li>If a method takes a parameters, you must pass it something.</li>
<li>Methods can return values. Every method is declared is declared with a return type.</li>
<li>If you declare a method to return a value, you <em>must</em> return a value of the declared type or a value that is <em>compatible</em> with the declared type.</li>
<li>Java is <strong>pass-by-value</strong>, which means <strong>pass-by-copy</strong>.</li>
</ul>

<h3 id="toc_16">4.2 Getters and setters</h3>

<p><strong>Getters</strong> and <strong>setters</strong> let you, well, <em>get and set things</em>.</p>

<ul>
<li>A Getter&#39;s sole purpose in life is to send back, as a return value, the value of whatever it is that particular Getter is supposed to be Getting.</li>
</ul>

<h3 id="toc_17">4.3 Encapsulation</h3>

<p>By forcing everybody to call a setter method, we can protect variables from unacceptable changes.</p>

<pre><code class="language-java">theCat.height = 0 //yikes! we can&#39;t let this happen

public void setHeight(int ht){
    if (ht&gt;9){ // we put in checks to guarantee a minimum cat height.
        height=ht;
    }
}
</code></pre>

<p>An <strong>encapsulation</strong> <em>starter</em> rule of thumb: <u>mark your instances variables <strong><em>private</em></strong>, and provide <strong><em>public</em></strong> getters and setters for access control.</u></p>

<ul>
<li>Encapsulations puts a force-field around instance variables, so nobody can set them to something <em>inappropriate</em>.</li>
<li>The point to setters (and getters, too) is that <strong><em>you can change your mind later, without breaking anybody else’s code</em></strong>!</li>
</ul>

<pre><code class="language-java">class GoodDog {
    private int size; //Make the instance variable private
    public int getSize() { // make the getter methods public
        return size; 
    }

    public void setSize(int s) {  // make the setter methods public
        size = s; 
    }

    // even though the methods don&#39;t really add new functionality,
    // the cool thing is that you can change your mind later.
    // you can come back and make a method safer, faster, better
    void bark() {
        if (size &gt; 60) { 
            System.out.println(“Wooof! Wooof!”); 
        } else if (size &gt; 14) {
            System.out.println(“Ruff! Ruff!”); } 
        else {
            System.out.println(“Yip! Yip!”); 
        }
    }
}
</code></pre>

<h3 id="toc_18">4.4 Instance variables</h3>

<p>You don&#39;t have to initialize instance variables, because they always have a default value:</p>

<ul>
<li>intergers: 0</li>
<li>floating points: 0.0</li>
<li>booleans: false</li>
<li>references: null</li>
</ul>

<h3 id="toc_19">4.5 Instance and local variables</h3>

<p>The difference between instance and local variables:</p>

<ul>
<li><strong>Instance</strong> variables are declared <u>inside a class</u> but not within a method.</li>
<li><strong>Local</strong> variables are declares <u>within a method</u> .</li>
<li><strong>Local</strong> variables <u>must be initialized</u> before use.</li>
</ul>

<h3 id="toc_20">4.6 Comparing variables</h3>

<p>If you want to know if two objects are <strong>equal</strong>, you need the <code>.equal()</code> method.</p>

<ul>
<li>whether two different objects should be treated as equal depends on what makes sense for that particular object type. (e.g. dog/string)</li>
</ul>

<pre><code class="language-java">String S = &quot;baby&quot;;
S.equal(another_string);
</code></pre>

<p>To see if two reference are the same (which means they refer to the same object on the heap) use the <code>==</code> operator.</p>

<pre><code class="language-text">Foo a = new Foo(); 
Foo b = new Foo(); 
Foo c = a; 
if (a == b) { // false } 
if (a == c) { // true } 
if (b == c) { // false }
</code></pre>

<p>To compare two primitives, use the <code>==</code> operator.</p>

<ul>
<li>Operator <code>==</code> doesn&#39;t care about the size of the variable, so all the extra zeros on the left end don&#39;t matter.</li>
</ul>

<pre><code class="language-java">int a = 3;
byte b = 3;
if (a==b){ //true}
</code></pre>

<h2 id="toc_21">5 Writing a Program</h2>

<ul>
<li><strong>prep code</strong>: a form of pseudocode, to help you focus on the logic without stressing about syntax. 一种伪代码</li>
<li><strong>test code</strong>: a class or methods that will test the real code and validate that it&#39;s doing the right thing. 测试代码</li>
<li><strong>real code</strong>: the actual implementation of the class. 真实代码</li>
</ul>

<p><strong>Extreme Programming</strong>（<a href="https://en.wikipedia.org/wiki/Extreme_programming">极限编程</a>):</p>

<ul>
<li>Write the test code first</li>
<li>Make small, but frequent, releases</li>
<li>Develop in iteration cycles.</li>
</ul>

<h2 id="toc_22">6  Get to know the Java API</h2>

<p><code>ArrayList</code> is a class in the core Java library (the API).</p>

<ul>
<li> <code>boolean add(Object elem)</code>: Adds the objects parameter to the list(return <code>true</code>).</li>
<li> <code>boolean remove(int index)</code>: Removes the object at the index parameter. Returns <code>true</code> if the element was in the list.</li>
<li> <code>boolean remove(Object elem)</code>: Removes this object(if it&#39;s in the ArrayList).</li>
<li> <code>boolean contains(Object elem)</code>: Returns <code>true</code> if there&#39;s a match for the object parameter.</li>
<li> <code>boolean isEmpty()</code>: Returns <code>true</code> if the list has no elements</li>
<li> <code>int indexOf(Object elem)</code>: Returns either the index of the object parameter, or -1</li>
<li> <code>size()</code>: Return the number of elements currently in the list.</li>
<li> <code>Object get(int index)</code>: Return the object currently at the index parameter.</li>
</ul>

<p>You have to know the full name of the class you want to use in your code. You have two options:</p>

<ul>
<li>Import: put an import statement at the top of your source code file:
<ul>
<li><code>import java.util.ArrayList</code></li>
</ul></li>
<li>Type: type the full name everywhere in your code. Each time you use it.
<ul>
<li><code>java.util.ArrayList&lt;Dog&gt; list = new java.util.ArrayList&lt;Dog&gt;();</code></li>
</ul></li>
</ul>

<h2 id="toc_23">7 Inheritance and polymorphism</h2>

<h3 id="toc_24">7.1 overriding</h3>

<p><strong>Overriding</strong>（重写) just means that a subclass redefines one of its inherited methods when it needs to change or extend the behavior of that method.</p>

<p>When one class inherits from another, the subclass inherits from the superclass. In Java, we say that the <strong>subclass extends the superclass</strong>.子类继承自父类。</p>

<p>Instance variables are not overridden because they don&#39;t need to be. They don&#39;t define any special behavior, so a subclass can give an inherited instance variable any value it chooses.实例变量无法被覆盖掉是因为不需要，它们并没有定义特殊的行为。</p>

<p>When you want to know if one thing should extend another, apply the IS-A test.若你想要知道某物是否应该要继承另一物时，则可以用IS-A(是一个)测试来检验。</p>

<p><strong>If class B extends class A, class B IS-A class A.</strong>   如果类B继承类A，那么类B是一个类A。</p>

<p>if your subclass overriding method, you can call the superclass version using the keyword <strong>super</strong>.</p>

<pre><code class="language-java">// this calls the inherited version on roam(),
// then comes back to do your own subclass-specific code
public void roam(){
    super.roam();
    //my own roam stuff
}
</code></pre>

<p>There are four access levels, moving from most restrictive to least, the four access levels are: 四种权限，左边是最受限制的，而越往右边限制程度越小：</p>

<p><strong>prive, default, protected, public</strong></p>

<ul>
<li>public members are inherited. public类型的成员会被继承</li>
<li>private members are not inherited. private类型的成员不会被继承</li>
</ul>

<p>Inheritances lets you guarantee that all classes grouped under a certain supertype have all the methods that the supertype has. In other words, you define a common protocol for a set of classes related through inheritance. 继承让你可以确保某个父类型之下的所有类都会有父类型所持有的全部方法。也就是说，你会通过继承来定义相关类间的共同协议。</p>

<p>when you define a supertype for a group of classes, any subclass of that supertype can be substituted where the supertype is expected.<br/>
当你定义出一组类的父型时，你可以用子型的任何类来填补任何需要或期待父型的位置。</p>

<h3 id="toc_25">7.2 Polymorphism</h3>

<p><strong>With polymorphism, the reference type can be a superclass of the actual object type</strong>. 运用多态时，引用类型可以是实际对象类型的父类。</p>

<pre><code class="language-java">Animal[] animals = new Animal[3];
animals [0] = new Dog();
animals [1] = new Cat();
animals [2] = new Lion();
for (int i=0; i&lt; animals.length; i++) {
    animals[i].eat();
    animals[i].roam();
}
</code></pre>

<p>You can have polymorphic arguments and return types. 参数和返回类型也可以多态。</p>

<pre><code class="language-java">class Vet {
    public void giveShot(Animal a) { 
    // do horrible things to the Animal at 
    // the other end of the ‘a’ parameter 
    a.makeNoise(); 
    }
}

class PetOwner {
    public void start() { 
        Vet v = new Vet(); 
        Dog d = new Dog(); 
        Hippo h = new Hippo(); 
        v.giveShot(d); 
        v.giveShot(h);
}
</code></pre>

<p>If I write my code using polymorphic arguments, where I declare the method parameter as a superclass type, I can pass in any subclass object at runtime. 如果我将程序代码编写使用多态参数，也就是说将参数声明为父类类型，我就可以在运行时传入任何的子类对象。</p>

<p>With polymorphism, you can write code that doesn&#39;t have to change when you introduce new subclass types into the program. 通过多态，你就可以编写出引进新型子类时也不必修改的程序。</p>

<p>There are three things that can prevent a class from being subclassed.</p>

<ul>
<li>A class can be non-public (if you don&#39;t declare the class as public. A non-public class can be subclassed only by classes in the same package as the class. 类可以是非公有的，非公有的类只能被同一个包的类作出子类。</li>
<li>Using keyword modifier <code>final</code> to stop  a class from being subclassed. 使用<code>final</code>修饰符阻止类被继承。</li>
<li>If a class has only <code>private</code> constructors, it can&#39;t be subclassed. 如果类只拥有<code>private</code>的构造程序，它不能被继承。</li>
</ul>

<p>If you want to protect a specific method from being overridden, mark the method with the <code>final</code> modifier. 如果你想要防止特定的方法被覆盖，可以将该方法标识成final表示没有任何的方法可以被覆盖。</p>

<p><strong>Rules for overriding</strong>:</p>

<ul>
<li>Arguments must be the same, and return types must be compatible. 参数必须要一样，且返回类型必须要兼容</li>
<li>The method can&#39;t be less accessible. 不能降低方法的访问权限</li>
</ul>

<h3 id="toc_26">7.3 Method overloading</h3>

<p><strong>Method overloading</strong>(方法重载) is nothing more than having two methods with the same name but different argument lists. 方法重载就是方法名称相同，但参数列表不同。 </p>

<ul>
<li>Purpose: overloading lets you make multiple versions of a method, with different argument lists, for convenience to the callers.  重载可以有同一方法的多个不同参数列表的版本，方便了调用者。</li>
<li>The return types can be different 返回类型可以不同</li>
<li>You can&#39;t change only the return type 不能只改变返回类型</li>
<li>You can vary the access levels in any direction 可以更改访问权限</li>
</ul>

<h2 id="toc_27">8 Interfaces and abstract classes</h2>

<p>What&#39;s an interface? it&#39;s a 100% abstract class. <br/>
What&#39;s an abstract class? it&#39;s a class that can&#39;t be instantiated.</p>

<h3 id="toc_28">8.1 Abstract classes</h3>

<p>Here&#39;s where it gets weird:</p>

<pre><code class="language-text">Animal anim = new Animal(); 
</code></pre>

<p>There two are the same type, but what the heck does an Animal object look like?</p>

<p><strong>Some classes just should not be instantiated!</strong><br/>
How?  By marking the class as <strong>abstract</strong>, the compiler will stop any code, anywhere, from ever creating an instance of that type. i.e. prevent a class from ever being instantiated.</p>

<p>Making a class abstract before the class declaration:</p>

<pre><code class="language-java">abstract class Caine extends Animal {
    public void roam() {}
}
</code></pre>

<p>When you&#39;re designing your class inheritance structure, you have to decide which classes are <em>abstract</em> and which are <em>concrete</em>. </p>

<ul>
<li><strong>Concrete</strong> classes are those that are specific enough to be instantiated. </li>
<li>A <strong>concrete</strong> class just means that it&#39;s OK to make objects of that type.</li>
<li>An <strong>abstract class</strong> has virtually no use, no value, no purpose in life, unless it is extended.</li>
</ul>

<h3 id="toc_29">8.2 Abstract methods</h3>

<p>An <strong>abstract method</strong> means the method must be overriden, whereas an abstract class means the class must be extended.</p>

<ul>
<li>there isn&#39;t any code that would make sense in the abstract method, you won&#39;t put in a method body. e.g. <code>public abstract void eat()</code>.</li>
<li>If you declare an abstract method, you must mark the class abstract as well. You can&#39;t have an abstract method in a non-abstract class.</li>
<li>You must implement all abstract methods.</li>
</ul>

<h3 id="toc_30">8.3 The ultimate superclass: Object</h3>

<p>Every class in Java extends class Object. Class Object is the mother of all classes; it&#39;s the superclass of everything. </p>

<ul>
<li>Any class that doesn&#39;t <em>explicitly</em> extend another class, <em>implicitly</em> extends Object.</li>
</ul>

<p>Methods of Object class:</p>

<ul>
<li><code>equals()</code>: tell you if two objects are considered equal.</li>
<li><code>getClass()</code>: Gives you back the class that object was instantiated from.</li>
<li><code>hashCode()</code>: Prints out a hashcode for the object</li>
<li><code>toString()</code>: Prints out a String message with the name of the class and some other number we rarely care about.</li>
</ul>

<p>Object is a <strong>non-abstract</strong> class because it&#39;s got method implementation code that all classes can inherit and use out-of-box, without having to override the methods.</p>

<p>The Object class serves two main purpose:</p>

<ul>
<li>to act as a polymorphic type for methods that need to work on any class that you or anyone else makes 作为方法的多态类型</li>
<li>to provide real method code that all objects in Java need at runtime (and putting them in class Object means all other classes inherit them).提供Java在执行期堆任何对象都有需要的实现方法代码。</li>
</ul>

<h3 id="toc_31">8.4 Using polymorphic references of type Object has a price</h3>

<p>When you put an object into an <code>ArrayList&lt;Dog&gt;</code>, it goes in as a Dog, and comes out as a Dog:</p>

<pre><code class="language-java">// Make an ArrayList declared to hold Dog objects.
ArrayList&lt;Dog&gt; myDogArrayList = new ArrayList&lt;Dog&gt;();
// Make a Dog
Dog aDog = new Dog();
// Add the Dog to the list
myDogArrayList.add(aDog);
//Assign the Dog from the list to a new Dog reference variable
Dog d = myDogArrayList.get(0);
</code></pre>

<p><strong>Everything comes out of an <code>ArrayList&lt;Object&gt;</code> as a reference of type Object, regardless of what the actual object is.</strong> 任何从<code>ArrayList&lt;Object&gt;</code>取出的东西都会被当作Object类型的引用，而不管它原来是什么。</p>

<pre><code class="language-java">// make an ArrayList declared to hold any type of Object
ArrayList&lt;Object&gt; myDogArrayList = new ArrayList&lt;object&gt;()
// make a Dog
Dog aDog = new Dog();
// Add the Dog to the list
myDogArrayList.add(aDog);
// No!! Won&#39;t compile!! the get() method returns type Object.
// The compiler knows only that the object inherits from Object,
// but it doesn&#39;t know it&#39;s a Dog!!
Dog d = myDogArrayList.get(0)
</code></pre>

<p><strong>The compiler decides whether you can call a method based on the <u>reference type</u> , not the actual object type.</strong></p>

<pre><code class="language-java">Object o = al.get(index);
// Class Object has a hashCode() method
// so you can call that method on any object in Java
int i = o.hashCode();
// Can&#39;t do this!! the Object class  has no idea what it means to bark().
o.bark();
</code></pre>

<p><img src="media/15321391987415/method%20based%20on%20the%20reference%20type.png" alt="method based on the reference type"/></p>

<p>If you&#39;re sure the object is really a Dog, you can make a new Dog reference to it by copying the Object reference, and forcing that copy to go into a Dog reference variable, using a <code>cast (Dog)</code>.</p>

<pre><code class="language-java">Object o = al.get(index);
// cast the Object back to a Dog we know is there.
Dog d = (Dog) o;
d.roam();
</code></pre>

<p>If you&#39;re not sure it&#39;s a Dog, you can use the <code>instanceof</code> operator to check.</p>

<pre><code class="language-java">if (o instanceof Dog) {
    Dog d = (Dog) o;
}
</code></pre>

<h3 id="toc_32">8.5 Interface</h3>

<p>Questions: what if you want to add Dog some Pet behaviors?</p>

<ul>
<li><p>Option one: We take the easy path, and put pet method in class Animal.</p>
<ul>
<li>Pros: All the Animals will instantly inherit the pet behaviors. We won&#39;t have to touch the existing Animal subclasses at all.</li>
<li>Cons: Some animals like lion, wolf are not a pet. Non-pet Animals running around with pet methods.</li>
</ul></li>
<li><p>Option two: We start with option one, putting the pet methods in class Animal, but we make the methods abstract.</p>
<ul>
<li>Pros: All classes must override the methods, but they can make the methods &quot;do-nothings&quot;.</li>
<li>Cons: Waste a lot of time to implement every concrete Animal subclasses.</li>
</ul></li>
<li><p>Options three: Put the pet methods Only in the classes where they belong.</p>
<ul>
<li>Pros: The methods are where they belong, and only where they belong.</li>
<li>Cons: Firstly, you&#39;d have to agree to a protocol, and all programmers of pet Animal classes now and in the future would have to know about the protocol. Secondly, you don&#39;t get to use polymorphism for the pet methods </li>
</ul></li>
</ul>

<p>It looks like we need two superclasses at the top.<br/>
<img src="media/15321391987415/it%20looks%20like%20we%20need%20two%20superclasses%20at%20the%20top.png" alt="it looks like we need two superclasses at the top"/></p>

<p>It’s called &quot;<strong>multiple inheritance</strong>&quot;(多重继承) and it can be a Really Bad Thing. Because multiple inheritance has a problem known as <strong>The Deadly Diamond of Death</strong>(致命的死亡砖石)</p>

<p><img src="media/15321391987415/deadly_diamond_of_death.png" alt="deadly_diamond_of_death"/></p>

<p>Java的方案: Interface!!!</p>

<ul>
<li>A Java <strong>interface</strong>(接口) solves multiple inheritance problem by giving you much of the polymorphic benefits of multiple inheritance without the pain and suffering from the Deadly Diamond of Death.</li>
</ul>

<p>How?</p>

<ul>
<li>surprisingly simple: <strong><em>make all the methods abstract</em></strong></li>
<li>A Java interface is like a 100% pure abstract class.</li>
</ul>

<p>To define an interface:</p>

<pre><code class="language-java">//use the keyword &quot;interface&quot; instead of &quot;class&quot;
public interface Pet {}
</code></pre>

<p>To implement an interface:</p>

<pre><code class="language-java">// Use the keyword &quot;implements&quot; followed by the interface name.
public class Dog extends Canine implements Pet {}
</code></pre>

<p>A class can implement <em>multiple</em> interfaces!</p>

<pre><code class="language-java">public class Dog extends Animal implements Pet, Saveable, Paintable {}
</code></pre>

<p>Classes from <em>different</em> inheritance trees can implement the <em>same</em> interface.</p>

<p><img src="media/15321391987415/Classes%20from%20different%20inheritance%20trees%20can%20implement%20the%20same%20interface..png" alt="Classes from different inheritance trees can implement the same interface."/></p>

<p>How do you know whether to make a class, subclass, an abstract class, or an interface?</p>

<ul>
<li>Make a class that doesn’t extend anything (other than Object) when your new class doesn’t pass the IS-A test for any other type.</li>
<li>Make a subclass (in other words, extend a class) only when you need to make a <strong><em>more specific</em></strong> version of a class and need to override or add new behaviors.</li>
<li>Use an abstract class when you want to define a <strong><em>template</em></strong> for a group of subclasses, and you have at least some implementation code that all subclasses could use. Make the class abstract when you want to guarantee that nobody can make objects of that type.</li>
<li>Use an interface when you want to define a <strong><em>role</em></strong> that other classes can play, regardless of where those classes are in the inheritance tree.</li>
</ul>

<h3 id="toc_33">8.6 Using <code>super</code></h3>

<p>What if you don&#39;t want to <em>replace</em> the method with an override in a concrete subclass, but you just want to <em>add</em> to it with some additional specific code?</p>

<pre><code class="language-java">abstract class Report { 
    void runReport() { 
        // set-up report 
    } 
    void printReport() { 
    // generic printing 
    } 
}

class BuzzwordsReport extends Report {
    void runReport() {
        // call superclass version, then come back and do some      
        // subclass-specific stuff
        super.runReport();
        buzzwordCompliance(); 
        printReport();
    }
    void buzzwordCompliance() {...}
}
</code></pre>

<p><img src="media/15321391987415/usage%20of%20Super.png" alt="usage of Supe"/></p>

<h2 id="toc_34">9 Constructors and garbage collection</h2>

<h2 id="toc_35">10 Numbers and statics</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/4/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='programming_language.html'>编程语言</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="exceptional_control_flow.html">
                
                  <h1>CSAPP - 异常控制流</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">1 异常</a>
<ul>
<li>
<a href="#toc_1">1.1 异常的处理</a>
</li>
<li>
<a href="#toc_2">1.2 异常的类别</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">2 进程</a>
<ul>
<li>
<a href="#toc_4">2.1 逻辑控制流</a>
</li>
<li>
<a href="#toc_5">2.2 并发流</a>
</li>
<li>
<a href="#toc_6">2.3 私有地址空间</a>
</li>
<li>
<a href="#toc_7">2.4 用户模式和内核模式</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">3 系统调用错误处理</a>
</li>
<li>
<a href="#toc_9">4 进程控制</a>
<ul>
<li>
<a href="#toc_10">4.1 获取进程ID</a>
</li>
<li>
<a href="#toc_11">4.2 创建和终止进程</a>
</li>
<li>
<a href="#toc_12">4.3 回收子进程</a>
</li>
<li>
<a href="#toc_13">4.4 进程休眠</a>
</li>
<li>
<a href="#toc_14">4.5  加载并运行程序</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">5 信号</a>
<ul>
<li>
<a href="#toc_16">5.1 发送/接收信号</a>
</li>
<li>
<a href="#toc_17">5.2 发送信号</a>
</li>
<li>
<a href="#toc_18">5.3 接收信号</a>
</li>
<li>
<a href="#toc_19">5.4 阻塞信号和进程回收</a>
<ul>
<li>
<a href="#toc_20">5.4.1 隐式阻塞机制</a>
</li>
<li>
<a href="#toc_21">5.4.2 显式阻塞机制</a>
</li>
</ul>
</li>
<li>
<a href="#toc_22">5.5 信号处理程序</a>
</li>
</ul>
</li>
<li>
<a href="#toc_23">7 操作进程的工具</a>
</li>
</ul>


<p>从给处理器加电开始，直到你断电为止，程序计数器假设成一个值的序列</p>

<p>\[a_0, a_1, ..., a_{n-1}\]</p>

<p>其中，每个\(a_k\)是某个相应的指令\(I_k\)的 <u>地址</u> 。每次从\(a_k\)到\(a_{k+1}\)的过渡称为<strong>控制转移</strong>(control transfer)。这样的控制转移序列叫做处理器的<strong>控制流</strong>(control flow)。</p>

<p>现在系统通过使控制流发生突变来应对系统状态的变化(eg.缺页异常，网络等待)，把这些突变称为<strong>异常控制流</strong>(Exceptional Control Flow, ECF)。</p>

<h2 id="toc_0">1 异常</h2>

<h3 id="toc_1">1.1 异常的处理</h3>

<p>系统为每<strong>类</strong>可能的异常都分配了一个唯一的非负整数的<strong>异常号</strong>(exception number)。在系统启动时，操作系统分配和初始化一张称为<strong>异常表</strong>的跳转表，使得表目\(k\)包含异常\(k\)的处理程序的地址。</p>

<p><img src="media/15312146721582/%E5%BC%82%E5%B8%B8%E8%A1%A8.png" alt="异常表"/></p>

<p>当检测到发生了一个事件，并且确定了相应的异常号\(k\)，处理器触发异常，执行间接过程调用，通过异常表的表目\(k\)，转到相应的处理程序。</p>

<h3 id="toc_2">1.2 异常的类别</h3>

<p>异常(exceptions)可以分为四类：中断(interrupt)、陷阱(trap)、故障(fault)和终止(abort)。<br/>
<img src="media/15312146721582/Exceptions.png" alt="Exceptions"/></p>

<ul>
<li><strong>中断</strong>是异步发生的，是来自处理器外部的I/O设备的信号的结果。</li>
<li><strong>陷阱</strong>是有意的异常，是执行一条指令的结果。
<ul>
<li>其用途是在用户程序和内核之间提供一个像过程一样的接口(系统调用)</li>
</ul></li>
<li><strong>故障</strong>是由错误情况引起的，可能能够被故障处理程序修正。
<ul>
<li>例如缺页异常</li>
</ul></li>
<li><strong>终止</strong>是不可恢复的致命错误造成的结果，通常是一些硬件错误。<br/></li>
</ul>

<h2 id="toc_3">2 进程</h2>

<p>进程(Process)的经典定义就是 <u>一个执行中程序的实例</u> (A process is a program in execuation) 。系统中的每个程序都运行在某个进程的上下文(context)中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p>

<p>进程提供了应用程序两个关键抽象：</p>

<ul>
<li>一个<strong>独立</strong>的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。</li>
<li>一个<strong>私有</strong>的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。</li>
</ul>

<h3 id="toc_4">2.1 逻辑控制流</h3>

<p><strong>逻辑控制流</strong>(Logical Control Flow，简称逻辑流)是PC值的序列。</p>

<h3 id="toc_5">2.2 并发流</h3>

<p>一个逻辑流的执行在时间上与另一个流重叠，称为<strong>并发流</strong>(concurrent flow)，这两个流被称为<strong>并发地运行</strong>。</p>

<h3 id="toc_6">2.3 私有地址空间</h3>

<p>进程为每个程序提供它自己的<strong>私有地址空间</strong>。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。</p>

<h3 id="toc_7">2.4 用户模式和内核模式</h3>

<p>处理器通常是用某个控制寄存器中的一个<strong>模式位</strong>(mode bit)来控制用户/内核模式。当设置了模式位时，进程就运行在<strong>内核模式</strong>中，否则运行在<strong>用户模式</strong>中。</p>

<p>运行在内核模式的进程可以执行指令集中的任何指令，可以访问任何内存位置。用户模式中的进程不允许执行特权指令，也不允许直接引用地址空间中内核区的代码和数据。</p>

<h2 id="toc_8">3 系统调用错误处理</h2>

<h2 id="toc_9">4 进程控制</h2>

<p>进程控制包括获取进程ID、创建和终止进程、回收子进程、让进程休眠、加载并运行程序等。这一节将描述Unix提供了控制进程的系统调用。</p>

<h3 id="toc_10">4.1 获取进程ID</h3>

<p>每一个进程都有一个唯一的整数(非零)进程ID(PID)。<code>getpid</code>函数返回调用进程的PID。<code>getppid</code>函数返回它的父进程的PID。</p>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t getpid(void);
pit_t getppid(void);
</code></pre>

<h3 id="toc_11">4.2 创建和终止进程</h3>

<p><strong>父进程</strong>通过调用fork函数创建一个新的运行的<strong>子进程</strong>。</p>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

pid_t fork(void);
</code></pre>

<p>新创建的子进程几乎但不完全与父进程相同：</p>

<ul>
<li><strong>相同但是独立的地址空间</strong>：子进程获得父进程虚拟地址空间的一份副本</li>
<li><strong>共享文件</strong>：子进程获得父进程打开文件描述符相同的副本</li>
<li>子进程与父进程pid不同</li>
</ul>

<h3 id="toc_12">4.3 回收子进程</h3>

<p>进程在终止后，并不会被内核从系统中清除，而是保持这种状态，直到被它的父进程<strong>回收</strong>(reaped)。</p>

<ul>
<li>一个终止了但还未被回收的进程称为<strong>僵死进程</strong>(zombie)。</li>
<li>即使僵死进程没有运行，它仍然消耗系统的内存资源。</li>
</ul>

<p>通过调用<code>waitpid</code>函数来等待子进程终止或者停止。</p>

<h3 id="toc_13">4.4 进程休眠</h3>

<p><code>sleep</code>函数将一个进程挂起一段制定的时间。</p>

<pre><code class="language-c">#include &lt;unistd.n&gt;
unsigned int sleep(unsigned int secs);
</code></pre>

<h3 id="toc_14">4.5  加载并运行程序</h3>

<p><code>execve</code>函数在当前进程的上下文中加载并运行一个新程序。</p>

<ul>
<li><code>execve</code>调用一次并从不返回。</li>
</ul>

<h2 id="toc_15">5 信号</h2>

<p>Linux<strong>信号</strong>，通知进程系统中发生一个某种类型的事件。每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。下面是Linux系统上常见的信号：</p>

<p><strong>常见的信号</strong>：</p>

<table>
<thead>
<tr>
<th>编号</th>
<th>名称</th>
<th>默认动作</th>
<th>对应事件</th>
</tr>
</thead>

<tbody>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>终止</td>
<td>来自键盘的中断CTRL+C</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>终止</td>
<td>来自键盘的退出CTRL+\</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>终止</td>
<td>杀死程序 <code>\bin\kill -9</code></td>
</tr>
<tr>
<td>11</td>
<td>SIGSEGV</td>
<td>终止并转储内存</td>
<td>段故障(无效的内存引用)</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>终止</td>
<td>软件终止信号<code>\bin\kill</code></td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>忽略</td>
<td>子进程停止或终止</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>忽略</td>
<td>继续进程如果该进程停止</td>
</tr>
<tr>
<td>20</td>
<td>SIGTSTP</td>
<td>停止直到下一个SIGCONT</td>
<td>用户输入CTRL+Z</td>
</tr>
</tbody>
</table>

<p>详细信息可以通过<code>man 7 signal</code>查询。</p>

<h3 id="toc_16">5.1 发送/接收信号</h3>

<p>传送一个信号到目的进程由发送、接收信号两个步骤组成：</p>

<ul>
<li>发送信号。内核通过更新目的进程上下文中的某个状态，发送(递送)一个信号给目的进程。</li>
<li>接收信号。当目的进程被内核强迫已某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为<strong>信号处理程序</strong>的用户层函数捕获这个信号。</li>
</ul>

<h3 id="toc_17">5.2 发送信号</h3>

<p>发送信号可以由以下原因引起：</p>

<ul>
<li>用户：用户能够通过输入<code>CTRL+c</code>(<code>SIGINT</code>)、<code>Ctrl+z</code>(<code>SIGTSTP</code>)，或者是终端驱动程序分配给信号控制字符的其他任何键来请求内核产生信号；</li>
<li>内核：当进程执行出错时，内核会给进程发送一个信号，例如非法段存取(内存访问违规)、浮点数溢出等；</li>
<li>进程：一个进程可以通过系统调用kill给另一个进程或自己发送信号。</li>
</ul>

<h3 id="toc_18">5.3 接收信号</h3>

<p>当内核把进程\(p\)从内核模式切换到用户模式时，它会检查进程\(p\)的未被阻塞的待处理信号的集合(<code>pending&amp;~blocked</code>,见下文)，如果集合非空，那么内核强制\(p\)接收信号，触发进程采取某种行为。</p>

<p>进程接收到信号以后，可以有如下3种选择进行处理：</p>

<ul>
<li>接收默认处理：接收默认处理的进程通常会导致进程本身消亡。例如连接到终端的进程，用户按下CTRL+c，将导致内核向进程发送一个SIGINT的信号，进程如果不对该信号做特殊的处理，系统将采用默认的方式处理该信号，即终止进程的执行；</li>
<li>忽略信号：进程可以通过代码，显示地忽略某个信号的处理，例如：<code>signal(SIGINT,SIGDEF)</code>；但是某些信号是不能被忽略的，</li>
<li>捕获信号并处理：当接收到信号时，由信号处理程序自动捕获并且处理信号。</li>
</ul>

<pre><code class="language-c">sighandler_t signal(int signum, sighandler_t handler);
</code></pre>

<p>有两个信号既不能被忽略也不能被捕获，它们是<code>SIGKILL</code>和<code>SIGSTOP</code>。即进程接收到这两个信号后，只能接受系统的默认处理，即终止线程。</p>

<h3 id="toc_19">5.4 阻塞信号和进程回收</h3>

<p>一个发出而没有被接受的信号叫做<strong>未处理信号</strong>（Pending Signal）。进程可以选择阻塞（Block）某个信号。被阻塞的信号产生时将保持在未处理状态，直到进程解除对此信号的阻塞，才执行接收的动作。阻塞和忽略是不同的，<strong>只要信号被阻塞就不会接收</strong>，而忽略是在接收之后可选的一种处理动作。</p>

<p>Linux提供阻塞信号的隐式和显式机制:</p>

<ul>
<li><strong>隐式阻塞机制</strong>：内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。如果在进程解除对某信号的阻塞之前这种信号产生过多次，只计一次。因为每个信号只有一个bit的未处理标志(如下图)，非0即1，不记录该信号产生了多少次，阻塞标志也是这样表示的。</li>
<li><strong>显式阻塞机制</strong>：应用<code>sigprocmask</code>函数，明确地阻塞和解除阻塞选定的信号。</li>
</ul>

<p>内核为每个进程在<strong>pending位向量</strong>中维护着待处理信号的集合，而在<strong>blocked位向量</strong>中维护着被阻塞的信号集合。信号在内核中的表示可以看作是这样的：</p>

<p><img src="media/15312146721582/15327695584336.png" alt=""/></p>

<p>每个信号都有两个标志位分别表示阻塞和未处理，还有一个函数指针表示处理动作。信号产生时，内核在进程控制块中设置该信号的未处理标志，直到信号接收才清除该标志。在上图的例子中，</p>

<ul>
<li>SIGHUP信号未阻塞也未产生过，当它接收时执行默认处理动作。</li>
<li>SIGINT信号产生过，但正在被阻塞，所以暂时不能接收。虽然它的处理动作是忽略，但在没有解除阻塞之前不能忽略这个信号，因为进程仍有机会改变处理动作之后再解除阻塞。</li>
<li>SIGQUIT信号未产生过，一旦产生SIGQUIT信号将被阻塞，它调用信号处理程序<code>sighandler</code>。</li>
</ul>

<h4 id="toc_20">5.4.1 隐式阻塞机制</h4>

<p>当多个未处理信号(<code>pending signal</code>)到达时，由于信号并不会产生排队等待这样的情况，所以产生的效果仅相当于一个未处理信号(也就是对应的<code>pending</code>位标记为1，例如上图中的<code>SIGINT</code>信号)。</p>

<p>这样带来几个问题：</p>

<ul>
<li>不能用信号来对其他进程中发生的事件计数，这是显而易见的</li>
<li>在回收子进程时，要回收尽可能多的子进程。例如下面这个例子。</li>
</ul>

<pre><code class="language-c">void handler1(int sig)   
{  
    pid_t pid;  
  
    if ((pid = waitpid(-1, NULL, 0)) &lt; 0)  
        unix_error(&quot;waitpid error&quot;);  
    printf(&quot;Handler reaped child %d\n&quot;, (int)pid);  
    Sleep(2);  
    return;  
}  

/* $begin signal2 */
void handler2(int sig) 
{
    int olderrno = errno;

    while (waitpid(-1, NULL, 0) &gt; 0) {
        Sio_puts(&quot;Handler reaped child\n&quot;);
    }
    // waitpid()函数有可能因为找不到子进程而报ECHILD错误
    if (errno != ECHILD)
        Sio_error(&quot;waitpid error&quot;);
    Sleep(1);
    errno = olderrno;
}
/* $end signal2 */

int main() 
{
    int i, n;
    char buf[MAXBUF];

    if (signal(SIGCHLD, handler2) == SIG_ERR) //handler2 或者 handler1
        unix_error(&quot;signal error&quot;);

    /* Parent creates children */
    for (i = 0; i &lt; 3; i++) {
        if (Fork() == 0) {
            printf(&quot;Hello from child %d\n&quot;, (int)getpid());
            exit(0);
        }
    }

    /* Parent waits for terminal input and then processes it */
    if ((n = read(STDIN_FILENO, buf, sizeof(buf))) &lt; 0)
        unix_error(&quot;read&quot;);

    printf(&quot;Parent processing input\n&quot;);
    while (1)
        ;

    exit(0);
}
</code></pre>

<p>在上面这个例子中，父进程创建一些子进程，这些子进程各自独立运行一段时间，然后终止。用<code>SIGCHLD</code>处理程序来回收子进程，其中<code>handler1</code>是错误的，会产生僵死子进程。<code>handler2</code>是安全的。原因是在<code>handler1</code>中，可能存在子进程先被执行，产生<code>SIGCHLD</code>信号；但是在子进程还未被回收之前，又有多个子进程被执行，产生多个<code>SIGCHLD</code>信号。于是多余的未处理<code>SIGCHLD</code>信号就被抛弃，只相当于一个<code>SIGCHLD</code>信号。最终会造成有的子进程未被回收，产生僵死子进程。</p>

<p>执行的可能结果如下，可以看到父进程只回收了两个子进程。</p>

<pre><code class="language-text">Hello from child 5617
Hello from child 5616
Hello from child 5618
Handler reaped child
Handler reaped child

Parent processing input
</code></pre>

<h4 id="toc_21">5.4.2 显式阻塞机制</h4>

<p>有时候不希望在发送信号后就立即去接收、处理信号，同时也不希望忽略该信号，那么可以通过<code>sigprocmask</code>显式地阻塞信号从而实现延迟接收信号。</p>

<p>函数<code>sigprocmask</code>可以更改当前阻塞的信号集合(即blocked位向量):</p>

<pre><code class="language-c">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
</code></pre>

<p>其具体行为依赖于how值：</p>

<pre><code class="language-text">SIG_BLOCK, blocked = blocked | set //添加set信号
SIG_UNBLOCK, blocked = blocked &amp; ~set //删除set信号
SIG_SETMASK, block = set //设置set信号为阻塞的信号
</code></pre>

<p>阻塞的信号集合其实就是一个无符号整型数组(在x86-64上，数组长度是16)。</p>

<pre><code class="language-c">/* A `sigset_t&#39; has a bit for each signal.  */
# define _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))
typedef struct
{
    unsigned long int __val[_SIGSET_NWORDS];
} sigset_t;
</code></pre>

<p>还有其他的一些函数可以对信号集进行操作：</p>

<pre><code class="language-c">int sigfillset(sigset_t *set); // 信号集初始化, 然后把所有的信号加入到此信号集里
int sigemptyset(sigset_t *set); //信号集初始化为空
int sigaddset(sigset_t *set, int signo); //将信号signo添加到信号集中  
</code></pre>

<p>下面看个例子, 是一个具有细微同步错误的SHELL程序。如果子进程在父进程能够开始运行前就结束了，那么<br/>
<code>addjob()</code> 和 <code>deletejob()</code> 会以错误的方式被调用。这个程序希望父进程在一个作业列表中记录着它的当前子进程，每个作业条目。 <code>addjob()</code> 和 <code>deletejob()</code> 分别想这个作业列表添加和从中删除作业。当父进程创建一个新的子进程时，它就把这个子进程添加到作业列表中。当父进程在<code>SIGCHLD</code> 处理程序中回收一个终止的（僵死）子进程时，它就从作业列表中删除这个子进程。乍一看，这段代码是对的。不幸的是，可能发生下面的情况：</p>

<ul>
<li>1. 父进程执行<code>fork()</code>，内核调度新创建的子进程运行，而不是父进程</li>
<li>2. 在父进程能够再次运行之前，子进程就终止，并且变成一个僵死进程，使得内核传递一个<code>SIGCHLD</code>信号给父进程</li>
<li>3. 后来，当父进程再次变成可运行但又在它执行之前，内核注意到待处理的<code>SIGCHLD</code>信号，并通过在父进程中运行处理程序接收这个信号</li>
<li>4. 处理程序回收终止的子进程，并调用<code>deletejob()</code>，这个函数什么都不做，因为父进程还没有把该子进程添加到列表中</li>
<li>5. 在处理程序运行结束后，内核运行父进程，父进程从<code>fork()</code>返回，通过调用<code>addjob()</code> 错误地把（不存在的）子进程添加到作业列表中</li>
</ul>

<pre><code class="language-c">void handler(int sig)
{
        pid_t pid;
        while ((pid = waitpid(-1, NULL, 0)) &gt; 0) /* Reap a zombie child */
                deletejob(pid); /* Delete the child from the job list */
        if (errno != ECHILD)
                unix_error(&quot;waitpid error&quot;);
}

int main(int argc, char **argv)
{
        int pid;

        Signal(SIGCHLD, handler);
        initjobs();             /* Initialize the job list */

        while (1) {
                /* Child process */
                if ((pid = Fork()) == 0) {
                        Execve(&quot;/bin/date&quot;, argv, NULL);
                }

                /* Parent process */
                addjob(pid);    /* Add the child to the job list */
        }

        exit(0);
}
</code></pre>

<p>正确的做法应该如下,  通过在调用 <code>fork()</code> 之前，阻塞 <code>SIGCHLD</code> 信号，然后在我们调用了 <code>addjob()</code> 之后就取消阻塞这些信号，我们保证了在子进程被添加到作业列表之后回收该子进程。注意，子进程继承了它们父进程的被阻塞集合，所以我们必须在调用 <code>execve()</code> 之前，小心地解除子进程中阻塞的 <code>SIGCHLD</code> 信号。这样，父进程保证在相应的 <code>deletejob()</code> 之前执行 <code>addjob()</code>。</p>

<pre><code class="language-c">int main(int argc, char **argv)
{
    int pid;
    sigset_t mask_all, mask_one, prev_one;

    Sigfillset(&amp;mask_all);
    Sigemptyset(&amp;mask_one);
    Sigaddset(&amp;mask_one, SIGCHLD);
    Signal(SIGCHLD, handler);
    initjobs(); /* Initialize the job list */

    while (1) {
        Sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); /* Block SIGCHLD */
        if ((pid = Fork()) == 0) { /* Child process */
            Sigprocmask(SIG_SETMASK, &amp;prev_one, NULL); /* Unblock SIGCHLD */
            Execve(&quot;/bin/date&quot;, argv, NULL);
        }
        Sigprocmask(SIG_BLOCK, &amp;mask_all, NULL); /* Parent process */  
        addjob(pid);  /* Add the child to the job list */
        Sigprocmask(SIG_SETMASK, &amp;prev_one, NULL);  /* Unblock SIGCHLD */
    }
    exit(0);
}
</code></pre>

<h3 id="toc_22">5.5 信号处理程序</h3>

<p>信号处理程序(signal handler)是重要且棘手的一个问题。其难点在：</p>

<ul>
<li>处理程序与主程序并发运行，共享同样的全局变量，因此可能与主程序和其他处理程序相互干扰；</li>
<li>如何以及何时接收信号的规则常常违背人的直觉。</li>
</ul>

<h2 id="toc_23">7 操作进程的工具</h2>

<p>Linux系统提供了大量的监控和操作进程的有用工具。</p>

<ul>
<li>STRACE： 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹</li>
<li>PS：列出当前系统中的进程(包括僵尸进程)</li>
<li>TOP: 打印出关于当前进程资源使用的信息</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/1/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="introduction_to_computer_system_CMU.html">
                
                  <h1>CMU 15-213 Introduction to Computer Systems</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>CMU 15-213 <code>Introduction to Computer Systems</code>是最受欢迎的计算机课之一。与这门课对应的课本CSAPP被各大名校所采用，也被无数学生拜读。课程内容涉及广泛、由浅入深，是进入计算机科学的最佳课程，也是各种击破BAT笔试题的必备良药(<a href="https://book.douban.com/review/5627139/">这篇帖子描述了笔试题所对应的章节</a>)。</p>

<p>非常幸运的是，CMU在网上分享了几乎所有课程资料，想学习课程的同学几乎可以和CMU学生一样学习该课程。</p>

<p>课程资料：</p>

<ul>
<li><a href="https://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx#folderID=%22b96d90ae-9871-4fae-91e2-b1627b43e25e%22&amp;sortColumn=0&amp;sortAscending=true">课程视频</a></li>
<li><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/schedule.html">课程主页</a>，包括了PPT，代码</li>
<li><a href="http://csapp.cs.cmu.edu">课本CSAPP主页</a>，包括了Lab资源。</li>
</ul>

<p>Lab攻略:</p>

<ul>
<li><a href="http://larryim.cc/wiki/2017/12/30/CSAPP-Attack-Lab/">Lab3 Attack Lab</a></li>
<li><a href="http://larryim.cc/wiki/2017/12/30/CSAPP-Cache-Lab/">Lab4 Cache Lab</a></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/12/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="os-concepts-os-structures.html">
                
                  <h1>Operating System Concepts 2 - Operating System structures</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">Operating system service</a>
</li>
<li>
<a href="#toc_1">User Interface</a>
</li>
<li>
<a href="#toc_2">System call</a>
<ul>
<li>
<a href="#toc_3">API</a>
</li>
<li>
<a href="#toc_4">Types of system calls</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">System Service</a>
</li>
<li>
<a href="#toc_6">OS Design and Implementation</a>
</li>
<li>
<a href="#toc_7">Operating system structure</a>
<ul>
<li>
<a href="#toc_8">Monolithic structure</a>
</li>
<li>
<a href="#toc_9">Layered</a>
</li>
<li>
<a href="#toc_10">Microkernel</a>
</li>
<li>
<a href="#toc_11">Modules</a>
</li>
<li>
<a href="#toc_12">Hybrid systems</a>
</li>
</ul>
</li>
<li>
<a href="#toc_13">System boot</a>
</li>
</ul>


<h2 id="toc_0">Operating system service</h2>

<p>The figure below is a view of the various operating-system services and how they interrelate.</p>

<p><img src="http://or9a8nskt.bkt.clouddn.com/A_view_of_operating_system_services.png" alt="A_view_of_operating_system_services"/></p>

<h2 id="toc_1">User Interface</h2>

<p>There&#39;re mainly three ways for users to interface with the operating system:</p>

<ul>
<li>command interpreter</li>
<li>graphical user interface</li>
<li>touch-screen interface</li>
</ul>

<h2 id="toc_2">System call</h2>

<p>Purpose of System Call: System calls provide an <strong>interface to the services</strong> made available by an operating system.</p>

<h3 id="toc_3">API</h3>

<p>Typically, application developers design programs according to an application programming interface(<strong>API</strong>, 应用程序编程接口) rather than invoking <strong>actual system call</strong>.</p>

<ul>
<li>because even simple program may make heavy use of system call.</li>
<li><strong>program portabilit</strong>y: expect programs to compile and run other system that supports the same API</li>
<li><strong>run-time environment</strong>(RTE, 运行时环境) - the full suit of software needed to execute applications, including its compilers, interpreters, libraries, loaders.</li>
</ul>

<h3 id="toc_4">Types of system calls</h3>

<p>System calls can be grouped roughly into six major categories:<br/>
系统调用可分成六大类：进程控制，文件管理，设备管理，信息维护，通信和保护。</p>

<ul>
<li>process control</li>
<li>file management</li>
<li>device management</li>
<li>information maintenance</li>
<li>communications</li>
<li>protection</li>
</ul>

<p><img src="media/15317361625058/examplesofunixandlinuxsystemcalls.png" alt="Examples of Windows and Unix systemcalls"/></p>

<p>Three ways to pass parameters to the operating system:</p>

<ul>
<li>when less than five parameters, passing the parameters in registers</li>
<li>when more than five parameters, parameters are stored in a block, passing the address of the block in a register</li>
<li>using stack</li>
</ul>

<h2 id="toc_5">System Service</h2>

<p><strong>System services</strong>, also known as <strong>system utilities</strong>, provide a convenient environment for program development and execution.</p>

<h2 id="toc_6">OS Design and Implementation</h2>

<p>One important principle of OS design is <u>the separation of <strong>policy</strong> from <strong>mechanism</strong></u> . Mechanisms determine <strong>how</strong> to do something; policies determine <strong>what</strong> will be done.<br/>
操作系统设计的一个重要原则是策略（policy）和机制（mechanism）的分离。机制决定如何做，策略决定做什么。</p>

<ul>
<li>The separation of policy and mechanism is important for <strong>flexibility</strong>.</li>
</ul>

<h2 id="toc_7">Operating system structure</h2>

<h3 id="toc_8">Monolithic structure</h3>

<p>Operating systems with <strong>monolithic structure</strong> (单体结构) place all of the functionality of kernel into a <strong>single</strong>, <strong>static</strong> binary file that runs in a <strong>single</strong> address space.</p>

<ul>
<li>a common technique for designing operating system</li>
<li>e.g. original Unix operating system ( figure below)</li>
</ul>

<p><img src="http://or9a8nskt.bkt.clouddn.com/traditional_unix_system_structure.png" alt="traditional_unix_system_structure"/></p>

<ul>
<li>e.g. Linux is based on Unix and is structured similarly, as shown in figure below.</li>
</ul>

<p><img src="http://or9a8nskt.bkt.clouddn.com/linux_system_structure.png" alt="linux_system_structure"/></p>

<p>pros</p>

<ul>
<li>simplicity of kernels</li>
<li>a distinct performance advantage</li>
<li>very little overhead in the system-call interface</li>
<li>fast communication within the kernel</li>
</ul>

<p>cons</p>

<ul>
<li>difficult to implement and extend</li>
</ul>

<h3 id="toc_9">Layered</h3>

<p>A <strong>loosely coupled</strong> (松耦合) system is divided into separate, smaller components that have specific and limited functionality (<strong>modular</strong> approach). All these components together comprise the kernel .</p>

<ul>
<li>changes in one component affect only that component</li>
</ul>

<p>A system can be made modular in many ways.</p>

<ul>
<li>one way is the layered approach.</li>
</ul>

<p>For the <strong>layered operating system</strong> (层次式操作系统), it is broken into a number of layers.</p>

<ul>
<li>The bottom layer is the hardware; the highest is the user interface.</li>
<li>low-level layers can be invoked by higher-level layers</li>
</ul>

<p>pros</p>

<ul>
<li>simplicity of construction and debugging
<ul>
<li>each layer is implemented only with operations provided by lower-level layers. </li>
<li>higher-level layers can be debugged without any concern for the lower-level layers</li>
</ul></li>
</ul>

<p>cons</p>

<ul>
<li>difficulty of defining the functionality of each layer</li>
<li>poor performance
<ul>
<li>overhead of requiring a user program to traverse through multiple layers to obtain an operating-system service </li>
</ul></li>
</ul>

<p>Used in computer networks and web applications</p>

<p><img src="http://or9a8nskt.bkt.clouddn.com/A_layed_Operating_System.png" alt="A_layed_Operating_System"/></p>

<h3 id="toc_10">Microkernel</h3>

<p>Another way to modularized the kernel is using microkernel approach (微内核)。</p>

<ul>
<li><strong>removing all nonessential</strong> components from the kernel and implementing them as <strong>user-level</strong> programs the reside in <strong>separate</strong> address spaces.</li>
<li>smaller kernel</li>
</ul>

<p>A typical microkernel shown below.</p>

<p><img src="http://or9a8nskt.bkt.clouddn.com/A_typical_microkernel.png" alt="A_typical_microkernel"/></p>

<p>pros</p>

<ul>
<li>easy to extend the os
<ul>
<li>all new services added to user space do not require modification of the kernel.</li>
<li>when modification of kernel needed, changes tend to be fewer because of small kernel</li>
</ul></li>
<li>more security and reliability
<ul>
<li>since most services are running as user</li>
</ul></li>
</ul>

<p>cons</p>

<ul>
<li>performance may suffer due to increased system function overhead.
<ul>
<li>messages of user-level services to communicate must be copied between the services. </li>
</ul></li>
</ul>

<p>Best-known microkernel os is <strong>Darwin</strong>, the kernel component of the macOS and iOS.  </p>

<h3 id="toc_11">Modules</h3>

<p>Perhaps the best current methodology for operating system design involves using <strong>loadable kernel modules</strong>(LVMs, 可装载内核模块). Here, the kernel has a set of core components and can link in additional services via modules, either at boot time or during run time.</p>

<ul>
<li>design purpose: for the kernel to provide core services, while other services are implemented <strong>dynamically</strong>, as the kernel is running</li>
</ul>

<h3 id="toc_12">Hybrid systems</h3>

<p>In practice, <strong>very few</strong> operating system adopt a single, strictly defined structure. Instead, they <strong>combine different structures</strong><br/>
, resulting in <strong>hybrid systems</strong> that address performance, security, and usability issues.</p>

<p>Architecture of Apple’s macOS and iOS operating systems:<br/>
<img src="http://or9a8nskt.bkt.clouddn.com/Architecture_of_Apple%E2%80%99s_macOS_and_iOS_operating_systems.png" alt="Architecture of Apple’s macOS and iOS operating systems"/></p>

<p>Darwin provides two system-call interfaces: Mach system calls and BSD system calls.</p>

<p>The structure of Darwin:<br/>
<img src="http://or9a8nskt.bkt.clouddn.com/The_structure_of_Darwin.png" alt="The structure of Darwin."/></p>

<p>To address such performance problems, Darwin combines Mach, BSD, the I/O kit, and any kernel extensions into a <strong>single</strong> address space.</p>

<p><a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/Architecture/Architecture.html#//apple_ref/doc/uid/TP30000905-CH1g-CACDAEDC">detailed documents for Darwin kernel</a></p>

<h2 id="toc_13">System boot</h2>

<p>The process of starting a computer by loading the kernel is known as <strong>booting</strong> the system.</p>

<ol>
<li>A small piece of code known as the <strong>bootstrap program</strong>（引导程序） or boot loader locates the kernel.</li>
<li>The kernel is loaded into memory and started.</li>
<li>The kernel initializes hardware.</li>
<li>The root file system is mounted.</li>
</ol>

<p>bootstrap program:</p>

<ul>
<li>usually, bootstrap program located in BIOS( nonvolatile firmware(固件) on motherboard, <a href="https://en.wikipedia.org/wiki/BIOS">wiki</a>)</li>
<li><strong>GRUB</strong> is an open-source bootstrap program for Linux and Unix systems <a href="https://en.wikipedia.org/wiki/GNU_GRUB">wiki</a>.</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/2/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="os-concets-processes.html">
                
                  <h1>Operating System Concepts 3 - Processes</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">1 Process concept</a>
<ul>
<li>
<a href="#toc_1">1.1 The process</a>
</li>
<li>
<a href="#toc_2">1.2 Process state</a>
</li>
<li>
<a href="#toc_3">1.3 Process control block</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">2 Process scheduling 进程调度</a>
<ul>
<li>
<a href="#toc_5">2.1 Scheduling Queues</a>
</li>
<li>
<a href="#toc_6">2.2 context switch</a>
</li>
</ul>
</li>
<li>
<a href="#toc_7">3 Operating on Processes</a>
<ul>
<li>
<a href="#toc_8">3.1 Process creation</a>
</li>
<li>
<a href="#toc_9">3.2 Process termination</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">4 Interprocess communication</a>
</li>
<li>
<a href="#toc_11">5 IPC in shared-memory system</a>
</li>
<li>
<a href="#toc_12">6 IPC in message-passing system</a>
<ul>
<li>
<a href="#toc_13">6.1 Direct/Indirect communication</a>
<ul>
<li>
<a href="#toc_14">(1) Direct Communication</a>
</li>
<li>
<a href="#toc_15">(2) Indirect Communication</a>
</li>
</ul>
</li>
<li>
<a href="#toc_16">6.2 Synchronization</a>
</li>
<li>
<a href="#toc_17">6.3 Buffering</a>
</li>
</ul>
</li>
<li>
<a href="#toc_18">7 Examples of IPC</a>
<ul>
<li>
<a href="#toc_19">7.1 Mach Message Passing</a>
</li>
<li>
<a href="#toc_20">7.2 Pipes</a>
<ul>
<li>
<a href="#toc_21">(1) Ordinary pipes</a>
</li>
<li>
<a href="#toc_22">(2) Named pipes</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_23">8 Communication in Client-server system</a>
<ul>
<li>
<a href="#toc_24">8.1 Sockets</a>
</li>
<li>
<a href="#toc_25">8.2 Remote procedure calls</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">1 Process concept</h2>

<h3 id="toc_1">1.1 The process</h3>

<p><strong>Process</strong> (进程) is a program in execution.</p>

<ul>
<li>Process is the unit of work in a modern computing system</li>
</ul>

<p>The status of the <strong>current</strong> activity of a process is represented by the value of the <strong>program counter</strong> and the contents of the processor&#39;s <strong>registers</strong>.</p>

<p>A program by itself is not a process.</p>

<ul>
<li>A program is a <strong>passive</strong> entity, such as a file containing a list of instructions stored on disk</li>
<li>A process is an <strong>active</strong> entity, with a program counter specifying the next instruction to execute</li>
</ul>

<h3 id="toc_2">1.2 Process state</h3>

<p>A process may be in one of the following states:</p>

<ul>
<li><strong>New</strong>(新建). The process is being created. 进程正在被创建</li>
<li><strong>Running</strong>(运行). Instructions are being executed.指令正在被执行</li>
<li><strong>Waiting</strong>(等待). The process is waiting for some event to occur(such as an I/O completion or reception of a signal). 进程等待某些事件发生</li>
<li><strong>Ready</strong>(就绪). The process is waiting to be assigned to a processor.进程等待分配处理器</li>
<li><strong>Terminated</strong>(终止). The process has finished execution.进程执行完毕</li>
</ul>

<p>Diagram of process state:</p>

<p><img src="media/15317585001692/diagramofprocessstate.png" alt="Diagram of process state"/></p>

<h3 id="toc_3">1.3 Process control block</h3>

<p>Each process is represented by a <strong>process control block</strong>(PCB, 进程控制块), it contains</p>

<ul>
<li><strong>Process state</strong>(进程状态)</li>
<li><strong>Program counter</strong>(程序计数器)</li>
<li><strong>CPU registers</strong>(CPU寄存器)</li>
<li><strong>CPU-scheduling information</strong>(CPU调度信息): a process priority, pointers to scheduling queues, and any other scheduling parameters.</li>
<li><strong>Memory-management information</strong>(内存管理信息)</li>
<li><strong>Accounting information</strong>(记账信息): the amount of CPU and real time used, time limits, account numbers, process numbers and so on.</li>
<li><strong>I/O status information</strong>(I/O状态信息): the list of I/O devices allocated to the process, a list of open files</li>
</ul>

<p>Process Control Block:<br/>
<img src="media/15317585001692/processcontrolblock.png" alt="process control block"/></p>

<p>The process control block in Linux is represented by the C structure <code>task_struct</code> (&#39;include/linux/sched.h&#39;)， <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L592">CODE LINK</a></p>

<ul>
<li>Within the Linux kernel, all active processes are represented using a <strong>doubly linked list</strong> of task struct.</li>
</ul>

<p>Task_strut:</p>

<p><img src="http://or9a8nskt.bkt.clouddn.com/task_strcutinLinux.png" alt="task_strcut in Linux"/></p>

<h2 id="toc_4">2 Process scheduling 进程调度</h2>

<p>The <strong>process scheduler</strong>(进程调度程序) selects an available process for program execution on a core.</p>

<ul>
<li>Each CPU core can run one process at a time.</li>
<li>The number of processes currently in memory is known as the <strong>degree of multiprogramming</strong>.</li>
</ul>

<h3 id="toc_5">2.1 Scheduling Queues</h3>

<p><strong>Ready queue</strong>(就绪队列): the status of processes are ready.</p>

<ul>
<li>generally stored as a linked list, its header contains pointers to the first PCB in the list, each PCB includes a pointer field that points to next PCB in the ready queue.</li>
</ul>

<p><strong>Wait Queue</strong>(等待队列): the status of processes are waiting.</p>

<p>Queueing-diagram representation of process scheduling: <br/>
<img src="media/15317585001692/Queueing-diagram%20representation%20of%20process%20scheduling.png" alt="Queueing-diagram representation of process scheduling"/></p>

<h3 id="toc_6">2.2 context switch</h3>

<p>Here the <strong><em>context</em></strong> of a process is represented in the PCB of the process, including the value of the CPU registers, the process state, and memory-management information.</p>

<p>An operating system performs a <strong>context switch</strong>（上下文切换) when it switches from running one process to running another.</p>

<ul>
<li>The kernel <strong>saves</strong> the context of the old process into its PCB and <strong>restore</strong> the saved context of the new process scheduled to run.</li>
<li>Context-switch time is overhead; the system does no useful work while switching. 
<ul>
<li>A typical speed is a several microseconds. </li>
</ul></li>
<li>Context-switch times are <strong>highly</strong> dependent on hardware support.</li>
</ul>

<p>Context switch from an old process to a new process:</p>

<p><img src="http://or9a8nskt.bkt.clouddn.com/context_switch.png" alt="context_switch"/></p>

<h2 id="toc_7">3 Operating on Processes</h2>

<h3 id="toc_8">3.1 Process creation</h3>

<p>A process may <strong>create</strong> several new processes.</p>

<ul>
<li>the creating process is called a <strong>parent process</strong>.</li>
<li>the new process is called a <strong>child process</strong> .</li>
</ul>

<p><img src="media/15317585001692/process%20creating%20using%20the%20fork--%20system%20call.png" alt="process creating using the fork-- system cal"/></p>

<h3 id="toc_9">3.2 Process termination</h3>

<p>A process <strong>terminates</strong> when it finishes executing its final statement and asks the operating system to delete it by using the <code>exit()</code> system call.</p>

<ul>
<li><strong>cascading termination</strong>(级联终止):  if a process terminates (either normally or abnormally), then all its children must also be terminated. </li>
<li>A process that has terminated, but whose parent has not yet called <code>wait()</code>, is known as a <strong>zombie process</strong>(僵尸进程).</li>
<li>if a parent did not invoke <code>wait()</code> and instead terminated, then leaving its child processes as <strong>orphan processes</strong>(孤儿进程).
<ul>
<li>Unix system may assign the <code>init</code> process as the new parent to orphan processes, and the <code>init</code> process periodically invokes <code>wait()</code>.</li>
</ul></li>
</ul>

<h2 id="toc_10">4 Interprocess communication</h2>

<p>Processes may be either <strong>independent processes</strong>(独立进程) or <strong>cooperating processes</strong>(协同进程).</p>

<ul>
<li>A process is <strong><em>independent</em></strong> if it does not share data with any other processes executing in the system.</li>
<li>A process is <strong><em>cooperating</em></strong> if it can affect or be affected by the other processes executing in the system.</li>
</ul>

<p>Advantages of  process cooperation:</p>

<ul>
<li>Information sharing 信息共享</li>
<li>Computation speedup 加速运算</li>
<li>Modularity 模块化</li>
</ul>

<p>Cooperating process require an <strong>interprocess communication</strong> (IPC，进程间通信) mechanism that will allow them to <strong>exchange</strong> data. There are two fundamental models of IPC:</p>

<ul>
<li><strong>shared memory</strong>（共享内存）: a region of memory is shared by cooperating process. Process can exchange information by reading and writing data to the shared region.
<ul>
<li>Shared memory can be <strong>faster</strong> than message passing.</li>
</ul></li>
<li><strong>message passing</strong>(消息传递)： communication takes place by means of messages exchanged between the cooperating processes.
<ul>
<li>Message passing is useful for exchanging <strong>smaller</strong> amounts of data, because no conflicts need be avoided.</li>
<li>Message passing is easier to implement in a distributed system than shared memory.</li>
</ul></li>
</ul>

<p><img src="http://or9a8nskt.bkt.clouddn.com/shared_memory_and_message_passing.png" alt="shared memory and message passing"/></p>

<h2 id="toc_11">5 IPC in shared-memory system</h2>

<p>Here, we explore the POSIX API for shared memory. POSIX shared memory is organized using <strong>memory-mapped files</strong> (内存映射文件), which associate the region of shared memory with a file. A process must first create a shared-memory object using the <code>shm_open()</code> system call, as follows:</p>

<pre><code class="language-c">fd = shm_open(name, O_CREAT | O_RDWR, 0666);
ftruncate(fd, 4096);
mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
</code></pre>

<ul>
<li>A successful call to <code>shm_open()</code> returns an integer file descriptor for the shared-memory object.</li>
<li>Once the object is established, the <code>ftruncate</code> function is used to configure the size of the object in bytes.</li>
<li>Finally, the <code>mmap()</code> function establishes a memory-mapped file containing the shared-memory object. It returns a pointer to the shared</li>
</ul>

<h2 id="toc_12">6 IPC in message-passing system</h2>

<p>A message-passing facility provides at least two operations:</p>

<ul>
<li>send(message)</li>
<li>receive(message)</li>
</ul>

<p>If P and Q wish to communicate, they need to</p>

<ul>
<li>establish a <strong>communication link</strong>(通信连接) between them</li>
<li>exchange messages via send/receive </li>
</ul>

<p>Here are several methods for logically implementing a <em>communication link</em> between processes:</p>

<ul>
<li>Direct or indirect communication 直接/间接通信</li>
<li>Synchronous or asynchronous communication 同步/异步同步</li>
<li>Automatic or explicit buffering 自动/显式缓冲</li>
</ul>

<h3 id="toc_13">6.1 Direct/Indirect communication</h3>

<h4 id="toc_14">(1) Direct Communication</h4>

<p>Under <strong>direct communication</strong>, each process that wants to communicate must explicitly name the recipient or sender of the communication.</p>

<ul>
<li>send(P, message) - send a message to process P.</li>
<li>receive(Q, message) - receive a message from process Q</li>
</ul>

<p>A communication link in this scheme has the following properties:</p>

<ul>
<li>A link is established <strong>automatically</strong> between every pair of processes that want to communicate.</li>
<li>A link is associated with <strong>exactly two</strong> processes.</li>
<li>Between each pair of processes, there exists exactly one link.</li>
</ul>

<p>Cons:</p>

<ul>
<li>limited modularity of the resulting process definitions. Changing the identifier of a process may necessinate examining all other process definitions.</li>
<li>any such hard-coding techniques, are less desirable.</li>
</ul>

<h4 id="toc_15">(2) Indirect Communication</h4>

<p>With <strong>indirect communication</strong>, the message are sent to and receive from <strong>mailboxes</strong>, or <strong>ports</strong>.</p>

<ul>
<li>send(A, message) - send a message to mailbox A</li>
<li>receive(A, message) - receive a message from mailbox A</li>
</ul>

<p>A mailbox can be viewed abstractly as an object into which messages can be placed by processes and from which messages can be removed.</p>

<ul>
<li>Each mailbox has an <strong>unique</strong> identification.</li>
<li>Two processes can communicate only if they have a shared mailbox.</li>
</ul>

<p>In this scheme, a communication link has the following properties:</p>

<ul>
<li>A link is established between a pair of processes only if both members of the pair have a shared mailbox.</li>
<li>A link may be associated with more than two processes.</li>
<li>Between each pair of communicating processes, a number of different links may exist, with each link corresponding to one mailbox.</li>
</ul>

<p>A mailbox may be owned either by a process or by the operating system.</p>

<p>If the mailbox is owned by a process</p>

<ul>
<li>We distinguish between the <strong>owner</strong> (which can only receive messages through his mailbox) and the <strong>user</strong> (which can only send messages to the mailbox)</li>
<li>Each mailbox has a unique owner.</li>
<li>When a process that owns a mailbox terminates, the mailbox disappears.</li>
<li>The process that creates a new mailbox is that mailbox&#39;s owner by default.</li>
</ul>

<h3 id="toc_16">6.2 Synchronization</h3>

<p>Message passing may be either <strong>blocking</strong> or <strong>nonblocking</strong> - also known as <strong>synchronous</strong> and <strong>asynchronous</strong>.</p>

<h3 id="toc_17">6.3 Buffering</h3>

<p>Messages exchanged by communicating processes reside in a temporary queue, whether communication is direct or indirect. Basically, it can be implemented in three ways:</p>

<ul>
<li>Zero capacity（零容量）-- no buffering
<ul>
<li>The link cannot have any messages waiting in it.</li>
<li>The sender must block until the recipient receives the message. </li>
</ul></li>
<li>Bounded capacity（有界容量）-- automatic buffering
<ul>
<li>The queue has finite length n, at most n message can reside in it.<br/></li>
<li>The sender must block until space is available in the queue if the link is full.<br/></li>
</ul></li>
<li>Unbounded capacity （无界容量） -- automatic buffering
<ul>
<li>Any number of messages can wait in it.</li>
<li>The sender never blocks. </li>
</ul></li>
</ul>

<h2 id="toc_18">7 Examples of IPC</h2>

<h3 id="toc_19">7.1 Mach Message Passing</h3>

<p>Mach was especially designed for distributed systems. Its kernel supports the creation and destruction of multiple <strong>tasks</strong>, which are similar to processes but have multiple threads of control and fewer associated resources.  </p>

<p>Messages are sent to, and received from, mailboxes, which are called <strong>ports</strong> in Mach. </p>

<ul>
<li>Ports are <strong>finite in size</strong> and <strong>unidirectional</strong>.</li>
<li>For two-way communication, a message is sent to one port, and a response is sent to a separate <strong>reply</strong> port.</li>
<li>Associated with each port is a collection of <strong>port rights</strong>, which  identify the capabilities necessary for a task to interact with the port.</li>
</ul>

<p>Functions:</p>

<ul>
<li><code>mach_port_allocate()</code> creates a new port and allocates space for its queue of messages.</li>
<li><code>mach_msg()</code> is the standard API for both sending and receiving messages.</li>
</ul>

<pre><code class="language-c">#include &lt;mach/mach.h&gt;

struct message {
    mach_msg_header_t header;
    int data;
};

mach_port_t client;
mach_port_t server;

/* Client Code */

struct message message;

// construct the header
message.header.msgh_size = sizeof(message);
message.header.msgh_remote_port = server;
message.header.msgh_local_port = client;

// send the message
mach msg(&amp;message.header, // message header
         MACH_SEND_MSG, // sending a message
         sizeof(message), // size of message sent
         0, // maximum size of received message - unnecessary
         MACH_PORT_NULL, // name of receive port - unnecessary
         MACH_MSG_TIMEOUT_NONE, // no time outs MACH PORT NULL // no notify port
);

/* Server Code */

struct message message;

// receive the message
mach_msg(&amp;message.header, // message header
  MACH_RCV_MSG, // sending a message  0, // size of message sent
  sizeof(message), // maximum size of received message
  server, // name of receive port
  MACH_MSG_TIMEOUT_NONE, // no time outs
  MACH_PORT_NULL // no notify port
);
</code></pre>

<h3 id="toc_20">7.2 Pipes</h3>

<p>A <strong>pipe</strong> acts as a conduit allowing two processes to communicate. Pipes were one of the first IPC mechanisms in early UNIX systems. There are two common types of pipes used on both UNIX and Windows systems: <strong>ordinary pipes</strong> and <strong>named pipes</strong>.</p>

<h4 id="toc_21">(1) Ordinary pipes</h4>

<p><strong>Ordinary pipes</strong> allow two processes to communicate in standard producer-consumer fashion: the producer writes to one end of the pipe (the <strong>write end</strong>) and the consumer reads from the other end (the <strong>read end</strong>).</p>

<ul>
<li>Ordinary pipes are <strong>unidirectional</strong>, allowing only one-way communication.</li>
<li>Function <code>pipe(int fd[])</code> constructs an ordinary pipe, where <code>fd</code> is a file descriptor.</li>
<li>UNIX treats a pipe as <em>a special type of file</em>. Pipes can be accessed using ordinary <code>read()</code> and <code>write()</code> system calls.</li>
<li>Ordinary pipes <strong>exit only</strong> while the processes are communicating with each other.</li>
</ul>

<p><img src="media/15317585001692/file_descriptors_for_an_ordinary_pipes.png" alt="file descriptors for an ordinary pipes"/></p>

<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

#define BUFFER_SIZE 25
#define READ_END 0
#define WRITE_END 1

int main(void)
{
        char write_msg[BUFFER_SIZE] = &quot;Greetings&quot;;
        char read_msg[BUFFER_SIZE];
        int fd[2];
        pid_t pid;

        /* create the pipe */
        if (pipe(fd) == -1){
                fprintf(stderr, &quot;Pipe failed&quot;);
                return 1;
        }

        /* fork a child process */
        pid = fork();

        if (pid&gt;0){ /* parent process */
                close(fd[READ_END]);/* close the unused end of the pipe */
                write(fd[WRITE_END], write_msg, strlen(write_msg)+1); /* write to the pipe */
                close(fd[WRITE_END]);  /* close the write end of the pipe */
        }
        else if (pid==0){ /* child process */
                close(fd[WRITE_END]); /* close the unused end of the pipe */
                read(fd[READ_END], read_msg, BUFFER_SIZE); /* read from the pipe */
                printf(&quot;read: %s\n&quot;, read_msg);
                close(fd[READ_END]); /* close the read end of the pipe */
        }
        return 0;

}
</code></pre>

<h4 id="toc_22">(2) Named pipes</h4>

<p><strong>Named pipes</strong>（命名管道） can be <strong>bidirectional</strong>, and no parent-child relationship is required.</p>

<ul>
<li>Named pipes are referred to as <strong>FIFOs</strong> in UNIX system.</li>
<li>Once created, they appear as typical files in the file system.</li>
<li>The communicating processes for named pipes must reside on the same machine.</li>
</ul>

<p>A FIFO is created with the <code>mkfifo()</code> system call and manipulated with the ordinary <code>open()</code>, <code>read()</code>, <code>write()</code>, and <code>close</code> system calls.：</p>

<pre><code class="language-c">int mkfifo(const char *filename, mode_t mode);
</code></pre>

<p><code>fifowrite.c</code>:</p>

<pre><code class="language-c">#include&lt;sys/types.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include&lt;fcntl.h&gt;
#include&lt;limits.h&gt;
int main()
{
    const char *fifo_name = &quot;/tmp/my_fifo&quot;;
    int pipe_fd = -1;
    int data_fd = -1;
    int res = 0;
    const int open_mode = O_WRONLY;
    char buffer[PIPE_BUF+1];
    if(access(fifo_name,F_OK)==-1)
    {
        res = mkfifo(fifo_name,0777);
        if(res!=0)
        {
            fprintf(stderr,&quot;could not create fifo\n&quot;);
            exit(EXIT_FAILURE);
        }
    }
    printf(&quot;process %d opening fifo O_WRONLY\n&quot;,getpid());
    pipe_fd = open(fifo_name,open_mode);
    data_fd = open(&quot;data.txt&quot;,O_RDONLY);
    printf(&quot;process %d result %d\n&quot;,getpid(),pipe_fd);
    if(pipe_fd!=-1)
    {
        int bytes_read = 0;
        bytes_read = read(data_fd,buffer,PIPE_BUF);
        while(bytes_read&gt;0)
        {
            res = write(pipe_fd,buffer,bytes_read);
            if(res==-1)
            {
                fprintf(stderr,&quot;write error\n&quot;);
                exit(EXIT_FAILURE);
            }
            bytes_read = read(data_fd,buffer,PIPE_BUF);
            buffer[bytes_read]=&#39;\0&#39;;
        }
        close(pipe_fd);
        close(data_fd);
    }
    else{
        exit(EXIT_FAILURE);
    }
    printf(&quot;process %d finished.\n&quot;,getpid());
    exit(EXIT_SUCCESS);
}
</code></pre>

<p><code>fiforead.c</code>:</p>

<pre><code class="language-c">#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;fcntl.h&gt;
#include&lt;limits.h&gt;
int main()
{
    const char *fifo_name = &quot;/tmp/my_fifo&quot;;
    int pipe_fd = -1;
    int data_fd = -1;
    int res = 0;
    int open_mode = O_RDONLY;
    char buffer[PIPE_BUF+1];
    int bytes_read = 0;
    int bytes_write = 0;
    memset(buffer,&#39;\0&#39;,sizeof(buffer));

    printf(&quot;process %d opening FIFO O_RDONLY\n&quot;,getpid());
    pipe_fd = open(fifo_name,open_mode);
    data_fd = open(&quot;dataformfifo.txt&quot;,O_WRONLY|O_CREAT,0644);
    printf(&quot;process %d result %d\n&quot;,getpid(),pipe_fd);
    if(pipe_fd!=-1)
    {
        do{
            res = read(pipe_fd,buffer,PIPE_BUF);
            bytes_write = write(data_fd,buffer,res);
            bytes_read +=res;
        }while(res&gt;0);
        close(pipe_fd);
        close(data_fd);
    }
    else{
        exit(EXIT_FAILURE);
    }
    printf(&quot;process %d finished,%d bytes read\n&quot;,getpid(),bytes_read);
    exit(EXIT_SUCCESS);
}
</code></pre>

<h2 id="toc_23">8 Communication in Client-server system</h2>

<p>In this section, we explore two other strategies for communication in client-server system: <strong>sockets</strong> and <strong>remote procedure calls</strong>(RPCs)</p>

<h3 id="toc_24">8.1 Sockets</h3>

<p>A <strong>socket</strong>（套接字）is defined as an endpoint for communication. A socket is identified by an IP address concatenated with a port number.</p>

<p>Communication using sockets：</p>

<p><img src="http://or9a8nskt.bkt.clouddn.com/communication_using_sockets.png" alt="communication using sockets"/></p>

<p>Servers implementing specific services (such as SSH, FTP, and HTTP) listen to well-known ports. Once a request is received, the server accepts a connection from the client socket to complete the connection.</p>

<h3 id="toc_25">8.2 Remote procedure calls</h3>

<p><strong>Remote Procedure Call</strong>（远程过程调用）allows programs on different machines to interact using simple procedure call/return semantics, just as if the two programs were in the same computer。</p>

<p>RPC between a client and a serve：</p>

<p><img src="http://or9a8nskt.bkt.clouddn.com/RPC_between_a_client_and_a_server.png" alt="RPC_between_a_client_and_a_server"/></p>

<p>RPC hides all the network code into the stub procedures. This prevents the application programs, the client and the server, from having to worry about details such as sockets, network byte order, and the like.</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/2/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_1.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="http://or9a8nskt.bkt.clouddn.com/figure.jpeg" /></div>
            
                <h1>techlarry</h1>
                <div class="site-des">他山之石，可以攻玉</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/techlarry" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:wang.zhen.hua.larry@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Leetcode.html"><strong>Leetcode</strong></a>
        
            <a href="programming_language.html"><strong>编程语言</strong></a>
        
            <a href="data_structure_and_algorithm.html"><strong>数据结构和算法</strong></a>
        
            <a href="Python%E7%89%B9%E6%80%A7.html"><strong>Python特性</strong></a>
        
            <a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html"><strong>机器学习</strong></a>
        
            <a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html"><strong>Python科学计算三维可视化</strong></a>
        
            <a href="English.html"><strong>English</strong></a>
        
            <a href="Computer%20System.html"><strong>Computer System</strong></a>
        
            <a href="Deep%20Learning.html"><strong>Deep Learning</strong></a>
        
            <a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html"><strong>Linux 系统编程</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html"><strong>数据库</strong></a>
        
            <a href="Tensorflow.html"><strong>Tensorflow</strong></a>
        
            <a href="Big%20Data.html"><strong>Big Data</strong></a>
        
            <a href="%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB.html"><strong>文献阅读</strong></a>
        
            <a href="Tools.html"><strong>Tools</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="head-first_java_note.html">Head first Java</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="exceptional_control_flow.html">CSAPP - 异常控制流</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="introduction_to_computer_system_CMU.html">CMU 15-213 Introduction to Computer Systems</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="os-concepts-os-structures.html">Operating System Concepts 2 - Operating System structures</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="os-concets-processes.html">Operating System Concepts 3 - Processes</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
