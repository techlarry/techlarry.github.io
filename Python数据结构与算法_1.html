<!doctype html>
<html class="no-js" lang="en">
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?fdc936c9f5a3b72177541183cdeb8cb3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Python数据结构与算法 - techlarry
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="techlarry" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:larryim.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_self" href="about.html">About</a></li>
        
        <li id=""><a target="_self" href="category.html">Category</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; techlarry</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        
        <li><a target="_self" href="about.html">About</a></li>
        
        <li><a target="_self" href="category.html">Category</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Leetcode.html">Leetcode</a></li>
        
            <li><a href="Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">Python数据结构与算法</a></li>
        
            <li><a href="Python%E7%89%B9%E6%80%A7.html">Python特性</a></li>
        
            <li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html">机器学习</a></li>
        
            <li><a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html">Python科学计算三维可视化</a></li>
        
            <li><a href="English.html">English</a></li>
        
            <li><a href="%20%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA.html"> 理解计算机</a></li>
        
            <li><a href="Deep%20Learning.html">Deep Learning</a></li>
        
            <li><a href="Latex.html">Latex</a></li>
        
            <li><a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html">操作系统</a></li>
        
            <li><a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html">Linux 系统编程</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a></li>
        
            <li><a href="Tensorflow.html">Tensorflow</a></li>
        
            <li><a href="%E5%B7%A5%E4%BD%9C%E4%B8%8E%E5%AD%A6%E4%B9%A0.html">工作与学习</a></li>
        
            <li><a href="Data%20Science.html">Data Science</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="clustering%20on%20big%20graph.html">
                
                  <h1>Clustering on big graph</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><strong>Question</strong>: what is the largest value of k such that there is a <code>k-clustering</code> with spacing at least 3?  That is, how many clusters are needed to ensure that no pair of nodes with all but 2 bits in common get split into different clusters?</p>

<p><strong>Input</strong>: <br/>
[first bit of node 1] … [last bit of node 1]<br/>
[first bit of node 2] … [last bit of node 2]</p>

<p>For example, the third line of the file “0 1 1 0 0 1 1 0 0 1 0 1 1 1 1 1 1 0 1 0 1 1 0 1″ denotes the 24 bits associated with node #2.</p>

<p><strong>Background</strong>:<br/>
The distance between two nodes \(u\) and \(v\) in this problem is defined as the <code>Hamming distance</code>--- the number of differing bits --- between the two nodes&#39; labels. </p>

<p><strong>Note</strong>: NOTE: The graph implicitly defined by the data file is so big that you probably can&#39;t write it out explicitly, let alone sort the edges by cost. So you will have to be a little creative to complete this part of the question. For example, is there some way you can identify the smallest distances without explicitly looking at every pair of nodes?</p>

<h2 id="toc_0">METHOD</h2>

<ul>
<li>We put all the nodes into a hash table, which of size is \(2^n\), where \(n=24\) is the length of input bits. </li>
</ul>

<p><strong>Detail</strong>: We use <code>list</code> to represent the hash table in python, of which index will be the numerical value of the input, and value will be the node number index. The node number index also denotes where each node is own cluster (i.e index of cluster).</p>

<ul>
<li>In order to find a \(k\)-clustering with spacing at least 3, we just need to find neighbors that the distance between neighbors and nodes are 1 or 2.</li>
</ul>

<p><strong>Detail</strong>: We use bit manipulation to find potential   neighbors of a node. According to <code>Hamming distance</code>, the distance means the number of differing bits. Since the distance should be 1 or 2, neighbor of node are such points that differ  from node in no more than 2 bits. Total number of potential neighbor is \(C^2_{24}+C^1_{24} = 300\) . The property of XOR is used to compute its neighbors directly: </p>

<pre><code class="language-python">if x ^ y == z: 
    x ^ z = y 
</code></pre>

<p>Hence, In order to find neighbors \(y\), we just compute <code>x^z</code>, where \(z\) is no more than 3 1s in the 24-bit binary integer.</p>

<ul>
<li>In order to keep track of connected clusters, the <code>disjoint-set</code> data structure is used here.</li>
</ul>

<h2 id="toc_1">Procedure</h2>

<pre><code class="language-python">for each node in Graph (200K iterations):
    for each code that is 0 or 1 or 2 units apart from this vertex:
        Add these 2 vertexes to a cluster.
</code></pre>

<h2 id="toc_2">Implementation</h2>

<pre><code class="language-python">class HashTable:
    def __init__(self, size):
        self.size = size
        self.slots = [None for i in range(self.size)]

    def add(self, key, value):
        if self.slots[key]:
            self.slots[key].append(value)
        else:
            self.slots[key] = [value]

    def values(self):
        key = 1
        for val in self.slots:
            if val:
                yield (key, val)
        key += 1


class BigClustring:

    def __init__(self):
        self.hash_table = None
        self.num = None
        self.len_bit = None
        self.disjoint_set = DisjointSet()
        self.val = []

    def read_from_file(self, file_name):
        with open(file_name) as infile:
            line = infile.readline()
            line = line.strip(&#39;\n&#39;)
            self.num, self.len_bit = [int(num) for num in line.split()]
            self.hash_table = HashTable(2 ** self.len_bit)

            node = 1
            for line in infile.readlines():
                line = line.strip(&#39;\n&#39;)
                line = line.replace(&#39; &#39;, &#39;&#39;)
                val = int(line, 2)
                self.hash_table.add(val, node)
                self.disjoint_set.make_set(node)
                self.val.append(val)
                node += 1

        if self.num + 1 != node:
            raise ValueError

    def hamming(self):
        &quot;&quot;&quot;
        return binary integer at hamming distance 1 or 2
        &quot;&quot;&quot;
        self.hamm = []
        for i in range(self.len_bit):
            for j in range(self.len_bit):
                self.hamm.append(1 &lt;&lt; i | 1 &lt;&lt; j)

    def neighbors(self, val):
        &quot;&quot;&quot;
        return node_index of neighbors for val
        &quot;&quot;&quot;
        for key in self.hamm:
            if self.hash_table.slots[key ^ val] is not None:
                yield self.hash_table.slots[key ^ val][0]

    def cluster(self):
        &quot;&quot;&quot;
        cluster nodes with 0-1-2 distances
        &quot;&quot;&quot;

        # first cluster the 0 distance nodes
        for key, val in self.hash_table.values():
            if len(val) &gt; 1:
                # union
                for val1 in val:
                    for val2 in val:
                        if val1 != val2:
                            self.disjoint_set.union(val1, val2)

        # second cluster the 1-2 distance nodes
        node = 1
        for val in self.val:
            neighbors = self.neighbors(val)
            for neighbor in neighbors:
                self.disjoint_set.union(node, neighbor)
            node += 1
        return len(self.disjoint_set)
</code></pre>

<h2 id="toc_3">Reference</h2>

<ol>
<li><a href="https://rstudio-pubs-static.s3.amazonaws.com/72033_dcd43db591574873aac22be4cde29af6.html">Clustering on big graph, python</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming Distance WIKIPEDIA</a></li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html'>Python数据结构与算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="bitwise%20operator%20in%20python.html">
                
                  <h1>Bitwise Operation</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">The method of complements</a>
<ul>
<li>
<a href="#toc_1">One&#39;s complement (反码)</a>
</li>
<li>
<a href="#toc_2">Two&#39;s complement (补码)</a>
<ul>
<li>
<a href="#toc_3">Implementation</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">One or Two</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">Reference</a>
</li>
</ul>


<p>There are 6 <code>Bitwise Operators</code>(位操作符) in Python:</p>

<ul>
<li><code>x&lt;&lt;y</code>: Returns \(x\) with the bits shifted to the left by y places (and new bits on the right-hand-side are zeros). This is the same as multiplying x by \(2^y\).</li>
<li><code>x&gt;&gt;y</code>: Returns \(x\) with the bits shifted to the right by y places. This is the same as //&#39;ing \(x\) by \(2^y\).</li>
<li><code>x&amp;y</code>(bitwise AND): Each bit of the output is 1 if the corresponding bit of \(x\) AND of \(y\) is 1, otherwise it&#39;s 0.</li>
<li><code>x|y</code> (bitwise OR): Each bit of the output is 0 if the corresponding bit of \(x\) AND of \(y\) is 0, otherwise it&#39;s 1.</li>
<li><code>~ x</code> ( bitwise NOT, or complement): Returns the complement of \(x\) - the number you get by switching each 1 for a 0 and each 0 for a 1. This is the same as \(-x-1\).</li>
<li><code>^</code> (bitwise Exclusive OR): outputs true only when inputs differ (one is 1, the other is 0).</li>
</ul>

<p><code>Bitwise Operators</code> operate on numbers, but instead of treating that number as if it were a single value, they treat it as if it were a string of bits, written  in <code>two&#39;s-complement</code> binary.</p>

<h2 id="toc_0">The method of complements</h2>

<p>The <code>method of complements</code> is a technique used to subtract one number from another using only addition of positive numbers.</p>

<p>Many early computers, use <code>one&#39;s complement</code> notation. The IBM 700/7000 series used to use <code>sign/magnitude</code> notation. Almost all subsequent minicomputers and microcomputers use <code>two&#39;s complement</code>  in the computer industry.</p>

<h3 id="toc_1">One&#39;s complement (反码)</h3>

<p>The one&#39;s complement of a <code>binary number</code> is defined as the value obtained by inverting all the bits in the binary representation of the number (swapping 0s for 1s and vice versa). </p>

<p>Positive numbers are the same simple, binary system used by <code>two&#39;s complement</code> and <code>sign-magnitude</code>. Negative values are the bit complement of the corresponding positive value. </p>

<p>The table below shows all possible values in a 4-bit system, from −7 to +7.</p>

<pre><code>      +      −
 0   0000   1111   — Note that both +0 and −0 return TRUE when tested for zero
 1   0001   1110   — and FALSE when tested for non-zero. 
 2   0010   1101
 3   0011   1100
 4   0100   1011
 5   0101   1010
 6   0110   1001
 7   0111   1000
</code></pre>

<p><strong>Negative zero</strong> is the condition where all bits in a signed word are 1. </p>

<pre><code>1111 1111
</code></pre>

<h3 id="toc_2">Two&#39;s complement (补码)</h3>

<p>A <code>two&#39;s complement</code> number system encodes positive and negative numbers in a binary number representation. The weight of each bit is a power of two, except for the <code>most significant bit</code>(最高有效位), whose weight is the negative of corresponding power of two.</p>

<p>The method to convert a negative integer into a two&#39;s complement is implemented as follows:</p>

<pre><code>eg. -3
Start with positive 0000 0011
flip bits 1111 1100
add one 1111 1101
</code></pre>

<h4 id="toc_3">Implementation</h4>

<p>The naive implementation of <code>Two&#39;s complement</code> in Python is as follows:</p>

<pre><code class="language-python">def int_to_two_complement(val, num_bits):

    if val &lt; 0:
        # major procedure as follows:
        # 1. take the absolute
        # 2. flip
        # 3. add one

        # absolute of val: use int to transform str to int
        val = bin(val)[3:].rjust(num_bits, &#39;0&#39;)

        # flip it: bitwise complement
        flip_val = &#39;&#39;
        flip_bit = {&#39;0&#39;: &#39;1&#39;, &#39;1&#39;: &#39;0&#39;}
        for bit in val:
            flip_val += flip_bit[bit]
        val = flip_val

        # add one
        val = list(val)
        if val[-1] == &#39;0&#39;:
            val[-1] = &#39;1&#39;
        else:
            index = -1
            while val[index] == &#39;1&#39;:
                index -= 1
            val[-1] = &#39;0&#39;
            val[index - 1] = &#39;1&#39;
        val = &#39;&#39;.join(val)
        val = int(val)

    else:

        # fill zeros before the binary number converted by bin, the result = bin(val)
        val = bin(val)[2:].rjust(num_bits, &#39;0&#39;)
    return val
</code></pre>

<h3 id="toc_4">One or Two</h3>

<p>A <code>two&#39;s complement</code> integer equals its <code>one&#39;s complement</code> integer plus one.</p>

<p>\[X_{two} = 2^n-x = x_{one}+1\]</p>

<h2 id="toc_5">Reference</h2>

<p>1.<a href="https://en.wikipedia.org/wiki/Most_significant_bit">Most Significant Bit</a><br/>
2.<a href="https://wiki.python.org/moin/BitwiseOperators">wiki-python</a><br/>
3.<a href="https://stackoverflow.com/questions/1604464/twos-complement-in-python">two&#39;s complement in python -Stackoverflow</a><br/>
4. <a href="https://en.wikipedia.org/wiki/Two&#x27;s_complement#Subtraction_from_2N">Two&#39;s complement WIKIPEDIA</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html'>Python数据结构与算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="minimum_spanning_tree_prim_kruskal.html">
                
                  <h1>Minimum Spanning Tree: Prim's, Kruskal's Algorithm and Clustering</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">Concepts</a>
</li>
<li>
<a href="#toc_1">Prim&#39;s algorithm</a>
<ul>
<li>
<a href="#toc_2">Implementation</a>
</li>
<li>
<a href="#toc_3">Prim&#39;s v.s. Dijkstra&#39;s</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">Kruskal&#39;s Algorithm</a>
<ul>
<li>
<a href="#toc_5">Implementation</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_6">Clustering</a>
<ul>
<li>
<a href="#toc_7">Implementation</a>
</li>
</ul>


<p>Let \(G=(V, E)\) be a connected, undirected graph with a real-valued weight function \(w\) defined on \(E\). If an acyclic subset \(T\in E\) that connects all of the vertices and whose total weight \(w(T)=\sum_{(u,v)\in T}w(u,v)\) is minimized, \(T\) forms a <code>Minimum Spanning Tree</code>.</p>

<h2 id="toc_0">Concepts</h2>

<ul>
<li><code>safe edge</code>: An edge that may be added to \(A\) without violating the invariant that \(A\) is a subset of some <code>minimum spanning tree</code>.</li>
<li><code>cut</code>: A <code>cut</code> \((S, V-S)\) of an undirected graph \(G=(V,E)\) is a partition of \(V\).</li>
<li><code>cross</code>: We say that an edge \((u,v)\in E\) <code>crosses</code> the cut \((S,V-S)\) if one of its endpoints is in \(S\) and the other is in \(V-S\).</li>
<li><code>respect</code>: If no edge in \(A\) (a subset of some <code>minimum spanning tree</code>) <code>crosses</code> the cut, the cut <code>respects</code> a set \(A\) of edges.</li>
<li><code>light edge</code>: An edge is a <code>light edge</code> crossing a cut if its weight is the minimum of any edge crossing the cut. </li>
</ul>

<h2 id="toc_1">Prim&#39;s algorithm</h2>

<p>In <code>Prim&#39;s algorithm</code>, each step adds a light edge to minimum spanning tree. The running time of the Prim&#39;s algorithm is \(O(E \log(V))\)</p>

<h3 id="toc_2">Implementation</h3>

<pre><code class="language-python">def prim(agraph, start):
    &quot;&quot;&quot;
    Prim&#39;s algorithm for minimum spanning tree
    Using min-heap data structure

    return a minimum spanning tree
    &quot;&quot;&quot;
    # vertex of minimun spanning tree
    mst_vertex = []
    pq = PriorityQueue()
    for v in agraph:
        v.setDistance(sys.maxsize)
        v.setPred(None)
    start.setDistance(0)
    pq.buildHeap([(v.getDistance(), v) for v in agraph])
    while not pq.isEmpty():
        u = pq.delMin()
        mst_vertex.append(u)
        for adjacent in u.getConnections():
            newcost = u.getWeight(adjacent)
            if adjacent in pq and newcost &lt; adjacent.getDistance():
                adjacent.setPred(u)
                adjacent.setDistance(newcost)
                pq.decreaseKey(adjacent, newcost)

    # edges of minimum spanning tree
    mst = []
    for i in range(1, len(mst_vertex)):
        # u, v, cost
        mst.append((mst_vertex[i-1], mst_vertex[i],  mst_vertex[i].getDistance()))

    return mst
</code></pre>

<h3 id="toc_3">Prim&#39;s v.s. Dijkstra&#39;s</h3>

<p><code>Prim&#39;s algorithm</code> are similar to <code>Dijkstra&#39;s algorithm</code>, both of which use a <code>priority queue</code>. And  each of them belongs to <code>greedy algorithm</code>. There is trivial difference when implementing:</p>

<p>\[\text{Prim&#39;s} p(v) = \min_{(u,v): u\in S} w(u,v)\]<br/>
\[\text{Dijkstra&#39;s} s(v) = \min_{(u,v): u\in S} \text{dist(su,u)} w(u,v)\]</p>

<h2 id="toc_4">Kruskal&#39;s Algorithm</h2>

<p>In <code>Kruskal&#39;s algorithm</code>, always add edges in increasing weight, skipping those whose addition would create a cycle.</p>

<p>In order to keep track of the connected components of a minimum spanning tree when implementing Kruskal&#39;s algorithm, a disjoint-set data structure should be used. The pseudo code for <code>MST-KRUSKAL</code>:</p>

<pre><code class="language-python">mst = []
for each vertex in G:
    make-set(vertex)
sort the edges of G into nondecreasing order by weight of edges
for each edge (u,v) in G:
    if find-set(u) != find_set(v):
        mst = mst + (u,v)
        union(u,v)
return mst
</code></pre>

<p>If we use <code>union-by-rank</code> and <code>path-compression</code> heuristics in <code>disjoint-set</code> data structure, the running time of <code>Kruskal&#39;s algorithm</code> is \(O(E\lg V)\).</p>

<h3 id="toc_5">Implementation</h3>

<pre><code class="language-python">def kruskal_mst(agraph):
    &quot;&quot;&quot;
    Return a minimum spanning tree using kruskal&#39;s algorithm
    &quot;&quot;&quot;
    # minimum spanning tree
    mst = []

    # disjoint set
    disjoint_set = DisjointSet()

    # make set
    for vertex in agraph.Vertices():
        disjoint_set.make_set(vertex)

    # edges of the graph
    edges = agraph.edges()
    edges.sort(key=lambda tup: tup[2])

    for u, v, cost in edges:
        if disjoint_set.find_set(u) != disjoint_set.find_set(v):
            mst.append((u, v, cost))
            disjoint_set.union(u, v)
    return mst
</code></pre>

<h1 id="toc_6">Clustering</h1>

<p><strong>Max-Spacing k clustering</strong>: Given a set of objects \(p_1, . . . , p_n\), a distance function \(d(p_i,p_j)\) specifies their similarity.  \(d(p_i,p_j)\) may be an actual distance, or some abstract representation of how dissimilar of two things are. </p>

<p><strong>OUR GOAL</strong>: Divide the \(n\) items up into \(k\) groups so that the minimum distance between items in different groups is maximized.</p>

<p><strong>IDEA</strong>: </p>

<ul>
<li>we maintain clusters as a set of connected components of a graph. </li>
<li>And Iteratively combine the clusters containing the two closest items by adding an edge between them.</li>
<li>Stop when there are \(k\) clusters.</li>
</ul>

<p>You&#39;ll find this is exactly <code>Kruskal&#39;s algorithm</code>.</p>

<h3 id="toc_7">Implementation</h3>

<pre><code class="language-python">def clustering(agraph, k):
    &quot;&quot;&quot;
    Max-Spacing k clustering

    Return maximum spacing of a k-clustering
    and corresponding mst.
    &quot;&quot;&quot;
    # minimum spanning tree
    mst = []

    # disjoint set
    disjoint_set = DisjointSet()

    # make set
    for vertex in agraph.Vertices():
        disjoint_set.make_set(vertex)

    # edges of the graph
    edges = agraph.edges()
    edges.sort(key=lambda tup: tup[2])

    for u, v, cost in edges:
        if len(disjoint_set) &gt;= k:

            if disjoint_set.find_set(u) != disjoint_set.find_set(v):
                mst.append((u, v, cost))
                max_cost = cost
                disjoint_set.union(u, v)
        else:
            break


    return max_cost, mst
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/4</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Tree.html'>Tree</a></span>
          				  
          					    <span class="posted-in"><a href='Graph.html'>Graph</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="hash_table_5_hashable.html">
                
                  <h1>Hash Table (5): Hashable</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>To make items hashable, you should implement <code>__hash__</code>. You should also implement <code>__eq__</code> in a compatible way -- items that are equivalent should hash the same.</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/3</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Hash%20Table.html'>Hash Table</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="disjoint_set_data_structure.html">
                
                  <h1>Disjoint-Set Data Structure</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">Linked-List Implementation</a>
</li>
<li>
<a href="#toc_1">Forest Implementation of Disjoint-Set</a>
</li>
<li>
<a href="#toc_2">Reference</a>
</li>
</ul>


<p>In order to keep track of the connected components of a minimum spanning tree when implementing <code>Kruskal&#39;s algorithm</code>, a disjoint-set data structure should be used.</p>

<p><code>Disjoint-set</code> data structure, also called <code>union-find</code> data structure, is a data structure that keeps track of a set of elements partitioned into a number of disjoint subsets.</p>

<p>A <code>disjoint-set</code> data structure supports following operations:</p>

<ul>
<li><code>MAKE-SET(x)</code> creates a new set whose only member is \(x\)</li>
<li><code>UNION(x,y)</code> unites the dynamic sets that contains \(x\) and \(y\), into a new set that is the union of these two sets.</li>
<li><code>FIND-SET(x)</code> returns the representative of the set containing \(x\).</li>
</ul>

<h2 id="toc_0">Linked-List Implementation</h2>

<p>Each set is represented by its own <strong>linked list</strong>. The object for each set has attributes <em>head</em>, pointing to the first object in the list, and <em>tail</em>, pointing to the last object. Each object in the linked list contains a set member, a pointer to the next object in the list, and a pointer back to the set object.</p>

<p><img src="media/15017471539381/Screen%20Shot%202017-08-03%20at%209.21.43%20PM.png" alt="Linked List implementaion"/></p>

<p><strong>Weighted-Union Heuristic</strong>: And each linked list also includes the length of the list and we always append the shorter list onto the longer.</p>

<p>Using the linked-list representation of disjoint sets and the weighted-union heuristic, a sequence of \(m\) MAKE-SET, UNION, and FIND-SET, \(n\) of which are MAKE-SET operations, takes \(O(m+n\lg n)\) time.</p>

<pre><code class="language-python">class Node:
    &quot;&quot;&quot;
    class Node for double liked list
    &quot;&quot;&quot;
    def __init__(self, elem):
        self.prev = None
        self.elem = elem
        self.next = None

    def __hash__(self):
        return hash(self.elem)

    def __eq__(self, x, y):
        return x.elem == y.elem


class LinkedList:

    def __init__(self):
        self.head = None
        self.tail = None
        self.length = 0

    def add(self, node):
        &quot;&quot;&quot;
        add element to disjoint set
        &quot;&quot;&quot;
        if self.head:
            node.prev = self
            self.tail.next = node
            self.tail = node
        else:
            self.head = node
            self.tail = node
            node.prev = self
        self.length += 1

    def __len__(self):
        return self.length

    def set_length(self, l):
        self.length = l

    def __iter__(self):
        next_node = self.head
        while next_node:
            yield next_node
            next_node = next_node.next


            

class DisjointSet:

    def __init__(self):
        self.sets = []

    def make_set(self, node):
        &quot;&quot;&quot; 
        creates a new set whose only member (and thus representative) is x.
        &quot;&quot;&quot;
        alist = LinkedList()
        alist.add(node)
        self.sets.append(alist)
        return alist

    def union(self, nodex, nodey):
        &quot;&quot;&quot;
        unites the dynamic sets that contain x and y, into a new set that is the union of these two sets.
        &quot;&quot;&quot;
        listx = self.find_set(nodex)
        listy = self.find_set(nodey)
        
        # append the shorter list onto the longer.
        if len(listx) &gt; len(listy):
            listx.tail.next = listy.head
            for y in listy:
                y.prev = listx
            listx.tail = listy.tail
            listx.set_length = len(listx) + len(listy)
            self.sets.remove(listy)
        else:
            listy.tail.next = listx.head
            for x in listx:
                x.prev = listy
            listy.tail = listx.tail
            listy.setlength = len(listx) + len(listy)
            self.sets.remove(listx)



    def find_set(self, node):
        &quot;&quot;&quot;
        returns the representative of the set containing x
        &quot;&quot;&quot;
        return node.prev

    def connected_components(self):
        for link_list in self.sets:
            print(&#39;( &#39;, end=&#39;&#39;)
            for node in link_list:
                print(node.elem, end=&#39; &#39;)
            print(&#39;) &#39;, end=&#39;&#39;)

    def __len__(self):
        return len(self.sets)

</code></pre>

<h2 id="toc_1">Forest Implementation of Disjoint-Set</h2>

<p><code>Disjoint-set forest</code>, a faster implementation of disjoint sets, uses rooted trees represent sets, with each node containing one member and each tree representing one set. In a <code>disjoint-set forest</code>, each member points only to its parents. The root of each tree contains the representative and is its own parent.</p>

<p><img src="media/15017471539381/15017663990040.png" alt="disjoint set forest"/></p>

<p><strong>Union by Rank</strong>: For each node, we maintain a <code>rank</code>, which is an upper bound on the hight of the node. We make the root with smaller rank point to the root with larger rank during a <code>Union</code> operation.</p>

<p><strong>Path Compression</strong>: When we call <code>find_set</code>, we traverse the path from a node up to its root. Instead of just returning root, we will link all the nodes in this path directly to root. </p>

<p><img src="media/15017471539381/15017663772888.png" alt="path compression"/></p>

<pre><code class="language-python">class DisjointSet:
    &quot;&quot;&quot;
    Disjoint set data structure
    &quot;&quot;&quot;

    def __init__(self):
        self.sets = []
        self.parent = {}
        self.rank = {}

    def make_set(self, node):
        &quot;&quot;&quot;
        creates a new set whose only member (and thus representative) is x.
        &quot;&quot;&quot;
        self.parent[node] = node
        self.sets.append(node)
        self.rank[node] = 0

    def union(self, x, y):
        &quot;&quot;&quot;
        unites the dynamic sets that contain x and y, into a new set that is the union of these two sets.
        &quot;&quot;&quot;
        x_root = self.find_set(x)
        y_root = self.find_set(y)
        if x_root == y_root:
            return

        if self.rank[x_root] &gt; self.rank[y_root]:
            self.parent[y_root] = x_root
        else:
            self.parent[x_root] = y_root
            if self.rank[x_root] == self.rank[y_root]:
                self.rank[y_root] = self.rank[y_root] + 1

    def find_set(self, x):
        &quot;&quot;&quot;
        returns the representative of the set containing x
        &quot;&quot;&quot;
        if self.parent[x] != x:
            self.parent[x] = self.find_set(self.parent[x])
        return self.parent[x]

</code></pre>

<h2 id="toc_2">Reference</h2>

<ol>
<li>Cormen, Leiserson, Rivest, and Stein. 2009. Introduction to Algorithms (3rd edition)</li>
<li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-design-and-analysis-of-algorithms-spring-2012/lecture-notes/MIT6_046JS12_lec16.pdf">Disjoint-set Data Structure MIT</a></li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/3</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html'>Python数据结构与算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Python数据结构与算法.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Python数据结构与算法_2.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="http://or9a8nskt.bkt.clouddn.com/figure.jpeg" /></div>
            
                <h1>techlarry</h1>
                <div class="site-des">他山之石，可以攻玉</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/techlarry" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:wang.zhen.hua.larry@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Leetcode.html"><strong>Leetcode</strong></a>
        
            <a href="Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html"><strong>Python数据结构与算法</strong></a>
        
            <a href="Python%E7%89%B9%E6%80%A7.html"><strong>Python特性</strong></a>
        
            <a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html"><strong>机器学习</strong></a>
        
            <a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html"><strong>Python科学计算三维可视化</strong></a>
        
            <a href="English.html"><strong>English</strong></a>
        
            <a href="%20%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA.html"><strong> 理解计算机</strong></a>
        
            <a href="Deep%20Learning.html"><strong>Deep Learning</strong></a>
        
            <a href="Latex.html"><strong>Latex</strong></a>
        
            <a href="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html"><strong>操作系统</strong></a>
        
            <a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html"><strong>Linux 系统编程</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html"><strong>数据库</strong></a>
        
            <a href="Tensorflow.html"><strong>Tensorflow</strong></a>
        
            <a href="%E5%B7%A5%E4%BD%9C%E4%B8%8E%E5%AD%A6%E4%B9%A0.html"><strong>工作与学习</strong></a>
        
            <a href="Data%20Science.html"><strong>Data Science</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15088244818278.html">Machine Learning Foundations - Mathematical Foundations</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15088177470889.html">Machine Learning Foundations (8): The noise and error</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15088177317059.html">Machine Learning Foundations (7): The VC dimension</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15088176831066.html">Machine Learning Foundations (6): Theory of generalization</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="active_learning_intro.html">主动学习</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
