<!doctype html>
<html class="no-js" lang="en">
  <head>

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  编程语言 - techlarry
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="techlarry" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:larryim.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fdc936c9f5a3b72177541183cdeb8cb3";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">HomePage</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_blank" href="wiki">WIKI</a></li>
        
        <li id=""><a target="_self" href="notebook.html">NOTEBOOK</a></li>
        
        <li id=""><a target="_self" href="about.html">About</a></li>
        
        <li id=""><a target="_blank" href="note-os">NOTE-OS</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; techlarry</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">HomePage</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        
        <li><a target="_blank" href="wiki">WIKI</a></li>
        
        <li><a target="_self" href="notebook.html">NOTEBOOK</a></li>
        
        <li><a target="_self" href="about.html">About</a></li>
        
        <li><a target="_blank" href="note-os">NOTE-OS</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Leetcode.html">Leetcode</a></li>
        
            <li><a href="programming_language.html">编程语言</a></li>
        
            <li><a href="data_structure_and_algorithm.html">数据结构和算法</a></li>
        
            <li><a href="Python%E7%89%B9%E6%80%A7.html">Python特性</a></li>
        
            <li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html">机器学习</a></li>
        
            <li><a href="English.html">English</a></li>
        
            <li><a href="Computer%20System.html">Computer System</a></li>
        
            <li><a href="Deep%20Learning.html">Deep Learning</a></li>
        
            <li><a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html">Linux 系统编程</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a></li>
        
            <li><a href="Tensorflow.html">Tensorflow</a></li>
        
            <li><a href="Big%20Data.html">Big Data</a></li>
        
            <li><a href="%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB.html">文献阅读</a></li>
        
            <li><a href="Tools.html">Tools</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="cpp_by_diessection.html">
                
                  <h1>[NOTE] C++ By Dissection</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Chapter 1 Writing an ANSI C++ Program</h2>

<h2 id="toc_1">Chapter 2 Native Types and Statements</h2>

<h2 id="toc_2">Chapter 3 Functions, Pointers, and Arrays</h2>

<h2 id="toc_3">Chapter 4 Classes and Abstract Data Types</h2>

<h2 id="toc_4">Chapter 5 Ctors, Dtors, Converisons, and Operator Overloading</h2>

<p><strong>Polymorphism</strong> means giving different meanings to the same function name or operator, dependent on context. Overloading of functions gives the same function name different meanings. The name has several interpretations that depend on function selection. This is called ad hoc polymorphism.</p>

<ul>
<li>ad hoc polymorphism: function overloading, operator overloading
<ul>
<li> functions can be applied to arguments of different types</li>
</ul></li>
<li>parametric polymorphism: using templates
<ul>
<li>allows the same code to be used with respect to various types, in which the type is a parameter of the code body.</li>
</ul></li>
<li>pure polymorphism: using virtual functions</li>
</ul>

<p>Chapter 11</p>

<p>OOP Language Characteristics</p>

<ul>
<li>Encapsulation with data hiding: the ability to distinguish an object&#39;s internal state and behavior from its external state and behavior.</li>
<li>Type extensibility: the ability to add user-defined types to augment the native types</li>
<li>Inheritance: the ability to create new types by importing or reusing the description of existing types</li>
<li>Polymorphism with dynamic binding: the ability of objects to be responsible for interpreting function invocation</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/9/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='programming_language.html'>编程语言</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="C_plus_plus_ostream.html">
                
                  <h1>C++ Ostream</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>设定输出域宽度: <code>setw</code></li>
</ul>

<pre><code class="language-cpp">// 设定域的输出长度为8，而实际字符串长度为4，所有前面补四个空格。
cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;;        // [    AAAA]
</code></pre>

<p>如果<code>setw</code>的数值小于实际数据长度，<code>setw</code>的值无效，比如上述例子：</p>

<pre><code class="language-cpp">//因为3小于实际字符串长度4，最终输出整个字符串。
cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(3) &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;         // [AAAA]
</code></pre>

<ul>
<li>对齐方式：<code>left</code>/<code>right</code>/<code>internal</code></li>
</ul>

<p>在设定了输出域的宽度<code>setw</code>后，如果设置对齐方式，左对齐还是右对齐(缺省是右对齐(<code>right</code>))</p>

<pre><code class="language-cpp"> cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; left &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;;       // [AAAA    ]
 cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; right &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;;      // [    AAAA]
 cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;;                    // [    AAAA]
</code></pre>

<ul>
<li>填充字符: <code>setfill</code></li>
</ul>

<p>域宽度不够时，还可以指定，用来代替缺省的空格</p>

<pre><code class="language-cpp">//使用字符&#39;0&#39;作为填充
 cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;; // [0000AAAA]
 cout &lt;&lt; &quot;[&quot; &lt;&lt; setw(8) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; left &lt;&lt; &quot;AAAA&quot; &lt;&lt; &quot;]&quot;;    // [AAAA0000]
</code></pre>

<ul>
<li>输出正负号: <code>showpos</code></li>
</ul>

<pre><code class="language-cpp"> cout &lt;&lt; &quot;[&quot; &lt;&lt; showpos &lt;&lt; 123 &lt;&lt; &quot;]&quot;;   // [+123]
 cout &lt;&lt; &quot;[&quot; &lt;&lt; showpos &lt;&lt; -456 &lt;&lt; &quot;]&quot;;  // [-456]
 cout &lt;&lt; &quot;[&quot; &lt;&lt; showpos &lt;&lt; 0 &lt;&lt; &quot;]&quot;;     // [+0]
</code></pre>

<ul>
<li>输出16进制数字值: <code>hex</code></li>
</ul>

<pre><code class="language-cpp">cout &lt;&lt; &quot;[&quot; &lt;&lt; hex &lt;&lt; 20  &lt;&lt; &quot;]&quot;;   //  [14]
</code></pre>

<ul>
<li>可以加前缀<code>0x</code>: <code>showbase</code></li>
</ul>

<pre><code class="language-cpp">cout &lt;&lt; &quot;[&quot; &lt;&lt; showbase &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; 5  &lt;&lt; &quot;]&quot;;  // [0x5]
</code></pre>

<ul>
<li>16进制值(A-F)大写: <code>uppercase</code></li>
</ul>

<pre><code class="language-cpp">cout &lt;&lt; &quot;[&quot; &lt;&lt; hex &lt;&lt; uppercase &lt;&lt; setw(2) &lt;&lt; setfill(&#39;0&#39;) &lt;&lt; 10  &lt;&lt; &quot;]&quot;;  // [0A]
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/12/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='programming_language.html'>编程语言</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="C++baics.html">
                
                  <h1>C++ Basics</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>The article summarizes the key points, concepts of C++, with detailed examples, from a C Programmer standpoint.</p>

<ul>
<li>
<a href="#toc_0">C++ Advantage</a>
</li>
<li>
<a href="#toc_1">C++ is better than C</a>
</li>
<li>
<a href="#toc_2">Overloading</a>
</li>
<li>
<a href="#toc_3">Generics</a>
<ul>
<li>
<a href="#toc_4">Multiple template arguments</a>
</li>
<li>
<a href="#toc_5">Overloading Operator</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">Natural way to build widgets: <code>class</code></a>
</li>
<li>
<a href="#toc_7">Constructor and destructor</a>
<ul>
<li>
<a href="#toc_8">Copy Constructor</a>
</li>
<li>
<a href="#toc_9">Destructor</a>
</li>
</ul>
</li>
<li>
<a href="#toc_10">Scope and storage class</a>
</li>
<li>
<a href="#toc_11">Memory Management</a>
</li>
<li>
<a href="#toc_12">Reference</a>
</li>
</ul>


<h2 id="toc_0">C++ Advantage</h2>

<ul>
<li>safe cast
<ul>
<li><code>static cast &lt;type&gt;</code></li>
</ul></li>
<li><code>for</code> statement can include declaration initializer</li>
<li><code>endl</code> io-manipulator can be placed in an iostream.</li>
</ul>

<h2 id="toc_1">C++ is better than C</h2>

<ul>
<li>More <code>type safety</code>(the extent to which a programming language discourages or prevents type errors)
<ul>
<li>The new operator returns a pointer of a specific type based on the operand, versus the void pointer from C&#39;s <code>malloc</code>.</li>
<li>Certain code written in C that uses void pointers can be rewritten using C++ templates to give a type to an argument whose type is variable.</li>
<li>Using <code>static_cast</code> and <code>dynamic_cast</code></li>
</ul></li>
<li>More Libraries
<ul>
<li>STL(Standard Template Library)</li>
</ul></li>
<li>Less reliance on preprocessor
<ul>
<li><code># define</code>  goes away, easy to use <code>const &lt;type&gt;</code> and <code>inline</code> (substitute macros in C)instead.</li>
</ul></li>
<li>OO vs imperative
<ul>
<li>OO is better</li>
</ul></li>
<li><code>namespace</code></li>
<li>safe cast 
<ul>
<li>using <code>static_cast &lt;type&gt;</code></li>
</ul></li>
<li><code>iostream</code></li>
<li>Declarations anywhere including
<ul>
<li>for-statement initialization</li>
</ul></li>
</ul>

<h2 id="toc_2">Overloading</h2>

<p><code>Overloaded functions</code> are an important polymorphic mechanism in C++. <code>signature matching algorithm</code> decides the way to pick the appropriate functions.</p>

<p><strong><code>Basic Signature Matching Algorithm</code></strong>:</p>

<ul>
<li>Use an exact match if found.</li>
<li>Try standard type promotions.</li>
<li>Try standard type conversions.</li>
<li>Try user-defined conversions.</li>
<li>...</li>
</ul>

<p><strong>Example: Swap in C</strong> </p>

<pre><code class="language-c"> //first swap function
 //Call by reference simulated with pointers
 void swap(int* i, int* j){
    int temp=*i;
    *i=*j;
    *j=temp;
 }

//second swap function
//Call by reference simulated with pointers
void swap_double(double* i, double* j){ 
    double temp=*i;
    *i=*j;
    *j=temp;
 }
 
 int main()
 {
    int m=5, n=10;
    double x=5.3, y=10.6;
    printf(&quot;inputs:%d, %d\n&quot;, m,n);
    swap_double(&amp;m, &amp;n);
    printf(&quot;outputs:%d, %d\n&quot;, m,n);
    printf(&quot;double inputs:%lf, %lf\n&quot;, x,y);
    swap_double(&amp;x, &amp;y);
    printf(&quot;double outputs: %lf, %lf\n&quot;, x, y);
}
</code></pre>

<p>In C each function in a given scope most have a unique name(no function overloading).</p>

<ul>
<li>C: Call by reference simulated with pointers (the previous example)</li>
<li>C++: Call by reference argument passing (see the example below)</li>
</ul>

<p><strong>Example: Swap in C++</strong>:</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// iostream type safe and intuitive convinient.

inline void swap(int &amp;i, int &amp;j){ // call by reference, reference to int
        int temp = i;
        i = j;
        j = temp;
}

inline void swap(double &amp;i, double &amp;j){
        double temp = i;
        i = j;
        j = temp;
}

int main()
{
        int m=5, n=10;
        double x = 5.3, y=10.6;
        cout &lt;&lt; &quot;inputs: &quot; &lt;&lt; m &lt;&lt; &quot;,&quot; &lt;&lt; n &lt;&lt; endl;
        swap(m,n);
        cout &lt;&lt; &quot;outputs: &quot; &lt;&lt; m &lt;&lt; &quot;,&quot; &lt;&lt; n &lt;&lt; endl;

        cout &lt;&lt; &quot;double inputs: &quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; endl;
        swap(x,y);
        cout &lt;&lt; &quot;outputs: &quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; endl;
}
</code></pre>

<ul>
<li>Having the same name for conceptually the same activity promotes readable code.</li>
<li>Overloading based on signature and the use of generics(<code>template</code>) is a powerful reuse mechanism.</li>
</ul>

<h2 id="toc_3">Generics</h2>

<p>Generics in C++: programing using templates.</p>

<ul>
<li>The compiler uses <code>template</code> to write code appropriate to each set of parameters.</li>
<li>The \(m\), \(n\) parameters are ints - so the compiled code is <code>swap(int&amp;, int&amp;)</code> signature.</li>
<li>Similarly, for the other two signatures. So the compiler is compiling code appropriate to each distinct signature.</li>
</ul>

<p><strong>Example: Swap Using templates</strong>:</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;complex&gt;

using namespace std;

template &lt;class T&gt;
inline void swaps(T&amp; d, T&amp; s)
{
        T temp=d;
        d = s;
        s = temp;
}

int main()
{
        int m=5, n=10;
        double x=5.3, y=10.6;
        complex&lt;double&gt; r(2.4, 3.5), s(3.4, 6.7);
        cout &lt;&lt; &quot;inputs: &quot; &lt;&lt; m &lt;&lt; &quot;,&quot; &lt;&lt; n &lt;&lt; endl;
        swaps(m,n);
        cout &lt;&lt; &quot;outputs:&quot; &lt;&lt; m &lt;&lt; &quot;,&quot; &lt;&lt; n &lt;&lt; endl;

        cout &lt;&lt; &quot;complex double inputs: &quot; &lt;&lt; r &lt;&lt; &quot;,&quot; &lt;&lt; s &lt;&lt; endl;
        swaps(r,s);
        cout &lt;&lt; &quot;complex double outputs:&quot; &lt;&lt; r &lt;&lt; &quot;,&quot; &lt;&lt; s &lt;&lt; endl;
}
</code></pre>

<p>Another example, how in C do you write a function to sum a array in doubles?</p>

<p><strong>Example: Sum a array in C</strong>:</p>

<pre><code class="language-c">double sum(double data[], int size)
{
    double s =0.0;
    int i;
    for (i=0; i&lt;size; i++)
        s += data[i];
    return s;        
</code></pre>

<p>Generic programming:</p>

<ul>
<li>writing code that can use an arbitrary type or types; in C++ this is done with template.</li>
</ul>

<p><strong>Example: Sum a array in C++ Using template</strong>:</p>

<pre><code class="language-cpp">template &lt;class T&gt; //T is generic type
T sum(const T data[], int size, T s=0)
{
    for (int i=0; i&lt;size; ++i)
        s += data[i]; // += must work for T
    return s;
}

int main()
{
    cout &lt;&lt; &quot;template for sum()&quot; &lt;&lt; endl;
    int a[] = {1,2,3};
    double b[] = {2.1, 2.2, 2.3};
    cout &lt;&lt; sum(a,3) &lt;&lt; endl;
    cout &lt;&lt; sum(b,3) &lt;&lt; endl;
}
</code></pre>

<h3 id="toc_4">Multiple template arguments</h3>

<ul>
<li>We have used templates with one template parameter, but it is useful to have more that one distinct type in a template.</li>
<li>More genericity - but be careful!</li>
</ul>

<p><strong>Type safety</strong>:</p>

<ul>
<li>More types means worrying about conversions and more signatures</li>
<li>There <code>static_cast</code> operators are considered safe.</li>
<li>The old cast operator (type) is deprecated as a reminder the other casting operators are:
<ul>
<li><code>reinterpret_cast&lt;type&gt;</code> highly unsafe</li>
<li><code>dynamic_cast&lt;type&gt;</code> used with classes</li>
<li><code>const_cast&lt;type&gt;</code> cast away const-ness</li>
</ul></li>
</ul>

<h3 id="toc_5">Overloading Operator</h3>

<p>Unary and binary operators can be overloaded as nonstatic member functions. Implicitly, they are acting on a class value.</p>

<pre><code class="language-cpp">#include&lt;iostream&gt; 
#include&lt;cstdint&gt; 

using namespace std;

enum class days:std::int8_t 
{SUN,MON,TUE,WED,THU,FRI,SAT};

//unlike plain enums C++11 enum class is typesafe and does not silently 
//convert to int

ostream&amp; operator&lt;&lt;(ostream&amp; out, const days&amp; d)  // call by reference 
{
    switch (d){
        case days::SUN: out&lt;&lt; &quot;SUN&quot;; break;
        case days::MON: out&lt;&lt; &quot;MON&quot;; break;
        case days::TUE: out&lt;&lt; &quot;TUE&quot;; break;
        case days::WED: out&lt;&lt; &quot;WED&quot;; break;
        case days::THU: out&lt;&lt; &quot;THU&quot;; break;
        case days::FRI: out&lt;&lt; &quot;FRI&quot;; break;
        case days::SAT: out&lt;&lt; &quot;SAT&quot;; break;
    }
    return out;
}

days operator++(days&amp; d) //PREFIX OPERATOR 
{ 
    d = static_cast&lt;days&gt;((static_cast&lt;int&gt;(d) + 1) % 7); 
    return d;
}

days operator++(days&amp; d, int) //POSTFIX OPERATOR 
{
    days temp = d;
    d = static_cast&lt;days&gt;((static_cast&lt;int&gt;(d) + 1) % 7);
    return temp; 
}

int main(){
    days today{days::MON};
    std::cout &lt;&lt; &quot;Demonstrate class enum&quot; &lt;&lt; std::endl; 
    std::cout &lt;&lt; &quot;MONDAY VALUE IS &quot; &lt;&lt; today &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;INCREMENT VALUE IS &quot; &lt;&lt; ++today &lt;&lt; std::endl; 
    std::cout &lt;&lt; &quot;INCREMENT VALUE IS &quot; &lt;&lt; today++ &lt;&lt; std::endl; 
    std::cout &lt;&lt; &quot;INCREMENT VALUE IS &quot; &lt;&lt; today &lt;&lt; std::endl; 
    return 0;
}

</code></pre>

<p>OO Principle:</p>

<ul>
<li>User defined types should be indistinguishable from native types
<ul>
<li>Operator overloading and conversion allows us to implement this principle</li>
</ul></li>
</ul>

<h2 id="toc_6">Natural way to build widgets: <code>class</code></h2>

<p><strong>C type extension</strong>:</p>

<ul>
<li>In C you can &#39;add&#39; a type using <code>struct</code></li>
<li>In C++ <code>struct</code> is different - <code>struct</code> is a named scope that can include functions (methods) and have different layers of opacity (data hiding). While C++ retains <code>struct</code> it has the new keyword <code>class</code>.</li>
<li><code>class</code> is almost equivalent to <code>struct</code> - but with different data hiding defaults.</li>
</ul>

<pre><code class="language-cpp">typedef struct point {double x,y;} point;
void add_points(point* p1, point* p2, point* sum)
{
    sum -&gt; x = p1 -&gt; x + p2 -&gt; x;
    sum -&gt; y = p1 -&gt; y + p2 -&gt; y;
}
</code></pre>

<ul>
<li>C struct has fields - data members;</li>
<li>File scope functions manipulate the struct using pointer operations</li>
</ul>

<p><strong>Naive C++ point</strong></p>

<pre><code class="language-cpp">class point{
    public:
        double x,y;
};
</code></pre>

<ul>
<li><code>public</code>, <code>private</code>, <code>protected</code> are access keywords.</li>
</ul>

<p><strong>Better C++ Point</strong>:</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class point{
    public:
        double getx(){return x;} // access methods
        void setx(double v){x = v;} // mutate methods 
        double x,y; 
};

point operator+(point&amp; p1, point&amp; p2){
    point sum={p1.x + p2.x, p1.y+p2.y};
    return sum;
}

ostream&amp; operator&lt;&lt;(ostream&amp; out, const point&amp;p){
    out &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt;&quot;)&quot;;
    return out;
}

int main()
{
    point a = {3.5, 2.5}, b={2.5, 4.5}, c;
    cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; &quot; b= &quot; &lt;&lt; b &lt;&lt; endl;
    cout &lt;&lt; &quot;sum= &quot; &lt;&lt; a+b &lt;&lt; endl;
}

// reuslt is 
//a=(3.5,2.5) b= (2.5,4.5)
//sum= (6,7)
</code></pre>

<p><strong>class - User defined types</strong>:</p>

<ul>
<li>Using point in <code>main()</code> looks very much like using a native type.</li>
<li>Indeed this is one of our key goal in Object Oriented Programming.</li>
<li>We accomplished this by having point be a class -- a user defined type. We overload the standard operators like + and &lt;&lt; to give them appropriate &quot;point&quot; semantics.</li>
</ul>

<p><strong>Methods</strong>:</p>

<ul>
<li>Class member functions have automatic access to private members.</li>
<li><code>p1.getx()</code>, <code>p1.setx(3.5)</code></li>
</ul>

<h2 id="toc_7">Constructor and destructor</h2>

<p>A <code>constructor</code>(构造函数) is a member function whose name is the same as the class name; it creates objects of the class type. This process involves initializing data members and, frequently, allocating storage from the heap by using <code>new</code>.</p>

<p><code>default constructor</code> does not requires a initializing value(no arguments),</p>

<pre><code class="language-cpp">class point{
    public:
        //constructor, initializer list
        point(double x=0.0, double y=0.0): x(x), y(y){} 
        double getx(){return x;}
        void setx(double v){x=v;}
    private:
        double x,y;
};
</code></pre>

<p><strong>A special method constructor</strong>:</p>

<ul>
<li><code>point(){x=y=0.0;}</code>: ordinary assignment</li>
<li><code>point(){this-&gt;x=0.0; this-&gt;y=0.0}</code> :initialized list</li>
<li><code>point():x(0.0), y(0.0){}</code> : best way</li>
<li>Default constructor - the constructor whose signature is void.</li>
</ul>

<p><strong>Constructor overloading</strong>:</p>

<ul>
<li>It is useful to have multiple ways to initialize an object like point.</li>
<li><code>point(double x, double y)</code></li>
<li><code>{this -&gt; x=x; this-&gt;y=y};</code></li>
</ul>

<p>It is also the case that usually there are several constructors per class. Each constructor signature represents a useful way to declare and initialize an object of that type.</p>

<p><strong>Example: Improved Points Using constructor</strong></p>

<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

class point{
    public:
        point(): x(0), y(0) {} //default
        point(double u): x(u), y(0) {} //double to point
        point(double u, double v): x(u), y(v) {}
        void print() const { cout &lt;&lt; &quot;(&quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;)&quot;; }
        void set(double u, double v) {x =u; y=v;}
        void plus(point c) {x += c.x; y+=c.y;}
    private:
        double x, y;
};


double parabola(double x, double p)
{
    return (x*x)/p;
}

void graph(double a, double b, double incr, 
    double f(double, double), double p, point gr[])
{
    double x = a;
    for (int i=0; x &lt;=b; ++i, x += incr)
        gr[i].set(x, f(x, p));
}


const int no_of_pts = 20;


int main()
{
    point g[no_of_pts]; // use default ctor

    graph(0, 2, 0.1, parabola, 5, g);
    cout &lt;&lt; &quot;First 20 samples:&quot; &lt;&lt; endl;
    for (int i=0; i&lt; no_of_pts; ++i)
    {
        g[i].print();
        if (i%5==4)
            cout &lt;&lt; endl;
        else
            cout &lt;&lt; &quot;  &quot;;
    }
}
</code></pre>

<h3 id="toc_8">Copy Constructor</h3>

<p>For class types, call-by-value requires a <code>copy constructor</code>. The compiler provides a copy constructor whose signature is <code>class_name:: class_name(const class_name &amp;)</code></p>

<h3 id="toc_9">Destructor</h3>

<p>A <code>destructor</code>(析构函数) is a member function whose name is the class preceded by the tilde character, <code>~</code>. The destructor is implicitly invoked on block and function exit to clean up storage no longer accessible.</p>

<p><strong>Example:List</strong>:</p>

<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

struct list_element {
    list_element(int n=0, list_element* ptr=0): d(n), next(ptr){}
    int d;
    list_element* next;
};


class list{
    public:
        list(): head(0), cursor(0){}  // default constructor
        list(const int* arr, int n); // transfer data
        list(const list&amp; lst); //copy constructor
        void prepend(int n); //insert at front value n
        int get_element(){ return cursor -&gt; d;}
        void advance(){ cursor = cursor -&gt; next;}
        void print();
        ~list(){delete head; delete cursor;}; // destructor
    private:
        list_element* head;
        list_element* cursor;
};


void list::prepend(int n)
{
    if (head==0) // empty list case
        cursor = head = new list_element(n, head);
    else // add to front-chain
        head = new list_element(n, head);
}


void list::print(){
    list_element* h = head;
    while(h!=0){//idiom for chaining
        cout &lt;&lt; h-&gt;d &lt;&lt; &quot;,&quot;;
        h = h-&gt;next;
    }
    cout &lt;&lt; &quot;###&quot; &lt;&lt; endl;
}

int main()
{
    list a, b;
    a.prepend(9);
    a.prepend(8);
    cout &lt;&lt; &quot; list a&quot; &lt;&lt; endl;
    a.print();
    for (int i=0; i&lt;40; ++i)
        b.prepend(i*i);
    cout &lt;&lt; &quot; list b&quot; &lt;&lt; endl;
    b.print();
    return 0;
}
</code></pre>

<h2 id="toc_10">Scope and storage class</h2>

<p>The C++ has two principle forms of scope: <code>local scope</code> and <code>file scope</code>. <code>Local scope</code> is scoped to a block(e.g. compound statements, function bodies). <code>File scope</code> has names that are external(global).  </p>

<p>The four storage classes are <code>auto</code>, <code>extern</code>, <code>register</code>, and <code>static</code>.</p>

<p><strong><code>auto</code></strong>:</p>

<ul>
<li>allocated within a block, and its lifetime is limited to the execution of that block.</li>
</ul>

<p><strong><code>register</code></strong>:</p>

<ul>
<li>tells the compiler that the associated variables should be stored in high-speed memory registers</li>
</ul>

<p><strong><code>static</code></strong>:</p>

<ul>
<li><code>static</code> variables retain its previous value when the block is reentered.</li>
<li><code>static</code> functions are visible only within the file in which they are defined.</li>
</ul>

<h2 id="toc_11">Memory Management</h2>

<p>In C++:</p>

<ul>
<li><code>new</code> (allocator) instead of <code>malloc()</code> in C </li>
<li><code>delete</code> (deallocator) instead of <code>free()</code> in C</li>
<li>Both work with a heap -- heap is dynamically allocated memory - unlike Java not automatically garbage collected.</li>
</ul>

<p><strong>Simple use of <code>new</code> and <code>delete</code></strong>:</p>

<pre><code class="language-cpp">char* s = new char[size]; //get of heap
int* p = new int(9); //single int initialized
delete [] s; //delete an array
delete p; //delete single element

// These will get used with dynamic data structures 
// in constructors and destructors
</code></pre>

<h2 id="toc_12">Reference</h2>

<ul>
<li>Ira Pohl. C++ for C Programmers,University of California, Santa Cruz</li>
<li>Ira Pohl. <a href="https://users.soe.ucsc.edu/%7Epohl/">C++ by Dissection</a>.</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/10/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='programming_language.html'>编程语言</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="C++STL.html">
                
                  <h1>C++ STL</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Containers come in two major families: <code>sequence</code> and <code>associative</code>. Sequence containers (<code>vector</code>, <code>list</code>, and <code>deque</code>) are ordered by having a sequence of elements. Associative containers (<code>set</code>, <code>multiset</code>, <code>map</code> and <code>multimaps</code>) have keys for looking up elements.</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/10/29</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='programming_language.html'>编程语言</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="C_language.html">
                
                  <h1>C Basics</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">C 语言的各种版本</h2>

<p><img src="media/15091487975421/15091488073990.png" alt=""/></p>

<p>广泛应用的仍然是<code>ANSI C</code>(C89).</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/10/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='programming_language.html'>编程语言</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="http://or9a8nskt.bkt.clouddn.com/figure.jpeg" /></div>
            
                <h1>techlarry</h1>
                <div class="site-des">他山之石，可以攻玉</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/techlarry" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:wang.zhen.hua.larry@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Leetcode.html"><strong>Leetcode</strong></a>
        
            <a href="programming_language.html"><strong>编程语言</strong></a>
        
            <a href="data_structure_and_algorithm.html"><strong>数据结构和算法</strong></a>
        
            <a href="Python%E7%89%B9%E6%80%A7.html"><strong>Python特性</strong></a>
        
            <a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html"><strong>机器学习</strong></a>
        
            <a href="English.html"><strong>English</strong></a>
        
            <a href="Computer%20System.html"><strong>Computer System</strong></a>
        
            <a href="Deep%20Learning.html"><strong>Deep Learning</strong></a>
        
            <a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html"><strong>Linux 系统编程</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html"><strong>数据库</strong></a>
        
            <a href="Tensorflow.html"><strong>Tensorflow</strong></a>
        
            <a href="Big%20Data.html"><strong>Big Data</strong></a>
        
            <a href="%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB.html"><strong>文献阅读</strong></a>
        
            <a href="Tools.html"><strong>Tools</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15400989593148.html">Scrapy爬取MovieLens</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="scrapy_top100.html">Scrapy爬取猫眼TOP100榜</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15046649572570.html">Pandas</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="exceptional_control_flow.html">CSAPP - 异常控制流</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="introduction_to_computer_system_CMU.html">CMU 15-213 Introduction to Computer Systems</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
