{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Zhenhua's Notes - Algorithm This site documents reading and learning notes. Other Note Site Note - Java/OS Note - Big Data Search (function() { var cx = '011299089536274713055:ppqfpivtvxy'; var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true; gcse.src = 'https://cse.google.com/cse.js?cx=' + cx; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s); })(); TOC See Table of Contents . Books and Materials See Books and Materials . Roadmap See Roadmap .","title":"Home"},{"location":"#zhenhuas-notes-algorithm","text":"This site documents reading and learning notes.","title":"Zhenhua's Notes - Algorithm"},{"location":"#other-note-site","text":"Note - Java/OS Note - Big Data","title":"Other Note Site"},{"location":"#search","text":"(function() { var cx = '011299089536274713055:ppqfpivtvxy'; var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true; gcse.src = 'https://cse.google.com/cse.js?cx=' + cx; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s); })();","title":"Search"},{"location":"#toc","text":"See Table of Contents .","title":"TOC"},{"location":"#books-and-materials","text":"See Books and Materials .","title":"Books and Materials"},{"location":"#roadmap","text":"See Roadmap .","title":"Roadmap"},{"location":"books/","text":"Books and Materials Books The following is the primary reading list of books. Each chapter is organized as a single page; the included sections are noted with major concepts, and summary. Algorithm Algorithm, 4th Edition by Robert Sedgewick and Kevin Wayne Materials CS61B CS61B Data Structures, Berkeley Instructor: Josh Hug","title":"Books"},{"location":"books/#books-and-materials","text":"","title":"Books and Materials"},{"location":"books/#books","text":"The following is the primary reading list of books. Each chapter is organized as a single page; the included sections are noted with major concepts, and summary.","title":"Books"},{"location":"books/#algorithm","text":"Algorithm, 4th Edition by Robert Sedgewick and Kevin Wayne","title":"Algorithm"},{"location":"books/#materials","text":"","title":"Materials"},{"location":"books/#cs61b","text":"CS61B Data Structures, Berkeley Instructor: Josh Hug","title":"CS61B"},{"location":"toc/","text":"Table of Contents Shortcuts APUE - x86 assembly - Bash - BD - C - CLRS - CNAPP - CNSPP - CSN - DDA - DevOps - x86 disassembly - Golang - GOPL - HTAE - ICND1 - ICND2 - iptables - LKD - LSP - Nginx - PER - PIC - Python - Ruby - SPEC - TCPIP - TCPv1 - TLPI - TWGR - UNP - UTLK - Vim Contents Name Status Progress APUE Backlog Almost Done x86 assembly Backlog Almost Done Bash Future Started BD Discontinued First Half C Stub - CLRS Discontinued Started CNAPP Future Started CNSPP Backlog Started CSN Active First Half DDA Active Started DevOps Future Second Half x86 disassembly Future Started Golang Discontinued First Half GOPL Active Almost Done HTAE Backlog Started ICND1 Future Started ICND2 Future Started iptables Stub - LKD Active Second Half LSP Backlog Started Nginx Stub - PER Future Started PIC Future Started Python Stub - Ruby Discontinued First Half SPEC Backlog First Half TCPIP Backlog Started TCPv1 Backlog First Half TLPI Backlog Started TWGR Backlog Started UNP Backlog First Half UTLK Backlog First Half Vim Stub - Note: Active items are of P0 priority per OKR , and are in bold. All other items in the OKR are in backlog . Future items are not in the OKR but are likely to be revisited in the future. Stub items are not intended as notes. For progress, started : 15%; first half : 15% ~ 50%; second half : 50% ~ 85%; almost done : 85% ~ 100%; complete : 100%. For full titles, see Books and Materials .","title":"Toc"},{"location":"toc/#table-of-contents","text":"","title":"Table of Contents"},{"location":"toc/#shortcuts","text":"APUE - x86 assembly - Bash - BD - C - CLRS - CNAPP - CNSPP - CSN - DDA - DevOps - x86 disassembly - Golang - GOPL - HTAE - ICND1 - ICND2 - iptables - LKD - LSP - Nginx - PER - PIC - Python - Ruby - SPEC - TCPIP - TCPv1 - TLPI - TWGR - UNP - UTLK - Vim","title":"Shortcuts"},{"location":"toc/#contents","text":"Name Status Progress APUE Backlog Almost Done x86 assembly Backlog Almost Done Bash Future Started BD Discontinued First Half C Stub - CLRS Discontinued Started CNAPP Future Started CNSPP Backlog Started CSN Active First Half DDA Active Started DevOps Future Second Half x86 disassembly Future Started Golang Discontinued First Half GOPL Active Almost Done HTAE Backlog Started ICND1 Future Started ICND2 Future Started iptables Stub - LKD Active Second Half LSP Backlog Started Nginx Stub - PER Future Started PIC Future Started Python Stub - Ruby Discontinued First Half SPEC Backlog First Half TCPIP Backlog Started TCPv1 Backlog First Half TLPI Backlog Started TWGR Backlog Started UNP Backlog First Half UTLK Backlog First Half Vim Stub - Note: Active items are of P0 priority per OKR , and are in bold. All other items in the OKR are in backlog . Future items are not in the OKR but are likely to be revisited in the future. Stub items are not intended as notes. For progress, started : 15%; first half : 15% ~ 50%; second half : 50% ~ 85%; almost done : 85% ~ 100%; complete : 100%. For full titles, see Books and Materials .","title":"Contents"},{"location":"algorithm/","text":"Algorithm Topic 1: UnionFind Topic 2: StackQueue","title":"Contents"},{"location":"algorithm/#algorithm","text":"Topic 1: UnionFind Topic 2: StackQueue","title":"Algorithm"},{"location":"algorithm/ch2/","text":"Chapter 2: Sorting Merge Sort Basic plan: Divide array into two halves Recursively sort each half Merge two halves Goal. Given two sorted subarrays a[lo] to a[mid] and a[mid+1] to a[hi], replace with sorted subarray a[lo] to a[hi] Java Implementation ```Java","title":"Ch2"},{"location":"algorithm/ch2/#chapter-2-sorting","text":"","title":"Chapter 2: Sorting"},{"location":"algorithm/ch2/#merge-sort","text":"Basic plan: Divide array into two halves Recursively sort each half Merge two halves Goal. Given two sorted subarrays a[lo] to a[mid] and a[mid+1] to a[hi], replace with sorted subarray a[lo] to a[hi]","title":"Merge Sort"},{"location":"algorithm/ch2/#java-implementation","text":"```Java","title":"Java Implementation"},{"location":"algorithm/ch3/","text":"Chapter 3: Searching","title":"Ch3"},{"location":"algorithm/ch3/#chapter-3-searching","text":"","title":"Chapter 3: Searching"},{"location":"algorithm/ch4/","text":"Chapter 4: Graphs","title":"Ch4"},{"location":"algorithm/ch4/#chapter-4-graphs","text":"","title":"Chapter 4: Graphs"},{"location":"algorithm/ch5/","text":"Chapter 5: Strings","title":"Ch5"},{"location":"algorithm/ch5/#chapter-5-strings","text":"","title":"Chapter 5: Strings"},{"location":"algorithm/ch6/","text":"Chapter 6: Context","title":"Ch6"},{"location":"algorithm/ch6/#chapter-6-context","text":"","title":"Chapter 6: Context"},{"location":"algorithm/topic1/","text":"Chapter 1: Union Find 1 Dynamic Connectivity The graph connectivity problem is the following: Given an undirected graph G, preprocess the graph so that queries of the form \u201care nodes u and v connected?\u201d Connected components : Maximal set of objects that are mutually connected. Union-Find data type (API) Union-Find API: the union() operation merges two components if the two sites are in different components. the find() operation returns an integer component identifier for a given site. the connected() operation determines whether two sites are in the same component. the count() method returns the number of components. public class QuickFind { private int [] id ; private int count ; public QuickFind ( int N ) { count = N ; id = new int [ N ]; for ( int i = 0 ; i N ; i ++) id [ i ] = i ; } public boolean connected ( int p , int q ) { return find ( p ) == find ( q ); } public int find ( int p ) { } public void union ( int p , int q ) { } } Dynamic-connectivity client Read in number of objects N N from standard input. Repeat: read in pair of integers from standard input if they are not yet connected, connect them and print out pair We shall consider several different implementations, all based on using the site-indexed id[] array, to determine whether two sites are in the same connected component. 2 Quick-Find Quick-find idea: all sites in a component must have the same value in id[]. This method is called quick-find because find(p) just returns id[p], which immediately implies that connected(p, q) reduces to just the test id[p] == id[q] and returns true , if and only if p and q are in the same component. Union() : To combine the two components into one, we have to make all of the id[] entries corresponding to both sets of sites the same value. To do so, we go through the array, changing all the entries with values equal to id[p] to the value id[q]. public class QuickFind { private int [] id ; public QuickFind ( int N ) { id = new int [ N ]; for ( int i = 0 ; i N ; i ++) id [ i ] = i ; } public boolean connected ( int p , int q ) { return id [ p ] == id [ q ]; } public void union ( int p , int q ) { int pid = id [ p ]; int qid = id [ q ]; for ( int i = 0 ; i id . length ; i ++) if ( id [ i ] == pid ) id [ i ] = qid ; } } Analysis The quick-find algorithm uses one array access for each call to find() and between N + 3 N + 3 and 2N + 1 2N + 1 array accesses for each call to union() that combines two components. WORST CASE: suppose we wind up with a single component. This requires at least N-1 N-1 calls to union() , and, consequently, at least (N+3)(N-1) \\sim N^2 (N+3)(N-1) \\sim N^2 array accesses\u2014we are led immediately to the hypothesis that dynamic connectivity with quick-find can be a quadratic-time process. 3 Quick-Union Data structure: Interpretation: id[i] is parent of i. Root of i is id[id[id[...id[i]...]]] (keep going until it doesn\u2019t change) Specifically, the id[] entry, for each site is the name of another site in the same component (possibly itself)\u2014we refer to this connection as a link. To implement find() , we start at the given site, follow its link to another site, follow that site\u2019s link to yet another site, and so forth, following links until reaching a root, a site that has a link to itself. Two sites are in the same component if and only if this process leads them to the same root. union(p, q) : we follow links to finds the roots associated with p and q, then rename one of the components by linking one of these roots to the other; hence the name quick-union. public class QuickUnion { private int [] id ; private int count ; public QuickUnion ( int N ) { count = N ; id = new int [ N ]; // set id of each object to itself (N array accesses) for ( int i = 0 ; i N ; i ++) id [ i ] = i ; } private int find ( int p ) { // chase parent pointers until reach root while ( p != id [ p ]) p = id [ p ]; return p ; } public boolean connected ( int p , int q ) { //check if p and q have same root return find ( p ) == find ( q ); } public void union ( int p , int q ) { // change root of p to point to root of q int i = find ( p ); int j = find ( q ); id [ i ] = j ; count --; } } Analysis The number of array accesses used by find() in quick-union is 1 plus the twice the depth of the node corresponding to the given site. The number of array accesses used by union() and connected() is the cost of the two find() operations (plus 1 for union() if the given sites are in different trees). WORST CASE: suppose we wind up with a single component, the running time is quadratic 4 Improvement 1: weighting Weighted quick-union : Rather than arbitrarily connecting the second tree to the first for union() , we keep track of the size of each tree and always c onnect the smaller tree to the larger . This change needs another array to hold the node counts. public class WeightedQuickUnion { private int [] id ; // parent link (site indexed) private int [] sz ; // size of component for roots (site indexed) private int count ; // number of components public WeightedQuickUnion ( int N ) { count = N ; id = new int [ N ]; for ( int i = 0 ; i N ; i ++) id [ i ] = i ; sz = new int [ N ]; for ( int i = 0 ; i N ; i ++) sz [ i ] = 1 ; } public int count () { return count ; } public boolean connected ( int p , int q ) { return find ( p ) == find ( q ); } private int find ( int p ) { // Follow links to find a root. while ( p != id [ p ]) p = id [ p ]; return p ; } public void union ( int p , int q ) { int i = find ( p ); int j = find ( q ); if ( i == j ) return ; // Make smaller root point to larger one. if ( sz [ i ] sz [ j ]) { id [ i ] = j ; sz [ j ] += sz [ i ]; } else { id [ j ] = i ; sz [ i ] += sz [ j ]; } count --; } } Analysis The depth of any node in a forest built by weighted quick-union for N N sites is at most \\log N \\log N . The worst case for weighted quick union is when the sizes of the trees to be merged by union() are always equal (and a power of 2). And they have the simple property that the height of a tree of 2^n 2^n nodes is n n . For weighted quick-union with N N sites, the worst-case order of growth of the cost of find() , connected() , and union() is \\log N \\log N . Specifically, the weighted quick-union algorithm uses at most cM\\log N cM\\log N array accesses to process M M connections among N N sites for a small constant c c . 5 Improvement 2: path compression IDEA: Just after computing the root of p, set the id of each examined node to point to that root. Two-pass implementation: add second loop to find() to set the id[] of each examined node to the root. Simpler one-pass variant: Make every other node in path point to its grandparent (thereby halving path length). private int find ( int p ) { // Follow links to find a root. while ( p != id [ p ]) { // only one extra line of code ! id [ p ] = id [ id [ p ]]; p = id [ p ]; } return p ; } Amortized Analysis Starting from an empty data structure, any sequence of M M union-find ops on N N objects makes \\le c ( N + M \\lg^*N ) \\le c ( N + M \\lg^*N ) array accesses, where lg^* lg^* is iterated logarithm[ wiki ]. ( lg^*N lg^*N \u8868\u793a\u5c06 N N \u53d8\u4e3a\u5c0f\u4e8e1\u9700\u8981\u7684 \\log \\log \u8fed\u4ee3\u6b21\u6570) Application - Percolation","title":"Topic 1: UnionFind "},{"location":"algorithm/topic1/#chapter-1-union-find","text":"","title":"Chapter 1: Union Find"},{"location":"algorithm/topic1/#1-dynamic-connectivity","text":"The graph connectivity problem is the following: Given an undirected graph G, preprocess the graph so that queries of the form \u201care nodes u and v connected?\u201d Connected components : Maximal set of objects that are mutually connected.","title":"1 Dynamic Connectivity"},{"location":"algorithm/topic1/#union-find-data-type-api","text":"Union-Find API: the union() operation merges two components if the two sites are in different components. the find() operation returns an integer component identifier for a given site. the connected() operation determines whether two sites are in the same component. the count() method returns the number of components. public class QuickFind { private int [] id ; private int count ; public QuickFind ( int N ) { count = N ; id = new int [ N ]; for ( int i = 0 ; i N ; i ++) id [ i ] = i ; } public boolean connected ( int p , int q ) { return find ( p ) == find ( q ); } public int find ( int p ) { } public void union ( int p , int q ) { } }","title":"Union-Find data type (API)"},{"location":"algorithm/topic1/#dynamic-connectivity-client","text":"Read in number of objects N N from standard input. Repeat: read in pair of integers from standard input if they are not yet connected, connect them and print out pair We shall consider several different implementations, all based on using the site-indexed id[] array, to determine whether two sites are in the same connected component.","title":"Dynamic-connectivity client"},{"location":"algorithm/topic1/#2-quick-find","text":"Quick-find idea: all sites in a component must have the same value in id[]. This method is called quick-find because find(p) just returns id[p], which immediately implies that connected(p, q) reduces to just the test id[p] == id[q] and returns true , if and only if p and q are in the same component. Union() : To combine the two components into one, we have to make all of the id[] entries corresponding to both sets of sites the same value. To do so, we go through the array, changing all the entries with values equal to id[p] to the value id[q]. public class QuickFind { private int [] id ; public QuickFind ( int N ) { id = new int [ N ]; for ( int i = 0 ; i N ; i ++) id [ i ] = i ; } public boolean connected ( int p , int q ) { return id [ p ] == id [ q ]; } public void union ( int p , int q ) { int pid = id [ p ]; int qid = id [ q ]; for ( int i = 0 ; i id . length ; i ++) if ( id [ i ] == pid ) id [ i ] = qid ; } }","title":"2 Quick-Find"},{"location":"algorithm/topic1/#analysis","text":"The quick-find algorithm uses one array access for each call to find() and between N + 3 N + 3 and 2N + 1 2N + 1 array accesses for each call to union() that combines two components. WORST CASE: suppose we wind up with a single component. This requires at least N-1 N-1 calls to union() , and, consequently, at least (N+3)(N-1) \\sim N^2 (N+3)(N-1) \\sim N^2 array accesses\u2014we are led immediately to the hypothesis that dynamic connectivity with quick-find can be a quadratic-time process.","title":"Analysis"},{"location":"algorithm/topic1/#3-quick-union","text":"Data structure: Interpretation: id[i] is parent of i. Root of i is id[id[id[...id[i]...]]] (keep going until it doesn\u2019t change) Specifically, the id[] entry, for each site is the name of another site in the same component (possibly itself)\u2014we refer to this connection as a link. To implement find() , we start at the given site, follow its link to another site, follow that site\u2019s link to yet another site, and so forth, following links until reaching a root, a site that has a link to itself. Two sites are in the same component if and only if this process leads them to the same root. union(p, q) : we follow links to finds the roots associated with p and q, then rename one of the components by linking one of these roots to the other; hence the name quick-union. public class QuickUnion { private int [] id ; private int count ; public QuickUnion ( int N ) { count = N ; id = new int [ N ]; // set id of each object to itself (N array accesses) for ( int i = 0 ; i N ; i ++) id [ i ] = i ; } private int find ( int p ) { // chase parent pointers until reach root while ( p != id [ p ]) p = id [ p ]; return p ; } public boolean connected ( int p , int q ) { //check if p and q have same root return find ( p ) == find ( q ); } public void union ( int p , int q ) { // change root of p to point to root of q int i = find ( p ); int j = find ( q ); id [ i ] = j ; count --; } }","title":"3 Quick-Union"},{"location":"algorithm/topic1/#analysis_1","text":"The number of array accesses used by find() in quick-union is 1 plus the twice the depth of the node corresponding to the given site. The number of array accesses used by union() and connected() is the cost of the two find() operations (plus 1 for union() if the given sites are in different trees). WORST CASE: suppose we wind up with a single component, the running time is quadratic","title":"Analysis"},{"location":"algorithm/topic1/#4-improvement-1-weighting","text":"Weighted quick-union : Rather than arbitrarily connecting the second tree to the first for union() , we keep track of the size of each tree and always c onnect the smaller tree to the larger . This change needs another array to hold the node counts. public class WeightedQuickUnion { private int [] id ; // parent link (site indexed) private int [] sz ; // size of component for roots (site indexed) private int count ; // number of components public WeightedQuickUnion ( int N ) { count = N ; id = new int [ N ]; for ( int i = 0 ; i N ; i ++) id [ i ] = i ; sz = new int [ N ]; for ( int i = 0 ; i N ; i ++) sz [ i ] = 1 ; } public int count () { return count ; } public boolean connected ( int p , int q ) { return find ( p ) == find ( q ); } private int find ( int p ) { // Follow links to find a root. while ( p != id [ p ]) p = id [ p ]; return p ; } public void union ( int p , int q ) { int i = find ( p ); int j = find ( q ); if ( i == j ) return ; // Make smaller root point to larger one. if ( sz [ i ] sz [ j ]) { id [ i ] = j ; sz [ j ] += sz [ i ]; } else { id [ j ] = i ; sz [ i ] += sz [ j ]; } count --; } }","title":"4 Improvement 1: weighting"},{"location":"algorithm/topic1/#analysis_2","text":"The depth of any node in a forest built by weighted quick-union for N N sites is at most \\log N \\log N . The worst case for weighted quick union is when the sizes of the trees to be merged by union() are always equal (and a power of 2). And they have the simple property that the height of a tree of 2^n 2^n nodes is n n . For weighted quick-union with N N sites, the worst-case order of growth of the cost of find() , connected() , and union() is \\log N \\log N . Specifically, the weighted quick-union algorithm uses at most cM\\log N cM\\log N array accesses to process M M connections among N N sites for a small constant c c .","title":"Analysis"},{"location":"algorithm/topic1/#5-improvement-2-path-compression","text":"IDEA: Just after computing the root of p, set the id of each examined node to point to that root. Two-pass implementation: add second loop to find() to set the id[] of each examined node to the root. Simpler one-pass variant: Make every other node in path point to its grandparent (thereby halving path length). private int find ( int p ) { // Follow links to find a root. while ( p != id [ p ]) { // only one extra line of code ! id [ p ] = id [ id [ p ]]; p = id [ p ]; } return p ; }","title":"5 Improvement 2: path compression"},{"location":"algorithm/topic1/#amortized-analysis","text":"Starting from an empty data structure, any sequence of M M union-find ops on N N objects makes \\le c ( N + M \\lg^*N ) \\le c ( N + M \\lg^*N ) array accesses, where lg^* lg^* is iterated logarithm[ wiki ]. ( lg^*N lg^*N \u8868\u793a\u5c06 N N \u53d8\u4e3a\u5c0f\u4e8e1\u9700\u8981\u7684 \\log \\log \u8fed\u4ee3\u6b21\u6570)","title":"Amortized Analysis"},{"location":"algorithm/topic1/#application-percolation","text":"","title":"Application - Percolation"},{"location":"algorithm/topic2/","text":"Stacks and Queues Bags, queues, and stacks are fundamental and broadly useful. They involve collections of objects. Specifically, the set of values is a collection of objects, and the operations revolve around adding, removing, or iterating objects in the collection. 1 stacks Stack API Stack: linked-list representation Maintain pointer to first node in a linked list; insert/remove from front. 2 resizing arrays 3 queues 4 generics 5 iterators 6 applications","title":"Topic 2: StackQueue"},{"location":"algorithm/topic2/#stacks-and-queues","text":"Bags, queues, and stacks are fundamental and broadly useful. They involve collections of objects. Specifically, the set of values is a collection of objects, and the operations revolve around adding, removing, or iterating objects in the collection.","title":"Stacks and Queues"},{"location":"algorithm/topic2/#1-stacks","text":"","title":"1 stacks"},{"location":"algorithm/topic2/#stack-api","text":"","title":"Stack API"},{"location":"algorithm/topic2/#stack-linked-list-representation","text":"Maintain pointer to first node in a linked list; insert/remove from front.","title":"Stack: linked-list representation"},{"location":"algorithm/topic2/#2-resizing-arrays","text":"","title":"2 resizing arrays"},{"location":"algorithm/topic2/#3-queues","text":"","title":"3 queues"},{"location":"algorithm/topic2/#4-generics","text":"","title":"4 generics"},{"location":"algorithm/topic2/#5-iterators","text":"","title":"5 iterators"},{"location":"algorithm/topic2/#6-applications","text":"","title":"6 applications"},{"location":"cs61b/","text":"CS61B Lab1: javac, java, git Lab2: Unit Testing with JUnit and IntLists Lab3: Unit Testing with JUnit, Debugging","title":"Contents"},{"location":"cs61b/#cs61b","text":"Lab1: javac, java, git Lab2: Unit Testing with JUnit and IntLists Lab3: Unit Testing with JUnit, Debugging","title":"CS61B"},{"location":"cs61b/Lab1/","text":"Lab 1: javac, java, git Add the skeleton remote repository, and pull from the skeleton remote in order to get the starter code for lab 1. $ git remote add skeleton https://github.com/Berkeley-CS61B/skeleton-sp18.git $ git pull skeleton master Leap Year In the lab1 folder, you should see a file called LeapYear.java . This program is supposed to test whether or not a given year is a Leap Year. The user will give a year as a command line parameter (examples given below), and then print out whether or not that year is a leap year, e.g. $ java LeapYear 2000 2000 is a leap year. $ java LeapYear 1999 1999 is not a leap year. $ java LeapYear 2004 2004 is a leap year. $ java LeapYear 2100 2100 is not a leap year. A leap year is either: divisible by 400 or divisible by 4 and not by 100. Requirement: Make sure to provide a description of the method as a comment. Your description should be contained by /* and / (JavaDocs). Use the @source tag any time you receive significant help on a project. Some Java tips: The % operator implements remainder. The != operator compares two values for inequality. When one of the arguments of the + operator is a String, the arguments are concatenated as Strings. /** Class that determines whether or not a year is a leap year. * @author zhenhua wang */ public class LeapYear { /** Calls isLeapYear to print correct statement. * @param year to be analyzed */ private static void checkLeapYear ( int year ) { if ( isLeapYear ( year )) { System . out . printf ( %d is a leap year.\\n , year ); } else { System . out . printf ( %d is not a leap year.\\n , year ); } } /** Check if the year is a leap year * @param year int year */ private static boolean isLeapYear ( int year ) { if ( year % 400 == 0 ) return true ; else if (( year % 4 == 0 ) ( year % 100 != 0 )) return true ; return false ; } /** Must be provided an integer as a command line argument ARGS. * @param args int year */ public static void main ( String [] args ) { if ( args . length 1 ) { System . out . println ( Please enter command line arguments. ); System . out . println ( e.g. java Year 2000 ); } for ( int i = 0 ; i args . length ; i ++) { try { int year = Integer . parseInt ( args [ i ]); checkLeapYear ( year ); } catch ( NumberFormatException e ) { System . out . printf ( %s is not a valid number.\\n , args [ i ]); } } } }","title":"Lab1: javac, java, git"},{"location":"cs61b/Lab1/#lab-1-javac-java-git","text":"Add the skeleton remote repository, and pull from the skeleton remote in order to get the starter code for lab 1. $ git remote add skeleton https://github.com/Berkeley-CS61B/skeleton-sp18.git $ git pull skeleton master","title":"Lab 1: javac, java, git"},{"location":"cs61b/Lab1/#leap-year","text":"In the lab1 folder, you should see a file called LeapYear.java . This program is supposed to test whether or not a given year is a Leap Year. The user will give a year as a command line parameter (examples given below), and then print out whether or not that year is a leap year, e.g. $ java LeapYear 2000 2000 is a leap year. $ java LeapYear 1999 1999 is not a leap year. $ java LeapYear 2004 2004 is a leap year. $ java LeapYear 2100 2100 is not a leap year. A leap year is either: divisible by 400 or divisible by 4 and not by 100. Requirement: Make sure to provide a description of the method as a comment. Your description should be contained by /* and / (JavaDocs). Use the @source tag any time you receive significant help on a project. Some Java tips: The % operator implements remainder. The != operator compares two values for inequality. When one of the arguments of the + operator is a String, the arguments are concatenated as Strings. /** Class that determines whether or not a year is a leap year. * @author zhenhua wang */ public class LeapYear { /** Calls isLeapYear to print correct statement. * @param year to be analyzed */ private static void checkLeapYear ( int year ) { if ( isLeapYear ( year )) { System . out . printf ( %d is a leap year.\\n , year ); } else { System . out . printf ( %d is not a leap year.\\n , year ); } } /** Check if the year is a leap year * @param year int year */ private static boolean isLeapYear ( int year ) { if ( year % 400 == 0 ) return true ; else if (( year % 4 == 0 ) ( year % 100 != 0 )) return true ; return false ; } /** Must be provided an integer as a command line argument ARGS. * @param args int year */ public static void main ( String [] args ) { if ( args . length 1 ) { System . out . println ( Please enter command line arguments. ); System . out . println ( e.g. java Year 2000 ); } for ( int i = 0 ; i args . length ; i ++) { try { int year = Integer . parseInt ( args [ i ]); checkLeapYear ( year ); } catch ( NumberFormatException e ) { System . out . printf ( %s is not a valid number.\\n , args [ i ]); } } } }","title":"Leap Year"},{"location":"cs61b/Lab2/","text":"Lab 2: Unit Testing with JUnit and IntLists 1 Lab 2 setup: Setting Up IntelliJ Installing the IntelliJ CS 61B Plugin after installation of IntelliJ. Getting Java Libraries git submodule update -- init 2 Lab 2: Unit Testing with JUnit and IntLists Introduction In this lab, you will learn about basic IntelliJ features, Destructive vs NonDestructive methods, and IntLists. Breakpoints and Step Into While print statements can be very useful for debugging, they have a few disadvantages: They require you to modify your code (to add print statements). They require you to explicitly state what you want to know (since you have to say precisely what you want to print). And they provide their results in a format that can be hard to read, since it s just a big blob of text in the execution window. The IntelliJ debugger allows you to pause the code in the middle of execution, step the code line by line, and even visualize the organization of complex data structures like linked lists. The step over button allows us to complete a function call without showing the function executing Conditional Breakpoints and Resume An even faster approach is to make our breakpoint conditional. To do this, right (or two-finer) click on the red breakpoint dot. Here, you can set a condition for when you want to stop. Destructive vs. Non-Destructive By destructive, we mean that the original list changes. The term mutative is also sometimes used. By contrast a non-destructive method does not affect the original list. Implementing Destructive vs. Non-destructive Methods package com.berkeycs61b.lab2.Intlist ; import java.util.Formatter ; /** * A naked recursive list of integers, similar to what we saw in lecture 3, but * with a large number of additional methods. * * @author P. N. Hilfinger, with some modifications by Josh Hug and melaniecebula * [Do not modify this file.] */ public class IntList { /** * First element of list. */ public int first ; /** * Remaining elements of list. */ public IntList rest ; /** * A List with first FIRST0 and rest REST0. */ public IntList ( int first0 , IntList rest0 ) { first = first0 ; rest = rest0 ; } /** * A List with null rest, and first = 0. */ public IntList () { /* NOTE: public IntList () { } would also work. */ this ( 0 , null ); } /** * Returns a list equal to L with all elements squared. Destructive. */ public static void dSquareList ( IntList L ) { while ( L != null ) { L . first = L . first * L . first ; L = L . rest ; } } /** * Returns a list equal to L with all elements squared. Non-destructive. */ public static IntList squareListIterative ( IntList L ) { if ( L == null ) { return null ; } IntList res = new IntList ( L . first * L . first , null ); IntList ptr = res ; L = L . rest ; while ( L != null ) { ptr . rest = new IntList ( L . first * L . first , null ); L = L . rest ; ptr = ptr . rest ; } return res ; } /** * Returns a list equal to L with all elements squared. Non-destructive. */ public static IntList squareListRecursive ( IntList L ) { if ( L == null ) { return null ; } return new IntList ( L . first * L . first , squareListRecursive ( L . rest )); } /** DO NOT MODIFY ANYTHING ABOVE THIS LINE! */ /** * Returns a list consisting of the elements of A followed by the * * elements of B. May modify items of A. Don t use new . */ public static IntList dcatenate ( IntList A , IntList B ) { //TODO: fill in method IntList A_location = A ; while ( A_location . rest != null ) { A_location = A_location . rest ; } A_location . rest = B ; return A ; } /** * Returns a list consisting of the elements of A followed by the * * elements of B. May NOT modify items of A. Use new . */ public static IntList catenate ( IntList A , IntList B ) { //TODO: fill in method IntList res = new IntList ( A . first , null ); IntList res_location = res ; IntList A_location = A . rest ; while ( A_location . rest != null ) { res_location . rest = new IntList ( A_location . first , null ); A_location = A_location . rest ; res_location = res_location . rest ; } res_location . rest = new IntList ( A_location . first , null ); res_location = res_location . rest ; IntList B_location = B ; while ( B_location . rest != null ) { res_location . rest = new IntList ( B_location . first , null ); B_location = B_location . rest ; res_location = res_location . rest ; } res_location . rest = new IntList ( B_location . first , null ); return res ; } /** * DO NOT MODIFY ANYTHING BELOW THIS LINE! Many of the concepts below here * will be introduced later in the course or feature some form of advanced * trickery which we implemented to help make your life a little easier for * the lab. */ @Override public int hashCode () { return first ; } /** * Returns a new IntList containing the ints in ARGS. You are not * expected to read or understand this method. */ public static IntList of ( Integer ... args ) { IntList result , p ; if ( args . length 0 ) { result = new IntList ( args [ 0 ], null ); } else { return null ; } int k ; for ( k = 1 , p = result ; k args . length ; k += 1 , p = p . rest ) { p . rest = new IntList ( args [ k ], null ); } return result ; } /** * Returns true iff X is an IntList containing the same sequence of ints * as THIS. Cannot handle IntLists with cycles. You are not expected to * read or understand this method. */ public boolean equals ( Object x ) { if (!( x instanceof IntList )) { return false ; } IntList L = ( IntList ) x ; IntList p ; for ( p = this ; p != null L != null ; p = p . rest , L = L . rest ) { if ( p . first != L . first ) { return false ; } } if ( p != null || L != null ) { return false ; } return true ; } /** * If a cycle exists in the IntList, this method * returns an integer equal to the item number of the location where the * cycle is detected. * p * If there is no cycle, the number 0 is returned instead. This is a * utility method for lab2. You are not expected to read, understand, or * even use this method. The point of this method is so that if you convert * an IntList into a String and that IntList has a loop, your computer * doesn t get stuck in an infinite loop. */ private int detectCycles ( IntList A ) { IntList tortoise = A ; IntList hare = A ; if ( A == null ) { return 0 ; } int cnt = 0 ; while ( true ) { cnt ++; if ( hare . rest != null ) { hare = hare . rest . rest ; } else { return 0 ; } tortoise = tortoise . rest ; if ( tortoise == null || hare == null ) { return 0 ; } if ( hare == tortoise ) { return cnt ; } } } @Override /** Outputs the IntList as a String. You are not expected to read * or understand this method. */ public String toString () { Formatter out = new Formatter (); String sep ; sep = ( ; int cycleLocation = detectCycles ( this ); int cnt = 0 ; for ( IntList p = this ; p != null ; p = p . rest ) { out . format ( %s%d , sep , p . first ); sep = , ; cnt ++; if (( cnt cycleLocation ) ( cycleLocation 0 )) { out . format ( ... (cycle exists) ... ); break ; } } out . format ( ) ); return out . toString (); } }","title":"Lab2: Unit Testing with JUnit and IntLists"},{"location":"cs61b/Lab2/#lab-2-unit-testing-with-junit-and-intlists","text":"","title":"Lab 2: Unit Testing with JUnit and IntLists"},{"location":"cs61b/Lab2/#1-lab-2-setup-setting-up-intellij","text":"Installing the IntelliJ CS 61B Plugin after installation of IntelliJ. Getting Java Libraries git submodule update -- init","title":"1 Lab 2 setup: Setting Up IntelliJ"},{"location":"cs61b/Lab2/#2-lab-2-unit-testing-with-junit-and-intlists","text":"","title":"2 Lab 2: Unit Testing with JUnit and IntLists"},{"location":"cs61b/Lab2/#introduction","text":"In this lab, you will learn about basic IntelliJ features, Destructive vs NonDestructive methods, and IntLists.","title":"Introduction"},{"location":"cs61b/Lab2/#breakpoints-and-step-into","text":"While print statements can be very useful for debugging, they have a few disadvantages: They require you to modify your code (to add print statements). They require you to explicitly state what you want to know (since you have to say precisely what you want to print). And they provide their results in a format that can be hard to read, since it s just a big blob of text in the execution window. The IntelliJ debugger allows you to pause the code in the middle of execution, step the code line by line, and even visualize the organization of complex data structures like linked lists. The step over button allows us to complete a function call without showing the function executing","title":"Breakpoints and Step Into"},{"location":"cs61b/Lab2/#conditional-breakpoints-and-resume","text":"An even faster approach is to make our breakpoint conditional. To do this, right (or two-finer) click on the red breakpoint dot. Here, you can set a condition for when you want to stop.","title":"Conditional Breakpoints and Resume"},{"location":"cs61b/Lab2/#destructive-vs-non-destructive","text":"By destructive, we mean that the original list changes. The term mutative is also sometimes used. By contrast a non-destructive method does not affect the original list.","title":"Destructive vs. Non-Destructive"},{"location":"cs61b/Lab2/#implementing-destructive-vs-non-destructive-methods","text":"package com.berkeycs61b.lab2.Intlist ; import java.util.Formatter ; /** * A naked recursive list of integers, similar to what we saw in lecture 3, but * with a large number of additional methods. * * @author P. N. Hilfinger, with some modifications by Josh Hug and melaniecebula * [Do not modify this file.] */ public class IntList { /** * First element of list. */ public int first ; /** * Remaining elements of list. */ public IntList rest ; /** * A List with first FIRST0 and rest REST0. */ public IntList ( int first0 , IntList rest0 ) { first = first0 ; rest = rest0 ; } /** * A List with null rest, and first = 0. */ public IntList () { /* NOTE: public IntList () { } would also work. */ this ( 0 , null ); } /** * Returns a list equal to L with all elements squared. Destructive. */ public static void dSquareList ( IntList L ) { while ( L != null ) { L . first = L . first * L . first ; L = L . rest ; } } /** * Returns a list equal to L with all elements squared. Non-destructive. */ public static IntList squareListIterative ( IntList L ) { if ( L == null ) { return null ; } IntList res = new IntList ( L . first * L . first , null ); IntList ptr = res ; L = L . rest ; while ( L != null ) { ptr . rest = new IntList ( L . first * L . first , null ); L = L . rest ; ptr = ptr . rest ; } return res ; } /** * Returns a list equal to L with all elements squared. Non-destructive. */ public static IntList squareListRecursive ( IntList L ) { if ( L == null ) { return null ; } return new IntList ( L . first * L . first , squareListRecursive ( L . rest )); } /** DO NOT MODIFY ANYTHING ABOVE THIS LINE! */ /** * Returns a list consisting of the elements of A followed by the * * elements of B. May modify items of A. Don t use new . */ public static IntList dcatenate ( IntList A , IntList B ) { //TODO: fill in method IntList A_location = A ; while ( A_location . rest != null ) { A_location = A_location . rest ; } A_location . rest = B ; return A ; } /** * Returns a list consisting of the elements of A followed by the * * elements of B. May NOT modify items of A. Use new . */ public static IntList catenate ( IntList A , IntList B ) { //TODO: fill in method IntList res = new IntList ( A . first , null ); IntList res_location = res ; IntList A_location = A . rest ; while ( A_location . rest != null ) { res_location . rest = new IntList ( A_location . first , null ); A_location = A_location . rest ; res_location = res_location . rest ; } res_location . rest = new IntList ( A_location . first , null ); res_location = res_location . rest ; IntList B_location = B ; while ( B_location . rest != null ) { res_location . rest = new IntList ( B_location . first , null ); B_location = B_location . rest ; res_location = res_location . rest ; } res_location . rest = new IntList ( B_location . first , null ); return res ; } /** * DO NOT MODIFY ANYTHING BELOW THIS LINE! Many of the concepts below here * will be introduced later in the course or feature some form of advanced * trickery which we implemented to help make your life a little easier for * the lab. */ @Override public int hashCode () { return first ; } /** * Returns a new IntList containing the ints in ARGS. You are not * expected to read or understand this method. */ public static IntList of ( Integer ... args ) { IntList result , p ; if ( args . length 0 ) { result = new IntList ( args [ 0 ], null ); } else { return null ; } int k ; for ( k = 1 , p = result ; k args . length ; k += 1 , p = p . rest ) { p . rest = new IntList ( args [ k ], null ); } return result ; } /** * Returns true iff X is an IntList containing the same sequence of ints * as THIS. Cannot handle IntLists with cycles. You are not expected to * read or understand this method. */ public boolean equals ( Object x ) { if (!( x instanceof IntList )) { return false ; } IntList L = ( IntList ) x ; IntList p ; for ( p = this ; p != null L != null ; p = p . rest , L = L . rest ) { if ( p . first != L . first ) { return false ; } } if ( p != null || L != null ) { return false ; } return true ; } /** * If a cycle exists in the IntList, this method * returns an integer equal to the item number of the location where the * cycle is detected. * p * If there is no cycle, the number 0 is returned instead. This is a * utility method for lab2. You are not expected to read, understand, or * even use this method. The point of this method is so that if you convert * an IntList into a String and that IntList has a loop, your computer * doesn t get stuck in an infinite loop. */ private int detectCycles ( IntList A ) { IntList tortoise = A ; IntList hare = A ; if ( A == null ) { return 0 ; } int cnt = 0 ; while ( true ) { cnt ++; if ( hare . rest != null ) { hare = hare . rest . rest ; } else { return 0 ; } tortoise = tortoise . rest ; if ( tortoise == null || hare == null ) { return 0 ; } if ( hare == tortoise ) { return cnt ; } } } @Override /** Outputs the IntList as a String. You are not expected to read * or understand this method. */ public String toString () { Formatter out = new Formatter (); String sep ; sep = ( ; int cycleLocation = detectCycles ( this ); int cnt = 0 ; for ( IntList p = this ; p != null ; p = p . rest ) { out . format ( %s%d , sep , p . first ); sep = , ; cnt ++; if (( cnt cycleLocation ) ( cycleLocation 0 )) { out . format ( ... (cycle exists) ... ); break ; } } out . format ( ) ); return out . toString (); } }","title":"Implementing Destructive vs. Non-destructive Methods"},{"location":"cs61b/Lab3/","text":"Lab 3: Unit Testing with JUnit, Debugging 1 Introduction JUnit is a Unit Testing Framework for Java. Unit Testing is a great way to rigorously test each method of your code and ultimately ensure that you have a working project. The \u201cUnit\u201d part of Unit Testing comes from the idea that you can break your program down into units, or the smallest testable part of an application. Therefore, Unit Testing enforces good code structure (each method should only do \u201cOne Thing\u201d), and allows you to consider all of the edge cases for each method and test for them individually. JUnit Syntax assertEquals is a common method used in JUnit tests. It tests if a variable\u2019s actual value is equivalent to its expected value. @Test public void testMethod () { assertEquals ( expected , actual ); } When you create JUnit test files, you should precede each test method with a @Test annotation, and can have one or more assertEquals or assertTrue methods (provided by the JUnit library). All tests must be non-static. Running JUnit Tests in IntelliJ Even though methods includes many assert statements, only one failure is shown. This is because JUnit tests are short-circuiting \u2013 as soon as one of the asserts in a method fails, it will output the failure and move on to the next test. Write a test BEFORE we write a method. Don\u2019t fill in the code for the actual method yet, just make it return null. Write a method, and rerun the tests until it passes. Pro tip: If you want to have your tests timeout after a certain amount of time (to prevent in\ufb01nite loops), you can declare your test like this: @Test ( timeout = 1000 ) A Debugging Mystery Another important skill to learn is how to exhaustively debug. When done properly, debugging should allow you to rapidly narrow down where a bug might be located, even when you are debugging code you don\u2019t fully understand. Using any combination of the following techniques, figure out whether the bug is in Horrible Steve\u2019s code or in Flik enterprise\u2019s library: Writing JUnit tests for the Flik library. Using the IntelliJ debugger, especially conditional breakpoints. Using print statements. Refactoring Horrible Steve\u2019s code. Refactoring means changing the syntax without changing the functionality. This may be hard to do since HS\u2019s code uses lots of weird stuff. We do not expect you to \ufb01x the bug or even understand why it\u2019s happening once you have found it. Instead, your job is simply to find the bug. Tip: JUnit provides methods assertTrue(boolean) and assertTrue(String, boolean) that you might find helpful. Running the 61B Style Checker We will be using the CS 61B IntelliJ Plugin to check for style. official 61B style guide My common mistake: ',' is followed by whitespace. Using trailing comments.","title":"Lab3: Unit Testing with JUnit, Debugging"},{"location":"cs61b/Lab3/#lab-3-unit-testing-with-junit-debugging","text":"","title":"Lab 3: Unit Testing with JUnit, Debugging"},{"location":"cs61b/Lab3/#1-introduction","text":"JUnit is a Unit Testing Framework for Java. Unit Testing is a great way to rigorously test each method of your code and ultimately ensure that you have a working project. The \u201cUnit\u201d part of Unit Testing comes from the idea that you can break your program down into units, or the smallest testable part of an application. Therefore, Unit Testing enforces good code structure (each method should only do \u201cOne Thing\u201d), and allows you to consider all of the edge cases for each method and test for them individually.","title":"1 Introduction"},{"location":"cs61b/Lab3/#junit-syntax","text":"assertEquals is a common method used in JUnit tests. It tests if a variable\u2019s actual value is equivalent to its expected value. @Test public void testMethod () { assertEquals ( expected , actual ); } When you create JUnit test files, you should precede each test method with a @Test annotation, and can have one or more assertEquals or assertTrue methods (provided by the JUnit library). All tests must be non-static.","title":"JUnit Syntax"},{"location":"cs61b/Lab3/#running-junit-tests-in-intellij","text":"Even though methods includes many assert statements, only one failure is shown. This is because JUnit tests are short-circuiting \u2013 as soon as one of the asserts in a method fails, it will output the failure and move on to the next test. Write a test BEFORE we write a method. Don\u2019t fill in the code for the actual method yet, just make it return null. Write a method, and rerun the tests until it passes. Pro tip: If you want to have your tests timeout after a certain amount of time (to prevent in\ufb01nite loops), you can declare your test like this: @Test ( timeout = 1000 )","title":"Running JUnit Tests in IntelliJ"},{"location":"cs61b/Lab3/#a-debugging-mystery","text":"Another important skill to learn is how to exhaustively debug. When done properly, debugging should allow you to rapidly narrow down where a bug might be located, even when you are debugging code you don\u2019t fully understand. Using any combination of the following techniques, figure out whether the bug is in Horrible Steve\u2019s code or in Flik enterprise\u2019s library: Writing JUnit tests for the Flik library. Using the IntelliJ debugger, especially conditional breakpoints. Using print statements. Refactoring Horrible Steve\u2019s code. Refactoring means changing the syntax without changing the functionality. This may be hard to do since HS\u2019s code uses lots of weird stuff. We do not expect you to \ufb01x the bug or even understand why it\u2019s happening once you have found it. Instead, your job is simply to find the bug. Tip: JUnit provides methods assertTrue(boolean) and assertTrue(String, boolean) that you might find helpful.","title":"A Debugging Mystery"},{"location":"cs61b/Lab3/#running-the-61b-style-checker","text":"We will be using the CS 61B IntelliJ Plugin to check for style. official 61B style guide My common mistake: ',' is followed by whitespace. Using trailing comments.","title":"Running the 61B Style Checker"}]}