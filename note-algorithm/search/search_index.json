{
    "docs": [
        {
            "location": "/", 
            "text": "Zhenhua's Notes - Algorithm\n\n\nThis site documents reading and learning notes.\n\n\nOther Note Site\n\n\nNote - Java/OS\n\n\nNote - Big Data\n\n\nSearch\n\n\n\n  \n\n    \n\n      (function() {\n        var cx = '000491777875727507539:_gc3mx7cstg';\n        var gcse = document.createElement('script');\n        gcse.type = 'text/javascript';\n        gcse.async = true;\n        gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +\n            '//cse.google.com/cse.js?cx=' + cx;\n        var s = document.getElementsByTagName('script')[0];\n        s.parentNode.insertBefore(gcse, s);\n      })();\n    \n\n    \n\n  \n\n\n\n\n\nTOC\n\n\nSee \nTable of Contents\n.\n\n\nBooks and Materials\n\n\nSee \nBooks and Materials\n.\n\n\nRoadmap\n\n\nSee \nRoadmap\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#zhenhuas-notes-algorithm", 
            "text": "This site documents reading and learning notes.", 
            "title": "Zhenhua's Notes - Algorithm"
        }, 
        {
            "location": "/#other-note-site", 
            "text": "Note - Java/OS  Note - Big Data", 
            "title": "Other Note Site"
        }, 
        {
            "location": "/#search", 
            "text": "(function() {\n        var cx = '000491777875727507539:_gc3mx7cstg';\n        var gcse = document.createElement('script');\n        gcse.type = 'text/javascript';\n        gcse.async = true;\n        gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +\n            '//cse.google.com/cse.js?cx=' + cx;\n        var s = document.getElementsByTagName('script')[0];\n        s.parentNode.insertBefore(gcse, s);\n      })();", 
            "title": "Search"
        }, 
        {
            "location": "/#toc", 
            "text": "See  Table of Contents .", 
            "title": "TOC"
        }, 
        {
            "location": "/#books-and-materials", 
            "text": "See  Books and Materials .", 
            "title": "Books and Materials"
        }, 
        {
            "location": "/#roadmap", 
            "text": "See  Roadmap .", 
            "title": "Roadmap"
        }, 
        {
            "location": "/algorithm/", 
            "text": "Algorithm\n\n\n\n\nChapter 1: Fundamentals \n\n\nChapter 2: Sorting\n\n\nChapter 3: Searching\n\n\nChapter 4: Graphs\n\n\nChapter 5: Strings\n\n\nChapter 6: Context", 
            "title": "Contents"
        }, 
        {
            "location": "/algorithm/#algorithm", 
            "text": "Chapter 1: Fundamentals   Chapter 2: Sorting  Chapter 3: Searching  Chapter 4: Graphs  Chapter 5: Strings  Chapter 6: Context", 
            "title": "Algorithm"
        }, 
        {
            "location": "/algorithm/ch1/", 
            "text": "Chapter 1: Fundamentals", 
            "title": "Chapter 1: Fundamentals "
        }, 
        {
            "location": "/algorithm/ch1/#chapter-1-fundamentals", 
            "text": "", 
            "title": "Chapter 1: Fundamentals"
        }, 
        {
            "location": "/algorithm/ch2/", 
            "text": "Chapter 2: Sorting", 
            "title": "Chapter 2: Sorting"
        }, 
        {
            "location": "/algorithm/ch2/#chapter-2-sorting", 
            "text": "", 
            "title": "Chapter 2: Sorting"
        }, 
        {
            "location": "/algorithm/ch3/", 
            "text": "Chapter 3: Searching", 
            "title": "Chapter 3: Searching"
        }, 
        {
            "location": "/algorithm/ch3/#chapter-3-searching", 
            "text": "", 
            "title": "Chapter 3: Searching"
        }, 
        {
            "location": "/algorithm/ch4/", 
            "text": "Chapter 4: Graphs", 
            "title": "Chapter 4: Graphs"
        }, 
        {
            "location": "/algorithm/ch4/#chapter-4-graphs", 
            "text": "", 
            "title": "Chapter 4: Graphs"
        }, 
        {
            "location": "/algorithm/ch5/", 
            "text": "Chapter 5: Strings", 
            "title": "Chapter 5: Strings"
        }, 
        {
            "location": "/algorithm/ch5/#chapter-5-strings", 
            "text": "", 
            "title": "Chapter 5: Strings"
        }, 
        {
            "location": "/algorithm/ch6/", 
            "text": "Chapter 6: Context", 
            "title": "Chapter 6: Context"
        }, 
        {
            "location": "/algorithm/ch6/#chapter-6-context", 
            "text": "", 
            "title": "Chapter 6: Context"
        }, 
        {
            "location": "/cs61b/", 
            "text": "CS61B\n\n\n\n\nLab1: javac, java, git\n\n\nLab2: Unit Testing with JUnit and IntLists\n\n\nLab3: Unit Testing with JUnit, Debugging", 
            "title": "Contents"
        }, 
        {
            "location": "/cs61b/#cs61b", 
            "text": "Lab1: javac, java, git  Lab2: Unit Testing with JUnit and IntLists  Lab3: Unit Testing with JUnit, Debugging", 
            "title": "CS61B"
        }, 
        {
            "location": "/cs61b/Lab1/", 
            "text": "Lab 1: javac, java, git\n\n\nAdd the skeleton remote repository, and pull from the skeleton remote in order to get the starter code for lab 1.\n\n\n \n$ git remote add skeleton https://github.com/Berkeley-CS61B/skeleton-sp18.git\n$ git pull skeleton master\n\n\n\nLeap Year\n\n\nIn the lab1 folder, you should see a file called \nLeapYear.java\n. This program is supposed to test whether or not a given year is a Leap Year. The user will give a year as a command line parameter (examples given below), and then print out whether or not that year is a leap year, e.g.\n\n\n \n$ java LeapYear \n2000\n \n\n2000\n is a leap year.\n$ java LeapYear \n1999\n \n\n1999\n is not a leap year. \n$ java LeapYear \n2004\n \n\n2004\n is a leap year.\n$ java LeapYear \n2100\n \n\n2100\n is not a leap year.\n\n\n\nA leap year is either:\n\n\n\n\ndivisible by 400 or\n\n\ndivisible by 4 and not by 100.\n\n\n\n\nRequirement:\n\n\n\n\nMake sure to provide a description of the method as a comment. Your description should be contained by /*\n and \n/ (JavaDocs). \n\n\nUse the @source tag any time you receive significant help on a project.\n\n\n\n\nSome Java tips:\n\n\n\n\nThe % operator implements remainder.\n\n\nThe != operator compares two values for inequality.\n\n\nWhen one of the arguments of the + operator is a String, the arguments are concatenated as Strings.\n\n\n\n\n \n/** Class that determines whether or not a year is a leap year.\n\n\n *  @author zhenhua wang\n\n\n */\n\n\npublic\n \nclass\n \nLeapYear\n \n{\n\n\n    \n/** Calls isLeapYear to print correct statement.\n\n\n     *  @param  year to be analyzed\n\n\n     */\n\n    \nprivate\n \nstatic\n \nvoid\n \ncheckLeapYear\n(\nint\n \nyear\n)\n \n{\n\n        \nif\n \n(\nisLeapYear\n(\nyear\n))\n \n{\n\n            \nSystem\n.\nout\n.\nprintf\n(\n%d is a leap year.\\n\n,\n \nyear\n);\n\n        \n}\n \nelse\n \n{\n\n            \nSystem\n.\nout\n.\nprintf\n(\n%d is not a leap year.\\n\n,\n \nyear\n);\n\n        \n}\n\n    \n}\n\n\n    \n/** Check if the year  is a leap year\n\n\n     * @param year int year\n\n\n     */\n\n    \nprivate\n \nstatic\n \nboolean\n \nisLeapYear\n(\nint\n \nyear\n)\n \n{\n\n        \nif\n \n(\nyear\n%\n400\n \n==\n \n0\n)\n\n            \nreturn\n \ntrue\n;\n\n        \nelse\n \nif\n \n((\nyear\n%\n4\n==\n0\n)\n \n \n(\nyear\n \n%\n100\n \n!=\n0\n))\n\n            \nreturn\n \ntrue\n;\n\n        \nreturn\n \nfalse\n;\n\n    \n}\n\n\n\n\n\n    \n/** Must be provided an integer as a command line argument ARGS.\n\n\n     * @param args int year\n\n\n     */\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n        \nif\n \n(\nargs\n.\nlength\n \n \n1\n)\n \n{\n\n            \nSystem\n.\nout\n.\nprintln\n(\nPlease enter command line arguments.\n);\n\n            \nSystem\n.\nout\n.\nprintln\n(\ne.g. java Year 2000\n);\n\n        \n}\n\n        \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nargs\n.\nlength\n;\n \ni\n++)\n \n{\n\n            \ntry\n \n{\n\n                \nint\n \nyear\n \n=\n \nInteger\n.\nparseInt\n(\nargs\n[\ni\n]);\n\n                \ncheckLeapYear\n(\nyear\n);\n\n            \n}\n \ncatch\n \n(\nNumberFormatException\n \ne\n)\n \n{\n\n                \nSystem\n.\nout\n.\nprintf\n(\n%s is not a valid number.\\n\n,\n \nargs\n[\ni\n]);\n\n            \n}\n\n        \n}\n\n    \n}\n\n\n}", 
            "title": "Lab1: javac, java, git"
        }, 
        {
            "location": "/cs61b/Lab1/#lab-1-javac-java-git", 
            "text": "Add the skeleton remote repository, and pull from the skeleton remote in order to get the starter code for lab 1.    $ git remote add skeleton https://github.com/Berkeley-CS61B/skeleton-sp18.git\n$ git pull skeleton master", 
            "title": "Lab 1: javac, java, git"
        }, 
        {
            "location": "/cs61b/Lab1/#leap-year", 
            "text": "In the lab1 folder, you should see a file called  LeapYear.java . This program is supposed to test whether or not a given year is a Leap Year. The user will give a year as a command line parameter (examples given below), and then print out whether or not that year is a leap year, e.g.    $ java LeapYear  2000   2000  is a leap year.\n$ java LeapYear  1999   1999  is not a leap year. \n$ java LeapYear  2004   2004  is a leap year.\n$ java LeapYear  2100   2100  is not a leap year.  A leap year is either:   divisible by 400 or  divisible by 4 and not by 100.   Requirement:   Make sure to provide a description of the method as a comment. Your description should be contained by /*  and  / (JavaDocs).   Use the @source tag any time you receive significant help on a project.   Some Java tips:   The % operator implements remainder.  The != operator compares two values for inequality.  When one of the arguments of the + operator is a String, the arguments are concatenated as Strings.     /** Class that determines whether or not a year is a leap year.   *  @author zhenhua wang   */  public   class   LeapYear   { \n\n     /** Calls isLeapYear to print correct statement.       *  @param  year to be analyzed       */ \n     private   static   void   checkLeapYear ( int   year )   { \n         if   ( isLeapYear ( year ))   { \n             System . out . printf ( %d is a leap year.\\n ,   year ); \n         }   else   { \n             System . out . printf ( %d is not a leap year.\\n ,   year ); \n         } \n     } \n\n     /** Check if the year  is a leap year       * @param year int year       */ \n     private   static   boolean   isLeapYear ( int   year )   { \n         if   ( year % 400   ==   0 ) \n             return   true ; \n         else   if   (( year % 4 == 0 )     ( year   % 100   != 0 )) \n             return   true ; \n         return   false ; \n     } \n\n\n\n\n     /** Must be provided an integer as a command line argument ARGS.       * @param args int year       */ \n     public   static   void   main ( String []   args )   { \n         if   ( args . length     1 )   { \n             System . out . println ( Please enter command line arguments. ); \n             System . out . println ( e.g. java Year 2000 ); \n         } \n         for   ( int   i   =   0 ;   i     args . length ;   i ++)   { \n             try   { \n                 int   year   =   Integer . parseInt ( args [ i ]); \n                 checkLeapYear ( year ); \n             }   catch   ( NumberFormatException   e )   { \n                 System . out . printf ( %s is not a valid number.\\n ,   args [ i ]); \n             } \n         } \n     }  }", 
            "title": "Leap Year"
        }, 
        {
            "location": "/cs61b/Lab2/", 
            "text": "Lab 2: Unit Testing with JUnit and IntLists\n\n\n1 Lab 2 setup: Setting Up IntelliJ\n\n\nInstalling the IntelliJ CS 61B Plugin after installation of IntelliJ.\n\n\n\n\nGetting Java Libraries\n\n\n \ngit\n \nsubmodule\n \nupdate\n \n--\ninit\n\n\n\n\n2 Lab 2: Unit Testing with JUnit and IntLists\n\n\nIntroduction\n\n\nIn this lab, you will learn about basic IntelliJ features, Destructive vs NonDestructive methods, and IntLists.\n\n\nBreakpoints and Step Into\n\n\nWhile print statements can be very useful for debugging, they have a few disadvantages: \n\n\n\n\nThey require you to modify your code (to add print statements). \n\n\nThey require you to explicitly state what you want to know (since you have to say precisely what you want to print). \n\n\nAnd they provide their results in a format that can be hard to read, since it\ns just a big blob of text in the execution window.\n\n\n\n\nThe IntelliJ debugger allows you to pause the code in the middle of execution, step the code line by line, and even visualize the organization of complex data structures like linked lists.\n\n\nThe \nstep over\n button allows us to complete a function call without showing the function executing\n\n\nConditional Breakpoints and Resume\n\n\nAn even faster approach is to make our breakpoint conditional. To do this, right (or two-finer) click on the red breakpoint dot. Here, you can set a condition for when you want to stop.\n\n\n\n\nDestructive vs. Non-Destructive\n\n\nBy destructive, we mean that the original list changes. The term \nmutative\n is also sometimes used. By contrast a non-destructive method  does not affect the original list.\n\n\nImplementing Destructive vs. Non-destructive Methods\n\n\n \npackage\n \ncom.berkeycs61b.lab2.Intlist\n;\n\n\n\nimport\n \njava.util.Formatter\n;\n\n\n\n/**\n\n\n * A naked recursive list of integers, similar to what we saw in lecture 3, but\n\n\n * with a large number of additional methods.\n\n\n *\n\n\n * @author P. N. Hilfinger, with some modifications by Josh Hug and melaniecebula\n\n\n *         [Do not modify this file.]\n\n\n */\n\n\npublic\n \nclass\n \nIntList\n \n{\n\n    \n/**\n\n\n     * First element of list.\n\n\n     */\n\n    \npublic\n \nint\n \nfirst\n;\n\n    \n/**\n\n\n     * Remaining elements of list.\n\n\n     */\n\n    \npublic\n \nIntList\n \nrest\n;\n\n\n    \n/**\n\n\n     * A List with first FIRST0 and rest REST0.\n\n\n     */\n\n    \npublic\n \nIntList\n(\nint\n \nfirst0\n,\n \nIntList\n \nrest0\n)\n \n{\n\n        \nfirst\n \n=\n \nfirst0\n;\n\n        \nrest\n \n=\n \nrest0\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * A List with null rest, and first = 0.\n\n\n     */\n\n    \npublic\n \nIntList\n()\n \n{\n\n    \n/* NOTE: public IntList () { }  would also work. */\n\n        \nthis\n(\n0\n,\n \nnull\n);\n\n    \n}\n\n\n    \n/**\n\n\n     * Returns a list equal to L with all elements squared. Destructive.\n\n\n     */\n\n    \npublic\n \nstatic\n \nvoid\n \ndSquareList\n(\nIntList\n \nL\n)\n \n{\n\n\n        \nwhile\n \n(\nL\n \n!=\n \nnull\n)\n \n{\n\n            \nL\n.\nfirst\n \n=\n \nL\n.\nfirst\n \n*\n \nL\n.\nfirst\n;\n\n            \nL\n \n=\n \nL\n.\nrest\n;\n\n        \n}\n\n    \n}\n\n\n    \n/**\n\n\n     * Returns a list equal to L with all elements squared. Non-destructive.\n\n\n     */\n\n    \npublic\n \nstatic\n \nIntList\n \nsquareListIterative\n(\nIntList\n \nL\n)\n \n{\n\n        \nif\n \n(\nL\n \n==\n \nnull\n)\n \n{\n\n            \nreturn\n \nnull\n;\n\n        \n}\n\n        \nIntList\n \nres\n \n=\n \nnew\n \nIntList\n(\nL\n.\nfirst\n \n*\n \nL\n.\nfirst\n,\n \nnull\n);\n\n        \nIntList\n \nptr\n \n=\n \nres\n;\n\n        \nL\n \n=\n \nL\n.\nrest\n;\n\n        \nwhile\n \n(\nL\n \n!=\n \nnull\n)\n \n{\n\n            \nptr\n.\nrest\n \n=\n \nnew\n \nIntList\n(\nL\n.\nfirst\n \n*\n \nL\n.\nfirst\n,\n \nnull\n);\n\n            \nL\n \n=\n \nL\n.\nrest\n;\n\n            \nptr\n \n=\n \nptr\n.\nrest\n;\n\n        \n}\n\n        \nreturn\n \nres\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Returns a list equal to L with all elements squared. Non-destructive.\n\n\n     */\n\n    \npublic\n \nstatic\n \nIntList\n \nsquareListRecursive\n(\nIntList\n \nL\n)\n \n{\n\n        \nif\n \n(\nL\n \n==\n \nnull\n)\n \n{\n\n            \nreturn\n \nnull\n;\n\n        \n}\n\n        \nreturn\n \nnew\n \nIntList\n(\nL\n.\nfirst\n \n*\n \nL\n.\nfirst\n,\n \nsquareListRecursive\n(\nL\n.\nrest\n));\n\n    \n}\n\n\n    \n/** DO NOT MODIFY ANYTHING ABOVE THIS LINE! */\n\n\n\n    \n/**\n\n\n     * Returns a list consisting of the elements of A followed by the\n\n\n     * *  elements of B.  May modify items of A. Don\nt use \nnew\n.\n\n\n     */\n\n\n    \npublic\n \nstatic\n \nIntList\n \ndcatenate\n(\nIntList\n \nA\n,\n \nIntList\n \nB\n)\n \n{\n\n        \n//TODO:  fill in method\n\n        \nIntList\n \nA_location\n \n=\n \nA\n;\n\n        \nwhile\n \n(\nA_location\n.\nrest\n!=\nnull\n)\n \n{\n\n            \nA_location\n \n=\n \nA_location\n.\nrest\n;\n\n        \n}\n\n        \nA_location\n.\nrest\n \n=\n \nB\n;\n\n\n        \nreturn\n \nA\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Returns a list consisting of the elements of A followed by the\n\n\n     * * elements of B.  May NOT modify items of A.  Use \nnew\n.\n\n\n     */\n\n    \npublic\n \nstatic\n \nIntList\n \ncatenate\n(\nIntList\n \nA\n,\n \nIntList\n \nB\n)\n \n{\n\n        \n//TODO:  fill in method\n\n        \nIntList\n \nres\n \n=\n \nnew\n \nIntList\n(\nA\n.\nfirst\n,\n \nnull\n);\n\n        \nIntList\n \nres_location\n \n=\n \nres\n;\n\n        \nIntList\n \nA_location\n \n=\n \nA\n.\nrest\n;\n\n        \nwhile\n \n(\nA_location\n.\nrest\n!=\nnull\n)\n \n{\n\n            \nres_location\n.\nrest\n \n=\n \nnew\n \nIntList\n(\nA_location\n.\nfirst\n,\n \nnull\n);\n\n            \nA_location\n \n=\n \nA_location\n.\nrest\n;\n\n            \nres_location\n \n=\n \nres_location\n.\nrest\n;\n\n        \n}\n\n\n        \nres_location\n.\nrest\n \n=\n \nnew\n \nIntList\n(\nA_location\n.\nfirst\n,\n \nnull\n);\n\n        \nres_location\n \n=\n \nres_location\n.\nrest\n;\n\n\n\n        \nIntList\n \nB_location\n \n=\n \nB\n;\n\n        \nwhile\n \n(\nB_location\n.\nrest\n!=\nnull\n)\n \n{\n\n            \nres_location\n.\nrest\n \n=\n \nnew\n \nIntList\n(\nB_location\n.\nfirst\n,\n \nnull\n);\n\n            \nB_location\n \n=\n \nB_location\n.\nrest\n;\n\n            \nres_location\n \n=\n \nres_location\n.\nrest\n;\n\n        \n}\n\n        \nres_location\n.\nrest\n \n=\n  \nnew\n \nIntList\n(\nB_location\n.\nfirst\n,\n \nnull\n);\n\n        \nreturn\n \nres\n;\n\n    \n}\n\n\n\n\n\n\n\n\n    \n/**\n\n\n     * DO NOT MODIFY ANYTHING BELOW THIS LINE! Many of the concepts below here\n\n\n     * will be introduced later in the course or feature some form of advanced\n\n\n     * trickery which we implemented to help make your life a little easier for\n\n\n     * the lab.\n\n\n     */\n\n\n    \n@Override\n\n    \npublic\n \nint\n \nhashCode\n()\n \n{\n\n        \nreturn\n \nfirst\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Returns a new IntList containing the ints in ARGS. You are not\n\n\n     * expected to read or understand this method.\n\n\n     */\n\n    \npublic\n \nstatic\n \nIntList\n \nof\n(\nInteger\n...\n \nargs\n)\n \n{\n\n        \nIntList\n \nresult\n,\n \np\n;\n\n\n        \nif\n \n(\nargs\n.\nlength\n \n \n0\n)\n \n{\n\n            \nresult\n \n=\n \nnew\n \nIntList\n(\nargs\n[\n0\n],\n \nnull\n);\n\n        \n}\n \nelse\n \n{\n\n            \nreturn\n \nnull\n;\n\n        \n}\n\n\n        \nint\n \nk\n;\n\n        \nfor\n \n(\nk\n \n=\n \n1\n,\n \np\n \n=\n \nresult\n;\n \nk\n \n \nargs\n.\nlength\n;\n \nk\n \n+=\n \n1\n,\n \np\n \n=\n \np\n.\nrest\n)\n \n{\n\n            \np\n.\nrest\n \n=\n \nnew\n \nIntList\n(\nargs\n[\nk\n],\n \nnull\n);\n\n        \n}\n\n        \nreturn\n \nresult\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Returns true iff X is an IntList containing the same sequence of ints\n\n\n     * as THIS. Cannot handle IntLists with cycles. You are not expected to\n\n\n     * read or understand this method.\n\n\n     */\n\n    \npublic\n \nboolean\n \nequals\n(\nObject\n \nx\n)\n \n{\n\n        \nif\n \n(!(\nx\n \ninstanceof\n \nIntList\n))\n \n{\n\n            \nreturn\n \nfalse\n;\n\n        \n}\n\n        \nIntList\n \nL\n \n=\n \n(\nIntList\n)\n \nx\n;\n\n        \nIntList\n \np\n;\n\n\n        \nfor\n \n(\np\n \n=\n \nthis\n;\n \np\n \n!=\n \nnull\n \n \nL\n \n!=\n \nnull\n;\n \np\n \n=\n \np\n.\nrest\n,\n \nL\n \n=\n \nL\n.\nrest\n)\n \n{\n\n            \nif\n \n(\np\n.\nfirst\n \n!=\n \nL\n.\nfirst\n)\n \n{\n\n                \nreturn\n \nfalse\n;\n\n            \n}\n\n        \n}\n\n        \nif\n \n(\np\n \n!=\n \nnull\n \n||\n \nL\n \n!=\n \nnull\n)\n \n{\n\n            \nreturn\n \nfalse\n;\n\n        \n}\n\n        \nreturn\n \ntrue\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * If a cycle exists in the IntList, this method\n\n\n     * returns an integer equal to the item number of the location where the\n\n\n     * cycle is detected.\n\n\n     * \np\n\n\n     * If there is no cycle, the number 0 is returned instead. This is a\n\n\n     * utility method for lab2. You are not expected to read, understand, or\n\n\n     * even use this method. The point of this method is so that if you convert\n\n\n     * an IntList into a String and that IntList has a loop, your computer\n\n\n     * doesn\nt get stuck in an infinite loop.\n\n\n     */\n\n\n    \nprivate\n \nint\n \ndetectCycles\n(\nIntList\n \nA\n)\n \n{\n\n        \nIntList\n \ntortoise\n \n=\n \nA\n;\n\n        \nIntList\n \nhare\n \n=\n \nA\n;\n\n\n        \nif\n \n(\nA\n \n==\n \nnull\n)\n \n{\n\n            \nreturn\n \n0\n;\n\n        \n}\n\n\n        \nint\n \ncnt\n \n=\n \n0\n;\n\n\n\n        \nwhile\n \n(\ntrue\n)\n \n{\n\n            \ncnt\n++;\n\n            \nif\n \n(\nhare\n.\nrest\n \n!=\n \nnull\n)\n \n{\n\n                \nhare\n \n=\n \nhare\n.\nrest\n.\nrest\n;\n\n            \n}\n \nelse\n \n{\n\n                \nreturn\n \n0\n;\n\n            \n}\n\n\n            \ntortoise\n \n=\n \ntortoise\n.\nrest\n;\n\n\n            \nif\n \n(\ntortoise\n \n==\n \nnull\n \n||\n \nhare\n \n==\n \nnull\n)\n \n{\n\n                \nreturn\n \n0\n;\n\n            \n}\n\n\n            \nif\n \n(\nhare\n \n==\n \ntortoise\n)\n \n{\n\n                \nreturn\n \ncnt\n;\n\n            \n}\n\n        \n}\n\n    \n}\n\n\n    \n@Override\n\n    \n/** Outputs the IntList as a String. You are not expected to read\n\n\n     * or understand this method. */\n\n    \npublic\n \nString\n \ntoString\n()\n \n{\n\n        \nFormatter\n \nout\n \n=\n \nnew\n \nFormatter\n();\n\n        \nString\n \nsep\n;\n\n        \nsep\n \n=\n \n(\n;\n\n        \nint\n \ncycleLocation\n \n=\n \ndetectCycles\n(\nthis\n);\n\n        \nint\n \ncnt\n \n=\n \n0\n;\n\n\n        \nfor\n \n(\nIntList\n \np\n \n=\n \nthis\n;\n \np\n \n!=\n \nnull\n;\n \np\n \n=\n \np\n.\nrest\n)\n \n{\n\n            \nout\n.\nformat\n(\n%s%d\n,\n \nsep\n,\n \np\n.\nfirst\n);\n\n            \nsep\n \n=\n \n, \n;\n\n\n            \ncnt\n++;\n\n            \nif\n \n((\ncnt\n \n \ncycleLocation\n)\n \n \n(\ncycleLocation\n \n \n0\n))\n \n{\n\n                \nout\n.\nformat\n(\n... (cycle exists) ...\n);\n\n                \nbreak\n;\n\n            \n}\n\n        \n}\n\n        \nout\n.\nformat\n(\n)\n);\n\n        \nreturn\n \nout\n.\ntoString\n();\n\n    \n}\n\n\n}", 
            "title": "Lab2: Unit Testing with JUnit and IntLists"
        }, 
        {
            "location": "/cs61b/Lab2/#lab-2-unit-testing-with-junit-and-intlists", 
            "text": "", 
            "title": "Lab 2: Unit Testing with JUnit and IntLists"
        }, 
        {
            "location": "/cs61b/Lab2/#1-lab-2-setup-setting-up-intellij", 
            "text": "Installing the IntelliJ CS 61B Plugin after installation of IntelliJ.   Getting Java Libraries    git   submodule   update   -- init", 
            "title": "1 Lab 2 setup: Setting Up IntelliJ"
        }, 
        {
            "location": "/cs61b/Lab2/#2-lab-2-unit-testing-with-junit-and-intlists", 
            "text": "", 
            "title": "2 Lab 2: Unit Testing with JUnit and IntLists"
        }, 
        {
            "location": "/cs61b/Lab2/#introduction", 
            "text": "In this lab, you will learn about basic IntelliJ features, Destructive vs NonDestructive methods, and IntLists.", 
            "title": "Introduction"
        }, 
        {
            "location": "/cs61b/Lab2/#breakpoints-and-step-into", 
            "text": "While print statements can be very useful for debugging, they have a few disadvantages:    They require you to modify your code (to add print statements).   They require you to explicitly state what you want to know (since you have to say precisely what you want to print).   And they provide their results in a format that can be hard to read, since it s just a big blob of text in the execution window.   The IntelliJ debugger allows you to pause the code in the middle of execution, step the code line by line, and even visualize the organization of complex data structures like linked lists.  The  step over  button allows us to complete a function call without showing the function executing", 
            "title": "Breakpoints and Step Into"
        }, 
        {
            "location": "/cs61b/Lab2/#conditional-breakpoints-and-resume", 
            "text": "An even faster approach is to make our breakpoint conditional. To do this, right (or two-finer) click on the red breakpoint dot. Here, you can set a condition for when you want to stop.", 
            "title": "Conditional Breakpoints and Resume"
        }, 
        {
            "location": "/cs61b/Lab2/#destructive-vs-non-destructive", 
            "text": "By destructive, we mean that the original list changes. The term  mutative  is also sometimes used. By contrast a non-destructive method  does not affect the original list.", 
            "title": "Destructive vs. Non-Destructive"
        }, 
        {
            "location": "/cs61b/Lab2/#implementing-destructive-vs-non-destructive-methods", 
            "text": "package   com.berkeycs61b.lab2.Intlist ;  import   java.util.Formatter ;  /**   * A naked recursive list of integers, similar to what we saw in lecture 3, but   * with a large number of additional methods.   *   * @author P. N. Hilfinger, with some modifications by Josh Hug and melaniecebula   *         [Do not modify this file.]   */  public   class   IntList   { \n     /**       * First element of list.       */ \n     public   int   first ; \n     /**       * Remaining elements of list.       */ \n     public   IntList   rest ; \n\n     /**       * A List with first FIRST0 and rest REST0.       */ \n     public   IntList ( int   first0 ,   IntList   rest0 )   { \n         first   =   first0 ; \n         rest   =   rest0 ; \n     } \n\n     /**       * A List with null rest, and first = 0.       */ \n     public   IntList ()   { \n     /* NOTE: public IntList () { }  would also work. */ \n         this ( 0 ,   null ); \n     } \n\n     /**       * Returns a list equal to L with all elements squared. Destructive.       */ \n     public   static   void   dSquareList ( IntList   L )   { \n\n         while   ( L   !=   null )   { \n             L . first   =   L . first   *   L . first ; \n             L   =   L . rest ; \n         } \n     } \n\n     /**       * Returns a list equal to L with all elements squared. Non-destructive.       */ \n     public   static   IntList   squareListIterative ( IntList   L )   { \n         if   ( L   ==   null )   { \n             return   null ; \n         } \n         IntList   res   =   new   IntList ( L . first   *   L . first ,   null ); \n         IntList   ptr   =   res ; \n         L   =   L . rest ; \n         while   ( L   !=   null )   { \n             ptr . rest   =   new   IntList ( L . first   *   L . first ,   null ); \n             L   =   L . rest ; \n             ptr   =   ptr . rest ; \n         } \n         return   res ; \n     } \n\n     /**       * Returns a list equal to L with all elements squared. Non-destructive.       */ \n     public   static   IntList   squareListRecursive ( IntList   L )   { \n         if   ( L   ==   null )   { \n             return   null ; \n         } \n         return   new   IntList ( L . first   *   L . first ,   squareListRecursive ( L . rest )); \n     } \n\n     /** DO NOT MODIFY ANYTHING ABOVE THIS LINE! */ \n\n\n     /**       * Returns a list consisting of the elements of A followed by the       * *  elements of B.  May modify items of A. Don t use  new .       */ \n\n     public   static   IntList   dcatenate ( IntList   A ,   IntList   B )   { \n         //TODO:  fill in method \n         IntList   A_location   =   A ; \n         while   ( A_location . rest != null )   { \n             A_location   =   A_location . rest ; \n         } \n         A_location . rest   =   B ; \n\n         return   A ; \n     } \n\n     /**       * Returns a list consisting of the elements of A followed by the       * * elements of B.  May NOT modify items of A.  Use  new .       */ \n     public   static   IntList   catenate ( IntList   A ,   IntList   B )   { \n         //TODO:  fill in method \n         IntList   res   =   new   IntList ( A . first ,   null ); \n         IntList   res_location   =   res ; \n         IntList   A_location   =   A . rest ; \n         while   ( A_location . rest != null )   { \n             res_location . rest   =   new   IntList ( A_location . first ,   null ); \n             A_location   =   A_location . rest ; \n             res_location   =   res_location . rest ; \n         } \n\n         res_location . rest   =   new   IntList ( A_location . first ,   null ); \n         res_location   =   res_location . rest ; \n\n\n         IntList   B_location   =   B ; \n         while   ( B_location . rest != null )   { \n             res_location . rest   =   new   IntList ( B_location . first ,   null ); \n             B_location   =   B_location . rest ; \n             res_location   =   res_location . rest ; \n         } \n         res_location . rest   =    new   IntList ( B_location . first ,   null ); \n         return   res ; \n     } \n\n\n\n\n\n\n\n     /**       * DO NOT MODIFY ANYTHING BELOW THIS LINE! Many of the concepts below here       * will be introduced later in the course or feature some form of advanced       * trickery which we implemented to help make your life a little easier for       * the lab.       */ \n\n     @Override \n     public   int   hashCode ()   { \n         return   first ; \n     } \n\n     /**       * Returns a new IntList containing the ints in ARGS. You are not       * expected to read or understand this method.       */ \n     public   static   IntList   of ( Integer ...   args )   { \n         IntList   result ,   p ; \n\n         if   ( args . length     0 )   { \n             result   =   new   IntList ( args [ 0 ],   null ); \n         }   else   { \n             return   null ; \n         } \n\n         int   k ; \n         for   ( k   =   1 ,   p   =   result ;   k     args . length ;   k   +=   1 ,   p   =   p . rest )   { \n             p . rest   =   new   IntList ( args [ k ],   null ); \n         } \n         return   result ; \n     } \n\n     /**       * Returns true iff X is an IntList containing the same sequence of ints       * as THIS. Cannot handle IntLists with cycles. You are not expected to       * read or understand this method.       */ \n     public   boolean   equals ( Object   x )   { \n         if   (!( x   instanceof   IntList ))   { \n             return   false ; \n         } \n         IntList   L   =   ( IntList )   x ; \n         IntList   p ; \n\n         for   ( p   =   this ;   p   !=   null     L   !=   null ;   p   =   p . rest ,   L   =   L . rest )   { \n             if   ( p . first   !=   L . first )   { \n                 return   false ; \n             } \n         } \n         if   ( p   !=   null   ||   L   !=   null )   { \n             return   false ; \n         } \n         return   true ; \n     } \n\n     /**       * If a cycle exists in the IntList, this method       * returns an integer equal to the item number of the location where the       * cycle is detected.       *  p       * If there is no cycle, the number 0 is returned instead. This is a       * utility method for lab2. You are not expected to read, understand, or       * even use this method. The point of this method is so that if you convert       * an IntList into a String and that IntList has a loop, your computer       * doesn t get stuck in an infinite loop.       */ \n\n     private   int   detectCycles ( IntList   A )   { \n         IntList   tortoise   =   A ; \n         IntList   hare   =   A ; \n\n         if   ( A   ==   null )   { \n             return   0 ; \n         } \n\n         int   cnt   =   0 ; \n\n\n         while   ( true )   { \n             cnt ++; \n             if   ( hare . rest   !=   null )   { \n                 hare   =   hare . rest . rest ; \n             }   else   { \n                 return   0 ; \n             } \n\n             tortoise   =   tortoise . rest ; \n\n             if   ( tortoise   ==   null   ||   hare   ==   null )   { \n                 return   0 ; \n             } \n\n             if   ( hare   ==   tortoise )   { \n                 return   cnt ; \n             } \n         } \n     } \n\n     @Override \n     /** Outputs the IntList as a String. You are not expected to read       * or understand this method. */ \n     public   String   toString ()   { \n         Formatter   out   =   new   Formatter (); \n         String   sep ; \n         sep   =   ( ; \n         int   cycleLocation   =   detectCycles ( this ); \n         int   cnt   =   0 ; \n\n         for   ( IntList   p   =   this ;   p   !=   null ;   p   =   p . rest )   { \n             out . format ( %s%d ,   sep ,   p . first ); \n             sep   =   ,  ; \n\n             cnt ++; \n             if   (( cnt     cycleLocation )     ( cycleLocation     0 ))   { \n                 out . format ( ... (cycle exists) ... ); \n                 break ; \n             } \n         } \n         out . format ( ) ); \n         return   out . toString (); \n     }  }", 
            "title": "Implementing Destructive vs. Non-destructive Methods"
        }, 
        {
            "location": "/cs61b/Lab3/", 
            "text": "Lab 3: Unit Testing with JUnit, Debugging\n\n\n1 Introduction\n\n\nJUnit is a Unit Testing Framework for Java.\n\n\nUnit Testing is a great way to rigorously test each method of your code and ultimately ensure that you have a working project.\n\n\nThe \u201cUnit\u201d part of Unit Testing comes from the idea that you can break your program down into units, or the smallest testable part of an application. Therefore, Unit Testing enforces good code structure (each method should only do \u201cOne Thing\u201d), and allows you to consider all of the edge cases for each method and test for them individually.\n\n\nJUnit Syntax\n\n\nassertEquals\n is a common method used in JUnit tests. It tests if a variable\u2019s actual value is equivalent to its expected value.\n\n\n \n@Test\n\n\npublic\n \nvoid\n \ntestMethod\n()\n \n{\n\n    \nassertEquals\n(\nexpected\n,\n \nactual\n);\n\n\n}\n\n\n\n\nWhen you create JUnit test files, you should precede each test method with a \n@Test\n annotation, and can have one or more \nassertEquals\n or \nassertTrue\n methods (provided by the JUnit library). \nAll tests must be non-static.\n \n\n\nRunning JUnit Tests in IntelliJ\n\n\nEven though methods includes many assert statements, only one failure is shown. This is because JUnit tests are short-circuiting \u2013 as soon as one of the asserts in a method fails, it will output the failure and move on to the next test.\n\n\n\n\nWrite a test BEFORE we write a method.\n\n\nDon\u2019t fill in the code for the actual method yet, just make it return null.\n\n\nWrite a method, and rerun the tests until it passes.\n\n\n\n\nPro tip: If you want to have your tests timeout after a certain amount of time (to prevent in\ufb01nite loops), you can declare your test like this: \n@Test\n(\ntimeout\n \n=\n \n1000\n)\n\n\nA Debugging Mystery\n\n\nAnother important skill to learn is how to exhaustively debug. When done properly, debugging should allow you to rapidly narrow down where a bug might be located, even when you are debugging code you don\u2019t fully understand.\n\n\nUsing any combination of the following techniques, figure out whether the bug is in Horrible Steve\u2019s code or in Flik enterprise\u2019s library:\n\n\n\n\nWriting JUnit tests for the Flik library.\n\n\nUsing the IntelliJ debugger, especially conditional breakpoints.\n\n\nUsing print statements.\n\n\nRefactoring Horrible Steve\u2019s code. Refactoring means changing the syntax without changing the functionality. This may be hard to do since HS\u2019s code uses lots of weird stuff.\n\n\n\n\nWe do not expect you to \ufb01x the bug or even understand why it\u2019s happening once you have found it. Instead, your job is simply to find the bug.\n\n\nTip: JUnit provides methods \nassertTrue(boolean)\n and \nassertTrue(String, boolean)\n that you might find helpful.\n\n\nRunning the 61B Style Checker\n\n\nWe will be using the CS 61B IntelliJ Plugin to check for style. \nofficial 61B style guide\n\n\nMy common mistake:\n\n\n\n\n',' is followed by whitespace.\n\n\nUsing trailing comments.", 
            "title": "Lab3: Unit Testing with JUnit, Debugging"
        }, 
        {
            "location": "/cs61b/Lab3/#lab-3-unit-testing-with-junit-debugging", 
            "text": "", 
            "title": "Lab 3: Unit Testing with JUnit, Debugging"
        }, 
        {
            "location": "/cs61b/Lab3/#1-introduction", 
            "text": "JUnit is a Unit Testing Framework for Java.  Unit Testing is a great way to rigorously test each method of your code and ultimately ensure that you have a working project.  The \u201cUnit\u201d part of Unit Testing comes from the idea that you can break your program down into units, or the smallest testable part of an application. Therefore, Unit Testing enforces good code structure (each method should only do \u201cOne Thing\u201d), and allows you to consider all of the edge cases for each method and test for them individually.", 
            "title": "1 Introduction"
        }, 
        {
            "location": "/cs61b/Lab3/#junit-syntax", 
            "text": "assertEquals  is a common method used in JUnit tests. It tests if a variable\u2019s actual value is equivalent to its expected value.    @Test  public   void   testMethod ()   { \n     assertEquals ( expected ,   actual );  }   When you create JUnit test files, you should precede each test method with a  @Test  annotation, and can have one or more  assertEquals  or  assertTrue  methods (provided by the JUnit library).  All tests must be non-static.", 
            "title": "JUnit Syntax"
        }, 
        {
            "location": "/cs61b/Lab3/#running-junit-tests-in-intellij", 
            "text": "Even though methods includes many assert statements, only one failure is shown. This is because JUnit tests are short-circuiting \u2013 as soon as one of the asserts in a method fails, it will output the failure and move on to the next test.   Write a test BEFORE we write a method.  Don\u2019t fill in the code for the actual method yet, just make it return null.  Write a method, and rerun the tests until it passes.   Pro tip: If you want to have your tests timeout after a certain amount of time (to prevent in\ufb01nite loops), you can declare your test like this:  @Test ( timeout   =   1000 )", 
            "title": "Running JUnit Tests in IntelliJ"
        }, 
        {
            "location": "/cs61b/Lab3/#a-debugging-mystery", 
            "text": "Another important skill to learn is how to exhaustively debug. When done properly, debugging should allow you to rapidly narrow down where a bug might be located, even when you are debugging code you don\u2019t fully understand.  Using any combination of the following techniques, figure out whether the bug is in Horrible Steve\u2019s code or in Flik enterprise\u2019s library:   Writing JUnit tests for the Flik library.  Using the IntelliJ debugger, especially conditional breakpoints.  Using print statements.  Refactoring Horrible Steve\u2019s code. Refactoring means changing the syntax without changing the functionality. This may be hard to do since HS\u2019s code uses lots of weird stuff.   We do not expect you to \ufb01x the bug or even understand why it\u2019s happening once you have found it. Instead, your job is simply to find the bug.  Tip: JUnit provides methods  assertTrue(boolean)  and  assertTrue(String, boolean)  that you might find helpful.", 
            "title": "A Debugging Mystery"
        }, 
        {
            "location": "/cs61b/Lab3/#running-the-61b-style-checker", 
            "text": "We will be using the CS 61B IntelliJ Plugin to check for style.  official 61B style guide  My common mistake:   ',' is followed by whitespace.  Using trailing comments.", 
            "title": "Running the 61B Style Checker"
        }, 
        {
            "location": "/books/", 
            "text": "Books and Materials\n\n\nBooks\n\n\nThe following is the primary reading list of books. Each chapter is organized as a single page; the included sections are noted with major concepts, and summary.\n\n\nAlgorithm\n\n\n\n\nAlgorithm, 4th Edition\n\n\nby Robert Sedgewick and Kevin Wayne\n\n\nMaterials\n\n\nCS61B\n\n\nCS61B Data Structures, Berkeley\n\n\nInstructor: Josh Hug", 
            "title": "Books"
        }, 
        {
            "location": "/books/#books-and-materials", 
            "text": "", 
            "title": "Books and Materials"
        }, 
        {
            "location": "/books/#books", 
            "text": "The following is the primary reading list of books. Each chapter is organized as a single page; the included sections are noted with major concepts, and summary.", 
            "title": "Books"
        }, 
        {
            "location": "/books/#algorithm", 
            "text": "Algorithm, 4th Edition  by Robert Sedgewick and Kevin Wayne", 
            "title": "Algorithm"
        }, 
        {
            "location": "/books/#materials", 
            "text": "", 
            "title": "Materials"
        }, 
        {
            "location": "/books/#cs61b", 
            "text": "CS61B Data Structures, Berkeley  Instructor: Josh Hug", 
            "title": "CS61B"
        }
    ]
}