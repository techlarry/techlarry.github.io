{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"algorithm/topic3/","text":"Topic 3: Sorting Selection Sort In iteration i i , find index min min of smallest remaining entry. Swap a[i] a[i] and a[min] a[min] . Animation: public class Selection { public static void sort ( Comparable [] a ) { int N = a . length ; for ( int i = 0 ; i N ; i ++) { int min = i ; for ( int j = i + 1 ; j N ; j ++) if ( less ( a [ j ], a [ min ])) min = j ; exch ( a , i , min ); } } } Analysis Selection sort uses (N-1)+(N-2)+...+1\\sim N^2/2 (N-1)+(N-2)+...+1\\sim N^2/2 compares and N N exchanges. Insertion Sort Animation: In iteration i i , swap a[i] a[i] with each larger entry to its left. Invariants. \u2191 scans from left to right. Entries to the left of \u2191 (including \u2191) are in ascending order. Entries to the right of \u2191 have not yet been seen. public class Insertion { public static void sort ( Comparable [] a ) { for ( int i = 1 ; i a . length ; i ++) { int j = i ; while ( j 0 less ( a [ j ], a [ j - 1 ])) { exch ( a , j , j - 1 ); j --; } } } @SuppressWarnings ( unchecked ) private static boolean less ( Comparable a , Comparable b ) { return a . compareTo ( b ) 0 ; } private static void exch ( Comparable [] a , int i , int j ) { Comparable temp = a [ i ]; a [ i ] = a [ j ]; a [ j ] = temp ; } } Analysis Insertion sort uses \\sim N^2/4 \\sim N^2/4 compares and \\sim N^2/4 \\sim N^2/4 exchanges to sort a randomly ordered array of length N N with distinct keys, on the average. The worst case is \\sim N^2/2 \\sim N^2/2 compares and \\sim N ^2/2 \\sim N ^2/2 exchanges and the best case is N-1 N-1 compares and 0 exchanges. Shell Sort Shuffling Our goal is to rearrange array so that result is a uniformly random permutation. Shuffle sort Generate a random real number for each array entry. Sort the array based on generated random numbers. Knuth shuffle In iteration i i , pick integer r r between 0 and i i uniformly at random. Swap a[i] a[i] and a[r] a[r] . public class KnuthShuffle { public static void shuffle ( Object [] a ) { Random random = new Random (); for ( int i = 0 ; i a . length ; i ++) { //In iteration i, pick integer r between 0 and i uniformly at random. int r = random . nextInt ( i + 1 ); // Swap a[i] and a[r]. exch ( a , i , r ); } } } Knuth shuffling algorithm produces a uniformly random permutation of the input array in linear time. Quick Sort Quicksort honored as one of top 10 algorithms of 20th century in science and engineering. Quicksort is the default Java sort for primitive types. Basic plan. Shuffle the array. Partition so that, for some j j entry a[j] a[j] is in place no larger entry to the left of j j no smaller entry to the right of j j Sort each piece recursively. public class Quick { public static void sort ( Comparable [] a ) { // shuffle needed for performance guarantee StdRandom . shuffle ( a ); sort ( a , 0 , a . length - 1 ); } private static void sort ( Comparable [] a , int lo , int hi ) { if ( hi = lo ) return ; int j = partition ( a , lo , hi ); sort ( a , lo , j - 1 ); sort ( a , j + 1 , hi ); } } ANIMATION: Partitioning The crux of the quick sort is the partitioning process, which rearranges the array to make the following three conditions hold: The entry a[j] a[j] is in its final place in the array, for some j j . No entry in a[lo] a[lo] through a[j-1] a[j-1] is greater than a[j] a[j] . No entry in a[j+1] a[j+1] through a[hi] a[hi] is less than a[j] a[j] . First, we arbitrarily choose a[lo] a[lo] to be the partitioning item\u2014the one that will go into its final position. Next, we scan from the left end of the array until we find an entry greater than (or equal to) the partitioning item, and we scan from the right end of the array until we find an entry less than (or equal to) the partitioning item. The two items that stopped the scans are out of place in the final partitioned array, so we exchange them. Continuing in this way, when the scan indices cross, all that we need to do is to exchange the partitioning item a[lo] a[lo] with the rightmost entry of the left subarray ( a[j] a[j] ) and return its index j j . private static int partition ( Comparable a [], int lo , int hi ) { int i = lo , j = hi + 1 ; while ( true ) { // find item on left to swap while ( less ( a [++ i ], a [ lo ])) if ( i == hi ) break ; // find item on right to swap while ( less ( a [ lo ], a [-- j ])) if ( j == lo ) break ; // check if pointers cross if ( i = j ) break ; // swap exch ( a , i , j ); } // swap with partitioning item exch ( a , lo , j ); // return index of item now known to be in place. return j ; } Analysis Best case. Number of compares is \\sim N \\lg N \\sim N \\lg N . Worst case. Number of compares is \\sim \\frac{1}{2} N^2 \\sim \\frac{1}{2} N^2 . The average number of compares C_N C_N to quicksort an array of N N distinct keys is ~ 2N\\ln N 2N\\ln N (and the number of exchanges is \\sim\\frac{1}{3}N \\ln N \\sim\\frac{1}{3}N \\ln N ). Quicksort is an in-place sorting algorithm, but is not stable . Merge Sort Basic plan: Divide array into two halves Recursively sort each half Merge two halves Goal. Given two sorted subarrays a[lo] to a[mid] and a[mid+1] to a[hi], replace with sorted subarray a[lo] to a[hi] Java Implementation","title":"Topic 3: Sort "},{"location":"algorithm/topic3/#topic-3-sorting","text":"","title":"Topic 3: Sorting"},{"location":"algorithm/topic3/#selection-sort","text":"In iteration i i , find index min min of smallest remaining entry. Swap a[i] a[i] and a[min] a[min] . Animation: public class Selection { public static void sort ( Comparable [] a ) { int N = a . length ; for ( int i = 0 ; i N ; i ++) { int min = i ; for ( int j = i + 1 ; j N ; j ++) if ( less ( a [ j ], a [ min ])) min = j ; exch ( a , i , min ); } } }","title":"Selection Sort"},{"location":"algorithm/topic3/#analysis","text":"Selection sort uses (N-1)+(N-2)+...+1\\sim N^2/2 (N-1)+(N-2)+...+1\\sim N^2/2 compares and N N exchanges.","title":"Analysis"},{"location":"algorithm/topic3/#insertion-sort","text":"Animation: In iteration i i , swap a[i] a[i] with each larger entry to its left. Invariants. \u2191 scans from left to right. Entries to the left of \u2191 (including \u2191) are in ascending order. Entries to the right of \u2191 have not yet been seen. public class Insertion { public static void sort ( Comparable [] a ) { for ( int i = 1 ; i a . length ; i ++) { int j = i ; while ( j 0 less ( a [ j ], a [ j - 1 ])) { exch ( a , j , j - 1 ); j --; } } } @SuppressWarnings ( unchecked ) private static boolean less ( Comparable a , Comparable b ) { return a . compareTo ( b ) 0 ; } private static void exch ( Comparable [] a , int i , int j ) { Comparable temp = a [ i ]; a [ i ] = a [ j ]; a [ j ] = temp ; } }","title":"Insertion Sort"},{"location":"algorithm/topic3/#analysis_1","text":"Insertion sort uses \\sim N^2/4 \\sim N^2/4 compares and \\sim N^2/4 \\sim N^2/4 exchanges to sort a randomly ordered array of length N N with distinct keys, on the average. The worst case is \\sim N^2/2 \\sim N^2/2 compares and \\sim N ^2/2 \\sim N ^2/2 exchanges and the best case is N-1 N-1 compares and 0 exchanges.","title":"Analysis"},{"location":"algorithm/topic3/#shell-sort","text":"","title":"Shell Sort"},{"location":"algorithm/topic3/#shuffling","text":"Our goal is to rearrange array so that result is a uniformly random permutation.","title":"Shuffling"},{"location":"algorithm/topic3/#shuffle-sort","text":"Generate a random real number for each array entry. Sort the array based on generated random numbers.","title":"Shuffle sort"},{"location":"algorithm/topic3/#knuth-shuffle","text":"In iteration i i , pick integer r r between 0 and i i uniformly at random. Swap a[i] a[i] and a[r] a[r] . public class KnuthShuffle { public static void shuffle ( Object [] a ) { Random random = new Random (); for ( int i = 0 ; i a . length ; i ++) { //In iteration i, pick integer r between 0 and i uniformly at random. int r = random . nextInt ( i + 1 ); // Swap a[i] and a[r]. exch ( a , i , r ); } } } Knuth shuffling algorithm produces a uniformly random permutation of the input array in linear time.","title":"Knuth shuffle"},{"location":"algorithm/topic3/#quick-sort","text":"Quicksort honored as one of top 10 algorithms of 20th century in science and engineering. Quicksort is the default Java sort for primitive types. Basic plan. Shuffle the array. Partition so that, for some j j entry a[j] a[j] is in place no larger entry to the left of j j no smaller entry to the right of j j Sort each piece recursively. public class Quick { public static void sort ( Comparable [] a ) { // shuffle needed for performance guarantee StdRandom . shuffle ( a ); sort ( a , 0 , a . length - 1 ); } private static void sort ( Comparable [] a , int lo , int hi ) { if ( hi = lo ) return ; int j = partition ( a , lo , hi ); sort ( a , lo , j - 1 ); sort ( a , j + 1 , hi ); } } ANIMATION:","title":"Quick Sort"},{"location":"algorithm/topic3/#partitioning","text":"The crux of the quick sort is the partitioning process, which rearranges the array to make the following three conditions hold: The entry a[j] a[j] is in its final place in the array, for some j j . No entry in a[lo] a[lo] through a[j-1] a[j-1] is greater than a[j] a[j] . No entry in a[j+1] a[j+1] through a[hi] a[hi] is less than a[j] a[j] . First, we arbitrarily choose a[lo] a[lo] to be the partitioning item\u2014the one that will go into its final position. Next, we scan from the left end of the array until we find an entry greater than (or equal to) the partitioning item, and we scan from the right end of the array until we find an entry less than (or equal to) the partitioning item. The two items that stopped the scans are out of place in the final partitioned array, so we exchange them. Continuing in this way, when the scan indices cross, all that we need to do is to exchange the partitioning item a[lo] a[lo] with the rightmost entry of the left subarray ( a[j] a[j] ) and return its index j j . private static int partition ( Comparable a [], int lo , int hi ) { int i = lo , j = hi + 1 ; while ( true ) { // find item on left to swap while ( less ( a [++ i ], a [ lo ])) if ( i == hi ) break ; // find item on right to swap while ( less ( a [ lo ], a [-- j ])) if ( j == lo ) break ; // check if pointers cross if ( i = j ) break ; // swap exch ( a , i , j ); } // swap with partitioning item exch ( a , lo , j ); // return index of item now known to be in place. return j ; }","title":"Partitioning"},{"location":"algorithm/topic3/#analysis_2","text":"Best case. Number of compares is \\sim N \\lg N \\sim N \\lg N . Worst case. Number of compares is \\sim \\frac{1}{2} N^2 \\sim \\frac{1}{2} N^2 . The average number of compares C_N C_N to quicksort an array of N N distinct keys is ~ 2N\\ln N 2N\\ln N (and the number of exchanges is \\sim\\frac{1}{3}N \\ln N \\sim\\frac{1}{3}N \\ln N ). Quicksort is an in-place sorting algorithm, but is not stable .","title":"Analysis"},{"location":"algorithm/topic3/#merge-sort","text":"Basic plan: Divide array into two halves Recursively sort each half Merge two halves Goal. Given two sorted subarrays a[lo] to a[mid] and a[mid+1] to a[hi], replace with sorted subarray a[lo] to a[hi]","title":"Merge Sort"},{"location":"algorithm/topic3/#java-implementation","text":"","title":"Java Implementation"}]}