{
    "docs": [
        {
            "location": "/", 
            "text": "Zhenhua's Notes - Algorithm\n\n\nThis site documents reading and learning notes.\n\n\nOther Note Site\n\n\nNote - Java/OS\n\n\nNote - Big Data\n\n\nSearch\n\n\n\n  \n\n    \n\n      (function() {\n        var cx = '011299089536274713055:ppqfpivtvxy';\n        var gcse = document.createElement('script');\n        gcse.type = 'text/javascript';\n        gcse.async = true;\n        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;\n        var s = document.getElementsByTagName('script')[0];\n        s.parentNode.insertBefore(gcse, s);\n      })();\n    \n\n    \n\n  \n\n\n\n\n\nTOC\n\n\nSee \nTable of Contents\n.\n\n\nBooks and Materials\n\n\nSee \nBooks and Materials\n.\n\n\nRoadmap\n\n\nSee \nRoadmap\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#zhenhuas-notes-algorithm", 
            "text": "This site documents reading and learning notes.", 
            "title": "Zhenhua's Notes - Algorithm"
        }, 
        {
            "location": "/#other-note-site", 
            "text": "Note - Java/OS  Note - Big Data", 
            "title": "Other Note Site"
        }, 
        {
            "location": "/#search", 
            "text": "(function() {\n        var cx = '011299089536274713055:ppqfpivtvxy';\n        var gcse = document.createElement('script');\n        gcse.type = 'text/javascript';\n        gcse.async = true;\n        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;\n        var s = document.getElementsByTagName('script')[0];\n        s.parentNode.insertBefore(gcse, s);\n      })();", 
            "title": "Search"
        }, 
        {
            "location": "/#toc", 
            "text": "See  Table of Contents .", 
            "title": "TOC"
        }, 
        {
            "location": "/#books-and-materials", 
            "text": "See  Books and Materials .", 
            "title": "Books and Materials"
        }, 
        {
            "location": "/#roadmap", 
            "text": "See  Roadmap .", 
            "title": "Roadmap"
        }, 
        {
            "location": "/algorithm/", 
            "text": "Algorithm\n\n\n\n\nTopic 1: UnionFind \n\n\nTopic 2: StackQueue", 
            "title": "Contents"
        }, 
        {
            "location": "/algorithm/#algorithm", 
            "text": "Topic 1: UnionFind   Topic 2: StackQueue", 
            "title": "Algorithm"
        }, 
        {
            "location": "/algorithm/topic1/", 
            "text": "Chapter 1: Union Find\n\n\n1 Dynamic Connectivity\n\n\nThe graph connectivity problem is the following: Given an \nundirected\n graph G, preprocess the graph so that queries of the form \u201care nodes u and v connected?\u201d\n\n\nConnected components\n:  Maximal set of objects that are mutually connected.\n\n\n\n\nUnion-Find data type (API)\n\n\nUnion-Find API:\n\n\n\n\nthe \nunion()\n operation merges two components if the two sites are in different components.\n\n\nthe \nfind()\n operation returns an integer component identifier for a given site.\n\n\nthe \nconnected()\n operation determines whether two sites are in the same component.\n\n\nthe \ncount()\n method returns the number of components.\n\n\n\n\n\n\n \npublic\n \nclass\n \nQuickFind\n \n{\n\n    \nprivate\n \nint\n[]\n \nid\n;\n\n    \nprivate\n \nint\n \ncount\n;\n\n\n    \npublic\n \nQuickFind\n(\nint\n \nN\n)\n \n{\n\n        \ncount\n \n=\n \nN\n;\n\n        \nid\n \n=\n \nnew\n \nint\n[\nN\n];\n\n        \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nN\n;\n \ni\n++)\n \nid\n[\ni\n]\n \n=\n \ni\n;\n\n    \n}\n\n\n    \npublic\n \nboolean\n \nconnected\n(\nint\n \np\n,\n \nint\n \nq\n)\n \n{\n\n        \nreturn\n \nfind\n(\np\n)\n \n==\n \nfind\n(\nq\n);\n\n    \n}\n\n\n    \npublic\n \nint\n \nfind\n(\nint\n \np\n)\n \n{\n\n     \n}\n\n\n    \npublic\n \nvoid\n \nunion\n(\nint\n \np\n,\n \nint\n \nq\n)\n \n{\n\n    \n}\n\n\n}\n\n\n\n\nDynamic-connectivity client\n\n\nRead in number of objects \nN\nN\n from standard input. Repeat:\n\n\n\n\nread in pair of integers from standard input\n\n\nif they are not yet connected, connect them and print out pair\n\n\n\n\nWe shall consider several different implementations, all based on using the site-indexed id[] array, to determine whether two sites are in the same connected component.\n\n\n2 Quick-Find\n\n\nQuick-find idea: all sites in a component must have the same value in id[]. \n\n\nThis method is called quick-find because \nfind(p)\n just returns id[p], which immediately implies that \nconnected(p, q)\n reduces to just the test id[p] == id[q] and returns \ntrue\n, if and only if p and q are in the same component.\n\n\nUnion()\n: To combine the two components into one, we have to make all of the id[] entries corresponding to both sets of sites the same value. To do so, we go through the array, changing all the entries with values equal to id[p] to the value id[q].\n\n\n \npublic\n \nclass\n \nQuickFind\n \n{\n\n    \nprivate\n \nint\n[]\n \nid\n;\n\n\n    \npublic\n \nQuickFind\n(\nint\n \nN\n)\n \n{\n\n        \nid\n \n=\n \nnew\n \nint\n[\nN\n];\n\n        \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nN\n;\n \ni\n++)\n \nid\n[\ni\n]\n \n=\n \ni\n;\n\n    \n}\n\n\n    \npublic\n \nboolean\n \nconnected\n(\nint\n \np\n,\n \nint\n \nq\n)\n \n{\n\n        \nreturn\n \nid\n[\np\n]\n \n==\n \nid\n[\nq\n];\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nunion\n(\nint\n \np\n,\n \nint\n \nq\n)\n \n{\n\n        \nint\n \npid\n \n=\n \nid\n[\np\n];\n\n        \nint\n \nqid\n \n=\n \nid\n[\nq\n];\n\n        \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nid\n.\nlength\n;\n \ni\n++)\n \nif\n \n(\nid\n[\ni\n]\n \n==\n \npid\n)\n \nid\n[\ni\n]\n \n=\n \nqid\n;\n\n    \n}\n\n\n\n}\n\n\n\n\nAnalysis\n\n\nThe quick-find algorithm uses one array access for each call to \nfind()\n and between \nN + 3\nN + 3\n and \n2N + 1\n2N + 1\n array accesses for each call to \nunion()\n that combines two components.\n\n\nWORST CASE: suppose we wind up with a single component. This requires at least \nN-1\nN-1\n calls to \nunion()\n, and, consequently, at least \n(N+3)(N-1) \\sim N^2\n(N+3)(N-1) \\sim N^2\n array accesses\u2014we are led immediately to the hypothesis that dynamic connectivity with quick-find can be a quadratic-time process.\n\n\n3 Quick-Union\n\n\nData structure:\n\n\n\n\nInterpretation: id[i] is parent of i. \n\n\nRoot of i is id[id[id[...id[i]...]]] (keep going until it doesn\u2019t change)\n\n\n\n\nSpecifically, the id[] entry, for each site is the name of another site in the same component (possibly itself)\u2014we refer to this connection as a link. To implement \nfind()\n, we start at the given site, follow its link to another site, follow that site\u2019s link to yet another site, and so forth, following links until reaching a root, a site that has a link to itself. Two sites are in the same component if and only if this process leads them to the same root.\n\n\nunion(p, q)\n: we follow links to finds the roots associated with p and q, then rename one of the components by linking one of these roots to the other; hence the name quick-union.\n\n\n\n\n \npublic\n \nclass\n \nQuickUnion\n \n{\n\n    \nprivate\n \nint\n[]\n \nid\n;\n\n    \nprivate\n \nint\n \ncount\n;\n\n\n    \npublic\n \nQuickUnion\n(\nint\n \nN\n)\n \n{\n\n        \ncount\n \n=\n \nN\n;\n\n        \nid\n \n=\n \nnew\n \nint\n[\nN\n];\n\n        \n// set id of each object to itself (N array accesses)\n\n        \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nN\n;\n \ni\n++)\n \nid\n[\ni\n]\n \n=\n \ni\n;\n\n    \n}\n\n\n    \nprivate\n \nint\n \nfind\n(\nint\n \np\n)\n \n{\n\n        \n// chase parent pointers until reach root\n\n        \nwhile\n \n(\np\n \n!=\n \nid\n[\np\n])\n \np\n \n=\n \nid\n[\np\n];\n\n        \nreturn\n \np\n;\n\n\n    \n}\n\n\n    \npublic\n \nboolean\n \nconnected\n(\nint\n \np\n,\n \nint\n \nq\n)\n \n{\n\n        \n//check if p and q have same root\n\n        \nreturn\n \nfind\n(\np\n)\n \n==\n \nfind\n(\nq\n);\n\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nunion\n(\nint\n \np\n,\n \nint\n \nq\n)\n \n{\n\n        \n// change root of p to point to root of q\n\n        \nint\n \ni\n \n=\n \nfind\n(\np\n);\n\n        \nint\n \nj\n \n=\n \nfind\n(\nq\n);\n\n        \nid\n[\ni\n]\n \n=\n \nj\n;\n\n        \ncount\n--;\n\n    \n}\n\n\n\n}\n\n\n\n\nAnalysis\n\n\nThe number of array accesses used by \nfind()\n in quick-union is 1 plus the twice the depth of the node corresponding to the given site. The number of array accesses used by \nunion()\n and \nconnected()\n is the cost of the two \nfind()\n operations (plus 1 for \nunion()\n if the given sites are in different trees).\n\n\nWORST CASE: suppose we wind up with a single component, the running time is quadratic\n\n\n4 Improvement 1: weighting\n\n\nWeighted quick-union\n: Rather than arbitrarily connecting the second tree to the first for \nunion()\n, we keep track of the size of each tree and always c\nonnect the smaller tree to the larger\n. This change needs another array to hold the node counts.\n\n\n\n\n \npublic\n \nclass\n \nWeightedQuickUnion\n \n{\n\n\n    \nprivate\n \nint\n[]\n \nid\n;\n \n// parent link (site indexed)\n\n    \nprivate\n \nint\n[]\n \nsz\n;\n \n// size of component for roots (site indexed)\n\n    \nprivate\n \nint\n \ncount\n;\n \n// number of components\n\n\n    \npublic\n \nWeightedQuickUnion\n(\nint\n \nN\n)\n \n{\n\n        \ncount\n \n=\n \nN\n;\n\n        \nid\n \n=\n \nnew\n \nint\n[\nN\n];\n\n        \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nN\n;\n \ni\n++)\n \nid\n[\ni\n]\n \n=\n \ni\n;\n\n        \nsz\n \n=\n \nnew\n \nint\n[\nN\n];\n\n        \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nN\n;\n \ni\n++)\n \nsz\n[\ni\n]\n \n=\n \n1\n;\n\n    \n}\n\n\n    \npublic\n \nint\n \ncount\n()\n \n{\n\n        \nreturn\n \ncount\n;\n\n    \n}\n\n\n    \npublic\n \nboolean\n \nconnected\n(\nint\n \np\n,\n \nint\n \nq\n)\n \n{\n\n        \nreturn\n \nfind\n(\np\n)\n \n==\n \nfind\n(\nq\n);\n\n    \n}\n\n\n    \nprivate\n \nint\n \nfind\n(\nint\n \np\n)\n \n{\n \n// Follow links to find a root.\n\n\n        \nwhile\n \n(\np\n \n!=\n \nid\n[\np\n])\n \np\n \n=\n \nid\n[\np\n];\n\n        \nreturn\n \np\n;\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nunion\n(\nint\n \np\n,\n \nint\n \nq\n)\n \n{\n\n        \nint\n \ni\n \n=\n \nfind\n(\np\n);\n\n        \nint\n \nj\n \n=\n \nfind\n(\nq\n);\n\n        \nif\n \n(\ni\n \n==\n \nj\n)\n \nreturn\n;\n\n        \n// Make smaller root point to larger one.\n\n        \nif\n \n(\nsz\n[\ni\n]\n \n \nsz\n[\nj\n])\n \n{\n\n            \nid\n[\ni\n]\n \n=\n \nj\n;\n\n            \nsz\n[\nj\n]\n \n+=\n \nsz\n[\ni\n];\n\n        \n}\n \nelse\n \n{\n\n            \nid\n[\nj\n]\n \n=\n \ni\n;\n\n            \nsz\n[\ni\n]\n \n+=\n \nsz\n[\nj\n];\n\n        \n}\n\n        \ncount\n--;\n\n    \n}\n\n\n\n}\n\n\n\n\nAnalysis\n\n\nThe depth of any node in a forest built by weighted quick-union for \nN\nN\n sites is at most \n\\log N\n\\log N\n.\n\n\nThe worst case for weighted quick union is when the sizes of the trees to be merged by \nunion()\n are always equal (and a power of 2). And they have the simple property that the height of a tree of \n2^n\n2^n\n nodes is \nn\nn\n.\n\n\n\n\nFor weighted quick-union with \nN\nN\n sites, the worst-case order of growth of the cost of \nfind()\n, \nconnected()\n, and \nunion()\n is \n\\log N\n\\log N\n.\n\n\nSpecifically, the weighted quick-union algorithm uses at most \ncM\\log N\ncM\\log N\n array accesses to process \nM\nM\n connections among \nN\nN\n sites for a small constant \nc\nc\n.\n\n\n5 Improvement 2: path compression\n\n\nIDEA: Just after computing the root of p, set the id of each examined node to point to that root.\n\n\nTwo-pass implementation: add second loop to \nfind()\n to set the id[] of each examined node to the root.\n\n\nSimpler one-pass variant: Make every other node in path point to its grandparent (thereby halving path length).\n\n\n \nprivate\n \nint\n \nfind\n(\nint\n \np\n)\n \n{\n \n// Follow links to find a root.\n\n    \nwhile\n \n(\np\n \n!=\n \nid\n[\np\n])\n \n{\n\n        \n// only one extra line of code !\n\n        \nid\n[\np\n]\n \n=\n \nid\n[\nid\n[\np\n]];\n\n        \np\n \n=\n \nid\n[\np\n];\n\n    \n}\n\n    \nreturn\n \np\n;\n\n\n}\n\n\n\n\nAmortized Analysis\n\n\nStarting from an empty data structure, any sequence of \nM\nM\n union-find ops on \nN\nN\n objects makes \n\\le c ( N + M \\lg^*N )\n\\le c ( N + M \\lg^*N )\n array accesses, where \nlg^*\nlg^*\n is iterated logarithm[\nwiki\n]. (\nlg^*N\nlg^*N\n\u8868\u793a\u5c06\nN\nN\n\u53d8\u4e3a\u5c0f\u4e8e1\u9700\u8981\u7684\n\\log\n\\log\n\u8fed\u4ee3\u6b21\u6570)\n\n\nApplication - Percolation", 
            "title": "Topic 1: UnionFind "
        }, 
        {
            "location": "/algorithm/topic1/#chapter-1-union-find", 
            "text": "", 
            "title": "Chapter 1: Union Find"
        }, 
        {
            "location": "/algorithm/topic1/#1-dynamic-connectivity", 
            "text": "The graph connectivity problem is the following: Given an  undirected  graph G, preprocess the graph so that queries of the form \u201care nodes u and v connected?\u201d  Connected components :  Maximal set of objects that are mutually connected.", 
            "title": "1 Dynamic Connectivity"
        }, 
        {
            "location": "/algorithm/topic1/#union-find-data-type-api", 
            "text": "Union-Find API:   the  union()  operation merges two components if the two sites are in different components.  the  find()  operation returns an integer component identifier for a given site.  the  connected()  operation determines whether two sites are in the same component.  the  count()  method returns the number of components.      public   class   QuickFind   { \n     private   int []   id ; \n     private   int   count ; \n\n     public   QuickFind ( int   N )   { \n         count   =   N ; \n         id   =   new   int [ N ]; \n         for   ( int   i   =   0 ;   i     N ;   i ++)   id [ i ]   =   i ; \n     } \n\n     public   boolean   connected ( int   p ,   int   q )   { \n         return   find ( p )   ==   find ( q ); \n     } \n\n     public   int   find ( int   p )   { \n      } \n\n     public   void   union ( int   p ,   int   q )   { \n     }  }", 
            "title": "Union-Find data type (API)"
        }, 
        {
            "location": "/algorithm/topic1/#dynamic-connectivity-client", 
            "text": "Read in number of objects  N N  from standard input. Repeat:   read in pair of integers from standard input  if they are not yet connected, connect them and print out pair   We shall consider several different implementations, all based on using the site-indexed id[] array, to determine whether two sites are in the same connected component.", 
            "title": "Dynamic-connectivity client"
        }, 
        {
            "location": "/algorithm/topic1/#2-quick-find", 
            "text": "Quick-find idea: all sites in a component must have the same value in id[].   This method is called quick-find because  find(p)  just returns id[p], which immediately implies that  connected(p, q)  reduces to just the test id[p] == id[q] and returns  true , if and only if p and q are in the same component.  Union() : To combine the two components into one, we have to make all of the id[] entries corresponding to both sets of sites the same value. To do so, we go through the array, changing all the entries with values equal to id[p] to the value id[q].    public   class   QuickFind   { \n     private   int []   id ; \n\n     public   QuickFind ( int   N )   { \n         id   =   new   int [ N ]; \n         for   ( int   i   =   0 ;   i     N ;   i ++)   id [ i ]   =   i ; \n     } \n\n     public   boolean   connected ( int   p ,   int   q )   { \n         return   id [ p ]   ==   id [ q ]; \n     } \n\n     public   void   union ( int   p ,   int   q )   { \n         int   pid   =   id [ p ]; \n         int   qid   =   id [ q ]; \n         for   ( int   i   =   0 ;   i     id . length ;   i ++)   if   ( id [ i ]   ==   pid )   id [ i ]   =   qid ; \n     }  }", 
            "title": "2 Quick-Find"
        }, 
        {
            "location": "/algorithm/topic1/#analysis", 
            "text": "The quick-find algorithm uses one array access for each call to  find()  and between  N + 3 N + 3  and  2N + 1 2N + 1  array accesses for each call to  union()  that combines two components.  WORST CASE: suppose we wind up with a single component. This requires at least  N-1 N-1  calls to  union() , and, consequently, at least  (N+3)(N-1) \\sim N^2 (N+3)(N-1) \\sim N^2  array accesses\u2014we are led immediately to the hypothesis that dynamic connectivity with quick-find can be a quadratic-time process.", 
            "title": "Analysis"
        }, 
        {
            "location": "/algorithm/topic1/#3-quick-union", 
            "text": "Data structure:   Interpretation: id[i] is parent of i.   Root of i is id[id[id[...id[i]...]]] (keep going until it doesn\u2019t change)   Specifically, the id[] entry, for each site is the name of another site in the same component (possibly itself)\u2014we refer to this connection as a link. To implement  find() , we start at the given site, follow its link to another site, follow that site\u2019s link to yet another site, and so forth, following links until reaching a root, a site that has a link to itself. Two sites are in the same component if and only if this process leads them to the same root.  union(p, q) : we follow links to finds the roots associated with p and q, then rename one of the components by linking one of these roots to the other; hence the name quick-union.     public   class   QuickUnion   { \n     private   int []   id ; \n     private   int   count ; \n\n     public   QuickUnion ( int   N )   { \n         count   =   N ; \n         id   =   new   int [ N ]; \n         // set id of each object to itself (N array accesses) \n         for   ( int   i   =   0 ;   i     N ;   i ++)   id [ i ]   =   i ; \n     } \n\n     private   int   find ( int   p )   { \n         // chase parent pointers until reach root \n         while   ( p   !=   id [ p ])   p   =   id [ p ]; \n         return   p ; \n\n     } \n\n     public   boolean   connected ( int   p ,   int   q )   { \n         //check if p and q have same root \n         return   find ( p )   ==   find ( q ); \n\n     } \n\n     public   void   union ( int   p ,   int   q )   { \n         // change root of p to point to root of q \n         int   i   =   find ( p ); \n         int   j   =   find ( q ); \n         id [ i ]   =   j ; \n         count --; \n     }  }", 
            "title": "3 Quick-Union"
        }, 
        {
            "location": "/algorithm/topic1/#analysis_1", 
            "text": "The number of array accesses used by  find()  in quick-union is 1 plus the twice the depth of the node corresponding to the given site. The number of array accesses used by  union()  and  connected()  is the cost of the two  find()  operations (plus 1 for  union()  if the given sites are in different trees).  WORST CASE: suppose we wind up with a single component, the running time is quadratic", 
            "title": "Analysis"
        }, 
        {
            "location": "/algorithm/topic1/#4-improvement-1-weighting", 
            "text": "Weighted quick-union : Rather than arbitrarily connecting the second tree to the first for  union() , we keep track of the size of each tree and always c onnect the smaller tree to the larger . This change needs another array to hold the node counts.     public   class   WeightedQuickUnion   { \n\n     private   int []   id ;   // parent link (site indexed) \n     private   int []   sz ;   // size of component for roots (site indexed) \n     private   int   count ;   // number of components \n\n     public   WeightedQuickUnion ( int   N )   { \n         count   =   N ; \n         id   =   new   int [ N ]; \n         for   ( int   i   =   0 ;   i     N ;   i ++)   id [ i ]   =   i ; \n         sz   =   new   int [ N ]; \n         for   ( int   i   =   0 ;   i     N ;   i ++)   sz [ i ]   =   1 ; \n     } \n\n     public   int   count ()   { \n         return   count ; \n     } \n\n     public   boolean   connected ( int   p ,   int   q )   { \n         return   find ( p )   ==   find ( q ); \n     } \n\n     private   int   find ( int   p )   {   // Follow links to find a root. \n\n         while   ( p   !=   id [ p ])   p   =   id [ p ]; \n         return   p ; \n     } \n\n     public   void   union ( int   p ,   int   q )   { \n         int   i   =   find ( p ); \n         int   j   =   find ( q ); \n         if   ( i   ==   j )   return ; \n         // Make smaller root point to larger one. \n         if   ( sz [ i ]     sz [ j ])   { \n             id [ i ]   =   j ; \n             sz [ j ]   +=   sz [ i ]; \n         }   else   { \n             id [ j ]   =   i ; \n             sz [ i ]   +=   sz [ j ]; \n         } \n         count --; \n     }  }", 
            "title": "4 Improvement 1: weighting"
        }, 
        {
            "location": "/algorithm/topic1/#analysis_2", 
            "text": "The depth of any node in a forest built by weighted quick-union for  N N  sites is at most  \\log N \\log N .  The worst case for weighted quick union is when the sizes of the trees to be merged by  union()  are always equal (and a power of 2). And they have the simple property that the height of a tree of  2^n 2^n  nodes is  n n .   For weighted quick-union with  N N  sites, the worst-case order of growth of the cost of  find() ,  connected() , and  union()  is  \\log N \\log N .  Specifically, the weighted quick-union algorithm uses at most  cM\\log N cM\\log N  array accesses to process  M M  connections among  N N  sites for a small constant  c c .", 
            "title": "Analysis"
        }, 
        {
            "location": "/algorithm/topic1/#5-improvement-2-path-compression", 
            "text": "IDEA: Just after computing the root of p, set the id of each examined node to point to that root.  Two-pass implementation: add second loop to  find()  to set the id[] of each examined node to the root.  Simpler one-pass variant: Make every other node in path point to its grandparent (thereby halving path length).    private   int   find ( int   p )   {   // Follow links to find a root. \n     while   ( p   !=   id [ p ])   { \n         // only one extra line of code ! \n         id [ p ]   =   id [ id [ p ]]; \n         p   =   id [ p ]; \n     } \n     return   p ;  }", 
            "title": "5 Improvement 2: path compression"
        }, 
        {
            "location": "/algorithm/topic1/#amortized-analysis", 
            "text": "Starting from an empty data structure, any sequence of  M M  union-find ops on  N N  objects makes  \\le c ( N + M \\lg^*N ) \\le c ( N + M \\lg^*N )  array accesses, where  lg^* lg^*  is iterated logarithm[ wiki ]. ( lg^*N lg^*N \u8868\u793a\u5c06 N N \u53d8\u4e3a\u5c0f\u4e8e1\u9700\u8981\u7684 \\log \\log \u8fed\u4ee3\u6b21\u6570)", 
            "title": "Amortized Analysis"
        }, 
        {
            "location": "/algorithm/topic1/#application-percolation", 
            "text": "", 
            "title": "Application - Percolation"
        }, 
        {
            "location": "/algorithm/topic2/", 
            "text": "Stacks and Queues\n\n\n1 stacks\n\n\n2 resizing arrays\n\n\n3 queues\n\n\n4 generics\n\n\n5 iterators\n\n\n6 applications", 
            "title": "Topic 2: StackQueue"
        }, 
        {
            "location": "/algorithm/topic2/#stacks-and-queues", 
            "text": "", 
            "title": "Stacks and Queues"
        }, 
        {
            "location": "/algorithm/topic2/#1-stacks", 
            "text": "", 
            "title": "1 stacks"
        }, 
        {
            "location": "/algorithm/topic2/#2-resizing-arrays", 
            "text": "", 
            "title": "2 resizing arrays"
        }, 
        {
            "location": "/algorithm/topic2/#3-queues", 
            "text": "", 
            "title": "3 queues"
        }, 
        {
            "location": "/algorithm/topic2/#4-generics", 
            "text": "", 
            "title": "4 generics"
        }, 
        {
            "location": "/algorithm/topic2/#5-iterators", 
            "text": "", 
            "title": "5 iterators"
        }, 
        {
            "location": "/algorithm/topic2/#6-applications", 
            "text": "", 
            "title": "6 applications"
        }, 
        {
            "location": "/cs61b/", 
            "text": "CS61B\n\n\n\n\nLab1: javac, java, git\n\n\nLab2: Unit Testing with JUnit and IntLists\n\n\nLab3: Unit Testing with JUnit, Debugging", 
            "title": "Contents"
        }, 
        {
            "location": "/cs61b/#cs61b", 
            "text": "Lab1: javac, java, git  Lab2: Unit Testing with JUnit and IntLists  Lab3: Unit Testing with JUnit, Debugging", 
            "title": "CS61B"
        }, 
        {
            "location": "/cs61b/Lab1/", 
            "text": "Lab 1: javac, java, git\n\n\nAdd the skeleton remote repository, and pull from the skeleton remote in order to get the starter code for lab 1.\n\n\n \n$ git remote add skeleton https://github.com/Berkeley-CS61B/skeleton-sp18.git\n$ git pull skeleton master\n\n\n\nLeap Year\n\n\nIn the lab1 folder, you should see a file called \nLeapYear.java\n. This program is supposed to test whether or not a given year is a Leap Year. The user will give a year as a command line parameter (examples given below), and then print out whether or not that year is a leap year, e.g.\n\n\n \n$ java LeapYear \n2000\n \n\n2000\n is a leap year.\n$ java LeapYear \n1999\n \n\n1999\n is not a leap year. \n$ java LeapYear \n2004\n \n\n2004\n is a leap year.\n$ java LeapYear \n2100\n \n\n2100\n is not a leap year.\n\n\n\nA leap year is either:\n\n\n\n\ndivisible by 400 or\n\n\ndivisible by 4 and not by 100.\n\n\n\n\nRequirement:\n\n\n\n\nMake sure to provide a description of the method as a comment. Your description should be contained by /*\n and \n/ (JavaDocs). \n\n\nUse the @source tag any time you receive significant help on a project.\n\n\n\n\nSome Java tips:\n\n\n\n\nThe % operator implements remainder.\n\n\nThe != operator compares two values for inequality.\n\n\nWhen one of the arguments of the + operator is a String, the arguments are concatenated as Strings.\n\n\n\n\n \n/** Class that determines whether or not a year is a leap year.\n\n\n *  @author zhenhua wang\n\n\n */\n\n\npublic\n \nclass\n \nLeapYear\n \n{\n\n\n    \n/** Calls isLeapYear to print correct statement.\n\n\n     *  @param  year to be analyzed\n\n\n     */\n\n    \nprivate\n \nstatic\n \nvoid\n \ncheckLeapYear\n(\nint\n \nyear\n)\n \n{\n\n        \nif\n \n(\nisLeapYear\n(\nyear\n))\n \n{\n\n            \nSystem\n.\nout\n.\nprintf\n(\n%d is a leap year.\\n\n,\n \nyear\n);\n\n        \n}\n \nelse\n \n{\n\n            \nSystem\n.\nout\n.\nprintf\n(\n%d is not a leap year.\\n\n,\n \nyear\n);\n\n        \n}\n\n    \n}\n\n\n    \n/** Check if the year  is a leap year\n\n\n     * @param year int year\n\n\n     */\n\n    \nprivate\n \nstatic\n \nboolean\n \nisLeapYear\n(\nint\n \nyear\n)\n \n{\n\n        \nif\n \n(\nyear\n%\n400\n \n==\n \n0\n)\n\n            \nreturn\n \ntrue\n;\n\n        \nelse\n \nif\n \n((\nyear\n%\n4\n==\n0\n)\n \n \n(\nyear\n \n%\n100\n \n!=\n0\n))\n\n            \nreturn\n \ntrue\n;\n\n        \nreturn\n \nfalse\n;\n\n    \n}\n\n\n\n\n\n    \n/** Must be provided an integer as a command line argument ARGS.\n\n\n     * @param args int year\n\n\n     */\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n        \nif\n \n(\nargs\n.\nlength\n \n \n1\n)\n \n{\n\n            \nSystem\n.\nout\n.\nprintln\n(\nPlease enter command line arguments.\n);\n\n            \nSystem\n.\nout\n.\nprintln\n(\ne.g. java Year 2000\n);\n\n        \n}\n\n        \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nargs\n.\nlength\n;\n \ni\n++)\n \n{\n\n            \ntry\n \n{\n\n                \nint\n \nyear\n \n=\n \nInteger\n.\nparseInt\n(\nargs\n[\ni\n]);\n\n                \ncheckLeapYear\n(\nyear\n);\n\n            \n}\n \ncatch\n \n(\nNumberFormatException\n \ne\n)\n \n{\n\n                \nSystem\n.\nout\n.\nprintf\n(\n%s is not a valid number.\\n\n,\n \nargs\n[\ni\n]);\n\n            \n}\n\n        \n}\n\n    \n}\n\n\n}", 
            "title": "Lab1: javac, java, git"
        }, 
        {
            "location": "/cs61b/Lab1/#lab-1-javac-java-git", 
            "text": "Add the skeleton remote repository, and pull from the skeleton remote in order to get the starter code for lab 1.    $ git remote add skeleton https://github.com/Berkeley-CS61B/skeleton-sp18.git\n$ git pull skeleton master", 
            "title": "Lab 1: javac, java, git"
        }, 
        {
            "location": "/cs61b/Lab1/#leap-year", 
            "text": "In the lab1 folder, you should see a file called  LeapYear.java . This program is supposed to test whether or not a given year is a Leap Year. The user will give a year as a command line parameter (examples given below), and then print out whether or not that year is a leap year, e.g.    $ java LeapYear  2000   2000  is a leap year.\n$ java LeapYear  1999   1999  is not a leap year. \n$ java LeapYear  2004   2004  is a leap year.\n$ java LeapYear  2100   2100  is not a leap year.  A leap year is either:   divisible by 400 or  divisible by 4 and not by 100.   Requirement:   Make sure to provide a description of the method as a comment. Your description should be contained by /*  and  / (JavaDocs).   Use the @source tag any time you receive significant help on a project.   Some Java tips:   The % operator implements remainder.  The != operator compares two values for inequality.  When one of the arguments of the + operator is a String, the arguments are concatenated as Strings.     /** Class that determines whether or not a year is a leap year.   *  @author zhenhua wang   */  public   class   LeapYear   { \n\n     /** Calls isLeapYear to print correct statement.       *  @param  year to be analyzed       */ \n     private   static   void   checkLeapYear ( int   year )   { \n         if   ( isLeapYear ( year ))   { \n             System . out . printf ( %d is a leap year.\\n ,   year ); \n         }   else   { \n             System . out . printf ( %d is not a leap year.\\n ,   year ); \n         } \n     } \n\n     /** Check if the year  is a leap year       * @param year int year       */ \n     private   static   boolean   isLeapYear ( int   year )   { \n         if   ( year % 400   ==   0 ) \n             return   true ; \n         else   if   (( year % 4 == 0 )     ( year   % 100   != 0 )) \n             return   true ; \n         return   false ; \n     } \n\n\n\n\n     /** Must be provided an integer as a command line argument ARGS.       * @param args int year       */ \n     public   static   void   main ( String []   args )   { \n         if   ( args . length     1 )   { \n             System . out . println ( Please enter command line arguments. ); \n             System . out . println ( e.g. java Year 2000 ); \n         } \n         for   ( int   i   =   0 ;   i     args . length ;   i ++)   { \n             try   { \n                 int   year   =   Integer . parseInt ( args [ i ]); \n                 checkLeapYear ( year ); \n             }   catch   ( NumberFormatException   e )   { \n                 System . out . printf ( %s is not a valid number.\\n ,   args [ i ]); \n             } \n         } \n     }  }", 
            "title": "Leap Year"
        }, 
        {
            "location": "/cs61b/Lab2/", 
            "text": "Lab 2: Unit Testing with JUnit and IntLists\n\n\n1 Lab 2 setup: Setting Up IntelliJ\n\n\nInstalling the IntelliJ CS 61B Plugin after installation of IntelliJ.\n\n\n\n\nGetting Java Libraries\n\n\n \ngit\n \nsubmodule\n \nupdate\n \n--\ninit\n\n\n\n\n2 Lab 2: Unit Testing with JUnit and IntLists\n\n\nIntroduction\n\n\nIn this lab, you will learn about basic IntelliJ features, Destructive vs NonDestructive methods, and IntLists.\n\n\nBreakpoints and Step Into\n\n\nWhile print statements can be very useful for debugging, they have a few disadvantages: \n\n\n\n\nThey require you to modify your code (to add print statements). \n\n\nThey require you to explicitly state what you want to know (since you have to say precisely what you want to print). \n\n\nAnd they provide their results in a format that can be hard to read, since it\ns just a big blob of text in the execution window.\n\n\n\n\nThe IntelliJ debugger allows you to pause the code in the middle of execution, step the code line by line, and even visualize the organization of complex data structures like linked lists.\n\n\nThe \nstep over\n button allows us to complete a function call without showing the function executing\n\n\nConditional Breakpoints and Resume\n\n\nAn even faster approach is to make our breakpoint conditional. To do this, right (or two-finer) click on the red breakpoint dot. Here, you can set a condition for when you want to stop.\n\n\n\n\nDestructive vs. Non-Destructive\n\n\nBy destructive, we mean that the original list changes. The term \nmutative\n is also sometimes used. By contrast a non-destructive method  does not affect the original list.\n\n\nImplementing Destructive vs. Non-destructive Methods\n\n\n \npackage\n \ncom.berkeycs61b.lab2.Intlist\n;\n\n\n\nimport\n \njava.util.Formatter\n;\n\n\n\n/**\n\n\n * A naked recursive list of integers, similar to what we saw in lecture 3, but\n\n\n * with a large number of additional methods.\n\n\n *\n\n\n * @author P. N. Hilfinger, with some modifications by Josh Hug and melaniecebula\n\n\n *         [Do not modify this file.]\n\n\n */\n\n\npublic\n \nclass\n \nIntList\n \n{\n\n    \n/**\n\n\n     * First element of list.\n\n\n     */\n\n    \npublic\n \nint\n \nfirst\n;\n\n    \n/**\n\n\n     * Remaining elements of list.\n\n\n     */\n\n    \npublic\n \nIntList\n \nrest\n;\n\n\n    \n/**\n\n\n     * A List with first FIRST0 and rest REST0.\n\n\n     */\n\n    \npublic\n \nIntList\n(\nint\n \nfirst0\n,\n \nIntList\n \nrest0\n)\n \n{\n\n        \nfirst\n \n=\n \nfirst0\n;\n\n        \nrest\n \n=\n \nrest0\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * A List with null rest, and first = 0.\n\n\n     */\n\n    \npublic\n \nIntList\n()\n \n{\n\n    \n/* NOTE: public IntList () { }  would also work. */\n\n        \nthis\n(\n0\n,\n \nnull\n);\n\n    \n}\n\n\n    \n/**\n\n\n     * Returns a list equal to L with all elements squared. Destructive.\n\n\n     */\n\n    \npublic\n \nstatic\n \nvoid\n \ndSquareList\n(\nIntList\n \nL\n)\n \n{\n\n\n        \nwhile\n \n(\nL\n \n!=\n \nnull\n)\n \n{\n\n            \nL\n.\nfirst\n \n=\n \nL\n.\nfirst\n \n*\n \nL\n.\nfirst\n;\n\n            \nL\n \n=\n \nL\n.\nrest\n;\n\n        \n}\n\n    \n}\n\n\n    \n/**\n\n\n     * Returns a list equal to L with all elements squared. Non-destructive.\n\n\n     */\n\n    \npublic\n \nstatic\n \nIntList\n \nsquareListIterative\n(\nIntList\n \nL\n)\n \n{\n\n        \nif\n \n(\nL\n \n==\n \nnull\n)\n \n{\n\n            \nreturn\n \nnull\n;\n\n        \n}\n\n        \nIntList\n \nres\n \n=\n \nnew\n \nIntList\n(\nL\n.\nfirst\n \n*\n \nL\n.\nfirst\n,\n \nnull\n);\n\n        \nIntList\n \nptr\n \n=\n \nres\n;\n\n        \nL\n \n=\n \nL\n.\nrest\n;\n\n        \nwhile\n \n(\nL\n \n!=\n \nnull\n)\n \n{\n\n            \nptr\n.\nrest\n \n=\n \nnew\n \nIntList\n(\nL\n.\nfirst\n \n*\n \nL\n.\nfirst\n,\n \nnull\n);\n\n            \nL\n \n=\n \nL\n.\nrest\n;\n\n            \nptr\n \n=\n \nptr\n.\nrest\n;\n\n        \n}\n\n        \nreturn\n \nres\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Returns a list equal to L with all elements squared. Non-destructive.\n\n\n     */\n\n    \npublic\n \nstatic\n \nIntList\n \nsquareListRecursive\n(\nIntList\n \nL\n)\n \n{\n\n        \nif\n \n(\nL\n \n==\n \nnull\n)\n \n{\n\n            \nreturn\n \nnull\n;\n\n        \n}\n\n        \nreturn\n \nnew\n \nIntList\n(\nL\n.\nfirst\n \n*\n \nL\n.\nfirst\n,\n \nsquareListRecursive\n(\nL\n.\nrest\n));\n\n    \n}\n\n\n    \n/** DO NOT MODIFY ANYTHING ABOVE THIS LINE! */\n\n\n\n    \n/**\n\n\n     * Returns a list consisting of the elements of A followed by the\n\n\n     * *  elements of B.  May modify items of A. Don\nt use \nnew\n.\n\n\n     */\n\n\n    \npublic\n \nstatic\n \nIntList\n \ndcatenate\n(\nIntList\n \nA\n,\n \nIntList\n \nB\n)\n \n{\n\n        \n//TODO:  fill in method\n\n        \nIntList\n \nA_location\n \n=\n \nA\n;\n\n        \nwhile\n \n(\nA_location\n.\nrest\n!=\nnull\n)\n \n{\n\n            \nA_location\n \n=\n \nA_location\n.\nrest\n;\n\n        \n}\n\n        \nA_location\n.\nrest\n \n=\n \nB\n;\n\n\n        \nreturn\n \nA\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Returns a list consisting of the elements of A followed by the\n\n\n     * * elements of B.  May NOT modify items of A.  Use \nnew\n.\n\n\n     */\n\n    \npublic\n \nstatic\n \nIntList\n \ncatenate\n(\nIntList\n \nA\n,\n \nIntList\n \nB\n)\n \n{\n\n        \n//TODO:  fill in method\n\n        \nIntList\n \nres\n \n=\n \nnew\n \nIntList\n(\nA\n.\nfirst\n,\n \nnull\n);\n\n        \nIntList\n \nres_location\n \n=\n \nres\n;\n\n        \nIntList\n \nA_location\n \n=\n \nA\n.\nrest\n;\n\n        \nwhile\n \n(\nA_location\n.\nrest\n!=\nnull\n)\n \n{\n\n            \nres_location\n.\nrest\n \n=\n \nnew\n \nIntList\n(\nA_location\n.\nfirst\n,\n \nnull\n);\n\n            \nA_location\n \n=\n \nA_location\n.\nrest\n;\n\n            \nres_location\n \n=\n \nres_location\n.\nrest\n;\n\n        \n}\n\n\n        \nres_location\n.\nrest\n \n=\n \nnew\n \nIntList\n(\nA_location\n.\nfirst\n,\n \nnull\n);\n\n        \nres_location\n \n=\n \nres_location\n.\nrest\n;\n\n\n\n        \nIntList\n \nB_location\n \n=\n \nB\n;\n\n        \nwhile\n \n(\nB_location\n.\nrest\n!=\nnull\n)\n \n{\n\n            \nres_location\n.\nrest\n \n=\n \nnew\n \nIntList\n(\nB_location\n.\nfirst\n,\n \nnull\n);\n\n            \nB_location\n \n=\n \nB_location\n.\nrest\n;\n\n            \nres_location\n \n=\n \nres_location\n.\nrest\n;\n\n        \n}\n\n        \nres_location\n.\nrest\n \n=\n  \nnew\n \nIntList\n(\nB_location\n.\nfirst\n,\n \nnull\n);\n\n        \nreturn\n \nres\n;\n\n    \n}\n\n\n\n\n\n\n\n\n    \n/**\n\n\n     * DO NOT MODIFY ANYTHING BELOW THIS LINE! Many of the concepts below here\n\n\n     * will be introduced later in the course or feature some form of advanced\n\n\n     * trickery which we implemented to help make your life a little easier for\n\n\n     * the lab.\n\n\n     */\n\n\n    \n@Override\n\n    \npublic\n \nint\n \nhashCode\n()\n \n{\n\n        \nreturn\n \nfirst\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Returns a new IntList containing the ints in ARGS. You are not\n\n\n     * expected to read or understand this method.\n\n\n     */\n\n    \npublic\n \nstatic\n \nIntList\n \nof\n(\nInteger\n...\n \nargs\n)\n \n{\n\n        \nIntList\n \nresult\n,\n \np\n;\n\n\n        \nif\n \n(\nargs\n.\nlength\n \n \n0\n)\n \n{\n\n            \nresult\n \n=\n \nnew\n \nIntList\n(\nargs\n[\n0\n],\n \nnull\n);\n\n        \n}\n \nelse\n \n{\n\n            \nreturn\n \nnull\n;\n\n        \n}\n\n\n        \nint\n \nk\n;\n\n        \nfor\n \n(\nk\n \n=\n \n1\n,\n \np\n \n=\n \nresult\n;\n \nk\n \n \nargs\n.\nlength\n;\n \nk\n \n+=\n \n1\n,\n \np\n \n=\n \np\n.\nrest\n)\n \n{\n\n            \np\n.\nrest\n \n=\n \nnew\n \nIntList\n(\nargs\n[\nk\n],\n \nnull\n);\n\n        \n}\n\n        \nreturn\n \nresult\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * Returns true iff X is an IntList containing the same sequence of ints\n\n\n     * as THIS. Cannot handle IntLists with cycles. You are not expected to\n\n\n     * read or understand this method.\n\n\n     */\n\n    \npublic\n \nboolean\n \nequals\n(\nObject\n \nx\n)\n \n{\n\n        \nif\n \n(!(\nx\n \ninstanceof\n \nIntList\n))\n \n{\n\n            \nreturn\n \nfalse\n;\n\n        \n}\n\n        \nIntList\n \nL\n \n=\n \n(\nIntList\n)\n \nx\n;\n\n        \nIntList\n \np\n;\n\n\n        \nfor\n \n(\np\n \n=\n \nthis\n;\n \np\n \n!=\n \nnull\n \n \nL\n \n!=\n \nnull\n;\n \np\n \n=\n \np\n.\nrest\n,\n \nL\n \n=\n \nL\n.\nrest\n)\n \n{\n\n            \nif\n \n(\np\n.\nfirst\n \n!=\n \nL\n.\nfirst\n)\n \n{\n\n                \nreturn\n \nfalse\n;\n\n            \n}\n\n        \n}\n\n        \nif\n \n(\np\n \n!=\n \nnull\n \n||\n \nL\n \n!=\n \nnull\n)\n \n{\n\n            \nreturn\n \nfalse\n;\n\n        \n}\n\n        \nreturn\n \ntrue\n;\n\n    \n}\n\n\n    \n/**\n\n\n     * If a cycle exists in the IntList, this method\n\n\n     * returns an integer equal to the item number of the location where the\n\n\n     * cycle is detected.\n\n\n     * \np\n\n\n     * If there is no cycle, the number 0 is returned instead. This is a\n\n\n     * utility method for lab2. You are not expected to read, understand, or\n\n\n     * even use this method. The point of this method is so that if you convert\n\n\n     * an IntList into a String and that IntList has a loop, your computer\n\n\n     * doesn\nt get stuck in an infinite loop.\n\n\n     */\n\n\n    \nprivate\n \nint\n \ndetectCycles\n(\nIntList\n \nA\n)\n \n{\n\n        \nIntList\n \ntortoise\n \n=\n \nA\n;\n\n        \nIntList\n \nhare\n \n=\n \nA\n;\n\n\n        \nif\n \n(\nA\n \n==\n \nnull\n)\n \n{\n\n            \nreturn\n \n0\n;\n\n        \n}\n\n\n        \nint\n \ncnt\n \n=\n \n0\n;\n\n\n\n        \nwhile\n \n(\ntrue\n)\n \n{\n\n            \ncnt\n++;\n\n            \nif\n \n(\nhare\n.\nrest\n \n!=\n \nnull\n)\n \n{\n\n                \nhare\n \n=\n \nhare\n.\nrest\n.\nrest\n;\n\n            \n}\n \nelse\n \n{\n\n                \nreturn\n \n0\n;\n\n            \n}\n\n\n            \ntortoise\n \n=\n \ntortoise\n.\nrest\n;\n\n\n            \nif\n \n(\ntortoise\n \n==\n \nnull\n \n||\n \nhare\n \n==\n \nnull\n)\n \n{\n\n                \nreturn\n \n0\n;\n\n            \n}\n\n\n            \nif\n \n(\nhare\n \n==\n \ntortoise\n)\n \n{\n\n                \nreturn\n \ncnt\n;\n\n            \n}\n\n        \n}\n\n    \n}\n\n\n    \n@Override\n\n    \n/** Outputs the IntList as a String. You are not expected to read\n\n\n     * or understand this method. */\n\n    \npublic\n \nString\n \ntoString\n()\n \n{\n\n        \nFormatter\n \nout\n \n=\n \nnew\n \nFormatter\n();\n\n        \nString\n \nsep\n;\n\n        \nsep\n \n=\n \n(\n;\n\n        \nint\n \ncycleLocation\n \n=\n \ndetectCycles\n(\nthis\n);\n\n        \nint\n \ncnt\n \n=\n \n0\n;\n\n\n        \nfor\n \n(\nIntList\n \np\n \n=\n \nthis\n;\n \np\n \n!=\n \nnull\n;\n \np\n \n=\n \np\n.\nrest\n)\n \n{\n\n            \nout\n.\nformat\n(\n%s%d\n,\n \nsep\n,\n \np\n.\nfirst\n);\n\n            \nsep\n \n=\n \n, \n;\n\n\n            \ncnt\n++;\n\n            \nif\n \n((\ncnt\n \n \ncycleLocation\n)\n \n \n(\ncycleLocation\n \n \n0\n))\n \n{\n\n                \nout\n.\nformat\n(\n... (cycle exists) ...\n);\n\n                \nbreak\n;\n\n            \n}\n\n        \n}\n\n        \nout\n.\nformat\n(\n)\n);\n\n        \nreturn\n \nout\n.\ntoString\n();\n\n    \n}\n\n\n}", 
            "title": "Lab2: Unit Testing with JUnit and IntLists"
        }, 
        {
            "location": "/cs61b/Lab2/#lab-2-unit-testing-with-junit-and-intlists", 
            "text": "", 
            "title": "Lab 2: Unit Testing with JUnit and IntLists"
        }, 
        {
            "location": "/cs61b/Lab2/#1-lab-2-setup-setting-up-intellij", 
            "text": "Installing the IntelliJ CS 61B Plugin after installation of IntelliJ.   Getting Java Libraries    git   submodule   update   -- init", 
            "title": "1 Lab 2 setup: Setting Up IntelliJ"
        }, 
        {
            "location": "/cs61b/Lab2/#2-lab-2-unit-testing-with-junit-and-intlists", 
            "text": "", 
            "title": "2 Lab 2: Unit Testing with JUnit and IntLists"
        }, 
        {
            "location": "/cs61b/Lab2/#introduction", 
            "text": "In this lab, you will learn about basic IntelliJ features, Destructive vs NonDestructive methods, and IntLists.", 
            "title": "Introduction"
        }, 
        {
            "location": "/cs61b/Lab2/#breakpoints-and-step-into", 
            "text": "While print statements can be very useful for debugging, they have a few disadvantages:    They require you to modify your code (to add print statements).   They require you to explicitly state what you want to know (since you have to say precisely what you want to print).   And they provide their results in a format that can be hard to read, since it s just a big blob of text in the execution window.   The IntelliJ debugger allows you to pause the code in the middle of execution, step the code line by line, and even visualize the organization of complex data structures like linked lists.  The  step over  button allows us to complete a function call without showing the function executing", 
            "title": "Breakpoints and Step Into"
        }, 
        {
            "location": "/cs61b/Lab2/#conditional-breakpoints-and-resume", 
            "text": "An even faster approach is to make our breakpoint conditional. To do this, right (or two-finer) click on the red breakpoint dot. Here, you can set a condition for when you want to stop.", 
            "title": "Conditional Breakpoints and Resume"
        }, 
        {
            "location": "/cs61b/Lab2/#destructive-vs-non-destructive", 
            "text": "By destructive, we mean that the original list changes. The term  mutative  is also sometimes used. By contrast a non-destructive method  does not affect the original list.", 
            "title": "Destructive vs. Non-Destructive"
        }, 
        {
            "location": "/cs61b/Lab2/#implementing-destructive-vs-non-destructive-methods", 
            "text": "package   com.berkeycs61b.lab2.Intlist ;  import   java.util.Formatter ;  /**   * A naked recursive list of integers, similar to what we saw in lecture 3, but   * with a large number of additional methods.   *   * @author P. N. Hilfinger, with some modifications by Josh Hug and melaniecebula   *         [Do not modify this file.]   */  public   class   IntList   { \n     /**       * First element of list.       */ \n     public   int   first ; \n     /**       * Remaining elements of list.       */ \n     public   IntList   rest ; \n\n     /**       * A List with first FIRST0 and rest REST0.       */ \n     public   IntList ( int   first0 ,   IntList   rest0 )   { \n         first   =   first0 ; \n         rest   =   rest0 ; \n     } \n\n     /**       * A List with null rest, and first = 0.       */ \n     public   IntList ()   { \n     /* NOTE: public IntList () { }  would also work. */ \n         this ( 0 ,   null ); \n     } \n\n     /**       * Returns a list equal to L with all elements squared. Destructive.       */ \n     public   static   void   dSquareList ( IntList   L )   { \n\n         while   ( L   !=   null )   { \n             L . first   =   L . first   *   L . first ; \n             L   =   L . rest ; \n         } \n     } \n\n     /**       * Returns a list equal to L with all elements squared. Non-destructive.       */ \n     public   static   IntList   squareListIterative ( IntList   L )   { \n         if   ( L   ==   null )   { \n             return   null ; \n         } \n         IntList   res   =   new   IntList ( L . first   *   L . first ,   null ); \n         IntList   ptr   =   res ; \n         L   =   L . rest ; \n         while   ( L   !=   null )   { \n             ptr . rest   =   new   IntList ( L . first   *   L . first ,   null ); \n             L   =   L . rest ; \n             ptr   =   ptr . rest ; \n         } \n         return   res ; \n     } \n\n     /**       * Returns a list equal to L with all elements squared. Non-destructive.       */ \n     public   static   IntList   squareListRecursive ( IntList   L )   { \n         if   ( L   ==   null )   { \n             return   null ; \n         } \n         return   new   IntList ( L . first   *   L . first ,   squareListRecursive ( L . rest )); \n     } \n\n     /** DO NOT MODIFY ANYTHING ABOVE THIS LINE! */ \n\n\n     /**       * Returns a list consisting of the elements of A followed by the       * *  elements of B.  May modify items of A. Don t use  new .       */ \n\n     public   static   IntList   dcatenate ( IntList   A ,   IntList   B )   { \n         //TODO:  fill in method \n         IntList   A_location   =   A ; \n         while   ( A_location . rest != null )   { \n             A_location   =   A_location . rest ; \n         } \n         A_location . rest   =   B ; \n\n         return   A ; \n     } \n\n     /**       * Returns a list consisting of the elements of A followed by the       * * elements of B.  May NOT modify items of A.  Use  new .       */ \n     public   static   IntList   catenate ( IntList   A ,   IntList   B )   { \n         //TODO:  fill in method \n         IntList   res   =   new   IntList ( A . first ,   null ); \n         IntList   res_location   =   res ; \n         IntList   A_location   =   A . rest ; \n         while   ( A_location . rest != null )   { \n             res_location . rest   =   new   IntList ( A_location . first ,   null ); \n             A_location   =   A_location . rest ; \n             res_location   =   res_location . rest ; \n         } \n\n         res_location . rest   =   new   IntList ( A_location . first ,   null ); \n         res_location   =   res_location . rest ; \n\n\n         IntList   B_location   =   B ; \n         while   ( B_location . rest != null )   { \n             res_location . rest   =   new   IntList ( B_location . first ,   null ); \n             B_location   =   B_location . rest ; \n             res_location   =   res_location . rest ; \n         } \n         res_location . rest   =    new   IntList ( B_location . first ,   null ); \n         return   res ; \n     } \n\n\n\n\n\n\n\n     /**       * DO NOT MODIFY ANYTHING BELOW THIS LINE! Many of the concepts below here       * will be introduced later in the course or feature some form of advanced       * trickery which we implemented to help make your life a little easier for       * the lab.       */ \n\n     @Override \n     public   int   hashCode ()   { \n         return   first ; \n     } \n\n     /**       * Returns a new IntList containing the ints in ARGS. You are not       * expected to read or understand this method.       */ \n     public   static   IntList   of ( Integer ...   args )   { \n         IntList   result ,   p ; \n\n         if   ( args . length     0 )   { \n             result   =   new   IntList ( args [ 0 ],   null ); \n         }   else   { \n             return   null ; \n         } \n\n         int   k ; \n         for   ( k   =   1 ,   p   =   result ;   k     args . length ;   k   +=   1 ,   p   =   p . rest )   { \n             p . rest   =   new   IntList ( args [ k ],   null ); \n         } \n         return   result ; \n     } \n\n     /**       * Returns true iff X is an IntList containing the same sequence of ints       * as THIS. Cannot handle IntLists with cycles. You are not expected to       * read or understand this method.       */ \n     public   boolean   equals ( Object   x )   { \n         if   (!( x   instanceof   IntList ))   { \n             return   false ; \n         } \n         IntList   L   =   ( IntList )   x ; \n         IntList   p ; \n\n         for   ( p   =   this ;   p   !=   null     L   !=   null ;   p   =   p . rest ,   L   =   L . rest )   { \n             if   ( p . first   !=   L . first )   { \n                 return   false ; \n             } \n         } \n         if   ( p   !=   null   ||   L   !=   null )   { \n             return   false ; \n         } \n         return   true ; \n     } \n\n     /**       * If a cycle exists in the IntList, this method       * returns an integer equal to the item number of the location where the       * cycle is detected.       *  p       * If there is no cycle, the number 0 is returned instead. This is a       * utility method for lab2. You are not expected to read, understand, or       * even use this method. The point of this method is so that if you convert       * an IntList into a String and that IntList has a loop, your computer       * doesn t get stuck in an infinite loop.       */ \n\n     private   int   detectCycles ( IntList   A )   { \n         IntList   tortoise   =   A ; \n         IntList   hare   =   A ; \n\n         if   ( A   ==   null )   { \n             return   0 ; \n         } \n\n         int   cnt   =   0 ; \n\n\n         while   ( true )   { \n             cnt ++; \n             if   ( hare . rest   !=   null )   { \n                 hare   =   hare . rest . rest ; \n             }   else   { \n                 return   0 ; \n             } \n\n             tortoise   =   tortoise . rest ; \n\n             if   ( tortoise   ==   null   ||   hare   ==   null )   { \n                 return   0 ; \n             } \n\n             if   ( hare   ==   tortoise )   { \n                 return   cnt ; \n             } \n         } \n     } \n\n     @Override \n     /** Outputs the IntList as a String. You are not expected to read       * or understand this method. */ \n     public   String   toString ()   { \n         Formatter   out   =   new   Formatter (); \n         String   sep ; \n         sep   =   ( ; \n         int   cycleLocation   =   detectCycles ( this ); \n         int   cnt   =   0 ; \n\n         for   ( IntList   p   =   this ;   p   !=   null ;   p   =   p . rest )   { \n             out . format ( %s%d ,   sep ,   p . first ); \n             sep   =   ,  ; \n\n             cnt ++; \n             if   (( cnt     cycleLocation )     ( cycleLocation     0 ))   { \n                 out . format ( ... (cycle exists) ... ); \n                 break ; \n             } \n         } \n         out . format ( ) ); \n         return   out . toString (); \n     }  }", 
            "title": "Implementing Destructive vs. Non-destructive Methods"
        }, 
        {
            "location": "/cs61b/Lab3/", 
            "text": "Lab 3: Unit Testing with JUnit, Debugging\n\n\n1 Introduction\n\n\nJUnit is a Unit Testing Framework for Java.\n\n\nUnit Testing is a great way to rigorously test each method of your code and ultimately ensure that you have a working project.\n\n\nThe \u201cUnit\u201d part of Unit Testing comes from the idea that you can break your program down into units, or the smallest testable part of an application. Therefore, Unit Testing enforces good code structure (each method should only do \u201cOne Thing\u201d), and allows you to consider all of the edge cases for each method and test for them individually.\n\n\nJUnit Syntax\n\n\nassertEquals\n is a common method used in JUnit tests. It tests if a variable\u2019s actual value is equivalent to its expected value.\n\n\n \n@Test\n\n\npublic\n \nvoid\n \ntestMethod\n()\n \n{\n\n    \nassertEquals\n(\nexpected\n,\n \nactual\n);\n\n\n}\n\n\n\n\nWhen you create JUnit test files, you should precede each test method with a \n@Test\n annotation, and can have one or more \nassertEquals\n or \nassertTrue\n methods (provided by the JUnit library). \nAll tests must be non-static.\n \n\n\nRunning JUnit Tests in IntelliJ\n\n\nEven though methods includes many assert statements, only one failure is shown. This is because JUnit tests are short-circuiting \u2013 as soon as one of the asserts in a method fails, it will output the failure and move on to the next test.\n\n\n\n\nWrite a test BEFORE we write a method.\n\n\nDon\u2019t fill in the code for the actual method yet, just make it return null.\n\n\nWrite a method, and rerun the tests until it passes.\n\n\n\n\nPro tip: If you want to have your tests timeout after a certain amount of time (to prevent in\ufb01nite loops), you can declare your test like this: \n@Test\n(\ntimeout\n \n=\n \n1000\n)\n\n\nA Debugging Mystery\n\n\nAnother important skill to learn is how to exhaustively debug. When done properly, debugging should allow you to rapidly narrow down where a bug might be located, even when you are debugging code you don\u2019t fully understand.\n\n\nUsing any combination of the following techniques, figure out whether the bug is in Horrible Steve\u2019s code or in Flik enterprise\u2019s library:\n\n\n\n\nWriting JUnit tests for the Flik library.\n\n\nUsing the IntelliJ debugger, especially conditional breakpoints.\n\n\nUsing print statements.\n\n\nRefactoring Horrible Steve\u2019s code. Refactoring means changing the syntax without changing the functionality. This may be hard to do since HS\u2019s code uses lots of weird stuff.\n\n\n\n\nWe do not expect you to \ufb01x the bug or even understand why it\u2019s happening once you have found it. Instead, your job is simply to find the bug.\n\n\nTip: JUnit provides methods \nassertTrue(boolean)\n and \nassertTrue(String, boolean)\n that you might find helpful.\n\n\nRunning the 61B Style Checker\n\n\nWe will be using the CS 61B IntelliJ Plugin to check for style. \nofficial 61B style guide\n\n\nMy common mistake:\n\n\n\n\n',' is followed by whitespace.\n\n\nUsing trailing comments.", 
            "title": "Lab3: Unit Testing with JUnit, Debugging"
        }, 
        {
            "location": "/cs61b/Lab3/#lab-3-unit-testing-with-junit-debugging", 
            "text": "", 
            "title": "Lab 3: Unit Testing with JUnit, Debugging"
        }, 
        {
            "location": "/cs61b/Lab3/#1-introduction", 
            "text": "JUnit is a Unit Testing Framework for Java.  Unit Testing is a great way to rigorously test each method of your code and ultimately ensure that you have a working project.  The \u201cUnit\u201d part of Unit Testing comes from the idea that you can break your program down into units, or the smallest testable part of an application. Therefore, Unit Testing enforces good code structure (each method should only do \u201cOne Thing\u201d), and allows you to consider all of the edge cases for each method and test for them individually.", 
            "title": "1 Introduction"
        }, 
        {
            "location": "/cs61b/Lab3/#junit-syntax", 
            "text": "assertEquals  is a common method used in JUnit tests. It tests if a variable\u2019s actual value is equivalent to its expected value.    @Test  public   void   testMethod ()   { \n     assertEquals ( expected ,   actual );  }   When you create JUnit test files, you should precede each test method with a  @Test  annotation, and can have one or more  assertEquals  or  assertTrue  methods (provided by the JUnit library).  All tests must be non-static.", 
            "title": "JUnit Syntax"
        }, 
        {
            "location": "/cs61b/Lab3/#running-junit-tests-in-intellij", 
            "text": "Even though methods includes many assert statements, only one failure is shown. This is because JUnit tests are short-circuiting \u2013 as soon as one of the asserts in a method fails, it will output the failure and move on to the next test.   Write a test BEFORE we write a method.  Don\u2019t fill in the code for the actual method yet, just make it return null.  Write a method, and rerun the tests until it passes.   Pro tip: If you want to have your tests timeout after a certain amount of time (to prevent in\ufb01nite loops), you can declare your test like this:  @Test ( timeout   =   1000 )", 
            "title": "Running JUnit Tests in IntelliJ"
        }, 
        {
            "location": "/cs61b/Lab3/#a-debugging-mystery", 
            "text": "Another important skill to learn is how to exhaustively debug. When done properly, debugging should allow you to rapidly narrow down where a bug might be located, even when you are debugging code you don\u2019t fully understand.  Using any combination of the following techniques, figure out whether the bug is in Horrible Steve\u2019s code or in Flik enterprise\u2019s library:   Writing JUnit tests for the Flik library.  Using the IntelliJ debugger, especially conditional breakpoints.  Using print statements.  Refactoring Horrible Steve\u2019s code. Refactoring means changing the syntax without changing the functionality. This may be hard to do since HS\u2019s code uses lots of weird stuff.   We do not expect you to \ufb01x the bug or even understand why it\u2019s happening once you have found it. Instead, your job is simply to find the bug.  Tip: JUnit provides methods  assertTrue(boolean)  and  assertTrue(String, boolean)  that you might find helpful.", 
            "title": "A Debugging Mystery"
        }, 
        {
            "location": "/cs61b/Lab3/#running-the-61b-style-checker", 
            "text": "We will be using the CS 61B IntelliJ Plugin to check for style.  official 61B style guide  My common mistake:   ',' is followed by whitespace.  Using trailing comments.", 
            "title": "Running the 61B Style Checker"
        }, 
        {
            "location": "/mla/", 
            "text": "MLA\n\n\n\n\n\u673a\u5668\u5b66\u4e60\u57fa\u7840\n\n\nknn\n\n\n\u51b3\u7b56\u6811\n\n\n\u6734\u7d20\u8d1d\u53f6\u65af", 
            "title": "Contents"
        }, 
        {
            "location": "/mla/#mla", 
            "text": "\u673a\u5668\u5b66\u4e60\u57fa\u7840  knn  \u51b3\u7b56\u6811  \u6734\u7d20\u8d1d\u53f6\u65af", 
            "title": "MLA"
        }, 
        {
            "location": "/mla/ch1/", 
            "text": "\u673a\u5668\u5b66\u4e60\u5b9e\u6218 1 - \u673a\u5668\u5b66\u4e60\u57fa\u7840", 
            "title": "\u673a\u5668\u5b66\u4e60\u57fa\u7840"
        }, 
        {
            "location": "/mla/ch1/#1-", 
            "text": "", 
            "title": "\u673a\u5668\u5b66\u4e60\u5b9e\u6218 1 - \u673a\u5668\u5b66\u4e60\u57fa\u7840"
        }, 
        {
            "location": "/mla/ch2/", 
            "text": "\u673a\u5668\u5b66\u4e60\u5b9e\u6218 2 - k-\u8fd1\u90bb\u7b97\u6cd5", 
            "title": "knn"
        }, 
        {
            "location": "/mla/ch2/#2-k-", 
            "text": "", 
            "title": "\u673a\u5668\u5b66\u4e60\u5b9e\u6218 2 - k-\u8fd1\u90bb\u7b97\u6cd5"
        }, 
        {
            "location": "/mla/ch3/", 
            "text": "\u673a\u5668\u5b66\u4e60\u5b9e\u6218 3 - \u51b3\u7b56\u6811", 
            "title": "\u51b3\u7b56\u6811"
        }, 
        {
            "location": "/mla/ch3/#3-", 
            "text": "", 
            "title": "\u673a\u5668\u5b66\u4e60\u5b9e\u6218 3 - \u51b3\u7b56\u6811"
        }, 
        {
            "location": "/mla/ch4/", 
            "text": "\u673a\u5668\u5b66\u4e60\u5b9e\u6218 - \u6734\u7d20\u8d1d\u53f6\u65af", 
            "title": "\u6734\u7d20\u8d1d\u53f6\u65af"
        }, 
        {
            "location": "/mla/ch4/#-", 
            "text": "", 
            "title": "\u673a\u5668\u5b66\u4e60\u5b9e\u6218 - \u6734\u7d20\u8d1d\u53f6\u65af"
        }, 
        {
            "location": "/books/", 
            "text": "Books and Materials\n\n\nBooks\n\n\nThe following is the primary reading list of books. Each chapter is organized as a single page; the included sections are noted with major concepts, and summary.\n\n\nAlgorithm\n\n\n\n\nAlgorithm, 4th Edition\n\n\nby Robert Sedgewick and Kevin Wayne\n\n\nMaterials\n\n\nCS61B\n\n\nCS61B Data Structures, Berkeley\n\n\nInstructor: Josh Hug", 
            "title": "Books"
        }, 
        {
            "location": "/books/#books-and-materials", 
            "text": "", 
            "title": "Books and Materials"
        }, 
        {
            "location": "/books/#books", 
            "text": "The following is the primary reading list of books. Each chapter is organized as a single page; the included sections are noted with major concepts, and summary.", 
            "title": "Books"
        }, 
        {
            "location": "/books/#algorithm", 
            "text": "Algorithm, 4th Edition  by Robert Sedgewick and Kevin Wayne", 
            "title": "Algorithm"
        }, 
        {
            "location": "/books/#materials", 
            "text": "", 
            "title": "Materials"
        }, 
        {
            "location": "/books/#cs61b", 
            "text": "CS61B Data Structures, Berkeley  Instructor: Josh Hug", 
            "title": "CS61B"
        }
    ]
}