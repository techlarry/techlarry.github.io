{
    "docs": [
        {
            "location": "/algorithm/ch1/", 
            "text": "Chapter 1: Union Find\n\n\n1 Dynamic Connectivity\n\n\nDynamic connectivity is a data structure that dynamically maintains information about the connected components of a graph.\n\n\nConnected components\n:  Maximal set of objects that are mutually connected.\n\n\n\n\nUnion-Find data type (API)\n\n\nUnion-Find API:\n\n\n\n\nthe \nunion()\n operation merges two components if the two sites are in different components.\n\n\nthe \nfind()\n operation returns an integer component identifier for a given site.\n\n\nthe \nconnected()\n operation determines whether two sites are in the same component.\n\n\nthe \ncount()\n method returns the number of components.\n\n\n\n\n\n\n \npublic\n \nclass\n \nQuickFind\n \n{\n\n    \nprivate\n \nint\n[]\n \nid\n;\n\n    \nprivate\n \nint\n \ncount\n;\n\n\n    \npublic\n \nQuickFind\n(\nint\n \nN\n)\n \n{\n\n        \ncount\n \n=\n \nN\n;\n\n        \nid\n \n=\n \nnew\n \nint\n[\nN\n];\n\n        \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nN\n;\n \ni\n++)\n \nid\n[\ni\n]\n \n=\n \ni\n;\n\n    \n}\n\n\n    \npublic\n \nboolean\n \nconnected\n(\nint\n \np\n,\n \nint\n \nq\n)\n \n{\n\n        \nreturn\n \nid\n[\np\n]\n \n==\n \nid\n[\nq\n];\n\n    \n}\n\n\n    \npublic\n \nint\n \nfind\n(\nint\n \np\n)\n \n{\n\n        \nreturn\n \nid\n[\np\n];\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nunion\n(\nint\n \np\n,\n \nint\n \nq\n)\n \n{\n\n        \n// Put p and q into the same component.\n\n        \nint\n \npid\n \n=\n \nfind\n(\np\n);\n\n        \nint\n \nqid\n \n=\n \nfind\n(\nq\n);\n\n        \n// Nothing to do if p and q are already in the same component.\n\n        \nif\n \n(\npid\n \n==\n \nqid\n)\n \nreturn\n;\n\n\n        \n// Rename p\u2019s component to q\u2019s name.\n\n        \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nid\n.\nlength\n;\n \ni\n++)\n\n            \nif\n \n(\nid\n[\ni\n]\n \n==\n \npid\n)\n\n                \nid\n[\ni\n]\n \n=\n \nqid\n;\n\n        \ncount\n--;\n\n    \n}\n\n\n}\n\n\n\n\nDynamic-connectivity client\n\n\nRead in number of objects \nN\nN\n from standard input. Repeat:\n\n\n\n\nread in pair of integers from standard input\n\n\nif they are not yet connected, connect them and print out pair\n\n\n\n\nWe shall consider several different implementations, all based on using the site-indexed id[] array, to determine whether two sites are in the same connected component.\n\n\n2 Quick-Find\n\n\nQuick-find idea: all sites in a component must have the same value in id[]. \n\n\nThis method is called quick-find because \nfind(p)\n just returns id[p], which immediately implies that \nconnected(p, q)\n reduces to just the test id[p] == id[q] and returns \ntrue\n, if and only if p and q are in the same component.\n\n\nUnion()\n: To combine the two components into one, we have to make all of the id[] entries corresponding to both sets of sites the same value. To do so, we go through the array, changing all the entries with values equal to id[p] to the value id[q].\n\n\n \npublic\n \nclass\n \nQuickFind\n \n{\n\n    \nprivate\n \nint\n[]\n \nid\n;\n\n\n    \npublic\n \nQuickFind\n(\nint\n \nN\n)\n \n{\n\n        \nid\n \n=\n \nnew\n \nint\n[\nN\n];\n\n        \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nN\n;\n \ni\n++)\n \nid\n[\ni\n]\n \n=\n \ni\n;\n\n    \n}\n\n\n    \npublic\n \nboolean\n \nconnected\n(\nint\n \np\n,\n \nint\n \nq\n)\n \n{\n\n        \nreturn\n \nid\n[\np\n]\n \n==\n \nid\n[\nq\n];\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nunion\n(\nint\n \np\n,\n \nint\n \nq\n)\n \n{\n\n        \nint\n \npid\n \n=\n \nid\n[\np\n];\n\n        \nint\n \nqid\n \n=\n \nid\n[\nq\n];\n\n        \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nid\n.\nlength\n;\n \ni\n++)\n \nif\n \n(\nid\n[\ni\n]\n \n==\n \npid\n)\n \nid\n[\ni\n]\n \n=\n \nqid\n;\n\n    \n}\n\n\n\n}\n\n\n\n\nAnalysis\n\n\nThe quick-find algorithm uses one array access for each call to \nfind()\n and between \nN + 3\nN + 3\n and \n2N + 1\n2N + 1\n array accesses for each call to \nunion()\n that combines two components.\n\n\nWORST CASE: suppose we wind up with a single component. This requires at least \nN-1\nN-1\n calls to \nunion()\n, and, consequently, at least \n(N+3)(N-1) \\sim N^2\n(N+3)(N-1) \\sim N^2\n array accesses\u2014we are led immediately to the hypothesis that dynamic connectivity with quick-find can be a quadratic-time process.\n\n\n3 Quick-Union\n\n\nData structure:\n\n\n\n\nInterpretation: id[i] is parent of i. \n\n\nRoot of i is id[id[id[...id[i]...]]] (keep going until it doesn\u2019t change)\n\n\n\n\nSpecifically, the id[] entry, for each site is the name of another site in the same component (possibly itself)\u2014we refer to this connection as a link. To implement \nfind()\n, we start at the given site, follow its link to another site, follow that site\u2019s link to yet another site, and so forth, following links until reaching a root, a site that has a link to itself. Two sites are in the same component if and only if this process leads them to the same root.\n\n\nunion(p, q)\n: we follow links to finds the roots associated with p and q, then rename one of the components by linking one of these roots to the other; hence the name quick-union.\n\n\n\n\n \npublic\n \nclass\n \nQuickUnion\n \n{\n\n    \nprivate\n \nint\n[]\n \nid\n;\n\n    \nprivate\n \nint\n \ncount\n;\n\n\n    \npublic\n \nQuickUnion\n(\nint\n \nN\n)\n \n{\n\n        \ncount\n \n=\n \nN\n;\n\n        \nid\n \n=\n \nnew\n \nint\n[\nN\n];\n\n        \n// set id of each object to itself (N array accesses)\n\n        \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nN\n;\n \ni\n++)\n \nid\n[\ni\n]\n \n=\n \ni\n;\n\n    \n}\n\n\n    \nprivate\n \nint\n \nfind\n(\nint\n \np\n)\n \n{\n\n        \n// chase parent pointers until reach root\n\n        \nwhile\n \n(\np\n \n!=\n \nid\n[\np\n])\n \np\n \n=\n \nid\n[\np\n];\n\n        \nreturn\n \np\n;\n\n\n    \n}\n\n\n    \npublic\n \nboolean\n \nconnected\n(\nint\n \np\n,\n \nint\n \nq\n)\n \n{\n\n        \n//check if p and q have same root\n\n        \nreturn\n \nfind\n(\np\n)\n \n==\n \nfind\n(\nq\n);\n\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nunion\n(\nint\n \np\n,\n \nint\n \nq\n)\n \n{\n\n        \n// change root of p to point to root of q\n\n        \nint\n \ni\n \n=\n \nfind\n(\np\n);\n\n        \nint\n \nj\n \n=\n \nfind\n(\nq\n);\n\n        \nid\n[\ni\n]\n \n=\n \nj\n;\n\n        \ncount\n--;\n\n    \n}\n\n\n\n}\n\n\n\n\nAnalysis\n\n\nThe number of array accesses used by \nfind()\n in quick-union is 1 plus the twice the depth of the node corresponding to the given site. The number of array accesses used by \nunion()\n and \nconnected()\n is the cost of the two \nfind()\n operations (plus 1 for \nunion()\n if the given sites are in different trees).\n\n\nWORST CASE: suppose we wind up with a single component, the running time is quadratic\n\n\n4 Improvement 1: weighting\n\n\nWeighted quick-union\n: Rather than arbitrarily connecting the second tree to the first for \nunion()\n, we keep track of the size of each tree and always c\nonnect the smaller tree to the larger\n. This change needs another array to hold the node counts.\n\n\n\n\n \npublic\n \nclass\n \nWeightedQuickUnion\n \n{\n\n\n    \nprivate\n \nint\n[]\n \nid\n;\n \n// parent link (site indexed)\n\n    \nprivate\n \nint\n[]\n \nsz\n;\n \n// size of component for roots (site indexed)\n\n    \nprivate\n \nint\n \ncount\n;\n \n// number of components\n\n\n    \npublic\n \nWeightedQuickUnion\n(\nint\n \nN\n)\n \n{\n\n        \ncount\n \n=\n \nN\n;\n\n        \nid\n \n=\n \nnew\n \nint\n[\nN\n];\n\n        \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nN\n;\n \ni\n++)\n \nid\n[\ni\n]\n \n=\n \ni\n;\n\n        \nsz\n \n=\n \nnew\n \nint\n[\nN\n];\n\n        \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nN\n;\n \ni\n++)\n \nsz\n[\ni\n]\n \n=\n \n1\n;\n\n    \n}\n\n\n    \npublic\n \nint\n \ncount\n()\n \n{\n\n        \nreturn\n \ncount\n;\n\n    \n}\n\n\n    \npublic\n \nboolean\n \nconnected\n(\nint\n \np\n,\n \nint\n \nq\n)\n \n{\n\n        \nreturn\n \nfind\n(\np\n)\n \n==\n \nfind\n(\nq\n);\n\n    \n}\n\n\n    \nprivate\n \nint\n \nfind\n(\nint\n \np\n)\n \n{\n \n// Follow links to find a root.\n\n\n        \nwhile\n \n(\np\n \n!=\n \nid\n[\np\n])\n \np\n \n=\n \nid\n[\np\n];\n\n        \nreturn\n \np\n;\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nunion\n(\nint\n \np\n,\n \nint\n \nq\n)\n \n{\n\n        \nint\n \ni\n \n=\n \nfind\n(\np\n);\n\n        \nint\n \nj\n \n=\n \nfind\n(\nq\n);\n\n        \nif\n \n(\ni\n \n==\n \nj\n)\n \nreturn\n;\n\n        \n// Make smaller root point to larger one.\n\n        \nif\n \n(\nsz\n[\ni\n]\n \n \nsz\n[\nj\n])\n \n{\n\n            \nid\n[\ni\n]\n \n=\n \nj\n;\n\n            \nsz\n[\nj\n]\n \n+=\n \nsz\n[\ni\n];\n\n        \n}\n \nelse\n \n{\n\n            \nid\n[\nj\n]\n \n=\n \ni\n;\n\n            \nsz\n[\ni\n]\n \n+=\n \nsz\n[\nj\n];\n\n        \n}\n\n        \ncount\n--;\n\n    \n}\n\n\n\n}\n\n\n\n\nAnalysis\n\n\nThe depth of any node in a forest built by weighted quick-union for \nN\nN\n sites is at most \n\\log N\n\\log N\n.\n\n\nThe worst case for weighted quick union is when the sizes of the trees to be merged by \nunion()\n are always equal (and a power of 2). And they have the simple property that the height of a tree of \n2^n\n2^n\n nodes is \nn\nn\n.\n\n\n\n\nFor weighted quick-union with \nN\nN\n sites, the worst-case order of growth of the cost of \nfind()\n, \nconnected()\n, and \nunion()\n is \n\\log N\n\\log N\n.\n\n\nSpecifically, the weighted quick-union algorithm uses at most \ncM\\log N\ncM\\log N\n array accesses to process \nM\nM\n connections among \nN\nN\n sites for a small constant \nc\nc\n.\n\n\n5 Improvement 2: path compression\n\n\nIDEA: Just after computing the root of p, set the id of each examined node to point to that root.\n\n\nTwo-pass implementation: add second loop to \nfind()\n to set the id[] of each examined node to the root.\n\n\nSimpler one-pass variant: Make every other node in path point to its grandparent (thereby halving path length).\n\n\n \nprivate\n \nint\n \nfind\n(\nint\n \np\n)\n \n{\n \n// Follow links to find a root.\n\n    \nwhile\n \n(\np\n \n!=\n \nid\n[\np\n])\n \n{\n\n        \n// only one extra line of code !\n\n        \nid\n[\np\n]\n \n=\n \nid\n[\nid\n[\np\n]];\n\n        \np\n \n=\n \nid\n[\np\n];\n\n    \n}\n\n    \nreturn\n \np\n;\n\n\n}\n\n\n\n\nAmortized Analysis\n\n\nStarting from an empty data structure, any sequence of \nM\nM\n union-find ops on \nN\nN\n objects makes \n\\le c ( N + M \\lg^*N )\n\\le c ( N + M \\lg^*N )\n array accesses, where \nlg^*\nlg^*\n is iterated logarithm[\nwiki\n]. (\nlg^*N\nlg^*N\n\u8868\u793a\u5c06\nN\nN\n\u53d8\u4e3a\u5c0f\u4e8e1\u9700\u8981\u7684\n\\log\n\\log\n\u8fed\u4ee3\u6b21\u6570)\n\n\nApplication - Percolation", 
            "title": "Chapter 1: Fundamentals "
        }, 
        {
            "location": "/algorithm/ch1/#chapter-1-union-find", 
            "text": "", 
            "title": "Chapter 1: Union Find"
        }, 
        {
            "location": "/algorithm/ch1/#1-dynamic-connectivity", 
            "text": "Dynamic connectivity is a data structure that dynamically maintains information about the connected components of a graph.  Connected components :  Maximal set of objects that are mutually connected.", 
            "title": "1 Dynamic Connectivity"
        }, 
        {
            "location": "/algorithm/ch1/#union-find-data-type-api", 
            "text": "Union-Find API:   the  union()  operation merges two components if the two sites are in different components.  the  find()  operation returns an integer component identifier for a given site.  the  connected()  operation determines whether two sites are in the same component.  the  count()  method returns the number of components.      public   class   QuickFind   { \n     private   int []   id ; \n     private   int   count ; \n\n     public   QuickFind ( int   N )   { \n         count   =   N ; \n         id   =   new   int [ N ]; \n         for   ( int   i   =   0 ;   i     N ;   i ++)   id [ i ]   =   i ; \n     } \n\n     public   boolean   connected ( int   p ,   int   q )   { \n         return   id [ p ]   ==   id [ q ]; \n     } \n\n     public   int   find ( int   p )   { \n         return   id [ p ]; \n     } \n\n     public   void   union ( int   p ,   int   q )   { \n         // Put p and q into the same component. \n         int   pid   =   find ( p ); \n         int   qid   =   find ( q ); \n         // Nothing to do if p and q are already in the same component. \n         if   ( pid   ==   qid )   return ; \n\n         // Rename p\u2019s component to q\u2019s name. \n         for   ( int   i   =   0 ;   i     id . length ;   i ++) \n             if   ( id [ i ]   ==   pid ) \n                 id [ i ]   =   qid ; \n         count --; \n     }  }", 
            "title": "Union-Find data type (API)"
        }, 
        {
            "location": "/algorithm/ch1/#dynamic-connectivity-client", 
            "text": "Read in number of objects  N N  from standard input. Repeat:   read in pair of integers from standard input  if they are not yet connected, connect them and print out pair   We shall consider several different implementations, all based on using the site-indexed id[] array, to determine whether two sites are in the same connected component.", 
            "title": "Dynamic-connectivity client"
        }, 
        {
            "location": "/algorithm/ch1/#2-quick-find", 
            "text": "Quick-find idea: all sites in a component must have the same value in id[].   This method is called quick-find because  find(p)  just returns id[p], which immediately implies that  connected(p, q)  reduces to just the test id[p] == id[q] and returns  true , if and only if p and q are in the same component.  Union() : To combine the two components into one, we have to make all of the id[] entries corresponding to both sets of sites the same value. To do so, we go through the array, changing all the entries with values equal to id[p] to the value id[q].    public   class   QuickFind   { \n     private   int []   id ; \n\n     public   QuickFind ( int   N )   { \n         id   =   new   int [ N ]; \n         for   ( int   i   =   0 ;   i     N ;   i ++)   id [ i ]   =   i ; \n     } \n\n     public   boolean   connected ( int   p ,   int   q )   { \n         return   id [ p ]   ==   id [ q ]; \n     } \n\n     public   void   union ( int   p ,   int   q )   { \n         int   pid   =   id [ p ]; \n         int   qid   =   id [ q ]; \n         for   ( int   i   =   0 ;   i     id . length ;   i ++)   if   ( id [ i ]   ==   pid )   id [ i ]   =   qid ; \n     }  }", 
            "title": "2 Quick-Find"
        }, 
        {
            "location": "/algorithm/ch1/#analysis", 
            "text": "The quick-find algorithm uses one array access for each call to  find()  and between  N + 3 N + 3  and  2N + 1 2N + 1  array accesses for each call to  union()  that combines two components.  WORST CASE: suppose we wind up with a single component. This requires at least  N-1 N-1  calls to  union() , and, consequently, at least  (N+3)(N-1) \\sim N^2 (N+3)(N-1) \\sim N^2  array accesses\u2014we are led immediately to the hypothesis that dynamic connectivity with quick-find can be a quadratic-time process.", 
            "title": "Analysis"
        }, 
        {
            "location": "/algorithm/ch1/#3-quick-union", 
            "text": "Data structure:   Interpretation: id[i] is parent of i.   Root of i is id[id[id[...id[i]...]]] (keep going until it doesn\u2019t change)   Specifically, the id[] entry, for each site is the name of another site in the same component (possibly itself)\u2014we refer to this connection as a link. To implement  find() , we start at the given site, follow its link to another site, follow that site\u2019s link to yet another site, and so forth, following links until reaching a root, a site that has a link to itself. Two sites are in the same component if and only if this process leads them to the same root.  union(p, q) : we follow links to finds the roots associated with p and q, then rename one of the components by linking one of these roots to the other; hence the name quick-union.     public   class   QuickUnion   { \n     private   int []   id ; \n     private   int   count ; \n\n     public   QuickUnion ( int   N )   { \n         count   =   N ; \n         id   =   new   int [ N ]; \n         // set id of each object to itself (N array accesses) \n         for   ( int   i   =   0 ;   i     N ;   i ++)   id [ i ]   =   i ; \n     } \n\n     private   int   find ( int   p )   { \n         // chase parent pointers until reach root \n         while   ( p   !=   id [ p ])   p   =   id [ p ]; \n         return   p ; \n\n     } \n\n     public   boolean   connected ( int   p ,   int   q )   { \n         //check if p and q have same root \n         return   find ( p )   ==   find ( q ); \n\n     } \n\n     public   void   union ( int   p ,   int   q )   { \n         // change root of p to point to root of q \n         int   i   =   find ( p ); \n         int   j   =   find ( q ); \n         id [ i ]   =   j ; \n         count --; \n     }  }", 
            "title": "3 Quick-Union"
        }, 
        {
            "location": "/algorithm/ch1/#analysis_1", 
            "text": "The number of array accesses used by  find()  in quick-union is 1 plus the twice the depth of the node corresponding to the given site. The number of array accesses used by  union()  and  connected()  is the cost of the two  find()  operations (plus 1 for  union()  if the given sites are in different trees).  WORST CASE: suppose we wind up with a single component, the running time is quadratic", 
            "title": "Analysis"
        }, 
        {
            "location": "/algorithm/ch1/#4-improvement-1-weighting", 
            "text": "Weighted quick-union : Rather than arbitrarily connecting the second tree to the first for  union() , we keep track of the size of each tree and always c onnect the smaller tree to the larger . This change needs another array to hold the node counts.     public   class   WeightedQuickUnion   { \n\n     private   int []   id ;   // parent link (site indexed) \n     private   int []   sz ;   // size of component for roots (site indexed) \n     private   int   count ;   // number of components \n\n     public   WeightedQuickUnion ( int   N )   { \n         count   =   N ; \n         id   =   new   int [ N ]; \n         for   ( int   i   =   0 ;   i     N ;   i ++)   id [ i ]   =   i ; \n         sz   =   new   int [ N ]; \n         for   ( int   i   =   0 ;   i     N ;   i ++)   sz [ i ]   =   1 ; \n     } \n\n     public   int   count ()   { \n         return   count ; \n     } \n\n     public   boolean   connected ( int   p ,   int   q )   { \n         return   find ( p )   ==   find ( q ); \n     } \n\n     private   int   find ( int   p )   {   // Follow links to find a root. \n\n         while   ( p   !=   id [ p ])   p   =   id [ p ]; \n         return   p ; \n     } \n\n     public   void   union ( int   p ,   int   q )   { \n         int   i   =   find ( p ); \n         int   j   =   find ( q ); \n         if   ( i   ==   j )   return ; \n         // Make smaller root point to larger one. \n         if   ( sz [ i ]     sz [ j ])   { \n             id [ i ]   =   j ; \n             sz [ j ]   +=   sz [ i ]; \n         }   else   { \n             id [ j ]   =   i ; \n             sz [ i ]   +=   sz [ j ]; \n         } \n         count --; \n     }  }", 
            "title": "4 Improvement 1: weighting"
        }, 
        {
            "location": "/algorithm/ch1/#analysis_2", 
            "text": "The depth of any node in a forest built by weighted quick-union for  N N  sites is at most  \\log N \\log N .  The worst case for weighted quick union is when the sizes of the trees to be merged by  union()  are always equal (and a power of 2). And they have the simple property that the height of a tree of  2^n 2^n  nodes is  n n .   For weighted quick-union with  N N  sites, the worst-case order of growth of the cost of  find() ,  connected() , and  union()  is  \\log N \\log N .  Specifically, the weighted quick-union algorithm uses at most  cM\\log N cM\\log N  array accesses to process  M M  connections among  N N  sites for a small constant  c c .", 
            "title": "Analysis"
        }, 
        {
            "location": "/algorithm/ch1/#5-improvement-2-path-compression", 
            "text": "IDEA: Just after computing the root of p, set the id of each examined node to point to that root.  Two-pass implementation: add second loop to  find()  to set the id[] of each examined node to the root.  Simpler one-pass variant: Make every other node in path point to its grandparent (thereby halving path length).    private   int   find ( int   p )   {   // Follow links to find a root. \n     while   ( p   !=   id [ p ])   { \n         // only one extra line of code ! \n         id [ p ]   =   id [ id [ p ]]; \n         p   =   id [ p ]; \n     } \n     return   p ;  }", 
            "title": "5 Improvement 2: path compression"
        }, 
        {
            "location": "/algorithm/ch1/#amortized-analysis", 
            "text": "Starting from an empty data structure, any sequence of  M M  union-find ops on  N N  objects makes  \\le c ( N + M \\lg^*N ) \\le c ( N + M \\lg^*N )  array accesses, where  lg^* lg^*  is iterated logarithm[ wiki ]. ( lg^*N lg^*N \u8868\u793a\u5c06 N N \u53d8\u4e3a\u5c0f\u4e8e1\u9700\u8981\u7684 \\log \\log \u8fed\u4ee3\u6b21\u6570)", 
            "title": "Amortized Analysis"
        }, 
        {
            "location": "/algorithm/ch1/#application-percolation", 
            "text": "", 
            "title": "Application - Percolation"
        }
    ]
}