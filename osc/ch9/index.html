<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Zhenhua Wang">
        <link rel="canonical" href="http://larryim.cc/note/osc/ch9/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Chapter 9: Main Memory - Zhenhua's Notes</title>
        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../extra_css/custom.css" rel="stylesheet">
        <link href="../../extra_css/custom.js" rel="stylesheet">
        <link href="../../extra_css/friendly.css" rel="stylesheet">
        <link href="../../extra_css/theme.css" rel="stylesheet">
        <link href="../../extra_css/mkdocs/js/lunr-0.5.7.min.js" rel="stylesheet">
        <link href="../../extra_css/mkdocs/js/mustache.min.js" rel="stylesheet">
        <link href="../../extra_css/mkdocs/js/require.js" rel="stylesheet">
        <link href="../../extra_css/mkdocs/js/search.js" rel="stylesheet">
        <link href="../../extra_css/mkdocs/js/text.js" rel="stylesheet">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../..">Zhenhua's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="../..">Home</a>
                    </li>
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">OSC <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../">Contents</a>
</li>
                            
<li >
    <a href="../ch1/">Chapter 1: Introduction </a>
</li>
                            
<li >
    <a href="../ch2/">Chapter 2: Operating System structures</a>
</li>
                            
<li >
    <a href="../ch3/">Chapter 3: Processes</a>
</li>
                            
<li >
    <a href="../ch4/">Chapter 4: Threads and Concurrency</a>
</li>
                            
<li >
    <a href="../ch5/">Chapter 5: CPU Scheduling</a>
</li>
                            
<li >
    <a href="../ch6/">Chapter 6: Synchronization Tools</a>
</li>
                            
<li >
    <a href="../ch7/">Chapter 7: Synchronization Examples</a>
</li>
                            
<li >
    <a href="../ch8/">Chapter 8: Deadlocks</a>
</li>
                            
<li class="active">
    <a href="./">Chapter 9: Main Memory</a>
</li>
                            
<li >
    <a href="../ch10/">Chapter 10: Virtual Memory</a>
</li>
                            
<li >
    <a href="../ch13/">Chapter 13: File-System Interfaces</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSAPP <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../csapp/">Contents</a>
</li>
                            
<li >
    <a href="../../csapp/ch1/">Chapter 1: 计算机系统漫游</a>
</li>
                            
<li >
    <a href="../../csapp/ch2/">Chapter 2: 信息的表示和处理</a>
</li>
                            
<li >
    <a href="../../csapp/ch3/">Chapter 3: 程序的机器级表示</a>
</li>
                            
<li >
    <a href="../../csapp/ch4/">Chapter 4: 处理器体系结构</a>
</li>
                            
<li >
    <a href="../../csapp/ch5/">Chapter 5: 优化程序性能</a>
</li>
                            
<li >
    <a href="../../csapp/ch6/">Chapter 6: 存储器层次结构</a>
</li>
                            
<li >
    <a href="../../csapp/ch7/">Chapter 7: 链接</a>
</li>
                            
<li >
    <a href="../../csapp/ch8/">Chapter 8: 异常控制流</a>
</li>
                            
<li >
    <a href="../../csapp/ch9/">Chapter 9: 虚拟内存</a>
</li>
                            
<li >
    <a href="../../csapp/ch10/">Chapter 10: 系统级I/O</a>
</li>
                            
<li >
    <a href="../../csapp/ch11/">Chapter 11: 网络编程</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">HFJ <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../hfj/">Contents</a>
</li>
                            
<li >
    <a href="../../hfj/ch1/">Chapter 1: Dive in A Quick Dip</a>
</li>
                            
<li >
    <a href="../../hfj/ch2/">Chapter 2: Classes and Objects</a>
</li>
                            
<li >
    <a href="../../hfj/ch3/">Chapter 3: Primitives and References</a>
</li>
                            
<li >
    <a href="../../hfj/ch4/">Chapter 4: Methods use Instance Variables</a>
</li>
                            
<li >
    <a href="../../hfj/ch5/">Chapter 5: Writing a Program</a>
</li>
                            
<li >
    <a href="../../hfj/ch6/">Chapter 6: Get to Know the Java API</a>
</li>
                            
<li >
    <a href="../../hfj/ch7/">Chapter 7: Inheritance and Polymorphism</a>
</li>
                            
<li >
    <a href="../../hfj/ch8/">Chapter 8: Interfaces and Abstract Classes</a>
</li>
                            
<li >
    <a href="../../hfj/ch9/">Chapter 9: Constructors and Garbage Collection</a>
</li>
                            
<li >
    <a href="../../hfj/ch10/">Chapter 10: Numbers and Statics</a>
</li>
                            
<li >
    <a href="../../hfj/ch11/">Chapter 11: Exception Handling</a>
</li>
                            
<li >
    <a href="../../hfj/ch12/">Chapter 12: Getting GUI</a>
</li>
                            
<li >
    <a href="../../hfj/ch13/">Chapter 13: Using Swing</a>
</li>
                            
<li >
    <a href="../../hfj/ch14/">Chapter 14: Serialization and File I/O</a>
</li>
                            
<li >
    <a href="../../hfj/ch15/">Chapter 15: Networking and Threads</a>
</li>
                            
<li >
    <a href="../../hfj/ch16/">Chapter 16: Collections and Generics</a>
</li>
                            
<li >
    <a href="../../hfj/ch17/">Chapter 17: Packages, Jars and Deployment</a>
</li>
                            
<li >
    <a href="../../hfj/ch18/">Chapter 18: Remote deploy with RMI</a>
</li>
                        </ul>
                    </li>
                    <li >
                        <a href="../../books/">Books</a>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="../ch8/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../ch10/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#operating-system-concepts-9-main-memory">Operating System Concepts 9 - Main Memory</a></li>
        <li class="main "><a href="#1-background">1 Background</a></li>
            <li><a href="#basic-hardware">Basic Hardware</a></li>
            <li><a href="#address-binding">Address Binding</a></li>
            <li><a href="#logical-versus-physical-address-space">Logical Versus Physical Address Space</a></li>
            <li><a href="#dynamic-loading">Dynamic Loading</a></li>
            <li><a href="#dynamic-linking-and-shared-libraries">Dynamic Linking and Shared Libraries</a></li>
        <li class="main "><a href="#2-contiguous-memory-allocation">2 Contiguous Memory Allocation</a></li>
            <li><a href="#memory-protection">Memory Protection</a></li>
            <li><a href="#memory-allocation">Memory Allocation</a></li>
            <li><a href="#fragmentation">Fragmentation</a></li>
        <li class="main "><a href="#3-paging">3 Paging</a></li>
            <li><a href="#basic-method">Basic Method</a></li>
            <li><a href="#hardware-suport">Hardware Suport</a></li>
            <li><a href="#protection">Protection</a></li>
            <li><a href="#shared-pages">Shared Pages</a></li>
        <li class="main "><a href="#4-structure-of-the-page-table">4 Structure of the Page Table</a></li>
            <li><a href="#hierarchical-paging">Hierarchical Paging</a></li>
            <li><a href="#hashed-page-tables">Hashed Page Tables</a></li>
            <li><a href="#inverted-page-tables">Inverted Page Tables</a></li>
        <li class="main "><a href="#5-swapping">5 Swapping</a></li>
            <li><a href="#standard-swapping">Standard Swapping</a></li>
            <li><a href="#swapping-with-paging">Swapping with paging</a></li>
            <li><a href="#swapping-on-mobile-systems">Swapping on Mobile Systems</a></li>
        <li class="main "><a href="#6-example-intel-64-bit-architectures">6 Example: Intel 64-bit Architectures</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h3 id="operating-system-concepts-9-main-memory"><strong>Operating System Concepts 9 - Main Memory</strong><a class="headerlink" href="#operating-system-concepts-9-main-memory" title="Permanent link">&para;</a></h3>
<h3 id="1-background">1 Background<a class="headerlink" href="#1-background" title="Permanent link">&para;</a></h3>
<h4 id="basic-hardware">Basic Hardware<a class="headerlink" href="#basic-hardware" title="Permanent link">&para;</a></h4>
<p>Main memory and the registers built into each processing core are the only general-purpose storage that the CPU can access directly.</p>
<p>Registers that are built into each CPU core are generally accessible within one cycle of the CPU clock. Completing a memory access may take hundreds cycles of the CPU clock. In such cases, the processor normally needs to stall. The remedy is to add cache between the CPU and main memory for fast access.</p>
<p>Approximate timing for various operations on a typical PC:</p>
<table>
<thead>
<tr>
<th>operations</th>
<th>approximate timing</th>
</tr>
</thead>
<tbody>
<tr>
<td>execute typical instruction</td>
<td>1/1,000,000,000 sec = 1 nanosec</td>
</tr>
<tr>
<td>fetch from L1 cache memory</td>
<td>0.5 nanosec</td>
</tr>
<tr>
<td>branch misprediction</td>
<td>5 nanosec</td>
</tr>
<tr>
<td>fetch from L2 cache memory</td>
<td>7 nanosec</td>
</tr>
<tr>
<td>Mutex lock/unlock</td>
<td>25 nanosec</td>
</tr>
<tr>
<td>fetch from main memory</td>
<td>100 nanosec</td>
</tr>
<tr>
<td>send 2K bytes over 1Gbps network</td>
<td>20,000 nanosec</td>
</tr>
<tr>
<td>read 1MB sequentially from memory</td>
<td>250,000 nanosec</td>
</tr>
<tr>
<td>fetch from new disk location (seek)</td>
<td>8,000,000 nanosec</td>
</tr>
<tr>
<td>read 1MB sequentially from disk</td>
<td>20,000,000 nanosec</td>
</tr>
<tr>
<td>send packet US to Europe and back</td>
<td>150 milliseconds = 150,000,000 nanosec</td>
</tr>
</tbody>
</table>
<p>We also must protect the operating system from access by user processes, as well as protect user processes from one another.</p>
<ul>
<li>This protection must be provided by the hardware, because the operating system doesn't usually intervene between the CPU and its memory access.</li>
<li>Hardware implements this production in several different ways.</li>
</ul>
<p>We first need to make sure that each process have a separate memory space.</p>
<ul>
<li>Separate per-process memory space protects the processes from each other and is fundamental to having multiple processes loading in memory for concurrent execution.</li>
<li>To separate memory spaces, we need the ability to determine the range of legal addresses that the process may access and to ensure that the process can access only these legal addresses.</li>
<li>We can provide this protection by using two registers, usually a base and a limit. The <strong>base register</strong> holds the smallest legal physical memory address; the <strong>limit register</strong> specifies the size of the range.</li>
<li>The base and limit registers can be loaded only by the operating system, which uses a special privileged instruction.</li>
</ul>
<p><img alt="A base and a limit register define a logical address space." src="../figures/A%20base%20and%20a%20limit%20register%20define%20a%20logical%20address%20space..png" /></p>
<p>Any attempt by a program executing in user mode to access operating-system memory or other users’ memory results in a trap to the operating system, which treats the attempt as a fatal error.</p>
<p><img alt="Hardware address protection with base and limit registers." src="../figures/Hardware%20address%20protection%20with%20base%20and%20limit%20registers..png" /></p>
<h4 id="address-binding">Address Binding<a class="headerlink" href="#address-binding" title="Permanent link">&para;</a></h4>
<p>In most cases, a user program goes through several steps. Addresses may be represented in different ways during these steps.</p>
<ul>
<li>Addresses in the source program are generally symbolic(符号).</li>
<li>A compiler typically <em>binds</em> these symbolic addresses to relocatable addresses(可重定位地址).</li>
<li>The linker or loader <em>binds</em> the relocatable addresses to absolute addresses(绝对地址)。</li>
</ul>
<p><img alt="Multistep processing of a user progra" src="../figures/Multistep%20processing%20of%20a%20user%20program.png" /></p>
<h4 id="logical-versus-physical-address-space">Logical Versus Physical Address Space<a class="headerlink" href="#logical-versus-physical-address-space" title="Permanent link">&para;</a></h4>
<p>An address generated by the CPU is commonly referred to as a <strong>logical address</strong>(逻辑地址), whereas an address loaded into <em>memory-address register</em> (MAR) of the memory is commonly referred to as a <strong>physical address</strong>(物理地址).</p>
<ul>
<li>We usually refer to the logical address as a <strong>virtual address</strong>(虚拟地址).</li>
<li>The run-time mapping from virtual to physical addresses is done by a hardware device called the <strong>memory-management unit</strong> (MMU，内存管理单元).</li>
<li>Note: <em>Program counter</em> points to the next instruction to be fetched/executed , whereas <em>memory address register</em> points to the memory location that contains data required (not an instruction).[<a href="https://stackoverflow.com/questions/10876372/difference-between-memory-address-registermar-and-program-counterpc">ref</a>]</li>
</ul>
<h4 id="dynamic-loading">Dynamic Loading<a class="headerlink" href="#dynamic-loading" title="Permanent link">&para;</a></h4>
<p>With <strong>dynamic loading</strong>(动态加载), a routine is not loaded until it is called.</p>
<ul>
<li>All routines are kept on disk in a relocatable load format. </li>
<li>
<p>The main program is loaded into memory and is executed. When a routine needs to call another routine, the calling routine first checks to see whether the other routine has been loaded. If it has not, the relocatable linking loader is called to load the desired routine into memory and to update the program’s address tables to reflect this change. Then control is passed to the newly loaded routine.</p>
</li>
<li>
<p>The advantage of dynamic loading is that a routine is loaded only when it is needed.</p>
</li>
<li>This method is particularly useful when <em>large</em> amounts of code are needed to handle <em>infrequently</em> occurring cases, such as error routines.</li>
</ul>
<p>A simple example:</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="o">*</span><span class="n">hndl</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span><span class="s">&quot;libnewshapes.so&quot;</span><span class="p">,</span> <span class="n">RTLD_NOW</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">hndl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
   <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">dlerror</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
   <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">mkr</span> <span class="o">=</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">hndl</span><span class="p">,</span> <span class="s">&quot;maker&quot;</span><span class="p">);</span>
</pre></div>


<h4 id="dynamic-linking-and-shared-libraries">Dynamic Linking and Shared Libraries<a class="headerlink" href="#dynamic-linking-and-shared-libraries" title="Permanent link">&para;</a></h4>
<p><strong>Dynamically linked libraries</strong>(DLLs，动态链接库) are system libraries that are linked to user programs when the programs are run</p>
<p><a href="../../csapp/ch7/#10">Detailed information in CSAPP</a></p>
<h3 id="2-contiguous-memory-allocation">2 Contiguous Memory Allocation<a class="headerlink" href="#2-contiguous-memory-allocation" title="Permanent link">&para;</a></h3>
<p>In order to accommodate both the operating system and the various user processes, allocating main memory are needed to be in the most efficient way. In <strong>Contiguous memory allocation</strong>(连续内存分配), <em>one <em>early</em> method, each process is contained in a single section of memory that is contiguous to the section containing the next process</em> .</p>
<p>The memory is usually divided into two partitions: one for the operating system and one for the user processes. </p>
<ul>
<li>We can place the operating system in either low memory addresses or high memory addresses.</li>
<li>Many operating system(including Linux and windows) place the operating system in high memory.</li>
</ul>
<h4 id="memory-protection">Memory Protection<a class="headerlink" href="#memory-protection" title="Permanent link">&para;</a></h4>
<p>Relocation register (重定位寄存器) and limit register (界限地址寄存器) are used to prevent a process from accessing memory that it does not own.</p>
<ul>
<li>The relocation register contains the value of the smallest physical address.</li>
<li>The limit register contains the range of logical addresses.</li>
<li>Each logical address must fall within the range specified by the limit register.</li>
<li>The MMU maps the logical address dynamically by adding the value in the relocation register.</li>
</ul>
<p><img alt="Hardware support for relocation and limit registers" src="../figures/Hardware%20support%20for%20relocation%20and%20limit%20registers.png" /></p>
<h4 id="memory-allocation">Memory Allocation<a class="headerlink" href="#memory-allocation" title="Permanent link">&para;</a></h4>
<p>One of the simplest methods of allocating memory is to assign processes to variably sized partitions in memory, where each partition may contain <em>exactly one</em> process.</p>
<ul>
<li>The operating system keeps a table indicating which parts of memory are available and which are occupied.</li>
<li>A block of available memory is a <strong>hole</strong>(孔).</li>
<li>When a process arrives and needs memory, the system searches for a hole that is large enough for this process.</li>
</ul>
<p><img alt="Variable partition" src="../figures/Variable%20partition.png" /></p>
<p><strong>Placement policy</strong>(放置策略)：Several Ways to satisfy a request of size <script type="math/tex">n</script> from a list of free holes.</p>
<ul>
<li><strong>First fit</strong>(首次适配). Allocate the first hole that is big enough.</li>
<li><strong>Best fit</strong>(最佳适配). Allocate the smallest hole that is big enough.</li>
<li><strong>Worst fit</strong>(最差适配). Allocate the largest hole.</li>
</ul>
<p>Both first fit and best fit are better than worst fit in terms of decreasing time and storage utilization. Neither first fit nor best fit is clearly better than the other in terms of storage utilization, but first fit is generally faster.</p>
<h4 id="fragmentation">Fragmentation<a class="headerlink" href="#fragmentation" title="Permanent link">&para;</a></h4>
<p><strong>External fragmentation</strong>(外部碎片) exists when there is enough total memory space to satisfy a request but the available spaces are not contiguous: storage is fragmented into a large number of small holes.</p>
<ul>
<li>One solution is <strong>compaction</strong>，which shuffles the memory contents so as to place all free memory together in one large block.</li>
<li>Another solution is to permit the logical address space of processes to be noncontiguous, thus allowing a process to be allocated physical memory wherever such memory is available.( <strong>paging</strong>, 分页, the most common memory-management technique for computer systems).</li>
</ul>
<p><strong>Internal fragmentation</strong>(内部碎片) occurs when unused memory is internal to a partition, because of allocating memory in units based on block size.</p>
<ul>
<li>The memory must be partitioned into variable sized blocks and assign the best fit block to the process.   </li>
</ul>
<h3 id="3-paging">3 Paging<a class="headerlink" href="#3-paging" title="Permanent link">&para;</a></h3>
<p><strong>Paging</strong>(分页), is a memory management scheme that permits a process's physical address space to be non-contiguous. Paging avoids external fragmentation and the associated need for compaction.</p>
<h4 id="basic-method">Basic Method<a class="headerlink" href="#basic-method" title="Permanent link">&para;</a></h4>
<p>The basic method for implementing paging involves breaking physical memory info fixed-sized blocks called <strong>frames</strong>(帧, also physical page), and breaking logical memory into blocks of the same size called <strong>pages</strong>(页, also virtual page).</p>
<ul>
<li>The backing store is divided into fixed-sized blocks that are the same size as the memory frames or clusters of multiple frames.</li>
</ul>
<p>Every address generated by the CPU is divided into two parts: a <strong>page number</strong>(p, 页号) and a <strong>page offset</strong>(d, 页偏移)。</p>
<ul>
<li>The page number is used as an index into a per-process <strong>page table</strong>.</li>
<li><strong>Page table</strong> contains the base address of each frame in physical memory and the offset is the location in the frame being referenced.</li>
<li>The base address of the frame is combined with the page offset to define the physical memory address.</li>
</ul>
<p><img alt="Paging hardware" src="../figures/Paging%20hardware.png" /></p>
<p>The MMU translates a logical address generated by the CPU to a physical address by:</p>
<ol>
<li>Extract the page number <script type="math/tex">p</script> and use it as an index into the page table.</li>
<li>Extract the corresponding frame number <script type="math/tex">f</script> from the page table.</li>
<li>Replace the page number <script type="math/tex">p</script> in the logical address with the frame number <script type="math/tex">f</script>.</li>
</ol>
<p>The page size is defined by the hardware, typically a power of 2. If the size of logical address space is <script type="math/tex">2^m </script>, and a page size is <script type="math/tex">2^n  </script> bytes, then the high-order <script type="math/tex">m-n</script> bits of a logical address designate the page number, and the <script type="math/tex">n</script> low-order bits designate the page offset.</p>
<p>Internal fragmentation still exists：</p>
<ul>
<li>If process size is independent of page size, we expect internal fragmentation to average one-half page per process.</li>
<li>This consideration suggests that small page sizes are desirable.</li>
<li>However, overhead is involved in each page table entry, and this overhead is reduced as the size of the pages increases.</li>
<li>Also, disk I/O is more efficient when the amount of data being transferred is larger</li>
</ul>
<h4 id="hardware-suport">Hardware Suport<a class="headerlink" href="#hardware-suport" title="Permanent link">&para;</a></h4>
<p>The hardware implementation of the page table can be done in several ways.</p>
<ul>
<li>In the simplest case, the page table is implemented as a set of dedicated high-speed hardware registers.<ul>
<li>It makes the page-address translation very efficient.</li>
<li>It increases context-switch time, as each one of these registers must be exchanged during a context switch.</li>
<li>The use of registers for the page table is satisfactory if the page table is reasonably small (for example, 256 entries).</li>
<li>It is not feasible for most contemporary CPUs, since much larger page tables needed.</li>
</ul>
</li>
<li>The page table is kept in main memory, and a <strong>page-table base register</strong> (PTBR, 页表基址寄存器) points to the page table.</li>
</ul>
<p>ISSUE: Although storing the page table in main memory can yield faster context switches, it may also result in slower memory access times. Because using page-table to find a physical address need one memory access, since the page-table is kept in main memory.</p>
<p>SOLUTION: To use a special, small, fast-lookup hardware <em>cache</em> called a <strong>translation look-aside buffer</strong>(TLB, 转译后备缓冲器).</p>
<ul>
<li>Each entry in the TLB consists of two parts: a key(tag) and a value.</li>
<li>When the associative memory is presented with an item, the item is compared with all keys simultaneously. If the item is found, the corresponding value field is returned.</li>
<li>TLB is kept small, typically between 32 and 1,024 entries in size.</li>
</ul>
<p><img alt="Paging hardware with TLB" src="../figures/Paging%20hardware%20with%20TLB.png" /></p>
<p>CPUs today may provide multiple levels of TLBs. </p>
<ul>
<li>For instance, the Intel Core i7 CPU has a 128-entry L1 instruction TLB and a 64-entry L1 data TLB. </li>
<li>In the case of a miss at L1, it takes the CPU six cycles to check for the entry in the L2 512-entry TLB. </li>
<li>A miss in L2 means that the CPU must either walk through the page-table entries in memory to find the associated frame address, which can take hundreds of cycles, or interrupt to the operating system to have it do the work.</li>
</ul>
<h4 id="protection">Protection<a class="headerlink" href="#protection" title="Permanent link">&para;</a></h4>
<p>Memory protection in a paged environment is accomplished by <strong>protection bits</strong> associated with each frame. Normally, these bits are kept in the page table.</p>
<ul>
<li>One bit can define a page to be read–write or read-only.</li>
<li>One additional bit is generally attached to each entry in the page table: a valid–invalid bit. (When the bit is set to invalid, the page is not in the process’s logical address space).</li>
</ul>
<h4 id="shared-pages">Shared Pages<a class="headerlink" href="#shared-pages" title="Permanent link">&para;</a></h4>
<p>An advantage of paging is the possibility of <strong><em>sharing</em></strong> common code. </p>
<p>Reentrant code is non-self-modifying code: it never changes during execution. If the code is reentrant code, it can be shared.</p>
<ul>
<li>Two or more processes can execute the same code at the same time. </li>
<li>Each process has its <em>own</em> copy of registers and data storage to hold the data for the process’s execution.</li>
<li>The shared libraries are typically implemented with shared pages.</li>
<li>Some operating systems implement <a href="../ch3/#5-ipc-in-shared-memory-system">shared memory</a> using shared pages.</li>
</ul>
<p>Example: Sharing of standard C library in a paging environment.</p>
<p><img alt="Sharing of standard C library in a paging environment" src="../figures/Sharing%20of%20standard%20C%20library%20in%20a%20paging%20environment.png" /></p>
<h3 id="4-structure-of-the-page-table">4 Structure of the Page Table<a class="headerlink" href="#4-structure-of-the-page-table" title="Permanent link">&para;</a></h3>
<h4 id="hierarchical-paging">Hierarchical Paging<a class="headerlink" href="#hierarchical-paging" title="Permanent link">&para;</a></h4>
<p>Most modern computer systems support a large logical address space (<script type="math/tex">2^32 - 2^64 </script>). In such an environment, the page table itself becomes excessively large.</p>
<p>One way is to use a two-level paging algorithm, in which the page table itself is also paged.</p>
<p><img alt="A two-level page-table scheme" src="../figures/A%20two-level%20page-table%20scheme.png" /></p>
<p>For a system with a 64-bit logical address space, a two-level paging scheme is no longer appropriate. </p>
<ul>
<li>So we can page the outer page table, giving us a three-level paging scheme. </li>
<li>But the outer page table is still large in size. </li>
<li>The next step would be a four-level paging scheme, where the second-level outer page table itself is also paged, and so forth.</li>
<li>For 64-bit architectures, hierarchical page tables are generally considered inappropriate.</li>
</ul>
<h4 id="hashed-page-tables">Hashed Page Tables<a class="headerlink" href="#hashed-page-tables" title="Permanent link">&para;</a></h4>
<p>One approach for handling address spaces larger than 32 bits is to use a <strong>hashed page table</strong>(哈希页表), with the hash value being the virtual page number.</p>
<p>Each entry in the hash table contains a linked list of elements that hash to the same location (to handle collisions). Each element consists of three fields: </p>
<ul>
<li>the virtual page number</li>
<li>the value of the mapped page frame</li>
<li>a pointer to the next element in the linked list.</li>
</ul>
<p>The algorithm works as follows:</p>
<ul>
<li>The virtual page number in the virtual address is hashed into the hash table. </li>
<li>The virtual page number is compared with field 1 in the first element in the linked list. </li>
<li>If there is a match, the corresponding page frame (field 2) is used to form the desired physical address. </li>
<li>If there is no match, subsequent entries in the linked list are searched for a matching virtual page number.</li>
</ul>
<p><img alt="Hashed page table" src="../figures/Hashed%20page%20table.png" /></p>
<p><strong>Clustered page tables</strong>, which are similar to hashed page tables except that each entry in the hash table refers to several pages (such as 16) rather than a single page. It is particularly useful for sparse address spaces, where memory references are noncontiguous and scattered throughout the address space.</p>
<h4 id="inverted-page-tables">Inverted Page Tables<a class="headerlink" href="#inverted-page-tables" title="Permanent link">&para;</a></h4>
<p>ISSUE: One of the drawbacks of methods above is that each page table may consist of millions of entries. These tables may consume large amounts of physical memory just to keep track of how other physical memory is being used.</p>
<p>SOLUTION: An <strong>inverted page table</strong>(反向页表) has one entry for each real page (or frame) of memory.</p>
<ul>
<li>Each entry consists of the virtual address of the page stored in that real memory location, with information about the process that owns the page.</li>
<li>Only one page table is in the system, and it has only one entry for each page of physical memory.</li>
</ul>
<p><img alt="Inverted page table" src="../figures/Inverted%20page%20table.png" /></p>
<p>DISADVANTAGE: It increases the amount of time needed to search the table when a page reference occurs.</p>
<h3 id="5-swapping">5 Swapping<a class="headerlink" href="#5-swapping" title="Permanent link">&para;</a></h3>
<p>A process, or a portion of a process, can be swapped temporarily out of memory to a backing store and then brought back into memory for continued execution. (The backing store is commonly fast secondary storage.)</p>
<p>Swapping makes it possible for the total physical address space of all processes to <em>exceed</em> the real physical memory of the system, thus increasing the degree of multiprogramming in a system.</p>
<h4 id="standard-swapping">Standard Swapping<a class="headerlink" href="#standard-swapping" title="Permanent link">&para;</a></h4>
<p>Standard swapping involves moving <em><em>entire</em></em> processes between main memory and a backing store.</p>
<ul>
<li>For a multithreaded process, all per-thread data structures must be swapped as well.</li>
<li>The advantage of standard swapping is that it allows physical memory to be <em>oversubscribed</em>, so that the system can accommodate more processes than there is actual physical memory to store them.</li>
<li>Idle or mostly idle processes are good candidates for swapping</li>
</ul>
<p><img alt="Standard swapping of two processes using a disk as a backing store" src="../figures/Standard%20swapping%20of%20two%20processes%20using%20a%20disk%20as%20a%20backing%20store.png" /></p>
<h4 id="swapping-with-paging">Swapping with paging<a class="headerlink" href="#swapping-with-paging" title="Permanent link">&para;</a></h4>
<p>ISSUE: For standard swapping, the amount of time required to move entire processes between memory and the backing store is prohibitive. It was used in traditional UNIX systems, but it is generally no longer used in contemporary operating systems.</p>
<p>SOLUTION: Most systems, including Linux and Windows, use a variation of swapping in which <em><em>pages</em></em> of a process—rather than an <em><em>entire process</em></em> —can be swapped.</p>
<ul>
<li>A <strong>page out</strong> operation moves a page from memory to the backing store; the reverse process is known as a <strong>page in</strong>.</li>
</ul>
<p><img alt="Swapping with paging" src="../figures/Swapping%20with%20paging.png" /></p>
<h4 id="swapping-on-mobile-systems">Swapping on Mobile Systems<a class="headerlink" href="#swapping-on-mobile-systems" title="Permanent link">&para;</a></h4>
<p>ISSUE: In contrast, mobile systems typically do <em><em>not</em></em> support swapping in any form.</p>
<ul>
<li>Space constraint: Mobile devices generally use flash memory rather than more spacious hard disks for nonvolatile storage.</li>
<li>Other reasons include the limited number of writes that flash memory can tolerate before it becomes unreliable and the poor throughput between main memory and flash memory in these devices.</li>
</ul>
<p>SOLUTION: Instead of using swapping, when free memory falls below a certain threshold, Apple’s iOS asks applications to voluntarily <em>relinquish</em> allocated memory. Any applications that fail to free up sufficient memory may be terminated by the operating system.</p>
<h3 id="6-example-intel-64-bit-architectures">6 Example: Intel 64-bit Architectures<a class="headerlink" href="#6-example-intel-64-bit-architectures" title="Permanent link">&para;</a></h3>
<p><a href="../../csapp/ch9/#4-core-i7">Core i7 Memory System</a></p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '../..';</script>
        <script src="../../js/base.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script src="../../search/require.js"></script>
        <script src="../../search/search.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td><kbd>&larr;</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td><kbd>&rarr;</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>


    </body>
</html>
