<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="Zhenhua Wang">
        <link rel="canonical" href="http://larryim.cc/note/ujvm/ch2/">
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Chapter 2 : Java内存区域与内存溢出正常 - Zhenhua's Notes</title>
        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <link href="../../extra_css/custom.css" rel="stylesheet">
        <link href="../../extra_css/custom.js" rel="stylesheet">
        <link href="../../extra_css/friendly.css" rel="stylesheet">
        <link href="../../extra_css/theme.css" rel="stylesheet">
        <link href="../../extra_css/mkdocs/js/lunr-0.5.7.min.js" rel="stylesheet">
        <link href="../../extra_css/mkdocs/js/mustache.min.js" rel="stylesheet">
        <link href="../../extra_css/mkdocs/js/require.js" rel="stylesheet">
        <link href="../../extra_css/mkdocs/js/search.js" rel="stylesheet">
        <link href="../../extra_css/mkdocs/js/text.js" rel="stylesheet">
        <link href="../../extra_css/code-tab.css" rel="stylesheet">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        <script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../..">Zhenhua's Notes</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="../..">Home</a>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">OSC <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../osc/">Contents</a>
</li>
                            
<li >
    <a href="../../osc/ch1/">Chapter 1: Introduction </a>
</li>
                            
<li >
    <a href="../../osc/ch2/">Chapter 2: Operating System structures</a>
</li>
                            
<li >
    <a href="../../osc/ch3/">Chapter 3: Processes</a>
</li>
                            
<li >
    <a href="../../osc/ch4/">Chapter 4: Threads and Concurrency</a>
</li>
                            
<li >
    <a href="../../osc/ch5/">Chapter 5: CPU Scheduling</a>
</li>
                            
<li >
    <a href="../../osc/ch6/">Chapter 6: Synchronization Tools</a>
</li>
                            
<li >
    <a href="../../osc/ch7/">Chapter 7: Synchronization Examples</a>
</li>
                            
<li >
    <a href="../../osc/ch8/">Chapter 8: Deadlocks</a>
</li>
                            
<li >
    <a href="../../osc/ch9/">Chapter 9: Main Memory</a>
</li>
                            
<li >
    <a href="../../osc/ch10/">Chapter 10: Virtual Memory</a>
</li>
                            
<li >
    <a href="../../osc/ch11/">Chapter 11: Mass-Storage Structure</a>
</li>
                            
<li >
    <a href="../../osc/ch13/">Chapter 13: File-System Interfaces</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">CSAPP <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../csapp/">Contents</a>
</li>
                            
<li >
    <a href="../../csapp/ch1/">Chapter 1: 计算机系统漫游</a>
</li>
                            
<li >
    <a href="../../csapp/ch2/">Chapter 2: 信息的表示和处理</a>
</li>
                            
<li >
    <a href="../../csapp/ch3/">Chapter 3: 程序的机器级表示</a>
</li>
                            
<li >
    <a href="../../csapp/ch4/">Chapter 4: 处理器体系结构</a>
</li>
                            
<li >
    <a href="../../csapp/ch5/">Chapter 5: 优化程序性能</a>
</li>
                            
<li >
    <a href="../../csapp/ch6/">Chapter 6: 存储器层次结构</a>
</li>
                            
<li >
    <a href="../../csapp/ch7/">Chapter 7: 链接</a>
</li>
                            
<li >
    <a href="../../csapp/ch8/">Chapter 8: 异常控制流</a>
</li>
                            
<li >
    <a href="../../csapp/ch9/">Chapter 9: 虚拟内存</a>
</li>
                            
<li >
    <a href="../../csapp/ch10/">Chapter 10: 系统级I/O</a>
</li>
                            
<li >
    <a href="../../csapp/ch11/">Chapter 11: 网络编程</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">HFJ <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../hfj/">Contents</a>
</li>
                            
<li >
    <a href="../../hfj/ch1/">Chapter 1: Dive in A Quick Dip</a>
</li>
                            
<li >
    <a href="../../hfj/ch2/">Chapter 2: Classes and Objects</a>
</li>
                            
<li >
    <a href="../../hfj/ch3/">Chapter 3: Primitives and References</a>
</li>
                            
<li >
    <a href="../../hfj/ch4/">Chapter 4: Methods use Instance Variables</a>
</li>
                            
<li >
    <a href="../../hfj/ch5/">Chapter 5: Writing a Program</a>
</li>
                            
<li >
    <a href="../../hfj/ch6/">Chapter 6: Get to Know the Java API</a>
</li>
                            
<li >
    <a href="../../hfj/ch7/">Chapter 7: Inheritance and Polymorphism</a>
</li>
                            
<li >
    <a href="../../hfj/ch8/">Chapter 8: Interfaces and Abstract Classes</a>
</li>
                            
<li >
    <a href="../../hfj/ch9/">Chapter 9: Constructors and Garbage Collection</a>
</li>
                            
<li >
    <a href="../../hfj/ch10/">Chapter 10: Numbers and Statics</a>
</li>
                            
<li >
    <a href="../../hfj/ch11/">Chapter 11: Exception Handling</a>
</li>
                            
<li >
    <a href="../../hfj/ch12/">Chapter 12: Getting GUI</a>
</li>
                            
<li >
    <a href="../../hfj/ch13/">Chapter 13: Using Swing</a>
</li>
                            
<li >
    <a href="../../hfj/ch14/">Chapter 14: Serialization and File I/O</a>
</li>
                            
<li >
    <a href="../../hfj/ch15/">Chapter 15: Networking and Threads</a>
</li>
                            
<li >
    <a href="../../hfj/ch16/">Chapter 16: Collections and Generics</a>
</li>
                            
<li >
    <a href="../../hfj/ch17/">Chapter 17: Packages, Jars and Deployment</a>
</li>
                            
<li >
    <a href="../../hfj/ch18/">Chapter 18: Remote deploy with RMI</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">CPJ <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../cpj/">Contents</a>
</li>
                            
<li >
    <a href="../../cpj/ch1/">Concurrent Programming in Java 1: Threads and Locks</a>
</li>
                            
<li >
    <a href="../../cpj/ch2/">Concurrent Programming in Java 2: Critical Sections and Isolation</a>
</li>
                            
<li >
    <a href="../../cpj/ch3/">Concurrent Programming in Java 3: Actors</a>
</li>
                            
<li >
    <a href="../../cpj/ch4/">Concurrent Programming in Java 4: Concurrent Data Structures</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">LKD <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../lkd/">Contents</a>
</li>
                            
<li >
    <a href="../../lkd/ch1/">Chapter 1 : Introduction to Linux Kernel</a>
</li>
                            
<li >
    <a href="../../lkd/ch2/">Chapter 2</a>
</li>
                            
<li >
    <a href="../../lkd/ch3/">Chapter 3</a>
</li>
                            
<li >
    <a href="../../lkd/ch4/">Chapter 4</a>
</li>
                            
<li >
    <a href="../../lkd/ch5/">Chapter 5</a>
</li>
                            
<li >
    <a href="../../lkd/ch6/">Chapter 6</a>
</li>
                            
<li >
    <a href="../../lkd/ch7/">Chapter 7</a>
</li>
                            
<li >
    <a href="../../lkd/ch8/">Chapter 8</a>
</li>
                            
<li >
    <a href="../../lkd/ch9/">Chapter 9</a>
</li>
                            
<li >
    <a href="../../lkd/ch10/">Chapter 10</a>
</li>
                            
<li >
    <a href="../../lkd/ch11/">Chapter 11</a>
</li>
                            
<li >
    <a href="../../lkd/ch12/">Chapter 12: Memory management</a>
</li>
                            
<li >
    <a href="../../lkd/ch13/">Chapter 13</a>
</li>
                            
<li >
    <a href="../../lkd/ch14/">Chapter 14</a>
</li>
                            
<li >
    <a href="../../lkd/ch15/">Chapter 15</a>
</li>
                            
<li >
    <a href="../../lkd/ch16/">Chapter 16</a>
</li>
                            
<li >
    <a href="../../lkd/ch17/">Chapter 17</a>
</li>
                            
<li >
    <a href="../../lkd/ch18/">Chapter 18</a>
</li>
                            
<li >
    <a href="../../lkd/ch19/">Chapter 19</a>
</li>
                            
<li >
    <a href="../../lkd/ch20/">Chapter 20</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">UJVM <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../">Contents</a>
</li>
                            
<li >
    <a href="../ch1/">Chapter 1 : 走进Java</a>
</li>
                            
<li class="active">
    <a href="./">Chapter 2 : Java内存区域与内存溢出正常</a>
</li>
                            
<li >
    <a href="../ch3/">Chapter 3 : 垃圾收集器与内存分配策略</a>
</li>
                            
<li >
    <a href="../ch4/">Chapter 4 : 虚拟机性能监控与故障处理工具</a>
</li>
                            
<li >
    <a href="../ch5/">Chapter 5 : 调优案例分析与实战</a>
</li>
                            
<li >
    <a href="../ch6/">Chapter 6 : 类文件结构</a>
</li>
                            
<li >
    <a href="../ch7/">Chapter 7 : 虚拟机类加载机制</a>
</li>
                            
<li >
    <a href="../ch8/">Chapter 8 : 虚拟机字节码执行引擎</a>
</li>
                            
<li >
    <a href="../ch9/">Chapter 9 : 类加载及执行子系统的案例与实战</a>
</li>
                            
<li >
    <a href="../ch10/">Chapter 10 : 早期(编译期)优化</a>
</li>
                            
<li >
    <a href="../ch11/">Chapter 11 : 晚期(运行期)优化</a>
</li>
                            
<li >
    <a href="../ch12/">Chapter 12 : Java内存模型与线程</a>
</li>
                            
<li >
    <a href="../ch13/">Chapter 13 : 线程安全与锁优化</a>
</li>
                            
<li >
    <a href="../AppendixC/">Appendix HotSpot虚拟机主要参数列表</a>
</li>
                        </ul>
                    </li>
                    <li >
                        <a href="../../books/">Books</a>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="../ch1/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../ch3/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#java-2-java">深入理解Java虚拟机 2 - Java内存区域与内存溢出正常</a></li>
        <li class="main "><a href="#1">1 概述</a></li>
        <li class="main "><a href="#2">2 运行时数据区域</a></li>
            <li><a href="#_1">程序计数器</a></li>
            <li><a href="#java">Java虚拟机栈</a></li>
            <li><a href="#_2">本地方法栈</a></li>
            <li><a href="#java_1">Java堆</a></li>
            <li><a href="#_3">方法区（永久代）</a></li>
            <li><a href="#_4">运行时常量池</a></li>
            <li><a href="#_5">直接内存</a></li>
        <li class="main "><a href="#3-hotspot">3 HotSpot虚拟机对象探秘</a></li>
            <li><a href="#_6">对象的创建</a></li>
            <li><a href="#_7">对象的内存布局</a></li>
            <li><a href="#_8">对象的访问定位</a></li>
        <li class="main "><a href="#4-outofmemoryerror">4 实战：OutOfMemoryError异常</a></li>
            <li><a href="#java_2">Java堆溢出</a></li>
            <li><a href="#_9">虚拟机栈和本地方法栈溢出</a></li>
            <li><a href="#_10">方法区和运行时常量池溢出</a></li>
            <li><a href="#_11">本机直接内存溢出</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h3 id="java-2-java"><strong>深入理解Java虚拟机 2 - Java内存区域与内存溢出正常</strong><a class="headerlink" href="#java-2-java" title="Permanent link">&para;</a></h3>
<h3 id="1">1 概述<a class="headerlink" href="#1" title="Permanent link">&para;</a></h3>
<p>本章将从概念上介绍Java虚拟机内存的各个区域，讲解这些区域的作⽤、服务对象以及其中可能产⽣的问题。</p>
<h3 id="2">2 运行时数据区域<a class="headerlink" href="#2" title="Permanent link">&para;</a></h3>
<p>根据《Java虚拟机规范(Java SE 7版)》的规定， Java虚拟机所管理的内存将会包括以下⼏个运⾏时数据区域。</p>
<p><img alt="" src="../figures/Java虚拟机运行时数据区larry.png" /></p>
<h4 id="_1">程序计数器<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h4>
<p>程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。每条线程都有⼀个独⽴的程序计数器，各条线程之间计数器互不影响，独⽴存储。</p>
<p>如果线程正在执行的是Java方法，那么这个计数器的值就是正在执行的虚拟机字节码指令的地址；如果正在执行的是<C>Native</C>方法，这个计数器值为空(undefined)。此内存区域是唯一一个在Java虚拟机规范中没有规定任何<C>OutOfMemoryError</C>情况的区域。</p>
<h4 id="java">Java虚拟机栈<a class="headerlink" href="#java" title="Permanent link">&para;</a></h4>
<p>Java虚拟机栈是线程私有的，它的生命周期与线程相同。每个方法执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>局部变量表存放了编译期可知的各种基本数据类型(<C>boolean</C>、<C>byte</C>、<C>char</C>、<C>short</C>、<C>int</C>、<C>float</C>、<C>long</C>、<C>double</C>)、对象引用(<C><C>Reference</C></C>类型)和<C>returnAddress</C>类型（指向了一条字节码指令的地址）。</p>
<p>其中64位长度的<C>long</C>和<C>double</C>类型的数据会占用2个局部变量空间(Slot)，其余的数据类型占1个。局部变量表所需的内存空间在编译期间分配完成，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常状况：</p>
<ul>
<li>如果线程请求栈的深度大于虚拟机所允许的深度，将抛出<C>StackOverflowError</C>异常。</li>
<li>如果虚拟机栈可以动态扩展（当前⼤部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时⽆法申请到⾜够的内存，就会抛出抛出<C>OutOfMemoryError</C>异常。</li>
</ul>
<h4 id="_2">本地方法栈<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h4>
<p><strong>本地方法栈</strong>(Native Method Stack)与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行java方法，而本地栈则为虚拟机使用到的<C>native</C>方法服务。</p>
<h4 id="java_1">Java堆<a class="headerlink" href="#java_1" title="Permanent link">&para;</a></h4>
<p>Java<strong>堆</strong>(Heap)是线程共享的，在虚拟机启动时创建。Java堆的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
<p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称作"GC堆"(Garbage Collected Heap)。由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。</p>
<p>Java堆在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的。</p>
<h4 id="_3">方法区（永久代）<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h4>
<p><strong>⽅法区</strong>(Method Area)是各个线程共享的内存区域，它⽤于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>对于HotSpot虚拟机来说，它也叫做<strong>永久代</strong>(Permanent Generation, <strong>PermGen</strong>)。这是因为HotSpot虚拟机把GC分代收集扩展⾄⽅法区，或者说使⽤永久代来实现⽅法区，这样HotSpot的垃圾收集器可以像管理Java堆⼀样管理这部分内存，能够省去专门为⽅法区编写内存管理代码的⼯作。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。</p>
<p>由于永久代内可能会发生内存泄露或溢出等问题而导致的<C>java.lang.OutOfMemoryError: PermGen</C>，JEP小组从JDK1.7开始就筹划移除永久代(<a href="http://openjdk.java.net/jeps/122">JEP 122: Remove the Permanent Generation</a>)，并且在JDK 1.7中把字符串常量，符号引用等移出了永久代。到了Java 8，永久代被彻底地移出了JVM，取而代之的是<strong>元空间</strong>(Metaspace)：</p>
<blockquote>
<p>In JDK 8, classes metadata is now stored in the <strong>native heap</strong>(本地对内存) and this space is called <strong>Metaspace</strong>.</p>
</blockquote>
<p>根据Java虚拟机规范的规定，当⽅法区⽆法满⾜内存分配需求时，将抛出<C>OutOfMemoryError</C>异常。</p>
<p><img alt="" src="../figures/hotspot_heap_structure.jpg" /></p>
<ul>
<li>Young Generation 新生代<ul>
<li>Eden: where new objects get instantiated</li>
<li>S0, S1 (Survivor space): hold live objects during minor GC<ul>
<li>S0: from Survivor</li>
<li>S1: to Survivor</li>
</ul>
</li>
</ul>
</li>
<li>Old Generation (Tenured) 老年代</li>
<li>Permanent Generation 永久代</li>
</ul>
<h4 id="_4">运行时常量池<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h4>
<p><strong>运⾏时常量池</strong>(Runtime Constant Pool）是⽅法区的⼀部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(Constant Pool)，用于存放编译期生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p>JDK 1.7开始，字符串常量和符号引用等就被移出永久代：</p>
<ul>
<li>符号引用迁移至系统堆内存(Native Heap)</li>
<li>字符串字面量迁移至Java堆(Java Heap)</li>
</ul>
<h4 id="_5">直接内存<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h4>
<p><strong>直接内存</strong>(Direct Memory)不是虚拟机运行时数据区的一部分。但是这部分内存也被频繁地使用，而且也可能导致<C>OutOfMemoryError</C>异常出现。</p>
<p>在JDK1.4中新加入了NIO类，引入了一种基于通道与缓存区(buffer)的I/O方式，它可以使用<C>Native</C>函数库直接分配堆外内存，然后通过一个存储在Java堆中的<C>DirectByteBuffer</C>对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和<ative</C>堆中来回复制数据。</p>
<h3 id="3-hotspot">3 HotSpot虚拟机对象探秘<a class="headerlink" href="#3-hotspot" title="Permanent link">&para;</a></h3>
<p>本节以常⽤的虚拟机HotSpot和常⽤的内存区域Java堆为例，深⼊探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p>
<h4 id="_6">对象的创建<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h4>
<p>(1) 虚拟机遇到一个<C>new</C>指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<p>(2)在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存。对象所需内存的⼤⼩在类加载完成后便可完全确定，为对象分配空间的任务等同于把⼀块确定⼤⼩的内存从Java堆中划分出来。如果Java堆是绝对规整的(所有⽤过的内存都放在⼀边， 空闲的内存放在另⼀边，中间放着⼀个指针作为分界点的指⽰器)，那么将使用<strong>指针碰撞</strong>(Bump the Pointer)的分配方式: 把那个指针向空闲空间那边挪动⼀段与对象⼤⼩相等的距离。 如果Java堆中的内存并不是规整的，已使⽤的内存和空闲的内存相互交错，那就没有办法简单地进⾏指针碰撞了，虚拟机就必须维护⼀个列表，记录上哪些内存块是可⽤的，在分配的时候从列表中找到⼀块⾜够⼤的空间划分给对象实 例，并更新列表上的记录，这种分配⽅式称为<strong>空闲列表</strong>(Free List)。</p>
<p>但是内存的分配是同步的，如果一个线程刚分配一个对象内存，但是还没有修改指针所指向的位置，那么另一个线程分配对象的时候可能就出错了。解决方法有两个:</p>
<ul>
<li>对分配内存空间的动作进行同步处理（CAS方式）。</li>
<li>把内存分配的动作按照线程划分在不同的空间进行，每个线程在java堆中预分配一小块内存，称为本地线程分配缓冲(TLAB)。只有TLAB用完并分配新的TLAB时，才需要同步。JVM是否开启TLAB功能，可通过-XX:+/-UseTLAB参数来设定。</li>
</ul>
<p>(3) 内存分配完之后，初始化零值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。</p>
<p>(4) 接下来，JVM对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头中，根据JVM当前运行状态不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<p>在上⾯⼯作都完成之后，从虚拟机的视⾓来看，⼀个新的对象已经产⽣了，但从Java程序的视⾓来看，对象创建才刚刚开始——<init>⽅法还没有执⾏，所有的字段都还为零。所以，⼀般来说（由字节码中是否跟随invokespecial指令所决定），执⾏<C>new</C>指令之后会接着执⾏<init>⽅法，把对象按照程序员的意愿进⾏初始化，这样⼀个真正可⽤的对象才算完全产⽣出来。</p>
<h4 id="_7">对象的内存布局<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h4>
<p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(Object Header)、实例数据(Instance Data)和对齐填充(Padding)。</p>
<p>HotSpot虚拟机的对象头包括两部分信息:</p>
<ul>
<li>MarkWord: 用于存储对象自身的运行时数据（哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等）</li>
<li>Klass pointer: 类型指针（即对象指向它的类元数据的指针，JVM通过这个指针来确定这个对象是哪个类的实例）。</li>
<li>另外，如果对象是⼀个Java数组，那在对象头中还必须有⼀块⽤于记录数组长度的数据，因 为虚拟机可以通过普通Java对象的元数据信息确定Java对象的⼤⼩，但是从数组的元数据中却⽆法确定数组的⼤⼩。</li>
</ul>
<p><img alt="objectHeade" src="../figures/ObjectHeader.png" /></p>
<p>HotSpot虚拟机<code class="codehilite">markOop.cpp</code>中的代码（注释）⽚段，它描述了32bit下Mark Word的存储状态。<a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/9b0ca45cd756/src/share/vm/oops/markOop.hpp">source</a></p>
<p> <div class=codehilite><pre><span class=k>enum</span> <span class=p>{</span> <span class=n>age_bits</span>                 <span class=o>=</span> <span class=mi>4</span><span class=p>,</span>
       <span class=n>lock_bits</span>                <span class=o>=</span> <span class=mi>2</span><span class=p>,</span>
       <span class=n>biased_lock_bits</span>         <span class=o>=</span> <span class=mi>1</span><span class=p>,</span>
       <span class=n>max_hash_bits</span>            <span class=o>=</span> <span class=n>BitsPerWord</span> <span class=o>-</span> <span class=n>age_bits</span> <span class=o>-</span> <span class=n>lock_bits</span> <span class=o>-</span> <span class=n>biased_lock_bits</span><span class=p>,</span>
       <span class=n>hash_bits</span>                <span class=o>=</span> <span class=n>max_hash_bits</span> <span class=o>&gt;</span> <span class=mi>31</span> <span class=o>?</span> <span class=mi>31</span> <span class=o>:</span> <span class=n>max_hash_bits</span><span class=p>,</span>
       <span class=n>cms_bits</span>                 <span class=o>=</span> <span class=n>LP64_ONLY</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=n>NOT_LP64</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span>
       <span class=n>epoch_bits</span>               <span class=o>=</span> <span class=mi>2</span>
  <span class=p>};</span>
</pre></div></p>
<p>接下来的实例数据是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。⽆论是从⽗类继承下来的，还是在⼦类中定义的，都需要记录起来。在父类中定义的变量会出现在子类之前，如果CompactFields参数值为true，那么子类中较窄的变量也可能会插入到父类变量的空隙之中。</p>
<p>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作⽤。由于HotSpot VM的⾃动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的⼤⼩必须是8字节的整数倍。⽽对象头部分正好是8字节的倍数(1倍或者2倍)，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h4 id="_8">对象的访问定位<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h4>
<p>我们的Java程序需要通过栈上的<C>Reference</C>数据来操作堆上的具体对象。目前主流的对象访问方式有两种：句柄(handle)和直接指针。</p>
<ul>
<li>如果直接使用句柄访问，java堆中将会划分出一块内存来作为句柄池，<C>Reference</C>中存储的是对象的句柄地址，而句柄中包含了对象数据与类型数据各自的具体地址信息。</li>
</ul>
<blockquote>
<p>In computer programming, a handle is an abstract reference to a resource.</p>
</blockquote>
<p><img alt="" src="../figures/vern通过句柄访问对象.jpg" /></p>
<ul>
<li>如果使用直接指针访问，那么java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而<C>Reference</C>中存储的直接就是对象地址，如下图所示。</li>
</ul>
<p><img alt="" src="../figures/vern通过直接指针访问对象.jpg" /></p>
<p>这两种对象访问方式各有优势：</p>
<ul>
<li>使用句柄来访问的最大好处是<C>Reference</C>中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而<C>Reference</C>本身不需要修改。</li>
<li>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。由于对象的访问在Java中⾮常频繁，因此这类开销积少成多后也是⼀项⾮常可观的执⾏成本</li>
</ul>
<p>HotSpot虚拟机使用的是直接指针访问的方式。但各种语⾔和框架使⽤句柄来访问的情况也⼗分常见。</p>
<h3 id="4-outofmemoryerror">4 实战：OutOfMemoryError异常<a class="headerlink" href="#4-outofmemoryerror" title="Permanent link">&para;</a></h3>
<p>主要是为了学习之前学的各种内存区域的内容，还有就是以后遇到内存错误的时候，能够根据异常的信息快速判读是哪个区域的内存溢出，知道是什么样的代码可能会导致这些区域内存溢出，以及出现这些异常后，该如何处置。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>常见的HotSpot JVM参数</p>
<ul>
<li><code class="codehilite">-Xms</code> 初始堆大小  </li>
<li><code class="codehilite">-Xmx</code>    最大堆大小   </li>
<li><code class="codehilite">-Xmn</code> 年轻代大小</li>
<li><code class="codehilite">-XX: MaxPermSize</code>    设置持久代最大值</li>
<li><code class="codehilite">-Xss</code>    每个线程的堆栈大小   </li>
</ul>
</div>
<h4 id="java_2">Java堆溢出<a class="headerlink" href="#java_2" title="Permanent link">&para;</a></h4>
<p>Java堆⽤于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最⼤堆的容量限制后就会产⽣内存溢出异常。</p>
<p>Java堆内存溢出异常测试:</p>
<p> <div class=codehilite><pre><span class=c1>//VM Args：-Xms20m -Xmx20m -XX: +HeapDumpOnOutOfMemoryError </span>
<span class=c1>// 限制Java堆的⼤⼩为20MB，不可扩展（将堆的最⼩值-Xms参数与最⼤值-Xmx参数设置为⼀样即可避免堆⾃动扩展）</span>
<span class=c1>// -XX: +HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢 出异常时Dump出当前的内存堆转储快照以便事后进⾏分析</span>
<span class=kn>import</span> <span class=nn>java.util.ArrayList</span><span class=o>;</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>HeapOOM</span><span class=o>{</span>
    <span class=kd>static</span> <span class=kd>class</span> <span class=nc>OOMObject</span><span class=o>{</span> <span class=o>}</span>
    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>){</span>
        <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>OOMObject</span><span class=o>&gt;</span> <span class=n>list</span><span class=o>=</span><span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>OOMObject</span><span class=o>&gt;();</span>
        <span class=k>while</span><span class=o>(</span><span class=kc>true</span><span class=o>){</span>
            <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>OOMObject</span><span class=o>());</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<p>结果</p>
<p> <div class=codehilite><pre>java.lang.OutOfMemoryError: Java heap space
Dumping heap to java_pid46106.hprof ...
Heap dump file created [29129293 bytes in 0.350 secs]
</pre></div></p>
<p>要解决这个区域的异常，⼀般的⼿段是先通过内存映像分析⼯具对Dump出来的堆转储快照进⾏分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>可以使用Eclipse Memory Analyzer打开堆转储快照⽂件。The Eclipse Memory Analyzer is a fast and feature-rich Java heap analyzer that helps you find memory leaks and reduce memory consumption.<a href="http://www.eclipse.org/mat/">Official Website</a></p>
<p><img alt="Eclipse Memory Analyse" src="../figures/Eclipse%20Memory%20Analyser.png" /></p>
</div>
<p>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置。</p>
<p>如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<h4 id="_9">虚拟机栈和本地方法栈溢出<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h4>
<p>由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然<code class="codehilite">-Xoss</code>参数（设置本地方法栈大小）存在，但实际上是没有效果的，栈容量只由<code class="codehilite">-Xss</code>参数设置。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出<C>StackOverflowError</C>异常。</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，将抛出<C>OutOfMemoryError</C>异常。</li>
</ul>
<p>虚拟机栈和本地⽅法栈OOM测试（仅作为第1点测试程序）:
　</p>
<div class=md-fenced-code-tabs id=tab-tab-group-3><input name=tab-group-3 type=radio id=tab-group-3-0_Java checked=checked class=code-tab data-lang=Java aria-controls=tab-group-3-0_Java-panel role=tab><label for=tab-group-3-0_Java class=code-tab-label data-lang=Java id=tab-group-3-0_Java-label>Java</label><div class=code-tabpanel role=tabpanel data-lang=Java id=tab-group-3-0_Java-panel aria-labelledby=tab-group-3-0_Java-label><div class=codehilite><pre><span class=c1>//VM args: -Xss128k</span>
<span class=c1>// -Xss128k 减小栈内存至128k</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>JavaVMStackOverFlowError</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kt>int</span> <span class=n>stackLength</span> <span class=o>=</span> <span class=mi>1</span><span class=o>;</span>
    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>stackLeak</span><span class=o>(){</span>
        <span class=n>stackLength</span><span class=o>++;</span>
        <span class=n>stackLeak</span><span class=o>();</span>
    <span class=o>}</span>
    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>){</span>
        <span class=n>JavaVMStackOverFlowError</span> <span class=n>sof</span> <span class=o>=</span> <span class=k>new</span> <span class=n>JavaVMStackOverFlowError</span><span class=o>();</span>
        <span class=k>try</span><span class=o>{</span>
            <span class=n>sof</span><span class=o>.</span><span class=na>stackLeak</span><span class=o>();</span>
        <span class=o>}</span><span class=k>catch</span><span class=o>(</span><span class=n>Throwable</span> <span class=n>e</span><span class=o>){</span>
            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&quot;stackLength: &quot;</span><span class=o>+</span><span class=n>sof</span><span class=o>.</span><span class=na>stackLength</span><span class=o>);</span>
            <span class=k>throw</span> <span class=n>e</span><span class=o>;</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></div><input name=tab-group-3 type=radio id=tab-group-3-1_29ffu2ykoe8ail5 class=code-tab data-lang aria-controls=tab-group-3-1_29ffu2ykoe8ail5-panel role=tab><label for=tab-group-3-1_29ffu2ykoe8ail5 class=code-tab-label data-lang id=tab-group-3-1_29ffu2ykoe8ail5-label></label><div class=code-tabpanel role=tabpanel data-lang id=tab-group-3-1_29ffu2ykoe8ail5-panel aria-labelledby=tab-group-3-1_29ffu2ykoe8ail5-label><div class=codehilite><pre><span class=n>stackLength</span><span class=o>:</span> <span class=mi>17600</span>
<span class=n>Exception</span> <span class=k>in</span> <span class=n>thread</span> <span class=s2>&quot;main&quot;</span> <span class=n>java</span><span class=o>.</span><span class=na>lang</span><span class=o>.</span><span class=na>StackOverflowError</span>
    <span class=n>at</span> <span class=n>JavaVMStackOverFlowError</span><span class=o>.</span><span class=na>stackLeak</span><span class=o>(</span><span class=n>JavaVMStackOverFlowError</span><span class=o>.</span><span class=na>java</span><span class=o>:</span><span class=mi>5</span><span class=o>)</span>
<span class=o>...</span>
</pre></div></div></div>

<p>这两种异常其实存在着一些互相重叠的地方。实验结果表明：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是<C>StackOverflowError</C>异常。如果测试时不限于单线程，通过不断地建立线程的方式倒是可以产生内存溢出异常。</p>
<p>如果是建立过多线程导致内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。</p>
<h4 id="_10">方法区和运行时常量池溢出<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h4>
<p><C>String.intern()</C>是一个<C>Native</C>方法，他的作用是：如果字符串常量池中已经包含一个等于此<C>String</C>常量的字符串，则返回代表池中这个字符串的<C>String</C>对象；否则，将此<C>String</C>对象包含的字符串添加到常量池中，并且返回此<C>String</C>对象的引用。在JDK1.6及之前的版本中，由于常量池分配在永久代内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中的常量池的容量。</p>
<p>这意味着重复调用<C>String.intern()</C>在JDK1.6之前的版本中会抛出方法区(PermGen space) <C>OutOfMemoryError</C>，而在JDK1.7中，不会出现。</p>
<p> <div class=codehilite><pre> <span class=c1>//VM args:-XX:PermSize10M -XX:MaxPermSize=10M</span>
 <span class=c1>// PermSize 方法区大小</span>
<span class=kn>import</span> <span class=nn>java.util.ArrayList</span><span class=o>;</span>
<span class=kn>import</span> <span class=nn>java.util.List</span><span class=o>;</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>RuntimeContantPoolOutOfMemoryError</span> <span class=o>{</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>//保存对常量池字符串的应用，避免Full GC回收常量池的行为</span>
        <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;();</span>
        <span class=c1>//10M在int的范围足够产生OutOfMemoryError</span>
        <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
        <span class=k>while</span><span class=o>(</span><span class=kc>true</span><span class=o>){</span>
            <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>String</span><span class=o>.</span><span class=na>valueOf</span><span class=o>(</span><span class=n>i</span><span class=o>++));</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<h4 id="_11">本机直接内存溢出<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h4>
<p><C>DirectMemory</C>容量可以通过<code class="codehilite">-XX:Max<span class="nt">&lt;C&gt;</span>DirectMemory<span class="nt">&lt;/C&gt;</span>Size</code>指定，如果不指定，则默认与Java堆最大值（<code class="codehilite">-Xmx</code>  指定）一样。代码清单越过了<C>DirectByteBuffer</C>类，直接通过反射获取Unsafe实例进行内存分配（Unsafe类的getUnsafe方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有<code class="codehilite">rt.jar</code>中的类才能使用Unsafe的功能）。因为，虽然使用<C>DirectByteBuffer</C>分配内存也会抛出内存异常，但它抛出异常时并没有真正向操作系统申请内存分配，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是<C>unsafe.allocateMemory</C>.</p>
<p> <div class=codehilite><pre><span class=cm>/**</span>
<span class=cm> * VM Args: -Xmx20M -XX:Max&lt;C&gt;DirectMemory&lt;/C&gt;Size=10M</span>
<span class=cm> */</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=err>&lt;</span><span class=nc>C</span><span class=o>&gt;</span><span class=n>DirectMemory</span><span class=o>&lt;/</span><span class=n>C</span><span class=o>&gt;</span><span class=n>OOM</span> <span class=o>{</span>
    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>_1MB</span> <span class=o>=</span> <span class=mi>1024</span><span class=o>*</span><span class=mi>1024</span><span class=o>;</span>
    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>IllegalAccessException</span> <span class=o>{</span>
        <span class=n>Field</span> <span class=n>unsafeField</span> <span class=o>=</span> <span class=n>Unsafe</span><span class=o>.</span><span class=na>class</span><span class=o>.</span><span class=na>getDeclaredFields</span><span class=o>()[</span><span class=mi>0</span><span class=o>];</span>
        <span class=n>unsafeField</span><span class=o>.</span><span class=na>setAccessible</span><span class=o>(</span><span class=kc>true</span><span class=o>);</span>
        <span class=n>Unsafe</span> <span class=n>unsafe</span> <span class=o>=</span> <span class=o>(</span><span class=n>Unsafe</span><span class=o>)</span> <span class=n>unsafeField</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=kc>null</span><span class=o>);</span>
        <span class=k>while</span><span class=o>(</span><span class=kc>true</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>unsafe</span><span class=o>.</span><span class=na>allocateMemory</span><span class=o>(</span><span class=n>_1MB</span><span class=o>);</span>
        <span class=o>}</span>
    <span class=o>}</span>
<span class=o>}</span>
</pre></div></p>
<p>由<C>DirectMemory</C>导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果读者发现OOM之后Dump文件很小，而程序中又直接或者间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '../..';</script>
        <script src="../../js/base.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
        <script src="../../extra_javascript/tabhack.js"></script>
        <script src="../../search/require.js"></script>
        <script src="../../search/search.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td><kbd>&larr;</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td><kbd>&rarr;</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>


    </body>
</html>
