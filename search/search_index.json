{
    "docs": [
        {
            "location": "/", 
            "text": "Zhenhua's Notes\n\n\nThis site documents reading and learning notes.\n\n\nSearch\n\n\n\n  \n\n    \n\n      (function() {\n        var cx = '000491777875727507539:_gc3mx7cstg';\n        var gcse = document.createElement('script');\n        gcse.type = 'text/javascript';\n        gcse.async = true;\n        gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +\n            '//cse.google.com/cse.js?cx=' + cx;\n        var s = document.getElementsByTagName('script')[0];\n        s.parentNode.insertBefore(gcse, s);\n      })();\n    \n\n    \n\n  \n\n\n\n\n\nTOC\n\n\nSee \nTable of Contents\n.\n\n\nBooks and Materials\n\n\nSee \nBooks and Materials\n.\n\n\nRoadmap\n\n\nSee \nRoadmap\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#zhenhuas-notes", 
            "text": "This site documents reading and learning notes.", 
            "title": "Zhenhua's Notes"
        }, 
        {
            "location": "/#search", 
            "text": "(function() {\n        var cx = '000491777875727507539:_gc3mx7cstg';\n        var gcse = document.createElement('script');\n        gcse.type = 'text/javascript';\n        gcse.async = true;\n        gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +\n            '//cse.google.com/cse.js?cx=' + cx;\n        var s = document.getElementsByTagName('script')[0];\n        s.parentNode.insertBefore(gcse, s);\n      })();", 
            "title": "Search"
        }, 
        {
            "location": "/#toc", 
            "text": "See  Table of Contents .", 
            "title": "TOC"
        }, 
        {
            "location": "/#books-and-materials", 
            "text": "See  Books and Materials .", 
            "title": "Books and Materials"
        }, 
        {
            "location": "/#roadmap", 
            "text": "See  Roadmap .", 
            "title": "Roadmap"
        }, 
        {
            "location": "/osc/", 
            "text": "OSC\n\n\n\n\nChapter 1: Introduction \n\n\nChapter 2: Operating System structures\n\n\nChapter 3: Processes\n\n\nChapter 4: Threads and Concurrency\n\n\nChapter 5: CPU Scheduling\n\n\nChapter 6: Synchronization Tools\n\n\nChapter 7: Synchronization Examples\n\n\nChapter 8: Deadlocks\n\n\nChapter 9: Main Memory\n\n\nChapter 10: Virtual Memory\n\n\nChapter 11: Mass-Storage Structure\n\n\nChapter 13: File-System Interfaces", 
            "title": "Contents"
        }, 
        {
            "location": "/osc/#osc", 
            "text": "Chapter 1: Introduction   Chapter 2: Operating System structures  Chapter 3: Processes  Chapter 4: Threads and Concurrency  Chapter 5: CPU Scheduling  Chapter 6: Synchronization Tools  Chapter 7: Synchronization Examples  Chapter 8: Deadlocks  Chapter 9: Main Memory  Chapter 10: Virtual Memory  Chapter 11: Mass-Storage Structure  Chapter 13: File-System Interfaces", 
            "title": "OSC"
        }, 
        {
            "location": "/osc/ch1/", 
            "text": "Operating System Concepts 1 - Introduction\n\n\n1. What operating system do\n\n\nThere is no completely adequate definition of operating system. A simple viewpoint is that it includes everything a vendor ships. A more common definition is that the \noperating system is the one program running at all times on computer - usually  called \nkernel\n . \n\n\nThree main \npurposes\n of an operating system are,\n\n\n\n\nmanages a computer's hardware\n\n\nprovides a basis for application programs\n\n\nacts as an intermediary between the user and hardware\n\n\n\n\nThe operating system includes the always running \nkernel\n, \nmiddleware\n frameworks that ease application development and provide features, and \nsystem programs\n that aid in managing the system while it is running.\n\n\nAnything between the kernel and user applications is considered \nmiddleware\n(\u4e2d\u95f4\u4ef6) [\n1\n].\n\n\n2 Computer-system organisation\n\n\nA computer system can be divided roughly into four components: the \nhardware\n, the \noperating system\n, the \napplication programs\n, and a \nuser\n.\n\n\n\n\nA \ncomputer system\n(\u8ba1\u7b97\u673a\u7cfb\u7edf) consists of one or more \nCPUs\n and a number of \ndevice controllers\n(\u8bbe\u5907\u63a7\u5236\u5668) connected through a common \nbus\n(\u603b\u7ebf) that provides access between components and shared \nmemory\n.\n\n\nA \ndevice controller\n maintains some \nlocal buffer storage\n(\u5c40\u90e8\u7f13\u51b2\u5b58\u50a8) and a set of special-purpose \nregisters\n.\n\n\n\n\nTypically, operating systems have a \ndevice driver\n(\u8bbe\u5907\u9a71\u52a8) for each device controller. This device driver understands the device controller and provides the rest of the operating system with a uniform interface to the device\n\n\n\n\nInterrupt\n\n\nWhen the CPU is \ninterrupted\n, it stops what it is doing and immediately transfers execution to a fixed location. The fixed location usually contains the starting address where the service routine for the interrupt is located.\n\n\nThe \ninterrupt routine\n(\u4e2d\u65ad\u7a0b\u5e8f) is called indirectly through the interrupt vector table\uff08\u4e2d\u65ad\u5411\u91cf\u8868).\n\n\n\n\nGenerally, the table of pointers is stored in low memory (the first hundred or so locations).\n\n\nThese locations hold the addresses of the interrupt service routines for the various devices.\n\n\nInterrupt vector is then indexed by a unique number(interrupt vector number, \u4e2d\u65ad\u5411\u91cf\u53f7)\n\n\ninterrupt priority levels(\u4e2d\u65ad\u4f18\u5148\u7ea7)\n\n\n\n\n\n\nSome \nservices\n are provided outside of the kernel by system programs that are loaded into memory at boot time to become system \ndaemons\n, which run the entire time the kernel is running.\n\n\n![interrupt-driven I:O cycle](http://or9a8nskt.bkt.clouddn.com/interrupt-driven I:O cycle.png)\n\n\ninterrupt, exception, trap\n\n\nUnfortunately, there is no clear consensus as to the exact meaning of these terms(exceptions, faults, aborts, traps, and interrupts). Different authors adopt different terms to their own use [\nref\n].\n\n\ntrap\n(\u9677\u9631) or \nexception\n(\u5f02\u5e38): a software-generated interrupt either by an error\uff08e.g. division by zero, or invalid memory access or by a system call.\n* usual way to invoke a kernel routine (a system call) \n\n\ninterrupt\n(\u4e2d\u65ad):  generated by the hardware (devices like the hard disk, graphics card, I/O ports, etc).\n\n\nmultiprogramming and multitasking\n\n\nMultiprogramming\n(\u591a\u9053\u7a0b\u5e8f) explained:\n\n\n\n\nThe operating system \nkeeps several processes in memory\n simultaneously. \n\n\nThe operating system picks and begins to execute one of these processes.\n\n\nEventually, the process may have to wait for some task, such as an I/O operation, to complete.\n\n\nWhen that process needs to wait, the CPU \nswitches\n to another process, and so on.\n\n\nEventually, the first process finishes waiting and gets the CPU back. As long as at least one process needs to execute, the \nCPU is never idle\n.\n\n\n\n\nMultitasking\n(\u591a\u4efb\u52a1) is a logical \nextension\n of multiprogramming. In multitasking systems, the CPU executes multiple processes by switching among them, but the switches occur \nfrequently\n, providing the user with a \nfast\n response time.\n\n\ndual-mode\n\n\nIn order to ensure the proper execution of the system, we must be able to distinguish between the execution of operating-system code\uff08\nkernel mode\n\uff09and user-defined code (\nuser mode\n).\n\n\n\n\nMode bit\n(\u6a21\u5f0f\u4f4d), is added to the hardware of the computer to indicate the current mode: kernel (0) or user (1).\n\n\nThe concept of modes can be \nextended\n beyond two modes.\n\n\n\n\n\n\nprotection rings\n\uff08\u4fdd\u62a4\u73af) are mechanisms to protect data and functionality from faults (by improving fault tolerance) and malicious behavior (by providing computer security). \n\n\n\n\n\n\nFor intel processors, ring 0 is kernel mode and ring 3 is user mode\n\n\n\n\n\n\n\n\ntimer\n\n\nA timer (\u5b9a\u65f6\u5668) can  be set to interrupt the computer after a specified period( usually, 100s hz)\n\n\n\n\nA variable timer is generally implemented by a fixed-rate clock and a counter. \n\n\nThe operating system sets the counter. Every time the clock ticks, the counter is decremented. \n\n\nWhen the counter reaches 0, an interrupt occurs.\n\n\n\n\n7 virtualization\n\n\nvirtualization\n(\u865a\u62df\u5316) is a technology that allows us to abstract the hardware of a single computer into several different execution environments, thereby creating the illusion that \neach separate environment is running on its own private computer\n .\n* v.s. [different] Emulation involves simulating computer handware in software.\n\n\n\n\n8 Free and Open-Source OS\n\n\nOpen-source OS\n\n\n\n\nsource code available\n\n\nopposite: closed-source OS\n\n\n\n\nFree OS\n\n\n\n\nsource code available\n\n\nallow no-cost use, redistribution, and modification\n\n\n\n\nArguably, open-source code is \nmore secure\n than closed-source code because many more eyes are viewing the code.\n\n\ne.g. OS\n\n\n\n\nGNU/Linux\n\n\nFreeBSD\n\n\nSolaris", 
            "title": "Chapter 1: Introduction "
        }, 
        {
            "location": "/osc/ch1/#operating-system-concepts-1-introduction", 
            "text": "", 
            "title": "Operating System Concepts 1 - Introduction"
        }, 
        {
            "location": "/osc/ch1/#1-what-operating-system-do", 
            "text": "There is no completely adequate definition of operating system. A simple viewpoint is that it includes everything a vendor ships. A more common definition is that the  operating system is the one program running at all times on computer - usually  called  kernel  .   Three main  purposes  of an operating system are,   manages a computer's hardware  provides a basis for application programs  acts as an intermediary between the user and hardware   The operating system includes the always running  kernel ,  middleware  frameworks that ease application development and provide features, and  system programs  that aid in managing the system while it is running.  Anything between the kernel and user applications is considered  middleware (\u4e2d\u95f4\u4ef6) [ 1 ].", 
            "title": "1. What operating system do"
        }, 
        {
            "location": "/osc/ch1/#2-computer-system-organisation", 
            "text": "A computer system can be divided roughly into four components: the  hardware , the  operating system , the  application programs , and a  user .   A  computer system (\u8ba1\u7b97\u673a\u7cfb\u7edf) consists of one or more  CPUs  and a number of  device controllers (\u8bbe\u5907\u63a7\u5236\u5668) connected through a common  bus (\u603b\u7ebf) that provides access between components and shared  memory .  A  device controller  maintains some  local buffer storage (\u5c40\u90e8\u7f13\u51b2\u5b58\u50a8) and a set of special-purpose  registers .   Typically, operating systems have a  device driver (\u8bbe\u5907\u9a71\u52a8) for each device controller. This device driver understands the device controller and provides the rest of the operating system with a uniform interface to the device", 
            "title": "2 Computer-system organisation"
        }, 
        {
            "location": "/osc/ch1/#interrupt", 
            "text": "When the CPU is  interrupted , it stops what it is doing and immediately transfers execution to a fixed location. The fixed location usually contains the starting address where the service routine for the interrupt is located.  The  interrupt routine (\u4e2d\u65ad\u7a0b\u5e8f) is called indirectly through the interrupt vector table\uff08\u4e2d\u65ad\u5411\u91cf\u8868).   Generally, the table of pointers is stored in low memory (the first hundred or so locations).  These locations hold the addresses of the interrupt service routines for the various devices.  Interrupt vector is then indexed by a unique number(interrupt vector number, \u4e2d\u65ad\u5411\u91cf\u53f7)  interrupt priority levels(\u4e2d\u65ad\u4f18\u5148\u7ea7)    Some  services  are provided outside of the kernel by system programs that are loaded into memory at boot time to become system  daemons , which run the entire time the kernel is running.  ![interrupt-driven I:O cycle](http://or9a8nskt.bkt.clouddn.com/interrupt-driven I:O cycle.png)", 
            "title": "Interrupt"
        }, 
        {
            "location": "/osc/ch1/#interrupt-exception-trap", 
            "text": "Unfortunately, there is no clear consensus as to the exact meaning of these terms(exceptions, faults, aborts, traps, and interrupts). Different authors adopt different terms to their own use [ ref ].  trap (\u9677\u9631) or  exception (\u5f02\u5e38): a software-generated interrupt either by an error\uff08e.g. division by zero, or invalid memory access or by a system call.\n* usual way to invoke a kernel routine (a system call)   interrupt (\u4e2d\u65ad):  generated by the hardware (devices like the hard disk, graphics card, I/O ports, etc).", 
            "title": "interrupt, exception, trap"
        }, 
        {
            "location": "/osc/ch1/#multiprogramming-and-multitasking", 
            "text": "Multiprogramming (\u591a\u9053\u7a0b\u5e8f) explained:   The operating system  keeps several processes in memory  simultaneously.   The operating system picks and begins to execute one of these processes.  Eventually, the process may have to wait for some task, such as an I/O operation, to complete.  When that process needs to wait, the CPU  switches  to another process, and so on.  Eventually, the first process finishes waiting and gets the CPU back. As long as at least one process needs to execute, the  CPU is never idle .   Multitasking (\u591a\u4efb\u52a1) is a logical  extension  of multiprogramming. In multitasking systems, the CPU executes multiple processes by switching among them, but the switches occur  frequently , providing the user with a  fast  response time.", 
            "title": "multiprogramming and multitasking"
        }, 
        {
            "location": "/osc/ch1/#dual-mode", 
            "text": "In order to ensure the proper execution of the system, we must be able to distinguish between the execution of operating-system code\uff08 kernel mode \uff09and user-defined code ( user mode ).   Mode bit (\u6a21\u5f0f\u4f4d), is added to the hardware of the computer to indicate the current mode: kernel (0) or user (1).  The concept of modes can be  extended  beyond two modes.    protection rings \uff08\u4fdd\u62a4\u73af) are mechanisms to protect data and functionality from faults (by improving fault tolerance) and malicious behavior (by providing computer security).     For intel processors, ring 0 is kernel mode and ring 3 is user mode", 
            "title": "dual-mode"
        }, 
        {
            "location": "/osc/ch1/#timer", 
            "text": "A timer (\u5b9a\u65f6\u5668) can  be set to interrupt the computer after a specified period( usually, 100s hz)   A variable timer is generally implemented by a fixed-rate clock and a counter.   The operating system sets the counter. Every time the clock ticks, the counter is decremented.   When the counter reaches 0, an interrupt occurs.", 
            "title": "timer"
        }, 
        {
            "location": "/osc/ch1/#7-virtualization", 
            "text": "virtualization (\u865a\u62df\u5316) is a technology that allows us to abstract the hardware of a single computer into several different execution environments, thereby creating the illusion that  each separate environment is running on its own private computer  .\n* v.s. [different] Emulation involves simulating computer handware in software.", 
            "title": "7 virtualization"
        }, 
        {
            "location": "/osc/ch1/#8-free-and-open-source-os", 
            "text": "Open-source OS   source code available  opposite: closed-source OS   Free OS   source code available  allow no-cost use, redistribution, and modification   Arguably, open-source code is  more secure  than closed-source code because many more eyes are viewing the code.  e.g. OS   GNU/Linux  FreeBSD  Solaris", 
            "title": "8 Free and Open-Source OS"
        }, 
        {
            "location": "/osc/ch2/", 
            "text": "Operating System Concepts 2 - Operating System structures\n\n\n1 Operating system service\n\n\nThe figure below is a view of the various operating-system services and how they interrelate.\n\n\n\n\n2 User and Operating System interface\n\n\nThere're mainly three ways for users to interface with the operating system:\n\n\n\n\ncommand interpreter\n\n\ngraphical user interface\n\n\ntouch-screen interface\n\n\n\n\n3 System calls\n\n\nPurpose of System Call: System calls provide an \ninterface to the services\n made available by an operating system.\n\n\n\n\nExample\n\n\nA simple program to read data from one file and copy them to another file: \ncp in.txt out.txt\n. As you can see, even simple programs may make heavy use of the operating system.\n\n\n\n\n\n\nAPI\n\n\nTypically, application developers design programs according to an application programming interface(\nAPI\n, \u5e94\u7528\u7a0b\u5e8f\u7f16\u7a0b\u63a5\u53e3) rather than invoking \nactual system call\n.\n\n\n\n\nbecause even simple program may make heavy use of system call.\n\n\nprogram portabilit\ny: expect programs to compile and run other system that supports the same API\n\n\nrun-time environment\n(RTE, \u8fd0\u884c\u65f6\u73af\u5883) - the full suit of software needed to execute applications, including its compilers, interpreters, libraries, loaders.\n\n\n\n\nTypes of system calls\n\n\nSystem calls can be grouped roughly into six major categories:\n\u7cfb\u7edf\u8c03\u7528\u53ef\u5206\u6210\u516d\u5927\u7c7b\uff1a\u8fdb\u7a0b\u63a7\u5236\uff0c\u6587\u4ef6\u7ba1\u7406\uff0c\u8bbe\u5907\u7ba1\u7406\uff0c\u4fe1\u606f\u7ef4\u62a4\uff0c\u901a\u4fe1\u548c\u4fdd\u62a4\u3002\n\n\n\n\nprocess control\n\n\nfile management\n\n\ndevice management\n\n\ninformation maintenance\n\n\ncommunications\n\n\nprotection\n\n\n\n\n\n\nExample\n\n\nThe following illustrates various equivalent system calls for Windows and UNIX operating systems.\n\n\n\n\n\n\nThree ways to pass parameters to the operating system:\n\n\n\n\nwhen less than five parameters, passing the parameters in registers\n\n\nwhen more than five parameters, parameters are stored in a block, passing the address of the block in a register\n\n\nusing stack\n\n\n\n\n4 System Services\n\n\nSystem services\n, also known as \nsystem utilities\n, provide a convenient environment for program development and execution.\n\n\nThey can be divided into these categories:\n\n\n\n\nFile management\n\n\nStatus information\n\n\nFile modification\n\n\nProgram loading and execution\n\n\nCommunications\n\n\nBackground services\n\n\n\n\n7 OS Design and Implementation\n\n\nOne important principle of OS design is \nthe separation of \npolicy\n from \nmechanism\n . Mechanisms determine \nhow\n to do something; policies determine \nwhat\n will be done.\n\u64cd\u4f5c\u7cfb\u7edf\u8bbe\u8ba1\u7684\u4e00\u4e2a\u91cd\u8981\u539f\u5219\u662f\u7b56\u7565\uff08policy\uff09\u548c\u673a\u5236\uff08mechanism\uff09\u7684\u5206\u79bb\u3002\u673a\u5236\u51b3\u5b9a\u5982\u4f55\u505a\uff0c\u7b56\u7565\u51b3\u5b9a\u505a\u4ec0\u4e48\u3002\n\n\n\n\nThe separation of policy and mechanism is important for \nflexibility\n.\n\n\n\n\n8 Operating system structure\n\n\nMonolithic structure\n\n\nOperating systems with \nmonolithic structure\n (\u5355\u4f53\u7ed3\u6784) place all of the functionality of kernel into a \nsingle\n, \nstatic\n binary file that runs in a \nsingle\n address space.\n\n\n\n\na common technique for designing operating system\n\n\ne.g. original Unix operating system ( figure below)\n\n\n\n\n\n\n\n\ne.g. Linux is based on Unix and is structured similarly, as shown in figure below.\n\n\n\n\n\n\npros:\n\n\n\n\nsimplicity of kernels\n\n\na distinct performance advantage\n\n\nvery little overhead in the system-call interface\n\n\nfast communication within the kernel\n\n\n\n\ncons\n\n\n\n\ndifficult to implement and extend\n\n\n\n\nLayered\n\n\nA \nloosely coupled\n (\u677e\u8026\u5408) system is divided into separate, smaller components that have specific and limited functionality (\nmodular\n approach). All these components together comprise the kernel.\n\n\n\n\nchanges in one component affect only that component\n\n\n\n\nA system can be made modular in many ways.\n\n\n\n\none way is the layered approach.\n\n\n\n\nFor the \nlayered operating system\n (\u5c42\u6b21\u5f0f\u64cd\u4f5c\u7cfb\u7edf), it is broken into a number of layers.\n\n\n\n\nThe bottom layer is the hardware; the highest is the user interface.\n\n\nlow-level layers can be invoked by higher-level layers\n\n\n\n\n\n\npros:\n\n\n\n\nsimplicity of construction and debugging\n\n\neach layer is implemented only with operations provided by lower-level layers. \n\n\nhigher-level layers can be debugged without any concern for the lower-level layers\n\n\n\n\n\n\n\n\ncons:\n\n\n\n\ndifficulty of defining the functionality of each layer\n\n\npoor performance\n\n\noverhead of requiring a user program to traverse through multiple layers to obtain an operating-system service \n\n\n\n\n\n\n\n\nLayered systems have been successfully used in computer networks (such as TCP/IP) and web applications.\n\n\nMicrokernel\n\n\nAnother way to modularized the kernel is using \nmicrokernel\n(\u5fae\u5185\u6838) approach.\n\n\n\n\nRemoving all nonessential\n components from the kernel and implementing them as \nuser-level\n programs the reside in \nseparate\n address spaces.\n\n\nA smaller kernel.\n\n\n\n\nA typical microkernel shown below.\n\n\n\n\nPros\n:\n\n\n\n\neasy to extend the os\n\n\nall new services added to user space do not require modification of the kernel.\n\n\nwhen modification of kernel needed, changes tend to be fewer because of small kernel\n\n\n\n\n\n\nmore security and reliability\n\n\nsince most services are running as user\n\n\n\n\n\n\n\n\nCons\n:\n\n\n\n\nperformance may suffer due to increased system function overhead. Because messages of user-level services to communicate must be copied between the services. \n\n\n\n\nBest-known microkernel os is \nDarwin\n, the kernel component of the macOS and iOS.  \n\n\nModules\n\n\nPerhaps the best current methodology for operating system design involves using \nloadable kernel modules\n(LVMs, \u53ef\u88c5\u8f7d\u5185\u6838\u6a21\u5757). Here, the kernel has a set of core components and can link in additional services via modules, either at boot time or during run time.\n\n\n\n\ndesign purpose: for the kernel to provide core services, while other services are implemented \ndynamically\n, as the kernel is running\n\n\n\n\n\n\nExample\n\n\nYou can list all Linux kernel modules that are currently loaded, by entering the command \nlsmod\n(lists name, size, and where the module is being used). \n\n\nLinux kernel modules are loaded(inserted) using the \ninsmod\n command, and are removed using the \nrmmod\n command.\n\n\n\n\nHybrid systems\n\n\nIn practice, \nvery few\n operating system adopt a single, strictly defined structure. Instead, they \ncombine different structures\n, resulting in \nhybrid systems\n that address performance, security, and usability issues.\n\n\nArchitecture of Apple\u2019s macOS and iOS operating systems:\n\n\n\n\nDarwin provides two system-call interfaces: Mach system calls and BSD system calls.\n\n\nThe structure of Darwin:\n\n\nTo address such performance problems, Darwin combines Mach, BSD, the I/O kit, and any kernel extensions into a \nsingle\n address space.\n\n\ndetailed documents for \n\n\n\n\n9 System boot\n\n\nThe process of starting a computer by loading the kernel is known as \nbooting\n the system.\n\n\n\n\nA small piece of code known as the \nbootstrap program\n(\u5f15\u5bfc\u7a0b\u5e8f) or boot loader locates the kernel.\n\n\nThe kernel is loaded into memory and started.\n\n\nThe kernel initializes hardware.\n\n\nThe root file system is mounted.\n\n\n\n\nBootstrap program:\n\n\n\n\nusually, bootstrap program located in BIOS( nonvolatile firmware(\u56fa\u4ef6) on motherboard, \nwiki\n)\n\n\nGRUB\n is an open-source bootstrap program for Linux and Unix systems \nwiki\n.", 
            "title": "Chapter 2: Operating System structures"
        }, 
        {
            "location": "/osc/ch2/#operating-system-concepts-2-operating-system-structures", 
            "text": "", 
            "title": "Operating System Concepts 2 - Operating System structures"
        }, 
        {
            "location": "/osc/ch2/#1-operating-system-service", 
            "text": "The figure below is a view of the various operating-system services and how they interrelate.", 
            "title": "1 Operating system service"
        }, 
        {
            "location": "/osc/ch2/#2-user-and-operating-system-interface", 
            "text": "There're mainly three ways for users to interface with the operating system:   command interpreter  graphical user interface  touch-screen interface", 
            "title": "2 User and Operating System interface"
        }, 
        {
            "location": "/osc/ch2/#3-system-calls", 
            "text": "Purpose of System Call: System calls provide an  interface to the services  made available by an operating system.   Example  A simple program to read data from one file and copy them to another file:  cp in.txt out.txt . As you can see, even simple programs may make heavy use of the operating system.", 
            "title": "3 System calls"
        }, 
        {
            "location": "/osc/ch2/#api", 
            "text": "Typically, application developers design programs according to an application programming interface( API , \u5e94\u7528\u7a0b\u5e8f\u7f16\u7a0b\u63a5\u53e3) rather than invoking  actual system call .   because even simple program may make heavy use of system call.  program portabilit y: expect programs to compile and run other system that supports the same API  run-time environment (RTE, \u8fd0\u884c\u65f6\u73af\u5883) - the full suit of software needed to execute applications, including its compilers, interpreters, libraries, loaders.", 
            "title": "API"
        }, 
        {
            "location": "/osc/ch2/#types-of-system-calls", 
            "text": "System calls can be grouped roughly into six major categories:\n\u7cfb\u7edf\u8c03\u7528\u53ef\u5206\u6210\u516d\u5927\u7c7b\uff1a\u8fdb\u7a0b\u63a7\u5236\uff0c\u6587\u4ef6\u7ba1\u7406\uff0c\u8bbe\u5907\u7ba1\u7406\uff0c\u4fe1\u606f\u7ef4\u62a4\uff0c\u901a\u4fe1\u548c\u4fdd\u62a4\u3002   process control  file management  device management  information maintenance  communications  protection    Example  The following illustrates various equivalent system calls for Windows and UNIX operating systems.    Three ways to pass parameters to the operating system:   when less than five parameters, passing the parameters in registers  when more than five parameters, parameters are stored in a block, passing the address of the block in a register  using stack", 
            "title": "Types of system calls"
        }, 
        {
            "location": "/osc/ch2/#4-system-services", 
            "text": "System services , also known as  system utilities , provide a convenient environment for program development and execution.  They can be divided into these categories:   File management  Status information  File modification  Program loading and execution  Communications  Background services", 
            "title": "4 System Services"
        }, 
        {
            "location": "/osc/ch2/#7-os-design-and-implementation", 
            "text": "One important principle of OS design is  the separation of  policy  from  mechanism  . Mechanisms determine  how  to do something; policies determine  what  will be done.\n\u64cd\u4f5c\u7cfb\u7edf\u8bbe\u8ba1\u7684\u4e00\u4e2a\u91cd\u8981\u539f\u5219\u662f\u7b56\u7565\uff08policy\uff09\u548c\u673a\u5236\uff08mechanism\uff09\u7684\u5206\u79bb\u3002\u673a\u5236\u51b3\u5b9a\u5982\u4f55\u505a\uff0c\u7b56\u7565\u51b3\u5b9a\u505a\u4ec0\u4e48\u3002   The separation of policy and mechanism is important for  flexibility .", 
            "title": "7 OS Design and Implementation"
        }, 
        {
            "location": "/osc/ch2/#8-operating-system-structure", 
            "text": "", 
            "title": "8 Operating system structure"
        }, 
        {
            "location": "/osc/ch2/#monolithic-structure", 
            "text": "Operating systems with  monolithic structure  (\u5355\u4f53\u7ed3\u6784) place all of the functionality of kernel into a  single ,  static  binary file that runs in a  single  address space.   a common technique for designing operating system  e.g. original Unix operating system ( figure below)     e.g. Linux is based on Unix and is structured similarly, as shown in figure below.    pros:   simplicity of kernels  a distinct performance advantage  very little overhead in the system-call interface  fast communication within the kernel   cons   difficult to implement and extend", 
            "title": "Monolithic structure"
        }, 
        {
            "location": "/osc/ch2/#layered", 
            "text": "A  loosely coupled  (\u677e\u8026\u5408) system is divided into separate, smaller components that have specific and limited functionality ( modular  approach). All these components together comprise the kernel.   changes in one component affect only that component   A system can be made modular in many ways.   one way is the layered approach.   For the  layered operating system  (\u5c42\u6b21\u5f0f\u64cd\u4f5c\u7cfb\u7edf), it is broken into a number of layers.   The bottom layer is the hardware; the highest is the user interface.  low-level layers can be invoked by higher-level layers    pros:   simplicity of construction and debugging  each layer is implemented only with operations provided by lower-level layers.   higher-level layers can be debugged without any concern for the lower-level layers     cons:   difficulty of defining the functionality of each layer  poor performance  overhead of requiring a user program to traverse through multiple layers to obtain an operating-system service      Layered systems have been successfully used in computer networks (such as TCP/IP) and web applications.", 
            "title": "Layered"
        }, 
        {
            "location": "/osc/ch2/#microkernel", 
            "text": "Another way to modularized the kernel is using  microkernel (\u5fae\u5185\u6838) approach.   Removing all nonessential  components from the kernel and implementing them as  user-level  programs the reside in  separate  address spaces.  A smaller kernel.   A typical microkernel shown below.   Pros :   easy to extend the os  all new services added to user space do not require modification of the kernel.  when modification of kernel needed, changes tend to be fewer because of small kernel    more security and reliability  since most services are running as user     Cons :   performance may suffer due to increased system function overhead. Because messages of user-level services to communicate must be copied between the services.    Best-known microkernel os is  Darwin , the kernel component of the macOS and iOS.", 
            "title": "Microkernel"
        }, 
        {
            "location": "/osc/ch2/#modules", 
            "text": "Perhaps the best current methodology for operating system design involves using  loadable kernel modules (LVMs, \u53ef\u88c5\u8f7d\u5185\u6838\u6a21\u5757). Here, the kernel has a set of core components and can link in additional services via modules, either at boot time or during run time.   design purpose: for the kernel to provide core services, while other services are implemented  dynamically , as the kernel is running    Example  You can list all Linux kernel modules that are currently loaded, by entering the command  lsmod (lists name, size, and where the module is being used).   Linux kernel modules are loaded(inserted) using the  insmod  command, and are removed using the  rmmod  command.", 
            "title": "Modules"
        }, 
        {
            "location": "/osc/ch2/#hybrid-systems", 
            "text": "In practice,  very few  operating system adopt a single, strictly defined structure. Instead, they  combine different structures , resulting in  hybrid systems  that address performance, security, and usability issues.  Architecture of Apple\u2019s macOS and iOS operating systems:   Darwin provides two system-call interfaces: Mach system calls and BSD system calls.  The structure of Darwin:  To address such performance problems, Darwin combines Mach, BSD, the I/O kit, and any kernel extensions into a  single  address space.  detailed documents for", 
            "title": "Hybrid systems"
        }, 
        {
            "location": "/osc/ch2/#9-system-boot", 
            "text": "The process of starting a computer by loading the kernel is known as  booting  the system.   A small piece of code known as the  bootstrap program (\u5f15\u5bfc\u7a0b\u5e8f) or boot loader locates the kernel.  The kernel is loaded into memory and started.  The kernel initializes hardware.  The root file system is mounted.   Bootstrap program:   usually, bootstrap program located in BIOS( nonvolatile firmware(\u56fa\u4ef6) on motherboard,  wiki )  GRUB  is an open-source bootstrap program for Linux and Unix systems  wiki .", 
            "title": "9 System boot"
        }, 
        {
            "location": "/osc/ch3/", 
            "text": "Operating System Concepts 3 - Processes\n\n\n1 Process concept\n\n\nThe process\n\n\nProcess\n (\u8fdb\u7a0b) is a program in execution.\n\n\n\n\nProcess is the unit of work in a modern computing system.\n\n\n\n\nThe status of the \ncurrent\n activity of a process is represented by the value of the \nprogram counter\n and the contents of the processor's \nregisters\n.\n\n\nA program by itself is not a process.\n\n\n\n\nA program is a \npassive\n entity, such as a file containing a list of instructions stored on disk.\n\n\nA process is an \nactive\n entity, with a program counter specifying the next instruction to execute.\n\n\n\n\nProcess state\n\n\nA process may be in one of the following states:\n\n\n\n\nNew\n(\u65b0\u5efa). The process is being created. \u8fdb\u7a0b\u6b63\u5728\u88ab\u521b\u5efa\n\n\nRunning\n(\u8fd0\u884c). Instructions are being executed. \u6307\u4ee4\u6b63\u5728\u88ab\u6267\u884c\n\n\nWaiting\n(\u7b49\u5f85). The process is waiting for some event to occur(such as an I/O completion or reception of a signal). \u8fdb\u7a0b\u7b49\u5f85\u67d0\u4e9b\u4e8b\u4ef6\u53d1\u751f\n\n\nReady\n(\u5c31\u7eea). The process is waiting to be assigned to a processor.\u8fdb\u7a0b\u7b49\u5f85\u5206\u914d\u5904\u7406\u5668\n\n\nTerminated\n(\u7ec8\u6b62). The process has finished execution. \u8fdb\u7a0b\u6267\u884c\u5b8c\u6bd5\n\n\n\n\nDiagram of process state:\n\n\n\n\nProcess control block\n\n\nEach process is represented by a \nprocess control block\n(PCB, \u8fdb\u7a0b\u63a7\u5236\u5757), it contains\n\n\n\n\nProcess state\n(\u8fdb\u7a0b\u72b6\u6001)\n\n\nProgram counter\n(\u7a0b\u5e8f\u8ba1\u6570\u5668)\n\n\nCPU registers\n(CPU\u5bc4\u5b58\u5668)\n\n\nCPU-scheduling information\n(CPU\u8c03\u5ea6\u4fe1\u606f): a process priority, pointers to scheduling queues, and any other scheduling parameters.\n\n\nMemory-management information\n(\u5185\u5b58\u7ba1\u7406\u4fe1\u606f)\n\n\nAccounting information\n(\u8bb0\u8d26\u4fe1\u606f): the amount of CPU and real time used, time limits, account numbers, process numbers and so on.\n\n\nI/O status information\n(I/O\u72b6\u6001\u4fe1\u606f): the list of I/O devices allocated to the process, a list of open files.\n\n\n\n\nProcess Control Block:\n\n\n\n\nThe process control block in Linux is represented by the C structure \ntask_struct\n ('include/linux/sched.h')\uff0c \nCODE LINK\n\n\n\n\nWithin the Linux kernel, all active processes are represented using a \ndoubly linked list\n of task struct.\n\n\n\n\nTask_strut\n:\n\n\n\n\n2 Process scheduling\n\n\nThe \nprocess scheduler\n(\u8fdb\u7a0b\u8c03\u5ea6\u7a0b\u5e8f) selects an available process for program execution on a core.\n\n\n\n\nEach CPU core can run one process at a time.\n\n\nThe number of processes currently in memory is known as the \ndegree of multiprogramming\n.\n\n\n\n\nScheduling Queues\n\n\nReady queue\n(\u5c31\u7eea\u961f\u5217): the status of processes are ready.\n* generally stored as a linked list, its header contains pointers to the first PCB in the list, each PCB includes a pointer field that points to next PCB in the ready queue.\n\n\nWait Queue\n(\u7b49\u5f85\u961f\u5217): the status of processes are waiting.\n\n\nQueueing-diagram representation of process scheduling: \n\n\n\n\ncontext switch\n\n\nHere the \ncontext\n of a process is represented in the PCB of the process, including the value of the CPU registers, the process state, and memory-management information.\n\n\nAn operating system performs a \ncontext switch\n\uff08\u4e0a\u4e0b\u6587\u5207\u6362) when it switches from running one process to running another.\n\n\n\n\nThe kernel \nsaves\n the context of the old process into its PCB and \nrestore\n the saved context of the new process scheduled to run.\n\n\nContext-switch time is overhead; the system does no useful work while switching. \n\n\nA typical speed is a several microseconds. \n\n\n\n\n\n\nContext-switch times are \nhighly\n dependent on hardware support.\n\n\n\n\nContext switch from an old process to a new process:\n\n\n\n\n3 Operating on Processes\n\n\nProcess creation\n\n\nA process may \ncreate\n several new processes.\n\n\n\n\nthe creating process is called a \nparent process\n.\n\n\nthe new process is called a \nchild process\n .\n\n\n\n\n\n\nProcess termination\n\n\nA process \nterminates\n when it finishes executing its final statement and asks the operating system to delete it by using the \nexit()\n system call.\n\n\n\n\ncascading termination\n(\u7ea7\u8054\u7ec8\u6b62):  if a process terminates (either normally or abnormally), then all its children must also be terminated. \n\n\nA process that has terminated, but whose parent has not yet called \nwait()\n, is known as a \nzombie process\n(\u50f5\u5c38\u8fdb\u7a0b).\n\n\nif a parent did not invoke \nwait()\n and instead terminated, then leaving its child processes as \norphan processes\n(\u5b64\u513f\u8fdb\u7a0b).\n\n\nUnix system may assign the \ninit\n process as the new parent to orphan processes, and the \ninit\n process periodically invokes \nwait()\n.\n\n\n\n\n\n\n\n\n\n\nExample\n\n\nA problem with a single process for a web browser is that if a web application in any tab crashes, the entire process \u2014\u2014 including all other tabs \u001f\u001f\u2014\u2014 crashes as well. Chrome web browser uses a multiprocess architecture \u2014\u2014 identifies three different types of processes: browser, renderers, plugins. see \nhere\n in detail.\n\n\n\n\n4 Interprocess communication\n\n\nProcesses may be either \nindependent processes\n(\u72ec\u7acb\u8fdb\u7a0b) or \ncooperating processes\n(\u534f\u540c\u8fdb\u7a0b).\n\n\n\n\nA process is \nindependent\n if it does not share data with any other processes executing in the system.\n\n\nA process is \ncooperating\n if it can affect or be affected by the other processes executing in the system.\n\n\n\n\nAdvantages of  process cooperation:\n\n\n\n\nInformation sharing \n\n\nComputation speedup \n\n\nModularity \n\n\n\n\nCooperating process require an \ninterprocess communication\n (IPC\uff0c\u8fdb\u7a0b\u95f4\u901a\u4fe1) mechanism that will allow them to \nexchange\n data. There are two fundamental models of IPC:\n\n\n\n\nshared memory\n(\u5171\u4eab\u5185\u5b58): a region of memory is shared by cooperating process. Process can exchange information by reading and writing data to the shared region.\n\n\nShared memory can be \nfaster\n than message passing.\n\n\n\n\n\n\nmessage passing\n(\u6d88\u606f\u4f20\u9012)\uff1a communication takes place by means of messages exchanged between the cooperating processes.\n\n\nMessage passing is useful for exchanging \nsmaller\n amounts of data, because no conflicts need be avoided.\n\n\nMessage passing is easier to implement in a distributed system than shared memory.\n\n\n\n\n\n\n\n\n\n\n5 IPC in shared-memory system\n\n\nLet's consider the producer-consumer problem, which is a common paradigm for cooperating processes. A \nproducer\n process produces information that is \nconsumed\n by a consumer process.  One solution to the producer-consumer problem uses shared memory.\n\n\nWe generally think of a server as a producer and a client as a consumer. For example, a web server produces web content such as HTML files and images, which are consumed by the client web browser requesting the resource.\n\n\nTwo types of buffers can be used.\n\n\n\n\nunbounded buffer\n(\u65e0\u754c\u7f13\u51b2): places no practical limit on the size of the buffer.\n\n\nbounded buffer\n(\u6709\u754c\u7f13\u51b2): assumes a fixed buffer size\n\n\n\n\n6 IPC in message-passing system\n\n\nA message-passing facility provides at least two operations:\n\n\n\n\nsend(message)\n\n\nreceive(message)\n\n\n\n\nIf P and Q wish to communicate, they need to\n\n\n\n\nestablish a \ncommunication link\n(\u901a\u4fe1\u8fde\u63a5) between them\n\n\nexchange messages via send/receive \n\n\n\n\nHere are several methods for logically implementing a \ncommunication link\n between processes:\n\n\n\n\nDirect or indirect communication \u76f4\u63a5/\u95f4\u63a5\u901a\u4fe1\n\n\nSynchronous or asynchronous communication \u540c\u6b65/\u5f02\u6b65\u540c\u6b65\n\n\nAutomatic or explicit buffering \u81ea\u52a8/\u663e\u5f0f\u7f13\u51b2\n\n\n\n\nDirect/Indirect communication\n\n\n....Direct Communication\n\n\nUnder \ndirect communication\n, each process that wants to communicate must explicitly name the recipient or sender of the communication.\n\n\n\n\nsend(P, message) - send a message to process P.\n\n\nreceive(Q, message) - receive a message from process Q\n\n\n\n\nA communication link in this scheme has the following properties:\n\n\n\n\nA link is established \nautomatically\n between every pair of processes that want to communicate.\n\n\nA link is associated with \nexactly two\n processes.\n\n\nBetween each pair of processes, there exists exactly one link.\n\n\n\n\nCons:\n\n\n\n\nlimited modularity of the resulting process definitions. Changing the identifier of a process may necessitate examining all other process definitions.\n\n\nany such hard-coding techniques, are less desirable.\n\n\n\n\n....Indirect Communication\n\n\nWith \nindirect communication\n, the message are sent to and receive from \nmailboxes\n, or \nports\n.\n\n\n\n\nsend(A, message) - send a message to mailbox A\n\n\nreceive(A, message) - receive a message from mailbox A\n\n\n\n\nA mailbox can be viewed abstractly as an object into which messages can be placed by processes and from which messages can be removed.\n\n\n\n\nEach mailbox has an \nunique\n identification.\n\n\nTwo processes can communicate only if they have a shared mailbox.\n\n\n\n\nIn this scheme, a communication link has the following properties:\n\n\n\n\nA link is established between a pair of processes only if both members of the pair have a shared mailbox.\n\n\nA link may be associated with more than two processes.\n\n\nBetween each pair of communicating processes, a number of different links may exist, with each link corresponding to one mailbox.\n\n\n\n\nA mailbox may be owned either by a process or by the operating system.\n\n\nIf the mailbox is owned by a process\n\n We distinguish between the \nowner\n (which can only receive messages through his mailbox) and the \nuser\n (which can only send messages to the mailbox)\n\n Each mailbox has a unique owner.\n\n When a process that owns a mailbox terminates, the mailbox disappears.\n\n The process that creates a new mailbox is that mailbox's owner by default.\n\n\nSynchronization\n\n\nMessage passing may be either \nblocking\n or \nnonblocking\n - also known as \nsynchronous\n and \nasynchronous\n.\n\n\nBuffering\n\n\nMessages exchanged by communicating processes reside in a temporary queue, whether communication is direct or indirect. Basically, it can be implemented in three ways:\n\n\n\n\nZero capacity\uff08\u96f6\u5bb9\u91cf\uff09-- no buffering\n\n\nThe link cannot have any messages waiting in it.\n\n\nThe sender must block until the recipient receives the message. \n\n\n\n\n\n\nBounded capacity\uff08\u6709\u754c\u5bb9\u91cf\uff09-- automatic buffering\n\n\nThe queue has finite length n, at most n message can reside in it.   \n\n\nThe sender must block until space is available in the queue if the link is full.    \n\n\n\n\n\n\nUnbounded capacity \uff08\u65e0\u754c\u5bb9\u91cf\uff09 -- automatic buffering\n\n\nAny number of messages can wait in it.\n\n\nThe sender never blocks. \n\n\n\n\n\n\n\n\n7 Examples of IPC Systems\n\n\nPOSIX Shared Memory\n\n\nHere, we explore the POSIX API for shared memory. POSIX shared memory is organized using \nmemory-mapped files\n (\u5185\u5b58\u6620\u5c04\u6587\u4ef6), which associate the region of shared memory with a file. A process must first create a shared-memory object using the \nshm_open()\n system call.\n\nfd\n \n=\n \nshm_open\n(\nname\n,\n \nO_CREAT\n \n|\n \nO_RDWR\n,\n \n0666\n);\n\n\nftruncate\n(\nfd\n,\n \n4096\n);\n\n\nmmap\n(\n0\n,\n \nSIZE\n,\n \nPROT_READ\n \n|\n \nPROT_WRITE\n,\n \nMAP_SHARED\n,\n \nfd\n,\n \n0\n);\n\n\n\n\n\n\nA successful call to \nshm_open()\n returns an integer file descriptor for the shared-memory object.\n\n\nOnce the object is established, the \nftruncate()\n function is used to configure the size of the object in bytes.\n\n\nFinally, the \nmmap()\n function establishes a memory-mapped file containing the shared-memory object. It returns a pointer to the shared\n\n\n\n\n\n\n#include\n \nstdio.h\n\n\n#include\n \nstdlib.h\n\n\n#include\n \nunistd.h\n\n\n#include\n \nfcntl.h\n\n\n#include\n \nsys/shm.h\n\n\n#include\n \nsys/stat.h\n\n\n#include\n \nsys/mman.h\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nconst\n \nchar\n \n*\nname\n \n=\n \nOS\n;\n\n    \nconst\n \nint\n \nSIZE\n \n=\n \n4096\n;\n\n\n    \nint\n \nshm_fd\n;\n\n    \nvoid\n \n*\nptr\n;\n\n    \nint\n \ni\n;\n\n\n    \n/* open the shared memory segment */\n\n    \nshm_fd\n \n=\n \nshm_open\n(\nname\n,\n \nO_RDONLY\n,\n \n0666\n);\n\n    \nif\n \n(\nshm_fd\n \n==\n \n-\n1\n)\n \n{\n\n        \nprintf\n(\nshared memory failed\n\\n\n);\n\n        \nexit\n(\n-\n1\n);\n\n    \n}\n\n\n    \n/* now map the shared memory segment in the address space of the process */\n\n    \nptr\n \n=\n \nmmap\n(\n0\n,\nSIZE\n,\n \nPROT_READ\n,\n \nMAP_SHARED\n,\n \nshm_fd\n,\n \n0\n);\n\n    \nif\n \n(\nptr\n \n==\n \nMAP_FAILED\n)\n \n{\n\n        \nprintf\n(\nMap failed\n\\n\n);\n\n        \nexit\n(\n-\n1\n);\n\n    \n}\n\n\n    \n/* now read from the shared memory region */\n\n    \nprintf\n(\n%s\n,(\nchar\n \n*\n)\nptr\n);\n\n\n    \n/* remove the shared memory segment */\n\n    \nif\n \n(\nshm_unlink\n(\nname\n)\n \n==\n \n-\n1\n)\n \n{\n\n        \nprintf\n(\nError removing %s\n\\n\n,\nname\n);\n\n        \nexit\n(\n-\n1\n);\n\n    \n}\n\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\nMach Message Passing\n\n\nMach was especially designed for distributed systems. Its kernel supports the creation and destruction of multiple \ntasks\n, which are similar to processes but have multiple threads of control and fewer associated resources.  \n\n\nMessages are sent to, and received from, mailboxes, which are called \nports\n in Mach. \n\n\n\n\nPorts are \nfinite in size\n and \nunidirectional\n.\n\n\nFor two-way communication, a message is sent to one port, and a response is sent to a separate \nreply\n port.\n\n\nAssociated with each port is a collection of \nport rights\n, which  identify the capabilities necessary for a task to interact with the port.\n\n\n\n\nFunctions:\n\n\n\n\nmach_port_allocate()\n creates a new port and allocates space for its queue of messages.\n\n\nmach_msg()\n is the standard API for both sending and receiving messages.\n\n\n\n\n#include\n \nmach/mach.h\n\n\n\nstruct\n \nmessage\n \n{\n\n    \nmach_msg_header_t\n \nheader\n;\n\n    \nint\n \ndata\n;\n\n\n};\n\n\n\nmach_port_t\n \nclient\n;\n\n\nmach_port_t\n \nserver\n;\n\n\n\n/* Client Code */\n\n\n\nstruct\n \nmessage\n \nmessage\n;\n\n\n\n// construct the header\n\n\nmessage\n.\nheader\n.\nmsgh_size\n \n=\n \nsizeof\n(\nmessage\n);\n\n\nmessage\n.\nheader\n.\nmsgh_remote_port\n \n=\n \nserver\n;\n\n\nmessage\n.\nheader\n.\nmsgh_local_port\n \n=\n \nclient\n;\n\n\n\n// send the message\n\n\nmach\n \nmsg\n(\nmessage\n.\nheader\n,\n \n// message header\n\n         \nMACH_SEND_MSG\n,\n \n// sending a message\n\n         \nsizeof\n(\nmessage\n),\n \n// size of message sent\n\n         \n0\n,\n \n// maximum size of received message - unnecessary\n\n         \nMACH_PORT_NULL\n,\n \n// name of receive port - unnecessary\n\n         \nMACH_MSG_TIMEOUT_NONE\n,\n \n// no time outs MACH PORT NULL // no notify port\n\n\n);\n\n\n\n/* Server Code */\n\n\n\nstruct\n \nmessage\n \nmessage\n;\n\n\n\n// receive the message\n\n\nmach_msg\n(\nmessage\n.\nheader\n,\n \n// message header\n\n  \nMACH_RCV_MSG\n,\n \n// sending a message  0, // size of message sent\n\n  \nsizeof\n(\nmessage\n),\n \n// maximum size of received message\n\n  \nserver\n,\n \n// name of receive port\n\n  \nMACH_MSG_TIMEOUT_NONE\n,\n \n// no time outs\n\n  \nMACH_PORT_NULL\n \n// no notify port\n\n\n);\n\n\n\n\n\nPipes\n\n\nA \npipe\n acts as a conduit allowing two processes to communicate. Pipes were one of the first IPC mechanisms in early UNIX systems. There are two common types of pipes used on both UNIX and Windows systems: \nordinary pipes\n and \nnamed pipes\n.\n\n\nOrdinary pipes\n\n\nOrdinary pipes\n allow two processes to communicate in standard producer-consumer fashion: the producer writes to one end of the pipe (the \nwrite end\n) and the consumer reads from the other end (the \nread end\n).\n\n\n\n\nOrdinary pipes are \nunidirectional\n, allowing only one-way communication.\n\n\nFunction \npipe(int fd[])\n constructs an ordinary pipe, where \nfd\n is a file descriptor.\n\n\nUNIX treats a pipe as \na special type of file\n. Pipes can be accessed using ordinary \nread()\n and \nwrite()\n system calls.\n\n\nOrdinary pipes \nexit only\n while the processes are communicating with each other.\n\n\n\n\n\n\n#include\n \nsys/types.h\n\n\n#include\n \nstdio.h\n\n\n#include\n \nstring.h\n\n\n#include\n \nunistd.h\n\n\n\n#define BUFFER_SIZE 25\n\n\n#define READ_END 0\n\n\n#define WRITE_END 1\n\n\n\nint\n \nmain\n(\nvoid\n)\n\n\n{\n\n        \nchar\n \nwrite_msg\n[\nBUFFER_SIZE\n]\n \n=\n \nGreetings\n;\n\n        \nchar\n \nread_msg\n[\nBUFFER_SIZE\n];\n\n        \nint\n \nfd\n[\n2\n];\n\n        \npid_t\n \npid\n;\n\n\n        \n/* create the pipe */\n\n        \nif\n \n(\npipe\n(\nfd\n)\n \n==\n \n-\n1\n){\n\n                \nfprintf\n(\nstderr\n,\n \nPipe failed\n);\n\n                \nreturn\n \n1\n;\n\n        \n}\n\n\n        \n/* fork a child process */\n\n        \npid\n \n=\n \nfork\n();\n\n\n        \nif\n \n(\npid\n0\n){\n \n/* parent process */\n\n                \nclose\n(\nfd\n[\nREAD_END\n]);\n/* close the unused end of the pipe */\n\n                \nwrite\n(\nfd\n[\nWRITE_END\n],\n \nwrite_msg\n,\n \nstrlen\n(\nwrite_msg\n)\n+\n1\n);\n \n/* write to the pipe */\n\n                \nclose\n(\nfd\n[\nWRITE_END\n]);\n  \n/* close the write end of the pipe */\n\n        \n}\n\n        \nelse\n \nif\n \n(\npid\n==\n0\n){\n \n/* child process */\n\n                \nclose\n(\nfd\n[\nWRITE_END\n]);\n \n/* close the unused end of the pipe */\n\n                \nread\n(\nfd\n[\nREAD_END\n],\n \nread_msg\n,\n \nBUFFER_SIZE\n);\n \n/* read from the pipe */\n\n                \nprintf\n(\nread: %s\n\\n\n,\n \nread_msg\n);\n\n                \nclose\n(\nfd\n[\nREAD_END\n]);\n \n/* close the read end of the pipe */\n\n        \n}\n\n        \nreturn\n \n0\n;\n\n\n\n}\n\n\n\n\n\nNamed pipes\n\n\nNamed pipes\n\uff08\u547d\u540d\u7ba1\u9053\uff09 can be \nbidirectional\n, and no parent-child relationship is required.\n\n\n\n\nNamed pipes are referred to as \nFIFOs\n in UNIX system.\n\n\nOnce created, they appear as typical files in the file system.\n\n\nThe communicating processes for named pipes must reside on the same machine.\n\n\n\n\nA FIFO is created with the \nmkfifo()\n system call and manipulated with the ordinary \nopen()\n, \nread()\n, \nwrite()\n, and \nclose\n system calls.\uff1a\n\n\nint\n \nmkfifo\n(\nconst\n \nchar\n \n*\nfilename\n,\n \nmode_t\n \nmode\n);\n\n\n\n\n\nThe program \nfifowrite.c\n is as follows.\n\n\n#include\nsys/types.h\n\n\n#include\nstdlib.h\n\n\n#include\nstdio.h\n\n\n#include\nfcntl.h\n\n\n#include\nlimits.h\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nconst\n \nchar\n \n*\nfifo_name\n \n=\n \n/tmp/my_fifo\n;\n\n    \nint\n \npipe_fd\n \n=\n \n-\n1\n;\n\n    \nint\n \ndata_fd\n \n=\n \n-\n1\n;\n\n    \nint\n \nres\n \n=\n \n0\n;\n\n    \nconst\n \nint\n \nopen_mode\n \n=\n \nO_WRONLY\n;\n\n    \nchar\n \nbuffer\n[\nPIPE_BUF\n+\n1\n];\n\n    \nif\n(\naccess\n(\nfifo_name\n,\nF_OK\n)\n==-\n1\n)\n\n    \n{\n\n        \nres\n \n=\n \nmkfifo\n(\nfifo_name\n,\n0777\n);\n\n        \nif\n(\nres\n!=\n0\n)\n\n        \n{\n\n            \nfprintf\n(\nstderr\n,\ncould not create fifo\n\\n\n);\n\n            \nexit\n(\nEXIT_FAILURE\n);\n\n        \n}\n\n    \n}\n\n    \nprintf\n(\nprocess %d opening fifo O_WRONLY\n\\n\n,\ngetpid\n());\n\n    \npipe_fd\n \n=\n \nopen\n(\nfifo_name\n,\nopen_mode\n);\n\n    \ndata_fd\n \n=\n \nopen\n(\ndata.txt\n,\nO_RDONLY\n);\n\n    \nprintf\n(\nprocess %d result %d\n\\n\n,\ngetpid\n(),\npipe_fd\n);\n\n    \nif\n(\npipe_fd\n!=-\n1\n)\n\n    \n{\n\n        \nint\n \nbytes_read\n \n=\n \n0\n;\n\n        \nbytes_read\n \n=\n \nread\n(\ndata_fd\n,\nbuffer\n,\nPIPE_BUF\n);\n\n        \nwhile\n(\nbytes_read\n0\n)\n\n        \n{\n\n            \nres\n \n=\n \nwrite\n(\npipe_fd\n,\nbuffer\n,\nbytes_read\n);\n\n            \nif\n(\nres\n==-\n1\n)\n\n            \n{\n\n                \nfprintf\n(\nstderr\n,\nwrite error\n\\n\n);\n\n                \nexit\n(\nEXIT_FAILURE\n);\n\n            \n}\n\n            \nbytes_read\n \n=\n \nread\n(\ndata_fd\n,\nbuffer\n,\nPIPE_BUF\n);\n\n            \nbuffer\n[\nbytes_read\n]\n=\n\\0\n;\n\n        \n}\n\n        \nclose\n(\npipe_fd\n);\n\n        \nclose\n(\ndata_fd\n);\n\n    \n}\n\n    \nelse\n{\n\n        \nexit\n(\nEXIT_FAILURE\n);\n\n    \n}\n\n    \nprintf\n(\nprocess %d finished.\n\\n\n,\ngetpid\n());\n\n    \nexit\n(\nEXIT_SUCCESS\n);\n\n\n}\n\n\n\n\n\nthe program \nfiforead.c\n is as follows.\n\n\n#include\nstdlib.h\n\n\n#include\nstdio.h\n\n\n#include\nsys/types.h\n\n\n#include\nfcntl.h\n\n\n#include\nlimits.h\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nconst\n \nchar\n \n*\nfifo_name\n \n=\n \n/tmp/my_fifo\n;\n\n    \nint\n \npipe_fd\n \n=\n \n-\n1\n;\n\n    \nint\n \ndata_fd\n \n=\n \n-\n1\n;\n\n    \nint\n \nres\n \n=\n \n0\n;\n\n    \nint\n \nopen_mode\n \n=\n \nO_RDONLY\n;\n\n    \nchar\n \nbuffer\n[\nPIPE_BUF\n+\n1\n];\n\n    \nint\n \nbytes_read\n \n=\n \n0\n;\n\n    \nint\n \nbytes_write\n \n=\n \n0\n;\n\n    \nmemset\n(\nbuffer\n,\n\\0\n,\nsizeof\n(\nbuffer\n));\n\n\n    \nprintf\n(\nprocess %d opening FIFO O_RDONLY\n\\n\n,\ngetpid\n());\n\n    \npipe_fd\n \n=\n \nopen\n(\nfifo_name\n,\nopen_mode\n);\n\n    \ndata_fd\n \n=\n \nopen\n(\ndataformfifo.txt\n,\nO_WRONLY\n|\nO_CREAT\n,\n0644\n);\n\n    \nprintf\n(\nprocess %d result %d\n\\n\n,\ngetpid\n(),\npipe_fd\n);\n\n    \nif\n(\npipe_fd\n!=-\n1\n)\n\n    \n{\n\n        \ndo\n{\n\n            \nres\n \n=\n \nread\n(\npipe_fd\n,\nbuffer\n,\nPIPE_BUF\n);\n\n            \nbytes_write\n \n=\n \nwrite\n(\ndata_fd\n,\nbuffer\n,\nres\n);\n\n            \nbytes_read\n \n+=\nres\n;\n\n        \n}\nwhile\n(\nres\n0\n);\n\n        \nclose\n(\npipe_fd\n);\n\n        \nclose\n(\ndata_fd\n);\n\n    \n}\n\n    \nelse\n{\n\n        \nexit\n(\nEXIT_FAILURE\n);\n\n    \n}\n\n    \nprintf\n(\nprocess %d finished,%d bytes read\n\\n\n,\ngetpid\n(),\nbytes_read\n);\n\n    \nexit\n(\nEXIT_SUCCESS\n);\n\n\n}\n\n\n\n\n\n8 Communication in Client-server system\n\n\nIn this section, we explore two other strategies for communication in client-server system: \nsockets\n and \nremote procedure calls\n(RPCs)\n\n\nSockets\n\n\nA \nsocket\n(\u5957\u63a5\u5b57) is defined as an \nendpoint\n for communication. A socket is identified by an \nIP address concatenated with a port number\n.\n\n\nCommunication using sockets\uff1a\n\n\n\n\nServers implementing specific services (such as SSH, FTP, and HTTP) listen to well-known ports. Once a request is received, the server accepts a connection from the client socket to complete the connection.\n\n\n\n\nExample\n\n\nJava provides three different types of sockets. Connection-oriented(TCP) sockets are implemented with the \nSocket\n class. \n\n\nThe example describes a data server that uses connection-oriented TCP sockets. \n\n\nimport\n \njava.net.*\n;\n\n\nimport\n \njava.io.*\n;\n\n\n\npublic\n \nclass\n \nDateClient\n\n\n{\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n  \n{\n\n        \ntry\n \n{\n\n            \n// this could be changed to an IP name or address other than the localhost.\n\n            \n// The IP address 127.0.0.1 is a special IP address known as the loopback. \n\n            \n// When a computer refers to IP address 127.0.0.1, it is referring to itself.\n\n            \n// This mechanism allows a client and server on the same host to communicate using the TCP/IP protocol.\n\n            \nSocket\n \nsock\n \n=\n \nnew\n \nSocket\n(\n127.0.0.1\n,\n6013\n);\n\n            \nInputStream\n \nin\n \n=\n \nsock\n.\ngetInputStream\n();\n\n            \nBufferedReader\n \nbin\n \n=\n \nnew\n \nBufferedReader\n(\nnew\n \nInputStreamReader\n(\nin\n));\n\n\n            \nString\n \nline\n;\n\n            \nwhile\n(\n \n(\nline\n \n=\n \nbin\n.\nreadLine\n())\n \n!=\n \nnull\n)\n\n                \nSystem\n.\nout\n.\nprintln\n(\nline\n);\n\n\n            \nsock\n.\nclose\n();\n\n        \n}\n\n        \ncatch\n \n(\nIOException\n \nioe\n)\n \n{\n\n                \nSystem\n.\nerr\n.\nprintln\n(\nioe\n);\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nDateServer\n\n\n{\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n  \n{\n\n        \ntry\n \n{\n\n            \nServerSocket\n \nsock\n \n=\n \nnew\n \nServerSocket\n(\n6013\n);\n\n\n            \n// now listen for connections\n\n            \nwhile\n \n(\ntrue\n)\n \n{\n\n                \nSocket\n \nclient\n \n=\n \nsock\n.\naccept\n();\n\n                \n// we have a connection\n\n\n                \nPrintWriter\n \npout\n \n=\n \nnew\n \nPrintWriter\n(\nclient\n.\ngetOutputStream\n(),\n \ntrue\n);\n\n                \n// write the Date to the socket\n\n                \npout\n.\nprintln\n(\nnew\n \njava\n.\nutil\n.\nDate\n().\ntoString\n());\n\n\n                \n// close the socket and resume listening for more connections\n\n                \nclient\n.\nclose\n();\n\n            \n}\n\n        \n}\n\n        \ncatch\n \n(\nIOException\n \nioe\n)\n \n{\n\n                \nSystem\n.\nerr\n.\nprintln\n(\nioe\n);\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nCommunication using sockets\u2014although \ncommon\n and \nefficient\n \u2014\u2014 is considered a \nlow-level\n form of communication between distributed processes. \n\n\n\n\nOne reason is that sockets allow only an \nunstructured\n stream of bytes to be exchanged between the communicating threads. It is the responsibility of the client or server application to impose a structure on the data.\n\n\n\n\nRemote procedure calls\n\n\nRemote Procedure Call\n(\u8fdc\u7a0b\u8fc7\u7a0b\u8c03\u7528), One of the \nmost common\n forms of remote service, allows programs on different machines to interact using simple procedure call/return semantics, just as if the two programs were in the same computer.\n\n\nRPC between a client and a serve\uff1a\n\n\n\n\nRPC hides all the network code into the stub procedures. This prevents the application programs, the client and the server, from having to worry about details such as sockets, network byte order, and the like.", 
            "title": "Chapter 3: Processes"
        }, 
        {
            "location": "/osc/ch3/#operating-system-concepts-3-processes", 
            "text": "", 
            "title": "Operating System Concepts 3 - Processes"
        }, 
        {
            "location": "/osc/ch3/#1-process-concept", 
            "text": "", 
            "title": "1 Process concept"
        }, 
        {
            "location": "/osc/ch3/#the-process", 
            "text": "Process  (\u8fdb\u7a0b) is a program in execution.   Process is the unit of work in a modern computing system.   The status of the  current  activity of a process is represented by the value of the  program counter  and the contents of the processor's  registers .  A program by itself is not a process.   A program is a  passive  entity, such as a file containing a list of instructions stored on disk.  A process is an  active  entity, with a program counter specifying the next instruction to execute.", 
            "title": "The process"
        }, 
        {
            "location": "/osc/ch3/#process-state", 
            "text": "A process may be in one of the following states:   New (\u65b0\u5efa). The process is being created. \u8fdb\u7a0b\u6b63\u5728\u88ab\u521b\u5efa  Running (\u8fd0\u884c). Instructions are being executed. \u6307\u4ee4\u6b63\u5728\u88ab\u6267\u884c  Waiting (\u7b49\u5f85). The process is waiting for some event to occur(such as an I/O completion or reception of a signal). \u8fdb\u7a0b\u7b49\u5f85\u67d0\u4e9b\u4e8b\u4ef6\u53d1\u751f  Ready (\u5c31\u7eea). The process is waiting to be assigned to a processor.\u8fdb\u7a0b\u7b49\u5f85\u5206\u914d\u5904\u7406\u5668  Terminated (\u7ec8\u6b62). The process has finished execution. \u8fdb\u7a0b\u6267\u884c\u5b8c\u6bd5   Diagram of process state:", 
            "title": "Process state"
        }, 
        {
            "location": "/osc/ch3/#process-control-block", 
            "text": "Each process is represented by a  process control block (PCB, \u8fdb\u7a0b\u63a7\u5236\u5757), it contains   Process state (\u8fdb\u7a0b\u72b6\u6001)  Program counter (\u7a0b\u5e8f\u8ba1\u6570\u5668)  CPU registers (CPU\u5bc4\u5b58\u5668)  CPU-scheduling information (CPU\u8c03\u5ea6\u4fe1\u606f): a process priority, pointers to scheduling queues, and any other scheduling parameters.  Memory-management information (\u5185\u5b58\u7ba1\u7406\u4fe1\u606f)  Accounting information (\u8bb0\u8d26\u4fe1\u606f): the amount of CPU and real time used, time limits, account numbers, process numbers and so on.  I/O status information (I/O\u72b6\u6001\u4fe1\u606f): the list of I/O devices allocated to the process, a list of open files.   Process Control Block:   The process control block in Linux is represented by the C structure  task_struct  ('include/linux/sched.h')\uff0c  CODE LINK   Within the Linux kernel, all active processes are represented using a  doubly linked list  of task struct.   Task_strut :", 
            "title": "Process control block"
        }, 
        {
            "location": "/osc/ch3/#2-process-scheduling", 
            "text": "The  process scheduler (\u8fdb\u7a0b\u8c03\u5ea6\u7a0b\u5e8f) selects an available process for program execution on a core.   Each CPU core can run one process at a time.  The number of processes currently in memory is known as the  degree of multiprogramming .", 
            "title": "2 Process scheduling"
        }, 
        {
            "location": "/osc/ch3/#scheduling-queues", 
            "text": "Ready queue (\u5c31\u7eea\u961f\u5217): the status of processes are ready.\n* generally stored as a linked list, its header contains pointers to the first PCB in the list, each PCB includes a pointer field that points to next PCB in the ready queue.  Wait Queue (\u7b49\u5f85\u961f\u5217): the status of processes are waiting.  Queueing-diagram representation of process scheduling:", 
            "title": "Scheduling Queues"
        }, 
        {
            "location": "/osc/ch3/#context-switch", 
            "text": "Here the  context  of a process is represented in the PCB of the process, including the value of the CPU registers, the process state, and memory-management information.  An operating system performs a  context switch \uff08\u4e0a\u4e0b\u6587\u5207\u6362) when it switches from running one process to running another.   The kernel  saves  the context of the old process into its PCB and  restore  the saved context of the new process scheduled to run.  Context-switch time is overhead; the system does no useful work while switching.   A typical speed is a several microseconds.     Context-switch times are  highly  dependent on hardware support.   Context switch from an old process to a new process:", 
            "title": "context switch"
        }, 
        {
            "location": "/osc/ch3/#3-operating-on-processes", 
            "text": "", 
            "title": "3 Operating on Processes"
        }, 
        {
            "location": "/osc/ch3/#process-creation", 
            "text": "A process may  create  several new processes.   the creating process is called a  parent process .  the new process is called a  child process  .", 
            "title": "Process creation"
        }, 
        {
            "location": "/osc/ch3/#process-termination", 
            "text": "A process  terminates  when it finishes executing its final statement and asks the operating system to delete it by using the  exit()  system call.   cascading termination (\u7ea7\u8054\u7ec8\u6b62):  if a process terminates (either normally or abnormally), then all its children must also be terminated.   A process that has terminated, but whose parent has not yet called  wait() , is known as a  zombie process (\u50f5\u5c38\u8fdb\u7a0b).  if a parent did not invoke  wait()  and instead terminated, then leaving its child processes as  orphan processes (\u5b64\u513f\u8fdb\u7a0b).  Unix system may assign the  init  process as the new parent to orphan processes, and the  init  process periodically invokes  wait() .      Example  A problem with a single process for a web browser is that if a web application in any tab crashes, the entire process \u2014\u2014 including all other tabs \u001f\u001f\u2014\u2014 crashes as well. Chrome web browser uses a multiprocess architecture \u2014\u2014 identifies three different types of processes: browser, renderers, plugins. see  here  in detail.", 
            "title": "Process termination"
        }, 
        {
            "location": "/osc/ch3/#4-interprocess-communication", 
            "text": "Processes may be either  independent processes (\u72ec\u7acb\u8fdb\u7a0b) or  cooperating processes (\u534f\u540c\u8fdb\u7a0b).   A process is  independent  if it does not share data with any other processes executing in the system.  A process is  cooperating  if it can affect or be affected by the other processes executing in the system.   Advantages of  process cooperation:   Information sharing   Computation speedup   Modularity    Cooperating process require an  interprocess communication  (IPC\uff0c\u8fdb\u7a0b\u95f4\u901a\u4fe1) mechanism that will allow them to  exchange  data. There are two fundamental models of IPC:   shared memory (\u5171\u4eab\u5185\u5b58): a region of memory is shared by cooperating process. Process can exchange information by reading and writing data to the shared region.  Shared memory can be  faster  than message passing.    message passing (\u6d88\u606f\u4f20\u9012)\uff1a communication takes place by means of messages exchanged between the cooperating processes.  Message passing is useful for exchanging  smaller  amounts of data, because no conflicts need be avoided.  Message passing is easier to implement in a distributed system than shared memory.", 
            "title": "4 Interprocess communication"
        }, 
        {
            "location": "/osc/ch3/#5-ipc-in-shared-memory-system", 
            "text": "Let's consider the producer-consumer problem, which is a common paradigm for cooperating processes. A  producer  process produces information that is  consumed  by a consumer process.  One solution to the producer-consumer problem uses shared memory.  We generally think of a server as a producer and a client as a consumer. For example, a web server produces web content such as HTML files and images, which are consumed by the client web browser requesting the resource.  Two types of buffers can be used.   unbounded buffer (\u65e0\u754c\u7f13\u51b2): places no practical limit on the size of the buffer.  bounded buffer (\u6709\u754c\u7f13\u51b2): assumes a fixed buffer size", 
            "title": "5 IPC in shared-memory system"
        }, 
        {
            "location": "/osc/ch3/#6-ipc-in-message-passing-system", 
            "text": "A message-passing facility provides at least two operations:   send(message)  receive(message)   If P and Q wish to communicate, they need to   establish a  communication link (\u901a\u4fe1\u8fde\u63a5) between them  exchange messages via send/receive    Here are several methods for logically implementing a  communication link  between processes:   Direct or indirect communication \u76f4\u63a5/\u95f4\u63a5\u901a\u4fe1  Synchronous or asynchronous communication \u540c\u6b65/\u5f02\u6b65\u540c\u6b65  Automatic or explicit buffering \u81ea\u52a8/\u663e\u5f0f\u7f13\u51b2", 
            "title": "6 IPC in message-passing system"
        }, 
        {
            "location": "/osc/ch3/#directindirect-communication", 
            "text": "", 
            "title": "Direct/Indirect communication"
        }, 
        {
            "location": "/osc/ch3/#direct-communication", 
            "text": "Under  direct communication , each process that wants to communicate must explicitly name the recipient or sender of the communication.   send(P, message) - send a message to process P.  receive(Q, message) - receive a message from process Q   A communication link in this scheme has the following properties:   A link is established  automatically  between every pair of processes that want to communicate.  A link is associated with  exactly two  processes.  Between each pair of processes, there exists exactly one link.   Cons:   limited modularity of the resulting process definitions. Changing the identifier of a process may necessitate examining all other process definitions.  any such hard-coding techniques, are less desirable.", 
            "title": "....Direct Communication"
        }, 
        {
            "location": "/osc/ch3/#indirect-communication", 
            "text": "With  indirect communication , the message are sent to and receive from  mailboxes , or  ports .   send(A, message) - send a message to mailbox A  receive(A, message) - receive a message from mailbox A   A mailbox can be viewed abstractly as an object into which messages can be placed by processes and from which messages can be removed.   Each mailbox has an  unique  identification.  Two processes can communicate only if they have a shared mailbox.   In this scheme, a communication link has the following properties:   A link is established between a pair of processes only if both members of the pair have a shared mailbox.  A link may be associated with more than two processes.  Between each pair of communicating processes, a number of different links may exist, with each link corresponding to one mailbox.   A mailbox may be owned either by a process or by the operating system.  If the mailbox is owned by a process  We distinguish between the  owner  (which can only receive messages through his mailbox) and the  user  (which can only send messages to the mailbox)  Each mailbox has a unique owner.  When a process that owns a mailbox terminates, the mailbox disappears.  The process that creates a new mailbox is that mailbox's owner by default.", 
            "title": "....Indirect Communication"
        }, 
        {
            "location": "/osc/ch3/#synchronization", 
            "text": "Message passing may be either  blocking  or  nonblocking  - also known as  synchronous  and  asynchronous .", 
            "title": "Synchronization"
        }, 
        {
            "location": "/osc/ch3/#buffering", 
            "text": "Messages exchanged by communicating processes reside in a temporary queue, whether communication is direct or indirect. Basically, it can be implemented in three ways:   Zero capacity\uff08\u96f6\u5bb9\u91cf\uff09-- no buffering  The link cannot have any messages waiting in it.  The sender must block until the recipient receives the message.     Bounded capacity\uff08\u6709\u754c\u5bb9\u91cf\uff09-- automatic buffering  The queue has finite length n, at most n message can reside in it.     The sender must block until space is available in the queue if the link is full.        Unbounded capacity \uff08\u65e0\u754c\u5bb9\u91cf\uff09 -- automatic buffering  Any number of messages can wait in it.  The sender never blocks.", 
            "title": "Buffering"
        }, 
        {
            "location": "/osc/ch3/#7-examples-of-ipc-systems", 
            "text": "", 
            "title": "7 Examples of IPC Systems"
        }, 
        {
            "location": "/osc/ch3/#posix-shared-memory", 
            "text": "Here, we explore the POSIX API for shared memory. POSIX shared memory is organized using  memory-mapped files  (\u5185\u5b58\u6620\u5c04\u6587\u4ef6), which associate the region of shared memory with a file. A process must first create a shared-memory object using the  shm_open()  system call. fd   =   shm_open ( name ,   O_CREAT   |   O_RDWR ,   0666 );  ftruncate ( fd ,   4096 );  mmap ( 0 ,   SIZE ,   PROT_READ   |   PROT_WRITE ,   MAP_SHARED ,   fd ,   0 );    A successful call to  shm_open()  returns an integer file descriptor for the shared-memory object.  Once the object is established, the  ftruncate()  function is used to configure the size of the object in bytes.  Finally, the  mmap()  function establishes a memory-mapped file containing the shared-memory object. It returns a pointer to the shared    #include   stdio.h  #include   stdlib.h  #include   unistd.h  #include   fcntl.h  #include   sys/shm.h  #include   sys/stat.h  #include   sys/mman.h  int   main ()  { \n     const   char   * name   =   OS ; \n     const   int   SIZE   =   4096 ; \n\n     int   shm_fd ; \n     void   * ptr ; \n     int   i ; \n\n     /* open the shared memory segment */ \n     shm_fd   =   shm_open ( name ,   O_RDONLY ,   0666 ); \n     if   ( shm_fd   ==   - 1 )   { \n         printf ( shared memory failed \\n ); \n         exit ( - 1 ); \n     } \n\n     /* now map the shared memory segment in the address space of the process */ \n     ptr   =   mmap ( 0 , SIZE ,   PROT_READ ,   MAP_SHARED ,   shm_fd ,   0 ); \n     if   ( ptr   ==   MAP_FAILED )   { \n         printf ( Map failed \\n ); \n         exit ( - 1 ); \n     } \n\n     /* now read from the shared memory region */ \n     printf ( %s ,( char   * ) ptr ); \n\n     /* remove the shared memory segment */ \n     if   ( shm_unlink ( name )   ==   - 1 )   { \n         printf ( Error removing %s \\n , name ); \n         exit ( - 1 ); \n     } \n\n     return   0 ;  }", 
            "title": "POSIX Shared Memory"
        }, 
        {
            "location": "/osc/ch3/#mach-message-passing", 
            "text": "Mach was especially designed for distributed systems. Its kernel supports the creation and destruction of multiple  tasks , which are similar to processes but have multiple threads of control and fewer associated resources.    Messages are sent to, and received from, mailboxes, which are called  ports  in Mach.    Ports are  finite in size  and  unidirectional .  For two-way communication, a message is sent to one port, and a response is sent to a separate  reply  port.  Associated with each port is a collection of  port rights , which  identify the capabilities necessary for a task to interact with the port.   Functions:   mach_port_allocate()  creates a new port and allocates space for its queue of messages.  mach_msg()  is the standard API for both sending and receiving messages.   #include   mach/mach.h  struct   message   { \n     mach_msg_header_t   header ; \n     int   data ;  };  mach_port_t   client ;  mach_port_t   server ;  /* Client Code */  struct   message   message ;  // construct the header  message . header . msgh_size   =   sizeof ( message );  message . header . msgh_remote_port   =   server ;  message . header . msgh_local_port   =   client ;  // send the message  mach   msg ( message . header ,   // message header \n          MACH_SEND_MSG ,   // sending a message \n          sizeof ( message ),   // size of message sent \n          0 ,   // maximum size of received message - unnecessary \n          MACH_PORT_NULL ,   // name of receive port - unnecessary \n          MACH_MSG_TIMEOUT_NONE ,   // no time outs MACH PORT NULL // no notify port  );  /* Server Code */  struct   message   message ;  // receive the message  mach_msg ( message . header ,   // message header \n   MACH_RCV_MSG ,   // sending a message  0, // size of message sent \n   sizeof ( message ),   // maximum size of received message \n   server ,   // name of receive port \n   MACH_MSG_TIMEOUT_NONE ,   // no time outs \n   MACH_PORT_NULL   // no notify port  );", 
            "title": "Mach Message Passing"
        }, 
        {
            "location": "/osc/ch3/#pipes", 
            "text": "A  pipe  acts as a conduit allowing two processes to communicate. Pipes were one of the first IPC mechanisms in early UNIX systems. There are two common types of pipes used on both UNIX and Windows systems:  ordinary pipes  and  named pipes .", 
            "title": "Pipes"
        }, 
        {
            "location": "/osc/ch3/#ordinary-pipes", 
            "text": "Ordinary pipes  allow two processes to communicate in standard producer-consumer fashion: the producer writes to one end of the pipe (the  write end ) and the consumer reads from the other end (the  read end ).   Ordinary pipes are  unidirectional , allowing only one-way communication.  Function  pipe(int fd[])  constructs an ordinary pipe, where  fd  is a file descriptor.  UNIX treats a pipe as  a special type of file . Pipes can be accessed using ordinary  read()  and  write()  system calls.  Ordinary pipes  exit only  while the processes are communicating with each other.    #include   sys/types.h  #include   stdio.h  #include   string.h  #include   unistd.h  #define BUFFER_SIZE 25  #define READ_END 0  #define WRITE_END 1  int   main ( void )  { \n         char   write_msg [ BUFFER_SIZE ]   =   Greetings ; \n         char   read_msg [ BUFFER_SIZE ]; \n         int   fd [ 2 ]; \n         pid_t   pid ; \n\n         /* create the pipe */ \n         if   ( pipe ( fd )   ==   - 1 ){ \n                 fprintf ( stderr ,   Pipe failed ); \n                 return   1 ; \n         } \n\n         /* fork a child process */ \n         pid   =   fork (); \n\n         if   ( pid 0 ){   /* parent process */ \n                 close ( fd [ READ_END ]); /* close the unused end of the pipe */ \n                 write ( fd [ WRITE_END ],   write_msg ,   strlen ( write_msg ) + 1 );   /* write to the pipe */ \n                 close ( fd [ WRITE_END ]);    /* close the write end of the pipe */ \n         } \n         else   if   ( pid == 0 ){   /* child process */ \n                 close ( fd [ WRITE_END ]);   /* close the unused end of the pipe */ \n                 read ( fd [ READ_END ],   read_msg ,   BUFFER_SIZE );   /* read from the pipe */ \n                 printf ( read: %s \\n ,   read_msg ); \n                 close ( fd [ READ_END ]);   /* close the read end of the pipe */ \n         } \n         return   0 ;  }", 
            "title": "Ordinary pipes"
        }, 
        {
            "location": "/osc/ch3/#named-pipes", 
            "text": "Named pipes \uff08\u547d\u540d\u7ba1\u9053\uff09 can be  bidirectional , and no parent-child relationship is required.   Named pipes are referred to as  FIFOs  in UNIX system.  Once created, they appear as typical files in the file system.  The communicating processes for named pipes must reside on the same machine.   A FIFO is created with the  mkfifo()  system call and manipulated with the ordinary  open() ,  read() ,  write() , and  close  system calls.\uff1a  int   mkfifo ( const   char   * filename ,   mode_t   mode );   The program  fifowrite.c  is as follows.  #include sys/types.h  #include stdlib.h  #include stdio.h  #include fcntl.h  #include limits.h  int   main ()  { \n     const   char   * fifo_name   =   /tmp/my_fifo ; \n     int   pipe_fd   =   - 1 ; \n     int   data_fd   =   - 1 ; \n     int   res   =   0 ; \n     const   int   open_mode   =   O_WRONLY ; \n     char   buffer [ PIPE_BUF + 1 ]; \n     if ( access ( fifo_name , F_OK ) ==- 1 ) \n     { \n         res   =   mkfifo ( fifo_name , 0777 ); \n         if ( res != 0 ) \n         { \n             fprintf ( stderr , could not create fifo \\n ); \n             exit ( EXIT_FAILURE ); \n         } \n     } \n     printf ( process %d opening fifo O_WRONLY \\n , getpid ()); \n     pipe_fd   =   open ( fifo_name , open_mode ); \n     data_fd   =   open ( data.txt , O_RDONLY ); \n     printf ( process %d result %d \\n , getpid (), pipe_fd ); \n     if ( pipe_fd !=- 1 ) \n     { \n         int   bytes_read   =   0 ; \n         bytes_read   =   read ( data_fd , buffer , PIPE_BUF ); \n         while ( bytes_read 0 ) \n         { \n             res   =   write ( pipe_fd , buffer , bytes_read ); \n             if ( res ==- 1 ) \n             { \n                 fprintf ( stderr , write error \\n ); \n                 exit ( EXIT_FAILURE ); \n             } \n             bytes_read   =   read ( data_fd , buffer , PIPE_BUF ); \n             buffer [ bytes_read ] = \\0 ; \n         } \n         close ( pipe_fd ); \n         close ( data_fd ); \n     } \n     else { \n         exit ( EXIT_FAILURE ); \n     } \n     printf ( process %d finished. \\n , getpid ()); \n     exit ( EXIT_SUCCESS );  }   the program  fiforead.c  is as follows.  #include stdlib.h  #include stdio.h  #include sys/types.h  #include fcntl.h  #include limits.h  int   main ()  { \n     const   char   * fifo_name   =   /tmp/my_fifo ; \n     int   pipe_fd   =   - 1 ; \n     int   data_fd   =   - 1 ; \n     int   res   =   0 ; \n     int   open_mode   =   O_RDONLY ; \n     char   buffer [ PIPE_BUF + 1 ]; \n     int   bytes_read   =   0 ; \n     int   bytes_write   =   0 ; \n     memset ( buffer , \\0 , sizeof ( buffer )); \n\n     printf ( process %d opening FIFO O_RDONLY \\n , getpid ()); \n     pipe_fd   =   open ( fifo_name , open_mode ); \n     data_fd   =   open ( dataformfifo.txt , O_WRONLY | O_CREAT , 0644 ); \n     printf ( process %d result %d \\n , getpid (), pipe_fd ); \n     if ( pipe_fd !=- 1 ) \n     { \n         do { \n             res   =   read ( pipe_fd , buffer , PIPE_BUF ); \n             bytes_write   =   write ( data_fd , buffer , res ); \n             bytes_read   += res ; \n         } while ( res 0 ); \n         close ( pipe_fd ); \n         close ( data_fd ); \n     } \n     else { \n         exit ( EXIT_FAILURE ); \n     } \n     printf ( process %d finished,%d bytes read \\n , getpid (), bytes_read ); \n     exit ( EXIT_SUCCESS );  }", 
            "title": "Named pipes"
        }, 
        {
            "location": "/osc/ch3/#8-communication-in-client-server-system", 
            "text": "In this section, we explore two other strategies for communication in client-server system:  sockets  and  remote procedure calls (RPCs)", 
            "title": "8 Communication in Client-server system"
        }, 
        {
            "location": "/osc/ch3/#sockets", 
            "text": "A  socket (\u5957\u63a5\u5b57) is defined as an  endpoint  for communication. A socket is identified by an  IP address concatenated with a port number .  Communication using sockets\uff1a   Servers implementing specific services (such as SSH, FTP, and HTTP) listen to well-known ports. Once a request is received, the server accepts a connection from the client socket to complete the connection.   Example  Java provides three different types of sockets. Connection-oriented(TCP) sockets are implemented with the  Socket  class.   The example describes a data server that uses connection-oriented TCP sockets.   import   java.net.* ;  import   java.io.* ;  public   class   DateClient  { \n     public   static   void   main ( String []   args )    { \n         try   { \n             // this could be changed to an IP name or address other than the localhost. \n             // The IP address 127.0.0.1 is a special IP address known as the loopback.  \n             // When a computer refers to IP address 127.0.0.1, it is referring to itself. \n             // This mechanism allows a client and server on the same host to communicate using the TCP/IP protocol. \n             Socket   sock   =   new   Socket ( 127.0.0.1 , 6013 ); \n             InputStream   in   =   sock . getInputStream (); \n             BufferedReader   bin   =   new   BufferedReader ( new   InputStreamReader ( in )); \n\n             String   line ; \n             while (   ( line   =   bin . readLine ())   !=   null ) \n                 System . out . println ( line ); \n\n             sock . close (); \n         } \n         catch   ( IOException   ioe )   { \n                 System . err . println ( ioe ); \n         } \n     }  }  public   class   DateServer  { \n     public   static   void   main ( String []   args )    { \n         try   { \n             ServerSocket   sock   =   new   ServerSocket ( 6013 ); \n\n             // now listen for connections \n             while   ( true )   { \n                 Socket   client   =   sock . accept (); \n                 // we have a connection \n\n                 PrintWriter   pout   =   new   PrintWriter ( client . getOutputStream (),   true ); \n                 // write the Date to the socket \n                 pout . println ( new   java . util . Date (). toString ()); \n\n                 // close the socket and resume listening for more connections \n                 client . close (); \n             } \n         } \n         catch   ( IOException   ioe )   { \n                 System . err . println ( ioe ); \n         } \n     }  }    Communication using sockets\u2014although  common  and  efficient  \u2014\u2014 is considered a  low-level  form of communication between distributed processes.    One reason is that sockets allow only an  unstructured  stream of bytes to be exchanged between the communicating threads. It is the responsibility of the client or server application to impose a structure on the data.", 
            "title": "Sockets"
        }, 
        {
            "location": "/osc/ch3/#remote-procedure-calls", 
            "text": "Remote Procedure Call (\u8fdc\u7a0b\u8fc7\u7a0b\u8c03\u7528), One of the  most common  forms of remote service, allows programs on different machines to interact using simple procedure call/return semantics, just as if the two programs were in the same computer.  RPC between a client and a serve\uff1a   RPC hides all the network code into the stub procedures. This prevents the application programs, the client and the server, from having to worry about details such as sockets, network byte order, and the like.", 
            "title": "Remote procedure calls"
        }, 
        {
            "location": "/osc/ch4/", 
            "text": "Operating System Concepts 4 - Threads \n Concurrency\n\n\n1 Overview\n\n\nA \nthread\n is a basic unit of CPU utilization; it comprises a thread ID, a program counter, a register set, and a stack.\n\n\n\u7ebf\u7a0b\u662f\u4e00\u4e2aCPU\u5229\u7528\u7684\u57fa\u672c\u5355\u5143\uff0c\u5b83\u7531\u7ebf\u7a0bID\uff0c\u7a0b\u5e8f\u8ba1\u6570\u5668\u3001\u5bc4\u5b58\u5668\u96c6\u5408\u548c\u6808\u7ec4\u6210\u3002\n\n\nA traditional process has a single thread of control. If a process has \nmultiple threads of control\n, it can perform more than one task at a time. \n\u4e00\u4e2a\u4f20\u7edf\u7684\u8fdb\u7a0b\u53ea\u6709\u5355\u4e2a\u63a7\u5236\u7ebf\u7a0b\uff0c\u5982\u679c\u8fdb\u7a0b\u6709\u591a\u4e2a\u63a7\u5236\u7ebf\u7a0b\uff0c\u90a3\u4e48\u5b83\u80fd\u4e00\u6b21\u5904\u7406\u591a\u4e2a\u4efb\u52a1\u3002\n\n\nThe figure below illustrates the difference between a traditional \nsingle-threaded\n process and a \nmultithreaded\n process.\n\n\n\n\nMotivation\n\n\nProcess creation is \ntime consuming\n and \nresource intensive\n. It is generally more efficient to use one process that contains multiple threads.\n\n\nBenefits\n\n\nThe benefits of  multithreaded programming can be broken down into four major categories:\n\n\n\n\nResponsiveness\n\n\nIt allows a program to continue running even if part of it is blocked or is performing a lengthy operation, thereby increasing responsiveness to the user.\n\n\n\u54cd\u5e94\u5ea6\u9ad8\uff1a\u5373\u4f7f\u7a0b\u5e8f\u90e8\u5206\u963b\u585e\u6216\u6267\u884c\u8f83\u5197\u957f\u64cd\u4f5c\uff0c\u8be5\u7a0b\u5e8f\u4ecd\u80fd\u7ee7\u7eed\u6267\u884c\uff0c\u4ece\u800c\u589e\u52a0\u4e86\u5bf9\u7528\u6237\u7684\u76f8\u5e94\u7a0b\u5ea6\u3002\n\n\n\n\n\n\nResource sharing\n\n\nProcesses can share resources only through techniques such as shared memory and message. Such techniques must be explicitly arranged by the programmer.\n\n\nThreads share the memory and the resources of the process to which they belong by default.\n\n\n\u8d44\u6e90\u5171\u4eab\uff1a\u7ebf\u7a0b\u9ed8\u8ba4\u5171\u4eab\u5b83\u4eec\u6240\u5c5e\u8fdb\u7a0b\u7684\u5185\u5b58\u548c\u8d44\u6e90\u3002\u4ee3\u7801\u548c\u6570\u636e\u5171\u4eab\u7684\u4f18\u70b9\u662f\u5b83\u5141\u8bb8\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\u5728\u540c\u4e00\u5730\u5740\u7a7a\u95f4\u6709\u591a\u4e2a\u4e0d\u540c\u7684\u6d3b\u52a8\u7ebf\u7a0b\u3002\n\n\n\n\n\n\nEconomy\n\n\nAllocating memory and resources for process creation is costly. Because threads share the resources of the process to which they belong, it is more economical to create and context-switch threads.\n\n\n\u7ecf\u6d4e\uff1a\u8fdb\u7a0b\u521b\u5efa\u6240\u9700\u8981\u7684\u5185\u5b58\u548c\u8d44\u6e90\u7684\u5206\u914d\u6bd4\u8f83\u6602\u8d35\u3002\u7531\u4e8e\u7ebf\u7a0b\u80fd\u5171\u4eab\u5b83\u4eec\u6240\u5c5e\u8fdb\u7a0b\u7684\u8d44\u6e90\uff0c\u6240\u4ee5\u521b\u5efa\u548c\u5207\u6362\u7ebf\u7a0b\u4f1a\u66f4\u4e3a\u7ecf\u6d4e\u3002\n\n\n\n\n\n\nScalability\n\n\nThe benefits of multithreading can be even greater in a multiprocessor architecture, where threads may be running in parallel on different processing cores.\n\n\n\u53ef\u6269\u5c55\u6027: \u591a\u7ebf\u7a0b\u7684\u4f18\u70b9\u4e4b\u4e00\u662f\u80fd\u5145\u5206\u4f7f\u7528\u591a\u5904\u7406\u5668\u4f53\u7cfb\u7ed3\u6784\u3002\u4ee5\u4fbf\u6bcf\u4e2a\u8fdb\u7a0b\u80fd\u5e76\u884c\u8fd0\u884c\u5728\u4e0d\u540c\u7684\u5904\u7406\u5668\u4e0a\u3002\n\n\n\n\n\n\n\n\n2 Multicore Programming\n\n\nOn a system with a \nsingle\n computing core, concurrency merely means that the execution of the threads will be \ninterleaved\n over time, because the processing core is capable of executing only one thread at a time.\n\n\nOn a system with \nmultiple\n cores, however, concurrency means that some threads can run in \nparallel\n, because the system can assign a separate thread to each core.\n\n\n\n\n\n\nNote\n\n\nConcurrency\n v.s. \nParallelism\n\n\n\n\nConcurrency: supports more than one task by allowing all the tasks to make progress.\n\n\nParallelism: perform more than one task simultaneously.\n\n\n\n\n\n\nProgramming Challenges\n\n\n\n\nIdentifying tasks\n. This involves examining applications to find areas that can be divided into separate, concurrent tasks.\n\n\nBalance\n. Programmer must ensure that the tasks perform equal work of equal value.\n\n\nData splitting\n. The data accessed and manipulated by the tasks must be divided to run on separate cores.\n\n\nData dependency\n. The data accessed by the tasks must be examined for dependencies between two or more tasks.\n\n\nTesting and debugging\n. Testing and debugging such concurrent programs is inherently more difficult than testing and debugging single-threaded applications.\n\n\n\n\nTypes of Parallelism\n\n\nIn general, there are two types of parallelism: data parallelism and task parallelism.\n\n\n\n\nData parallelism\n focuses on distributing subsets of the same data across multiple computing cores and performing the same operation on each core. \n\n\nTask parallelism\n involves distributing not data but tasks (threads) across multiple computing cores.\n\n\nHowever, data and task parallelism are not mutually exclusive, and an application may in fact use a hybrid of these two strategies.\n\n\n\n\n\n\n3 Multithreading Models\n\n\nSupport for threads may be provided either at the user level, for \nuser threads\n, or by the kernel, for \nkernel threads\n. \n\n\n\n\nUser threads are supported above the kernel and are managed without kernel support.\n\n\nKernel threads are supported and managed directly by the operating system.\n\n\n\n\n\u6709\u4e24\u79cd\u4e0d\u540c\u7684\u65b9\u6cd5\u6765\u63d0\u4f9b\u7ebf\u7a0b\u652f\u6301\uff1a\u7528\u6237\u5c42\u7684\u7528\u6237\u7ea7\u7ebf\u7a0b\u548c\u5185\u6838\u5c42\u7684\u5185\u6838\u7ea7\u7ebf\u7a0b\u3002\u7528\u6237\u7ea7\u7ebf\u7a0b\u53d7\u5185\u6838\u652f\u6301\uff0c\u800c\u65e0\u9700\u5185\u6838\u7ba1\u7406\uff1b\u800c\u5185\u6838\u7ea7\u7ebf\u7a0b\u7531\u64cd\u4f5c\u7cfb\u7edf\u76f4\u63a5\u652f\u6301\u548c\u7ba1\u7406\u3002\u4e8b\u5b9e\u4e0a\u6240\u6709\u5f53\u4ee3\u64cd\u4f5c\u7cfb\u7edf\u90fd\u652f\u6301\u5185\u6838\u7ea7\u7ebf\u7a0b\u3002\n\n\nUltimately, a relationship must exist between user threads and kernel threads. There are three common ways of establishing such a relationship: the many-to-one model, the one-to-one model, and the many-to-many model.\n\u5728\u7528\u6237\u7ea7\u7ebf\u7a0b\u548c\u5185\u6838\u7ea7\u7ebf\u7a0b\u4e4b\u95f4\u5fc5\u7136\u5b58\u5728\u4e00\u79cd\u5173\u7cfb\u3002\u6709\u4e09\u79cd\u666e\u904d\u5efa\u7acb\u8fd9\u79cd\u5173\u7cfb\u7684\u65b9\u6cd5\uff1a\u591a\u5bf9\u4e00\u6a21\u578b\u3001\u4e00\u5bf9\u4e00\u6a21\u578b\u3001\u591a\u5bf9\u591a\u6a21\u578b\u3002\n\n\nMany-to-One Model\n\n\nThe \nmany-to-one model\n maps many user-level threads to one kernel thread. \u591a\u5bf9\u4e00\u6a21\u578b\u5c06\u8bb8\u591a\u7528\u6237\u7ea7\u7ebf\u7a0b\u6620\u5c04\u5230\u4e00\u4e2a\u5185\u6838\u7ebf\u7a0b\u3002\n\n\n\n\nThread management is done by the thread library in user space, so it is efficient. \u7ebf\u7a0b\u7ba1\u7406\u7531\u7ebf\u7a0b\u5e93\u5728\u7528\u6237\u7a7a\u95f4\u8fdb\u884c\u7684\uff0c\u56e0\u800c\u6548\u7387\u6bd4\u8f83\u9ad8\u3002\n\n\nAlso, because only one thread can access the kernel at a time, multiple threads are unable to run in parallel on multicore systems. \u56e0\u4e3a\u4efb\u610f\u65f6\u523b\u53ea\u80fd\u6709\u4e00\u4e2a\u7ebf\u7a0b\u80fd\u591f\u8bbf\u95ee\u5185\u6838\uff0c\u591a\u4e2a\u7ebf\u7a0b\u4e0d\u80fd\u5e76\u884c\u8fd0\u884c\u5728\u591a\u5904\u7406\u5668\u4e0a\u3002\n\n\n\n\n\n\nOne-to-One Model\n\n\nThe \none-to-one model\n maps each user thread to a kernel thread. \u4e00\u5bf9\u4e00\u6a21\u578b\u6bcf\u4e2a\u7528\u6237\u7ebf\u7a0b\u6620\u5c04\u5230\u4e00\u4e2a\u5185\u6838\u7ebf\u7a0b\u3002\n\n\n\n\nIt provides more concurrency by allowing another thread to run when a thread makes a blocking system call. \u8be5\u6a21\u578b\u5728\u4e00\u4e2a\u7ebf\u7a0b\u6267\u884c\u963b\u585e\u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u80fd\u5141\u8bb8\u53e6\u4e00\u4e2a\u7ebf\u7a0b\u7ee7\u7eed\u6267\u884c\uff0c\u63d0\u4f9b\u4e86\u66f4\u9ad8\u7684\u5e76\u53d1\u6027\u3002\n\n\nIt also allows multiple threads to run in parallel on multiprocessors. \u5b83\u4e5f\u5141\u8bb8\u591a\u4e2a\u7ebf\u7a0b\u80fd\u5e76\u884c\u8fd0\u884c\u5728\u591a\u5904\u7406\u5668\u7cfb\u7edf\u4e0a\u3002\n\n\nThe only drawback to this model is that creating a user thread requires creating the corresponding kernel thread, and a large number of kernel threads may burden the performance of a system. \u8fd9\u79cd\u6a21\u578b\u7684\u552f\u4e00\u7f3a\u70b9\u662f\u6bcf\u521b\u5efa\u4e00\u4e2a\u7528\u6237\u7ebf\u7a0b\u5c31\u4f1a\u521b\u5efa\u4e00\u4e2a\u76f8\u5e94\u7684\u5185\u6838\u7ebf\u7a0b, \u5927\u91cf\u5185\u6838\u7ebf\u7a0b\u4f1a\u5f71\u54cd\u7cfb\u7edf\u6027\u80fd\u3002\n\n\n\n\n\n\nMany-to-Many Model\n\n\nThe \nmany-to-many model\n multiplexes many user-level threads to a smaller or equal number of kernel threads. \u591a\u5bf9\u591a\u6a21\u578b\u591a\u8def\u590d\u7528\u4e86\u8bb8\u591a\u7528\u6237\u7ebf\u7a0b\u5230\u540c\u6837\u6570\u91cf\u6216\u66f4\u5c0f\u6570\u91cf\u7684\u5185\u6838\u7ebf\u7a0b\u4e0a\u3002\n\n\n\n\nDevelopers can create as many user threads as necessary. \u5f00\u53d1\u4eba\u5458\u53ef\u521b\u5efa\u4efb\u610f\u591a\u7684\u7528\u6237\u7ebf\u7a0b\u3002\n\n\nThe corresponding kernel threads can run in parallel on a multiprocessor. \u76f8\u5e94\u5185\u6838\u7ebf\u7a0b\u80fd\u5728\u591a\u5904\u7406\u5668\u7cfb\u7edf\u4e0a\u5e76\u53d1\u6267\u884c\u3002\n\n\nAlso, when a thread performs a blocking system call, the kernel can schedule another thread for execution. \u800c\u4e14\u5f53\u4e00\u4e2a\u7ebf\u7a0b\u6267\u884c\u963b\u585e\u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u5185\u6838\u80fd\u8c03\u5ea6\u53e6\u4e00\u4e2a\u7ebf\u7a0b\u6765\u6267\u884c\u3002\n\n\nIn practice it is \ndifficult to implement\n. \u5b9e\u9645\u4e0a\u96be\u4ee5\u5b9e\u65bd\u3002\n\n\n\n\n\n\nMost operating systems now use the one-to-one model.\n\n\nUser/Kernel-Level threads\n\n\nref: Scheduler Activations\n\n\n(1) \nUser-Level Threads\n(\u7528\u6237\u7ea7\u7ebf\u7a0b)\n\n\nAdvantages:\n\n\n\n\nCommon operations can be implemented \nefficiently\n \n\n\nInterface can be tailored to application needs\n\n\n\n\nIssues:\n\n\n\n\nA blocking system call blocks all user-level threads. \u963b\u585e\u7cfb\u7edf\u8c03\u7528\u80fd\u591f\u963b\u585e\u6240\u6709\u7528\u6237\u7ea7\u7ebf\u7a0b\u3002\n\n\nAsynchronous system calls can provide partial work-around. \u975e\u540c\u6b65\u7cfb\u7edf\u8c03\u7528\u80fd\u63d0\u4f9b\u90e8\u5206work-around. \nview the definition of work-around here\n\n\nA page fault blocks all user-level threads. \u7f3a\u9875\u5f02\u5e38\u963b\u585e\u6240\u6709\u7528\u6237\u7ea7\u7ebf\u7a0b\u3002\n\n\nMatching threads to CPUs in a multiprocessor is hard\uff1a\n\n\nNo knowledge about the numbers of CPUs available to address space \n\n\nNo knowledge when a thread blocks\n\n\n\n\n\n\n\n\n(2) \nKernel-Level Threads\n (\u5185\u6838\u7ea7\u7ebf\u7a0b)\n\n\nPrimary advantage\n* Blocking system calls and page faults handled correctly\n\n\nIssues\n\n Cost of performing thread operations\n\n Create, exit, lock, signal, wait all require user/kernel crossings\n\n\nNOTE\n: The term \nvirtual processor\n is often used instead of kernel thread.\n\n\n4 Thread Libraries\n\n\nA thread library provides the programmer with an API for creating and managing threads. \u7ebf\u7a0b\u5e93\u4e3a\u7a0b\u5e8f\u5458\u63d0\u4f9b\u4e86\u521b\u5efa\u548c\u7ba1\u7406\u7ebf\u7a0b\u7684API\u3002\n\n\nPthreads\n, the threads extension of the POSIX standard, may be provided as either a user-level or a kernel-level library. Pthread\u4f5c\u4e3aPOSIX\u6807\u51c6\u6269\u5c55\uff0c\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u7ea7\u6216\u5185\u6838\u7ea7\u7684\u5e93\u3002\n\n\n\n\npthread_t tid\n: declares the identifier for the thread\n\n\npthread attr_t attr\n: declares the attributes for the thread\n\n\npthread_attr_init(\nattr)\n: initialize thread attributes object\n\n\npthread_create()\n: create a new thread\n\n\npthread_join()\n:  join with a terminated thread  \n\n\npthread_exit()\n:  terminate calling thread  \n\n\n\n\nNote: Compile and link with \n-pthread\n.\n\n\npthread\n\u8be6\u7ec6\u7528\u6cd5\u548c\u5b9e\u4f8b, \u89c1\nPOSIX thread (pthread) libraries\n\n\n5 Implicit threading\n\n\nImplicit threading\n(\u9690\u5f0f\u7ebf\u7a0b): Transfers the creation and management of threading from application developers to compilers and run-time libraries.\n\n\n\n\nOne way to address difficulties and better support the design of concurrent and parallel applications\n\n\nThe advantage of this approach is that developers \nonly need to identify parallel tasks\n, and the libraries determine the specific details of thread creation and management.\n\n\n\n\nIn this section, we explore four alternative approaches to designing applications that can take advantage of multicore processors through implicit threading:\n\n\n\n\nThread Pools\n\n\nFork Join\n\n\nOpemMP\n\n\nGrand Central Dispatch\n\n\n\n\nThread Pools\n\n\nTwo main issues exist:\n\n\n\n\nThe thread will be \ndiscarded\n once it has completed its work. \u7ebf\u7a0b\u5728\u5b8c\u6210\u5de5\u4f5c\u4e4b\u540e\u5c31\u8981\u88ab\u4e22\u5f03\n\n\nUnlimited\n threads could exhaust system resources. \u65e0\u9650\u5236\u7684\u7ebf\u7a0b\u4f1a\u8017\u5c3d\u7cfb\u7edf\u8d44\u6e90\n\n\n\n\nSolution -\n \nthread pool\n(\u7ebf\u7a0b\u6c60)\n\n\n\n\nIt creates a number of threads at start-up, and places them into a pool, where they sit and wait for work.\n\n\nWhen a server receives a request, it submits the request to the thread pool and resumes waiting for additional requests.\n\n\nIf there is an available thread in the pool, it is awakened, and the request is serviced immediately. \n\n\nIf the pool contains no available thread, the task is queued until one becomes free. \n\n\n\n\n\u7ebf\u7a0b\u6c60\u7684\u601d\u60f3\u662f\u5728\u8fdb\u7a0b\u5f00\u59cb\u65f6\u521b\u5efa\u4e00\u5b9a\u6570\u91cf\u7684\u7ebf\u7a0b\uff0c\u5e76\u653e\u5165\u5230\u6c60\u4e2d\u4ee5\u7b49\u5f85\u5de5\u4f5c\u3002\u5f53\u670d\u52a1\u5668\u6536\u5230\u8bf7\u6c42\u65f6\uff0c\u5b83\u4f1a\u5524\u9192\u7ebf\u7a0b\u6c60\u4e2d\u7684\u4e00\u4e2a\u7ebf\u7a0b\uff0c\u5e76\u5c06\u8981\u5904\u7406\u7684\u8bf7\u6c42\u4f20\u9012\u7ed9\u5b83\uff0c\u4e00\u65e6\u7ebf\u7a0b\u5b8c\u6210\u4e86\u670d\u52a1\uff0c\u5b83\u4f1a\u8fd4\u56de\u5230\u6c60\u4e2d\u5728\u7b49\u5f85\u5de5\u4f5c\u3002\u5982\u679c\u6c60\u4e2d\u6ca1\u6709\u53ef\u7528\u7684\u7ebf\u7a0b\uff0c\u90a3\u4e48\u670d\u52a1\u5668\u4f1a\u4e00\u76f4\u7b49\u5f85\u76f4\u5230\u6709\u7a7a\u7ebf\u7a0b\u4e3a\u6b62\u3002\n\n\nThread pools offer these benefits:\n\n\n\n\nServicing a request with an existing thread is often \nfaster\n than waiting to create a thread. \u901a\u5e38\u7528\u73b0\u6709\u7ebf\u7a0b\u5904\u7406\u8bf7\u6c42\u8981\u6bd4\u7b49\u5f85\u521b\u5efa\u65b0\u7684\u7ebf\u7a0b\u8981\u5feb.\n\n\nA thread pool \nlimits\n the number of threads that exist at any one point.  \u7ebf\u7a0b\u6c60\u9650\u5236\u4e86\u5728\u4efb\u4f55\u65f6\u5019\u53ef\u7528\u7ebf\u7a0b\u7684\u6570\u91cf.\n\n\nSeparating the task to be performed from the mechanics of creating the task allows us to use different strategies for running the task.\n\n\n\n\nJava\u7ebf\u7a0b\u5e93\u7684\u4e00\u4e2a\u4f8b\u5b50\uff1a\n\n\nimport\n \njava.util.concurrent.*\n;\n \n\npublic\n \nclass\n \nThreadPoolExample\n \n\n{\n \n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n        \nint\n \nnumTasks\n \n=\n \nInteger\n.\nparseInt\n(\nargs\n[\n0\n].\ntrim\n());\n \n\n        \n/* Create the thread pool */\n \n        \nExecutorService\n \npool\n \n=\n \nExecutors\n.\nnewCachedThreadPool\n();\n \n        \n/* Run each task using a thread in the pool */\n \n        \nfor\n \n(\nint\n \ni\n \n=\n \n0\n;\n \ni\n \n \nnumTasks\n;\n \ni\n++)\n \n            \npool\n.\nexecute\n(\nnew\n \nTask\n());\n \n\n         \n/* Shut down the pool once all threads have completed */\n            \n        \npool\n.\nshutdown\n();\n\n\n}\n\n\n\n\n\nGrand Central Dispatch\n\n\nGrand Central Dispatch\n (GCD) is a technology for Apple's Mac OS X and iOS operating systems. It is a combination of extensions to the C languages, an API, and a run-time library that allows application developers identify sections of code to run in parallel.\n\n\n\n\nGCD identifies two types of dispatch queues: serial and concurrent.\n\n\n\n\n6 Threading Issues\n\n\nLight Weight Process\n\n\nMany systems implementing either the many-to-many or the two-level model place an \nintermediate\n data structure between the user and kernel threads. This data structure\u2014typically known as a \nlightweight process\n\uff08\u8f7b\u91cf\u7ea7\u8fdb\u7a0b\uff09, or \nLWP\n.\n\n\n\n\nTo the user-thread library, the LWP appears to be a \nvirtual\n processor on which the application can schedule a user thread to run.\n\n\nEach LWP is attached to a kernel thread.\n\n\nIf a kernel thread blocks, the LWP blocks as well. Up the chain, the user-level thread attached to the LWP also blocks.\n\n\n\n\n\n\n\n\nwhere K denotes kernel threads and  P denotes Process.\n\n\n\u4e0b\u9762\u662f\u4e00\u4e2a\u6d4b\u8bd5LINUX\u4e2dLWP\u7684C\u7a0b\u5e8f\n\n\n/* filename: test_LWP.c */\n\n\n#include\n \nstdlib.h\n\n\n#include\n \npthread.h\n\n\n#include\n \nstdio.h\n\n\n#include\n \nunistd.h\n\n\n\nint\n*\n \nthread\n(\nvoid\n*\n \narg\n)\n\n\n{\n\n    \npthread_t\n \ntid\n;\n \n// the ID of a thread\n\n    \ntid\n \n=\n \npthread_self\n();\n//get the current thread\ns id\n\n\n    \nprintf\n(\nThe ID of new thread is =%lu\n\\n\n,\n \ntid\n);\n\n    \nsleep\n(\n500\n);\n \n//sleep for 500 seconds\n\n    \nreturn\n \nNULL\n;\n \n\n}\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \npthread_t\n \ntid\n;\n\n    \nprintf\n(\nThe ID of main thread is %lu\n\\n\n,\n \npthread_self\n());\n \n//get the main thread\ns id\n\n  \nif\n \n(\npthread_create\n(\ntid\n,\n \nNULL\n,\n \n(\nvoid\n \n*\n)\n \nthread\n,\n \nNULL\n)\n \n!=\n0\n)\n \n    \n{\n\n       \nprintf\n(\nThread creation failed\n\\n\n);\n\n        \nexit\n(\n1\n);\n\n    \n}\n\n\n    \nprintf\n(\nmy Id is %lu, new thread ID is %lu\n\\n\n,\n \npthread_self\n(),\n \ntid\n);\n\n    \nsleep\n(\n1000\n);\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\u8fd0\u884c\nps -efL\n \u53ef\u4ee5\u770b\u5230, \ntest_LWP\n\u8fdb\u7a0b(PID=1953)\u6709\u4e24\u4e2aLWP\uff0c\u5373NLWP(number of light weight process)=2\u3002\n\n\nUID        PID  PPID   LWP  C NLWP STIME TTY          TIME CMD\nvagrant   1953  1644  1953  0    2 04:16 pts/0    00:00:00 ./test_LWP\nvagrant   1953  1644  1954  0    2 04:16 pts/0    00:00:00 ./test_LWP\nvagrant   2028  1839  2028  0    1 04:18 pts/1    00:00:00 ps -efL\n\n\n\n\nScheduler activation\n\n\nProblems\n:\n\u5185\u6838\u7ebf\u7a0b\u5728\u5404\u65b9\u9762\u90fd\u6bd4\u8f83\u7075\u6d3b\uff0c\u4f46\u662f\u6027\u80fd\u4e0d\u9ad8\uff0c\u7ecf\u5e38\u4f1a\u51fa\u73b0\u8bf7\u6c42\u5728\u7528\u6237\u7a7a\u95f4\u548c\u5185\u6838\u7a7a\u95f4\u7684\u4f20\u9012\u3002\u90a3\u4e48\u5982\u4f55\u5728\u62e5\u6709\u5185\u6838\u7a7a\u95f4\u7ebf\u7a0b\u7684\u7075\u6d3b\u6027\u7684\u540c\u65f6\u53c8\u63d0\u9ad8\u6027\u80fd\u5462?\n\n\nSolution\n:\n\n\nScheduler activation\n\uff08\u8c03\u5ea6\u5668\u6fc0\u6d3b\uff09are a threading mechanism that, when implemented in an operating system's process scheduler, provide \nkernel-level\n thread functionality with \nuser-level\n thread flexibility and performance [\nref\n]. \n\n\nIt works as follows: \n\n\n\n\nThe kernel provides an application with a set of virtual processors (LWPs), and the application can \nschedule\n user threads onto an available virtual processor. \n\n\nFurthermore, the kernel must inform an application about certain events. This procedure is known as an \nupcall\n(\u5411\u4e0a\u8c03\u7528). \n\n\nUpcalls are handled by the thread library with an upcall handler, and upcall handlers must run on a virtual processor.\n\n\nWhile the user threading library will schedule user threads, the kernel will schedule the underlying LWPs.\n\n\n\n\nExample\n [\nref\n]: \n\n\nLet\u2019s study an example of how scheduler activations can be used. The kernel has allocated one kernel thread (1) to a process with three user-level threads (2). The three user level threads take turn executing on the single kernel-level thread.\n\n\n\n\n\n\n(3) The executing thread makes a \nblocking system call\n.\n\n\n(4) And the the kernel blocks the calling user-level thread and the kernel-level thread used to execute the user-level thread .\n\n\n(5) Scheduler activation: the kernel decides to allocate a new kernel-level thread to the process . \n\n\n(6) Upcall: the kernel notifies the user-level thread manager which user-level thread that is now blocked and that a new kernel-level thread is available. \n\n\n(7) The user-level thread manager move the other threads to the new kernel thread and resumes one of the ready threads.", 
            "title": "Chapter 4: Threads and Concurrency"
        }, 
        {
            "location": "/osc/ch4/#operating-system-concepts-4-threads-concurrency", 
            "text": "", 
            "title": "Operating System Concepts 4 - Threads &amp; Concurrency"
        }, 
        {
            "location": "/osc/ch4/#1-overview", 
            "text": "A  thread  is a basic unit of CPU utilization; it comprises a thread ID, a program counter, a register set, and a stack.  \u7ebf\u7a0b\u662f\u4e00\u4e2aCPU\u5229\u7528\u7684\u57fa\u672c\u5355\u5143\uff0c\u5b83\u7531\u7ebf\u7a0bID\uff0c\u7a0b\u5e8f\u8ba1\u6570\u5668\u3001\u5bc4\u5b58\u5668\u96c6\u5408\u548c\u6808\u7ec4\u6210\u3002  A traditional process has a single thread of control. If a process has  multiple threads of control , it can perform more than one task at a time. \n\u4e00\u4e2a\u4f20\u7edf\u7684\u8fdb\u7a0b\u53ea\u6709\u5355\u4e2a\u63a7\u5236\u7ebf\u7a0b\uff0c\u5982\u679c\u8fdb\u7a0b\u6709\u591a\u4e2a\u63a7\u5236\u7ebf\u7a0b\uff0c\u90a3\u4e48\u5b83\u80fd\u4e00\u6b21\u5904\u7406\u591a\u4e2a\u4efb\u52a1\u3002  The figure below illustrates the difference between a traditional  single-threaded  process and a  multithreaded  process.", 
            "title": "1 Overview"
        }, 
        {
            "location": "/osc/ch4/#motivation", 
            "text": "Process creation is  time consuming  and  resource intensive . It is generally more efficient to use one process that contains multiple threads.", 
            "title": "Motivation"
        }, 
        {
            "location": "/osc/ch4/#benefits", 
            "text": "The benefits of  multithreaded programming can be broken down into four major categories:   Responsiveness  It allows a program to continue running even if part of it is blocked or is performing a lengthy operation, thereby increasing responsiveness to the user.  \u54cd\u5e94\u5ea6\u9ad8\uff1a\u5373\u4f7f\u7a0b\u5e8f\u90e8\u5206\u963b\u585e\u6216\u6267\u884c\u8f83\u5197\u957f\u64cd\u4f5c\uff0c\u8be5\u7a0b\u5e8f\u4ecd\u80fd\u7ee7\u7eed\u6267\u884c\uff0c\u4ece\u800c\u589e\u52a0\u4e86\u5bf9\u7528\u6237\u7684\u76f8\u5e94\u7a0b\u5ea6\u3002    Resource sharing  Processes can share resources only through techniques such as shared memory and message. Such techniques must be explicitly arranged by the programmer.  Threads share the memory and the resources of the process to which they belong by default.  \u8d44\u6e90\u5171\u4eab\uff1a\u7ebf\u7a0b\u9ed8\u8ba4\u5171\u4eab\u5b83\u4eec\u6240\u5c5e\u8fdb\u7a0b\u7684\u5185\u5b58\u548c\u8d44\u6e90\u3002\u4ee3\u7801\u548c\u6570\u636e\u5171\u4eab\u7684\u4f18\u70b9\u662f\u5b83\u5141\u8bb8\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\u5728\u540c\u4e00\u5730\u5740\u7a7a\u95f4\u6709\u591a\u4e2a\u4e0d\u540c\u7684\u6d3b\u52a8\u7ebf\u7a0b\u3002    Economy  Allocating memory and resources for process creation is costly. Because threads share the resources of the process to which they belong, it is more economical to create and context-switch threads.  \u7ecf\u6d4e\uff1a\u8fdb\u7a0b\u521b\u5efa\u6240\u9700\u8981\u7684\u5185\u5b58\u548c\u8d44\u6e90\u7684\u5206\u914d\u6bd4\u8f83\u6602\u8d35\u3002\u7531\u4e8e\u7ebf\u7a0b\u80fd\u5171\u4eab\u5b83\u4eec\u6240\u5c5e\u8fdb\u7a0b\u7684\u8d44\u6e90\uff0c\u6240\u4ee5\u521b\u5efa\u548c\u5207\u6362\u7ebf\u7a0b\u4f1a\u66f4\u4e3a\u7ecf\u6d4e\u3002    Scalability  The benefits of multithreading can be even greater in a multiprocessor architecture, where threads may be running in parallel on different processing cores.  \u53ef\u6269\u5c55\u6027: \u591a\u7ebf\u7a0b\u7684\u4f18\u70b9\u4e4b\u4e00\u662f\u80fd\u5145\u5206\u4f7f\u7528\u591a\u5904\u7406\u5668\u4f53\u7cfb\u7ed3\u6784\u3002\u4ee5\u4fbf\u6bcf\u4e2a\u8fdb\u7a0b\u80fd\u5e76\u884c\u8fd0\u884c\u5728\u4e0d\u540c\u7684\u5904\u7406\u5668\u4e0a\u3002", 
            "title": "Benefits"
        }, 
        {
            "location": "/osc/ch4/#2-multicore-programming", 
            "text": "On a system with a  single  computing core, concurrency merely means that the execution of the threads will be  interleaved  over time, because the processing core is capable of executing only one thread at a time.  On a system with  multiple  cores, however, concurrency means that some threads can run in  parallel , because the system can assign a separate thread to each core.    Note  Concurrency  v.s.  Parallelism   Concurrency: supports more than one task by allowing all the tasks to make progress.  Parallelism: perform more than one task simultaneously.", 
            "title": "2 Multicore Programming"
        }, 
        {
            "location": "/osc/ch4/#programming-challenges", 
            "text": "Identifying tasks . This involves examining applications to find areas that can be divided into separate, concurrent tasks.  Balance . Programmer must ensure that the tasks perform equal work of equal value.  Data splitting . The data accessed and manipulated by the tasks must be divided to run on separate cores.  Data dependency . The data accessed by the tasks must be examined for dependencies between two or more tasks.  Testing and debugging . Testing and debugging such concurrent programs is inherently more difficult than testing and debugging single-threaded applications.", 
            "title": "Programming Challenges"
        }, 
        {
            "location": "/osc/ch4/#types-of-parallelism", 
            "text": "In general, there are two types of parallelism: data parallelism and task parallelism.   Data parallelism  focuses on distributing subsets of the same data across multiple computing cores and performing the same operation on each core.   Task parallelism  involves distributing not data but tasks (threads) across multiple computing cores.  However, data and task parallelism are not mutually exclusive, and an application may in fact use a hybrid of these two strategies.", 
            "title": "Types of Parallelism"
        }, 
        {
            "location": "/osc/ch4/#3-multithreading-models", 
            "text": "Support for threads may be provided either at the user level, for  user threads , or by the kernel, for  kernel threads .    User threads are supported above the kernel and are managed without kernel support.  Kernel threads are supported and managed directly by the operating system.   \u6709\u4e24\u79cd\u4e0d\u540c\u7684\u65b9\u6cd5\u6765\u63d0\u4f9b\u7ebf\u7a0b\u652f\u6301\uff1a\u7528\u6237\u5c42\u7684\u7528\u6237\u7ea7\u7ebf\u7a0b\u548c\u5185\u6838\u5c42\u7684\u5185\u6838\u7ea7\u7ebf\u7a0b\u3002\u7528\u6237\u7ea7\u7ebf\u7a0b\u53d7\u5185\u6838\u652f\u6301\uff0c\u800c\u65e0\u9700\u5185\u6838\u7ba1\u7406\uff1b\u800c\u5185\u6838\u7ea7\u7ebf\u7a0b\u7531\u64cd\u4f5c\u7cfb\u7edf\u76f4\u63a5\u652f\u6301\u548c\u7ba1\u7406\u3002\u4e8b\u5b9e\u4e0a\u6240\u6709\u5f53\u4ee3\u64cd\u4f5c\u7cfb\u7edf\u90fd\u652f\u6301\u5185\u6838\u7ea7\u7ebf\u7a0b\u3002  Ultimately, a relationship must exist between user threads and kernel threads. There are three common ways of establishing such a relationship: the many-to-one model, the one-to-one model, and the many-to-many model.\n\u5728\u7528\u6237\u7ea7\u7ebf\u7a0b\u548c\u5185\u6838\u7ea7\u7ebf\u7a0b\u4e4b\u95f4\u5fc5\u7136\u5b58\u5728\u4e00\u79cd\u5173\u7cfb\u3002\u6709\u4e09\u79cd\u666e\u904d\u5efa\u7acb\u8fd9\u79cd\u5173\u7cfb\u7684\u65b9\u6cd5\uff1a\u591a\u5bf9\u4e00\u6a21\u578b\u3001\u4e00\u5bf9\u4e00\u6a21\u578b\u3001\u591a\u5bf9\u591a\u6a21\u578b\u3002", 
            "title": "3 Multithreading Models"
        }, 
        {
            "location": "/osc/ch4/#many-to-one-model", 
            "text": "The  many-to-one model  maps many user-level threads to one kernel thread. \u591a\u5bf9\u4e00\u6a21\u578b\u5c06\u8bb8\u591a\u7528\u6237\u7ea7\u7ebf\u7a0b\u6620\u5c04\u5230\u4e00\u4e2a\u5185\u6838\u7ebf\u7a0b\u3002   Thread management is done by the thread library in user space, so it is efficient. \u7ebf\u7a0b\u7ba1\u7406\u7531\u7ebf\u7a0b\u5e93\u5728\u7528\u6237\u7a7a\u95f4\u8fdb\u884c\u7684\uff0c\u56e0\u800c\u6548\u7387\u6bd4\u8f83\u9ad8\u3002  Also, because only one thread can access the kernel at a time, multiple threads are unable to run in parallel on multicore systems. \u56e0\u4e3a\u4efb\u610f\u65f6\u523b\u53ea\u80fd\u6709\u4e00\u4e2a\u7ebf\u7a0b\u80fd\u591f\u8bbf\u95ee\u5185\u6838\uff0c\u591a\u4e2a\u7ebf\u7a0b\u4e0d\u80fd\u5e76\u884c\u8fd0\u884c\u5728\u591a\u5904\u7406\u5668\u4e0a\u3002", 
            "title": "Many-to-One Model"
        }, 
        {
            "location": "/osc/ch4/#one-to-one-model", 
            "text": "The  one-to-one model  maps each user thread to a kernel thread. \u4e00\u5bf9\u4e00\u6a21\u578b\u6bcf\u4e2a\u7528\u6237\u7ebf\u7a0b\u6620\u5c04\u5230\u4e00\u4e2a\u5185\u6838\u7ebf\u7a0b\u3002   It provides more concurrency by allowing another thread to run when a thread makes a blocking system call. \u8be5\u6a21\u578b\u5728\u4e00\u4e2a\u7ebf\u7a0b\u6267\u884c\u963b\u585e\u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u80fd\u5141\u8bb8\u53e6\u4e00\u4e2a\u7ebf\u7a0b\u7ee7\u7eed\u6267\u884c\uff0c\u63d0\u4f9b\u4e86\u66f4\u9ad8\u7684\u5e76\u53d1\u6027\u3002  It also allows multiple threads to run in parallel on multiprocessors. \u5b83\u4e5f\u5141\u8bb8\u591a\u4e2a\u7ebf\u7a0b\u80fd\u5e76\u884c\u8fd0\u884c\u5728\u591a\u5904\u7406\u5668\u7cfb\u7edf\u4e0a\u3002  The only drawback to this model is that creating a user thread requires creating the corresponding kernel thread, and a large number of kernel threads may burden the performance of a system. \u8fd9\u79cd\u6a21\u578b\u7684\u552f\u4e00\u7f3a\u70b9\u662f\u6bcf\u521b\u5efa\u4e00\u4e2a\u7528\u6237\u7ebf\u7a0b\u5c31\u4f1a\u521b\u5efa\u4e00\u4e2a\u76f8\u5e94\u7684\u5185\u6838\u7ebf\u7a0b, \u5927\u91cf\u5185\u6838\u7ebf\u7a0b\u4f1a\u5f71\u54cd\u7cfb\u7edf\u6027\u80fd\u3002", 
            "title": "One-to-One Model"
        }, 
        {
            "location": "/osc/ch4/#many-to-many-model", 
            "text": "The  many-to-many model  multiplexes many user-level threads to a smaller or equal number of kernel threads. \u591a\u5bf9\u591a\u6a21\u578b\u591a\u8def\u590d\u7528\u4e86\u8bb8\u591a\u7528\u6237\u7ebf\u7a0b\u5230\u540c\u6837\u6570\u91cf\u6216\u66f4\u5c0f\u6570\u91cf\u7684\u5185\u6838\u7ebf\u7a0b\u4e0a\u3002   Developers can create as many user threads as necessary. \u5f00\u53d1\u4eba\u5458\u53ef\u521b\u5efa\u4efb\u610f\u591a\u7684\u7528\u6237\u7ebf\u7a0b\u3002  The corresponding kernel threads can run in parallel on a multiprocessor. \u76f8\u5e94\u5185\u6838\u7ebf\u7a0b\u80fd\u5728\u591a\u5904\u7406\u5668\u7cfb\u7edf\u4e0a\u5e76\u53d1\u6267\u884c\u3002  Also, when a thread performs a blocking system call, the kernel can schedule another thread for execution. \u800c\u4e14\u5f53\u4e00\u4e2a\u7ebf\u7a0b\u6267\u884c\u963b\u585e\u7cfb\u7edf\u8c03\u7528\u65f6\uff0c\u5185\u6838\u80fd\u8c03\u5ea6\u53e6\u4e00\u4e2a\u7ebf\u7a0b\u6765\u6267\u884c\u3002  In practice it is  difficult to implement . \u5b9e\u9645\u4e0a\u96be\u4ee5\u5b9e\u65bd\u3002    Most operating systems now use the one-to-one model.", 
            "title": "Many-to-Many Model"
        }, 
        {
            "location": "/osc/ch4/#userkernel-level-threads", 
            "text": "ref: Scheduler Activations  (1)  User-Level Threads (\u7528\u6237\u7ea7\u7ebf\u7a0b)  Advantages:   Common operations can be implemented  efficiently    Interface can be tailored to application needs   Issues:   A blocking system call blocks all user-level threads. \u963b\u585e\u7cfb\u7edf\u8c03\u7528\u80fd\u591f\u963b\u585e\u6240\u6709\u7528\u6237\u7ea7\u7ebf\u7a0b\u3002  Asynchronous system calls can provide partial work-around. \u975e\u540c\u6b65\u7cfb\u7edf\u8c03\u7528\u80fd\u63d0\u4f9b\u90e8\u5206work-around.  view the definition of work-around here  A page fault blocks all user-level threads. \u7f3a\u9875\u5f02\u5e38\u963b\u585e\u6240\u6709\u7528\u6237\u7ea7\u7ebf\u7a0b\u3002  Matching threads to CPUs in a multiprocessor is hard\uff1a  No knowledge about the numbers of CPUs available to address space   No knowledge when a thread blocks     (2)  Kernel-Level Threads  (\u5185\u6838\u7ea7\u7ebf\u7a0b)  Primary advantage\n* Blocking system calls and page faults handled correctly  Issues  Cost of performing thread operations  Create, exit, lock, signal, wait all require user/kernel crossings  NOTE : The term  virtual processor  is often used instead of kernel thread.", 
            "title": "User/Kernel-Level threads"
        }, 
        {
            "location": "/osc/ch4/#4-thread-libraries", 
            "text": "A thread library provides the programmer with an API for creating and managing threads. \u7ebf\u7a0b\u5e93\u4e3a\u7a0b\u5e8f\u5458\u63d0\u4f9b\u4e86\u521b\u5efa\u548c\u7ba1\u7406\u7ebf\u7a0b\u7684API\u3002  Pthreads , the threads extension of the POSIX standard, may be provided as either a user-level or a kernel-level library. Pthread\u4f5c\u4e3aPOSIX\u6807\u51c6\u6269\u5c55\uff0c\u53ef\u4ee5\u63d0\u4f9b\u7528\u6237\u7ea7\u6216\u5185\u6838\u7ea7\u7684\u5e93\u3002   pthread_t tid : declares the identifier for the thread  pthread attr_t attr : declares the attributes for the thread  pthread_attr_init( attr) : initialize thread attributes object  pthread_create() : create a new thread  pthread_join() :  join with a terminated thread    pthread_exit() :  terminate calling thread     Note: Compile and link with  -pthread .  pthread \u8be6\u7ec6\u7528\u6cd5\u548c\u5b9e\u4f8b, \u89c1 POSIX thread (pthread) libraries", 
            "title": "4 Thread Libraries"
        }, 
        {
            "location": "/osc/ch4/#5-implicit-threading", 
            "text": "Implicit threading (\u9690\u5f0f\u7ebf\u7a0b): Transfers the creation and management of threading from application developers to compilers and run-time libraries.   One way to address difficulties and better support the design of concurrent and parallel applications  The advantage of this approach is that developers  only need to identify parallel tasks , and the libraries determine the specific details of thread creation and management.   In this section, we explore four alternative approaches to designing applications that can take advantage of multicore processors through implicit threading:   Thread Pools  Fork Join  OpemMP  Grand Central Dispatch", 
            "title": "5 Implicit threading"
        }, 
        {
            "location": "/osc/ch4/#thread-pools", 
            "text": "Two main issues exist:   The thread will be  discarded  once it has completed its work. \u7ebf\u7a0b\u5728\u5b8c\u6210\u5de5\u4f5c\u4e4b\u540e\u5c31\u8981\u88ab\u4e22\u5f03  Unlimited  threads could exhaust system resources. \u65e0\u9650\u5236\u7684\u7ebf\u7a0b\u4f1a\u8017\u5c3d\u7cfb\u7edf\u8d44\u6e90   Solution -   thread pool (\u7ebf\u7a0b\u6c60)   It creates a number of threads at start-up, and places them into a pool, where they sit and wait for work.  When a server receives a request, it submits the request to the thread pool and resumes waiting for additional requests.  If there is an available thread in the pool, it is awakened, and the request is serviced immediately.   If the pool contains no available thread, the task is queued until one becomes free.    \u7ebf\u7a0b\u6c60\u7684\u601d\u60f3\u662f\u5728\u8fdb\u7a0b\u5f00\u59cb\u65f6\u521b\u5efa\u4e00\u5b9a\u6570\u91cf\u7684\u7ebf\u7a0b\uff0c\u5e76\u653e\u5165\u5230\u6c60\u4e2d\u4ee5\u7b49\u5f85\u5de5\u4f5c\u3002\u5f53\u670d\u52a1\u5668\u6536\u5230\u8bf7\u6c42\u65f6\uff0c\u5b83\u4f1a\u5524\u9192\u7ebf\u7a0b\u6c60\u4e2d\u7684\u4e00\u4e2a\u7ebf\u7a0b\uff0c\u5e76\u5c06\u8981\u5904\u7406\u7684\u8bf7\u6c42\u4f20\u9012\u7ed9\u5b83\uff0c\u4e00\u65e6\u7ebf\u7a0b\u5b8c\u6210\u4e86\u670d\u52a1\uff0c\u5b83\u4f1a\u8fd4\u56de\u5230\u6c60\u4e2d\u5728\u7b49\u5f85\u5de5\u4f5c\u3002\u5982\u679c\u6c60\u4e2d\u6ca1\u6709\u53ef\u7528\u7684\u7ebf\u7a0b\uff0c\u90a3\u4e48\u670d\u52a1\u5668\u4f1a\u4e00\u76f4\u7b49\u5f85\u76f4\u5230\u6709\u7a7a\u7ebf\u7a0b\u4e3a\u6b62\u3002  Thread pools offer these benefits:   Servicing a request with an existing thread is often  faster  than waiting to create a thread. \u901a\u5e38\u7528\u73b0\u6709\u7ebf\u7a0b\u5904\u7406\u8bf7\u6c42\u8981\u6bd4\u7b49\u5f85\u521b\u5efa\u65b0\u7684\u7ebf\u7a0b\u8981\u5feb.  A thread pool  limits  the number of threads that exist at any one point.  \u7ebf\u7a0b\u6c60\u9650\u5236\u4e86\u5728\u4efb\u4f55\u65f6\u5019\u53ef\u7528\u7ebf\u7a0b\u7684\u6570\u91cf.  Separating the task to be performed from the mechanics of creating the task allows us to use different strategies for running the task.   Java\u7ebf\u7a0b\u5e93\u7684\u4e00\u4e2a\u4f8b\u5b50\uff1a  import   java.util.concurrent.* ;   public   class   ThreadPoolExample   {  \n     public   static   void   main ( String []   args )   { \n         int   numTasks   =   Integer . parseInt ( args [ 0 ]. trim ());  \n\n         /* Create the thread pool */  \n         ExecutorService   pool   =   Executors . newCachedThreadPool ();  \n         /* Run each task using a thread in the pool */  \n         for   ( int   i   =   0 ;   i     numTasks ;   i ++)  \n             pool . execute ( new   Task ());  \n\n          /* Shut down the pool once all threads have completed */             \n         pool . shutdown ();  }", 
            "title": "Thread Pools"
        }, 
        {
            "location": "/osc/ch4/#grand-central-dispatch", 
            "text": "Grand Central Dispatch  (GCD) is a technology for Apple's Mac OS X and iOS operating systems. It is a combination of extensions to the C languages, an API, and a run-time library that allows application developers identify sections of code to run in parallel.   GCD identifies two types of dispatch queues: serial and concurrent.", 
            "title": "Grand Central Dispatch"
        }, 
        {
            "location": "/osc/ch4/#6-threading-issues", 
            "text": "", 
            "title": "6 Threading Issues"
        }, 
        {
            "location": "/osc/ch4/#light-weight-process", 
            "text": "Many systems implementing either the many-to-many or the two-level model place an  intermediate  data structure between the user and kernel threads. This data structure\u2014typically known as a  lightweight process \uff08\u8f7b\u91cf\u7ea7\u8fdb\u7a0b\uff09, or  LWP .   To the user-thread library, the LWP appears to be a  virtual  processor on which the application can schedule a user thread to run.  Each LWP is attached to a kernel thread.  If a kernel thread blocks, the LWP blocks as well. Up the chain, the user-level thread attached to the LWP also blocks.     where K denotes kernel threads and  P denotes Process.  \u4e0b\u9762\u662f\u4e00\u4e2a\u6d4b\u8bd5LINUX\u4e2dLWP\u7684C\u7a0b\u5e8f  /* filename: test_LWP.c */  #include   stdlib.h  #include   pthread.h  #include   stdio.h  #include   unistd.h  int *   thread ( void *   arg )  { \n     pthread_t   tid ;   // the ID of a thread \n     tid   =   pthread_self (); //get the current thread s id \n\n     printf ( The ID of new thread is =%lu \\n ,   tid ); \n     sleep ( 500 );   //sleep for 500 seconds \n     return   NULL ;   }  int   main ()  { \n     pthread_t   tid ; \n     printf ( The ID of main thread is %lu \\n ,   pthread_self ());   //get the main thread s id \n   if   ( pthread_create ( tid ,   NULL ,   ( void   * )   thread ,   NULL )   != 0 )  \n     { \n        printf ( Thread creation failed \\n ); \n         exit ( 1 ); \n     } \n\n     printf ( my Id is %lu, new thread ID is %lu \\n ,   pthread_self (),   tid ); \n     sleep ( 1000 ); \n     return   0 ;  }   \u8fd0\u884c ps -efL  \u53ef\u4ee5\u770b\u5230,  test_LWP \u8fdb\u7a0b(PID=1953)\u6709\u4e24\u4e2aLWP\uff0c\u5373NLWP(number of light weight process)=2\u3002  UID        PID  PPID   LWP  C NLWP STIME TTY          TIME CMD\nvagrant   1953  1644  1953  0    2 04:16 pts/0    00:00:00 ./test_LWP\nvagrant   1953  1644  1954  0    2 04:16 pts/0    00:00:00 ./test_LWP\nvagrant   2028  1839  2028  0    1 04:18 pts/1    00:00:00 ps -efL", 
            "title": "Light Weight Process"
        }, 
        {
            "location": "/osc/ch4/#scheduler-activation", 
            "text": "Problems :\n\u5185\u6838\u7ebf\u7a0b\u5728\u5404\u65b9\u9762\u90fd\u6bd4\u8f83\u7075\u6d3b\uff0c\u4f46\u662f\u6027\u80fd\u4e0d\u9ad8\uff0c\u7ecf\u5e38\u4f1a\u51fa\u73b0\u8bf7\u6c42\u5728\u7528\u6237\u7a7a\u95f4\u548c\u5185\u6838\u7a7a\u95f4\u7684\u4f20\u9012\u3002\u90a3\u4e48\u5982\u4f55\u5728\u62e5\u6709\u5185\u6838\u7a7a\u95f4\u7ebf\u7a0b\u7684\u7075\u6d3b\u6027\u7684\u540c\u65f6\u53c8\u63d0\u9ad8\u6027\u80fd\u5462?  Solution :  Scheduler activation \uff08\u8c03\u5ea6\u5668\u6fc0\u6d3b\uff09are a threading mechanism that, when implemented in an operating system's process scheduler, provide  kernel-level  thread functionality with  user-level  thread flexibility and performance [ ref ].   It works as follows:    The kernel provides an application with a set of virtual processors (LWPs), and the application can  schedule  user threads onto an available virtual processor.   Furthermore, the kernel must inform an application about certain events. This procedure is known as an  upcall (\u5411\u4e0a\u8c03\u7528).   Upcalls are handled by the thread library with an upcall handler, and upcall handlers must run on a virtual processor.  While the user threading library will schedule user threads, the kernel will schedule the underlying LWPs.   Example  [ ref ]:   Let\u2019s study an example of how scheduler activations can be used. The kernel has allocated one kernel thread (1) to a process with three user-level threads (2). The three user level threads take turn executing on the single kernel-level thread.    (3) The executing thread makes a  blocking system call .  (4) And the the kernel blocks the calling user-level thread and the kernel-level thread used to execute the user-level thread .  (5) Scheduler activation: the kernel decides to allocate a new kernel-level thread to the process .   (6) Upcall: the kernel notifies the user-level thread manager which user-level thread that is now blocked and that a new kernel-level thread is available.   (7) The user-level thread manager move the other threads to the new kernel thread and resumes one of the ready threads.", 
            "title": "Scheduler activation"
        }, 
        {
            "location": "/osc/ch5/", 
            "text": "Operating System Concepts 5 - CPU Scheduling\n\n\nOn modern operating systems it is \nkernel-level threads\n \u2014not processes\u2014that are in fact being scheduled by the operating system. \n\n\n\n\nUser-level threads are managed by a thread library, and the kernel is \nunaware\n of them.\n\n\nTo run on a CPU, user-level threads must ultimately be mapped to an associated kernel-level thread, although this mapping may be indirect and may use a lightweight process (LWP).\n\n\n\n\n1 Basic Concepts\n\n\nCPU-I/O Burst Cycle\n\n\nProcess execution consists of a \ncycle\n of CPU execution and I/O wait. \u8fdb\u7a0b\u6267\u884c\u7531CPU\u6267\u884c\u5468\u671f\u548cI/O\u7b49\u5f85\u5468\u671f\u7ec4\u6210\u3002\n\n\n\n\nProcesses alternate between these two states. \u8fdb\u7a0b\u5728\u8fd9\u4e24\u4e2a\u72b6\u6001\u4e4b\u95f4\u5207\u6362\u3002\n\n\nProcess execution begins with a \nCPU burst\n, which is followed by an \nI/O burst\n and so on. \u8fdb\u7a0b\u6267\u884c\u4eceCPU\u533a\u95f4\u5f00\u59cb\uff0c\u5728\u8fd9\u4e4b\u540e\u662fI/O\u533a\u95f4\u3002\n\n\n\n\n\u8fdb\u7a0b\u5728CPU\u533a\u95f4\u548cI/O\u533a\u95f4\u4e4b\u95f4\u5207\u6362\uff1a\n\n\n\n\nThe durations of CPU bursts tend to have a frequency curve similar to the figure below. \n\n\n\n\nThe curve is generally characterized as \nexponential\n or hyperexpoential(\u8d85\u6307\u6570).\n\n\nA large number of short CPU bursts and a small number of long CPU burst.\n\n\nAn I/O-bounded program typically has many short CPU bursts. I/O\u5bc6\u96c6\u7a0b\u5e8f\u901a\u5e38\u5177\u6709\u5f88\u591a\u77edCPU\u533a\u95f4\u3002\n\n\nA CPU-bound program might have a few long CPU bursts.CPU\u5bc6\u96c6\u7a0b\u5e8f\u53ef\u80fd\u6709\u5c11\u91cf\u7684\u957fCPU\u533a\u95f4\u3002\n\n\nThe distribution can be important when implementing a CPU-scheduling algorithm. \u5206\u5e03\u6709\u52a9\u4e8e\u9009\u62e9\u5408\u9002\u7684CPU\u8c03\u5ea6\u7b97\u6cd5\u3002\n\n\n\n\n\n\nCPU Scheduler\n\n\nWhenever the CPU becomes idle, the operating system must select one of the processes in the \nready queue\n(\u5c31\u7eea\u961f\u5217) to be executed. \u6bcf\u5f53CPU\u7a7a\u95f2\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u5fc5\u987b\u4ece\u5c31\u7eea\u961f\u5217\u4e2d\u9009\u62e9\u4e00\u4e2a\u8fdb\u7a0b\u6765\u6267\u884c\u3002\n\n\n\n\nThe selection process is carried out by the \nCPU scheduler\n(CPU\u8c03\u5ea6\u7a0b\u5e8f).  \u8fdb\u7a0b\u9009\u62e9\u7531CPU\u8c03\u5ea6\u7a0b\u5e8f\u6267\u884c\u3002\n\n\nCPU scheduler selects a process from the processes in memory that are ready to execute and allocates the CPU to that process. \u8c03\u5ea6\u7a0b\u5e8f\u4ece\u5185\u5b58\u4e2d\u9009\u62e9\u4e00\u4e2a\u80fd\u591f\u6267\u884c\u7684\u8fdb\u7a0b\uff0c\u5e76\u4e3a\u4e4b\u5206\u914dCPU\u3002\n\n\nA ready queue can be implemented as a FIFO queue, a priority queue, a tree, or simply an unordered linked list. \u5c31\u7eea\u961f\u5217\u53ef\u4ee5\u662fFIFO\u961f\u5217\uff0c\u4f18\u5148\u961f\u5217\u3001\u6811\u6216\u65e0\u5e8f\u94fe\u8868\u3002\n\n\n\n\nPreemptive and Nonpreemptive Scheduling\n\n\nCPU-scheduling decisions may take place under the following four circumstances: \n\n\n\n\nWhen a process switches from the running state to the waiting state (for example, as the result of an I/O request or an invocation of \nwait()\n for the termination of a child process) \u5f53\u4e00\u4e2a\u8fdb\u7a0b\u4ece\u8fd0\u884c\u72b6\u6001\u5207\u6362\u5230\u7b49\u5f85\u72b6\u6001\uff08\u5982\uff1aI/O\u8bf7\u6c42\uff0c\u6216\u8005\u8c03\u7528wait\u7b49\u5f85\u4e00\u4e2a\u5b50\u8fdb\u7a0b\u7684\u7ec8\u6b62\uff09 \n\n\nWhen a process switches from the running state to the ready state (for example, when an interrupt occurs) \u5f53\u4e00\u4e2a\u8fdb\u7a0b\u4ece\u8fd0\u884c\u72b6\u6001\u5207\u6362\u5230\u5c31\u7eea\u72b6\u6001\uff08\u5982\uff1a\u51fa\u73b0\u4e2d\u65ad\uff09 \n\n\nWhen a process switches from the waiting state to the ready state (for example, at completion of I/O) \u5f53\u4e00\u4e2a\u8fdb\u7a0b\u4ece\u7b49\u5f85\u72b6\u6001\u5207\u6362\u5230\u5c31\u7eea\u72b6\u6001\uff08\u5982\uff1aI/O\u5b8c\u6210\uff09 \n\n\nWhen a process terminates \u5f53\u4e00\u4e2a\u8fdb\u7a0b\u7ec8\u6b62\u65f6\n\n\n\n\nWhen scheduling takes place only under circumstances 1 and 4, the scheduling scheme is \nnonpreemptive\n(\u975e\u62a2\u5360\u7684) or \ncooperative\n(\u534f\u4f5c\u7684). Otherwise, it is \npreemptive\n(\u62a2\u5360\u7684).\n\n\n\n\nUnder nonpreemptive scheduling, once the CPU has been allocated to a process, the process keeps the CPU until it releases it either by terminating or by switching to the waiting state.\n\n\nVirtually all modern Operating systems use preemptive scheduling algorithms. \n\n\n\n\nDispatcher\n\n\nThe \ndispatcher\n(\u5206\u6d3e\u7a0b\u5e8f) is the module that gives control of the CPU's core to the process selected by the CPU scheduler. This function involves the following:\n\n\n\n\nSwitching context from one process to another\n\n\nSwitching to user mode\n\n\nJumping to the proper location in the user program to resume that program\n\n\n\n\nDispatch latency\n (\u5206\u6d3e\u5ef6\u8fdf) is the time it takes for the dispatcher to stop one process and start another running.\n\n\n\n\n2 Scheduling Criteria\n\n\nScheduling criteria\uff08\u8c03\u5ea6\u51c6\u5219) include the following:\n\n\n\n\nCPU utilization\n(CPU\u5229\u7528\u7387)\n\n\nThroughput\n(\u541e\u5410\u91cf): the number of processes that are completed per time unit.\n\n\nTurnaround time\n(\u5468\u8f6c\u65f6\u95f4): the interval from the time of submission of a process to the time of completion.\n\n\nWaiting time\n(\u7b49\u5f85\u65f6\u95f4): the sum of time spent waiting in the ready queue.\n\n\nResponse time\n(\u54cd\u5e94\u65f6\u95f4): the time from the submission of a request until the first response is produced.\n\n\n\n\n3 Scheduling Algorithms\n\n\nFirst-Come,First-Serve scheduling, FCFS\n\n\nBy far the simplest CPU-scheduling algorithm is the \nfirst-come first serve scheduling\n (\u5148\u5230\u5148\u670d\u52a1\u8c03\u5ea6, FCFS) algorithm.\n\n\n\n\nThe implementation of FCFS policy is easily managed with a \nFIFO queue\n.\n\n\nThe average \nwaiting time\n under the FCFS policy is often quite \nlong\n.\n\n\nConvoy effect\n(\u62a4\u822a\u6548\u679c) occurs when all the other processes wait for the one big process to get off the CPU. \u6240\u6709\u5176\u4ed6\u8fdb\u7a0b\u90fd\u7b49\u5f85\u4e00\u4e2a\u5927\u8fdb\u7a0b\u91ca\u653eCPU\uff0c\u8fd9\u79f0\u4e4b\u4e3a\u62a4\u822a\u6548\u679c\u3002\n\n\nThe FCFS scheduling algorithm is \nnonpreemptive\n. FCFS\u8c03\u5ea6\u7b97\u6cd5\u662f\u975e\u62a2\u5360\u7684\u3002\n\n\n\n\nShortest-job-first scheduling, SJF\n\n\nThe \nshortest-job-first scheduling\n (\u6700\u77ed\u4f5c\u4e1a\u4f18\u5148\u8c03\u5ea6, SJF) algorithm associates with each process the length of the process's next CPU burst.\n\n\n\n\nWhen the CPU is available, it is assigned to the process that has the smallest \nnext\n CPU burst.\n\n\nIt gives the \nminimum\n average waiting time for a given set of processes.\n\n\nThe SJF algorithm can be either preemptive or nonpreemptive.\n\n\nPreempt the currently executing process: when a new process arrives at the ready queue while a previous process is still executing. The next CPU burst of the newly arrived process may be shorter than what is left of the currently executing process. \n\n\n\n\n\n\n\n\nThe next CPU burst is generally predicted as an \nexponential average\n of the measured lengths of previous CPU bursts. Let \nt_n\nt_n\n be the length of the \nn\nn\nth CPU burst, and let \n\\tau_{n+1}\n\\tau_{n+1}\n be predicted value for the next CPU burst:\n\n\n\n\n\\tau_{n+1}= \\alpha t_n + (1-\\alpha) \\tau_n\n\n\n\\tau_{n+1}= \\alpha t_n + (1-\\alpha) \\tau_n\n\n\n\n\nwhere \n0\\le\\alpha \\le 1\n0\\le\\alpha \\le 1\n, commonly \n\\alpha = 1/2\n\\alpha = 1/2\n.\n\n\nRound-Robin scheduling, RR\n\n\nThe \nround-robin scheduling\n(\u8f6e\u8f6c\u8c03\u5ea6) algorithm is similar to FCFS scheduling, but switch occurs after 1 \ntime quantum\n (\u65f6\u95f4\u7247).\n\n\n\n\nTime quantum is a small unit of time, generally from 10 to 100 milliseconds in length.\n\n\nThe ready queue is treated as a circular queue.\n\n\nIf the process have a CPU burst of less than 1 time quantum, the  process itself will release the CPU voluntarily.\n\n\notherwise, a context switch will be executed, and the process will be put at the tail of the ready queue.\n\n\n\n\nThe performance of the RR algorithm depends heavily on the size of the time quantum.\n\n\n\n\nIf extremely large, the RR policy is the same as the FCFS policy.\n\n\nIf extremely small, it'll result in a large number of context switches.\n\n\n\n\nPriority scheduling algorithm\n\n\nThe \npriority-scheduling\n(\u4f18\u5148\u7ea7\u8c03\u5ea6) algorithm associate each process a priority, and the CPU allocated to the process with the highest priority.\n\n\n\n\nFCFS: equal-priority\n\n\nSJF: the priority is the inverse of the next CPU burst.\n\n\n\n\nISSUE: \nIndefinite blocking\n(\u65e0\u9650\u963b\u585e), or \nstarvation\n(\u9965\u997f) \noccurs when some low-priority processes waiting indefinitely\n.\n\n\nSOLUTION: \nAging\n(\u8001\u5316) involves gradually increasing the priority of processes that wait in the system for a long time.\n\n\nMultilevel Queue Scheduling\n\n\nFor \nmultilevel queue scheduling\n(\u591a\u7ea7\u961f\u5217\u8c03\u5ea6), there are separate queues for each distinct priority, and priority scheduling simply schedules the process in the highest-priority queue.\n\n\nA multilevel queue scheduling algorithm can be used to partition processes into several separate queues based on the process type:\n\n\n\n\nIn addition, there must be scheduling \namong the queues\n :\n\n\n\n\nFixed-priority preemptive scheduling\n(\u56fa\u5b9a\u4f18\u5148\u7ea7\u62a2\u5360\u8c03\u5ea6): Each queue has absolute priority over lower-priority queues\n\n\neg. no process in the batch queue, could run unless the queues for real-time processes, system processes, and interactive processes were all empty. \n\n\n\n\n\n\nTime-slice among queues\n(\u961f\u5217\u4e4b\u95f4\u5212\u5206\u65f6\u95f4\u7247): each queue gets a certain portion of the CPU time.\n\n\neg. the foreground queue can be given 80 percent of the CPU time for RR scheduling among its processes, while the background queue receives 20 percent of the CPU to give to its processes on an FCFS basis.\n\n\n\n\n\n\n\n\nMultilevel Feedback-Queue Scheduling\n\n\nThe \nmultilevel feedback queue scheduling\n(\u591a\u7ea7\u53cd\u9988\u961f\u5217\u8c03\u5ea6) algorithm allows a process to move between queues.\n\n\n\n\nIf a process uses too much CPU time, it will be moved to a lower-priority queue.\n\n\nIt leaves I/O-bound and interactive processes\u2014which are typically characterized by short CPU bursts \u2014in the higher-priority queues. \n\n\n\n\n\n\nA process that waits too long in a lower-priority queue may be moved to a higher-priority queue.\n\n\nThis form of aging prevent starvation.\n\n\n\n\n\n\n\n\nIn general, a multilevel feedback queue scheduler is defined by the following parameters:\n\n\n\n\nThe number of queues\n\n\nThe scheduling algorithm for each queue\n\n\nThe method used to determine when to upgrade a process to a higher priority queue\n\n\nThe method used to determine when to demote a process to a lower priority queue\n\n\nThe method used to determine which queue a process will enter when that process needs service\n\n\n\n\n4 Thread Scheduling\n\n\nContention Scope\n\n\nProcess contention scope\n(PCS\uff0c\u8fdb\u7a0b\u7ade\u4e89\u8303\u56f4), specifies that competition for the CPU takes place among threads belonging to the same process.\n\n\n\n\nthe thread library schedules user-level threads to run on an available LWP, on systems implementing the many-to-one and many-to-many models.\n\n\n\n\nTo decide which kernel-level thread to schedule onto a CPU, the kernel uses \nsystem-contention scope\n(SCS, \u7cfb\u7edf\u7ade\u4e89\u8303\u56f4).\n\n\n\n\nSystems using the one-to-one model, such as Windows and Linux schedule threads using only SCS.\n\n\n\n\nPthread Scheduling\n\n\nPthreads\n identifies the following contention scope values:\n\n\n\n\nPTHREAD_SCOPE_PROCESS\n schedules threads using PCS scheduling.\n\n\nPTHREAD_SCOPE_SYSTEM\n schedules threads using SCS scheduling.\n\n\n\n\nThe Pthread IPC (Interprocess Communication) provides two functions for setting\u2014and getting\u2014the contention scope policy:\n\n\n\n\npthread_attr_setscope(pthread_attr_t *attr, int scope)\n\n\npthread_attr_getscope(pthread_attr_t *attr, int *scope)\n\n\n\n\n#include\n \npthread.h\n\n\n#include\n \nstdio.h\n\n\n#define NUM_THREADS 5\n\n\n\n/* the thread runs in this function */\n\n\nvoid\n \n*\nrunner\n(\nvoid\n \n*\nparam\n);\n \n\n\nint\n \nmain\n(\nint\n \nargc\n,\n \nchar\n \n*\nargv\n[])\n\n\n{\n\n    \nint\n \ni\n,\n \nscope\n;\n\n    \npthread_t\n \ntid\n[\nNUM_THREADS\n];\n     \n/* the thread identifier */\n\n    \npthread_attr_t\n \nattr\n;\n        \n/* set of attributes for the thread */\n\n\n    \n/* get the default attributes */\n\n    \npthread_attr_init\n(\nattr\n);\n\n\n    \n/* first inquire on the current scope */\n\n    \nif\n \n(\npthread_attr_getscope\n(\nattr\n,\nscope\n)\n \n!=\n \n0\n)\n\n        \nfprintf\n(\nstderr\n,\n \nUnable to get scheduling scope.\n\\n\n);\n\n    \nelse\n \n{\n\n        \nif\n \n(\nscope\n \n==\n \nPTHREAD_SCOPE_PROCESS\n)\n\n            \nprintf\n(\nPTHREAD_SCOPE_PROCESS\n\\n\n);\n\n        \nelse\n \nif\n \n(\nscope\n \n==\n \nPTHREAD_SCOPE_SYSTEM\n)\n\n            \nprintf\n(\nPTHREAD_SCOPE_SYSTEM\n\\n\n);\n\n        \nelse\n \n            \nfprintf\n(\nstderr\n,\nIllegal scope value.\n\\n\n);\n\n    \n}\n\n\n    \n/* set the scheduling algorithm to PCS or SCS */\n\n    \nif\n \n(\npthread_attr_setscope\n(\nattr\n,\n \nPTHREAD_SCOPE_SYSTEM\n)\n \n!=\n \n0\n)\n\n        \nprintf\n(\nunable to set scheduling policy.\n\\n\n);\n\n\n    \n/* create the threads */\n\n    \nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n \nNUM_THREADS\n;\n \ni\n++\n)\n \n        \npthread_create\n(\ntid\n[\ni\n],\nattr\n,\nrunner\n,\nNULL\n);\n \n\n    \n/**\n\n\n     * Now join on each thread\n\n\n     */\n\n    \nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n \nNUM_THREADS\n;\n \ni\n++\n)\n \n        \npthread_join\n(\ntid\n[\ni\n],\n \nNULL\n);\n\n\n}\n\n\n\n/**\n\n\n * The thread will begin control in this function.\n\n\n */\n\n\nvoid\n \n*\nrunner\n(\nvoid\n \n*\nparam\n)\n \n\n{\n\n    \n/* do some work ... */\n\n\n    \npthread_exit\n(\n0\n);\n\n\n}\n\n\n\n\n\n5 Multi-Processor Scheduling\n\n\nApproaches to Multiple-Processor Scheduling\n\n\nAsymmetric multiprocessing\n (AMP\uff0c\u975e\u5bf9\u79f0\u591a\u5904\u7406)\n\n\n\n\nAll scheduling decisions, I/O processing, and other system activities handled by a single processor -- the master server; the other processors execute only user code.\n\n\nIt is simple because only one core accesses the system data structures, reducing the need for data sharing.\n\n\nThe master server becomes a potential bottleneck where overall system performance may be reduced.\n\n\n\n\nSymmetric multiprocessing\n (SMP\uff0c \u5bf9\u79f0\u591a\u5904\u7406)\n\n\n\n\nEach processor is self-scheduling.\n\n\nIt provides two possible strategies for organizing the threads eligible to be scheduled:\n\n\nAll threads may be in a \ncommon ready queue\n.\n\n\nUse some form of locking to protect the common ready queue from race condition\n\n\nAll accesses to the queue would require lock ownership, it would be a performance bottleneck.\n\n\n\n\n\n\nEach processor may have its own \nprivate queue\n of threads.\n\n\nMost common approach on systems supporting SMP\n\n\nMore efficient use of cache memory.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMulticore Processors\n\n\nIssue\n : memory stalls occurs when a processor accesses memory, it spends a significant amount of time waiting for the data to become available.\n\n\n\n\nOccurs primarily because modern processors operate at much faster speeds than memory\n\n\nOccur because of a cache miss as well\n\n\n\n\n\n\nSolution\n : many recent hardware designs have implemented multithreaded processing cores in which two (or more) \nhardware threads\n(\u786c\u4ef6\u7ebf\u7a0b) are assigned to each core.\n\n\n\n\nIf one hardware thread stalls while waiting for memory, the core can switch to another thread.\n\n\nFrom an operating system perspective, each hardware thread maintains its architectural state, such as instruction pointer and register set, and thus appears as a logical CPU that is available to run a software thread. This technique is known as \nchip multithreading\n (CMT, \u82af\u7247\u591a\u7ebf\u7a0b). Intel use the term \nhyper-threading\n(\u8d85\u7ebf\u7a0b).\n\n\nNOTE\n: The resources of the physical core (such as caches and pipelines) are shared among its hardware threads, and a processing core can only execute \none\n hardware thread at a time.\n\n\n\n\n\n\nTwo levels of scheduling needed:\n\n\n\n\nIt chooses which software thread to run on each hardware thread.\n\n\nIt may choose any scheduling algorithm. \n\n\n\n\n\n\nIt chooses which hardware thread to run on CPU.\n\n\nUse a simple round-robin algorithm\n\n\nassigned to each hardware thread a dynamic urgency value ranging from 0 to 7, with 0 representing the lowest urgency and 7 the highest. \n\n\n\n\n\n\n\n\n\n\nLoad Balancing\n\n\nLoad balancing\n(\u8d1f\u8f7d\u5747\u8861) attempts to keep the workload evenly distributed across all processors in an SMP system.\n\n\nTwo general approaches to load balancing:\n\n\n\n\nPush migration\n: a specific task periodically checks the load on each processor and -- if it finds an imbalance -- evenly distributes the load by moving (or pushing) threads from overloaded to idle or less-busy processors.\n\n\nPull migration\n: an idle processor pulls a waiting task from a busy processor.\n\n\nThey are not mutually exclusive and are, in fact, often implemented in parallel on load-balancing systems.\n\n\n\n\nProcessor Affinity\n\n\nBecause of the high cost of invalidating and repopulating caches, most operating systems with SMP support try to \navoid migrating\n a thread from one processor to another and instead attempt to keep a thread running on the same processor and take advantage of a warm cache. This is known as \nprocessor affinity\n(\u5904\u7406\u5668\u4eb2\u548c\u6027)\u3002\n\n\nCommon ready queue and per-processor ready queue(section 5.1):\n\n\n\n\nIf we adopt the approach of a common ready queue, a thread may be selected for execution by any processor. Thus, if a thread is scheduled on a new processor, that processor\u2019s cache must be repopulated.\n\n\nWith private, per-processor ready queues, a thread is always scheduled on the same processor and can therefore benefit from the contents of a warm cache.\n\n\n\n\nThe main-memory architecture of a system can affect processor affinity issues as well. \nNon-uniform memory access\n(NUMA, \u975e\u4e00\u81f4\u6027\u5185\u5b58\u8bbf\u95ee) where there are two physical processor chips each with their own CPU and local memory. A CPU has faster access to its local memory than to memory local to another CPU.\n\n\n\n\nInterestingly, load balancing often \ncounteracts\n the benefits of processor affinity.\n\n\n6 Real-Time CPU Scheduling\n\n\nTwo kinds of real-time systems exist:\n\n\n\n\nSoft real-time systems\n(\u8f6f\u5b9e\u65f6\u7cfb\u7edf) provide no guarantee as to when a critical real-time process will be scheduled.\n\n\nHard real-time system\n(\u786c\u5b9e\u65f6\u7cfb\u7edf) have stricter requirements, A task must be serviced by its deadline; service after the deadline has expired is the same as no service at all.\n\n\n\n\nMinimizing latency\n\n\nWhen an event occurs, the system must respond to and service it as quickly as possible. \n\n\nEvent latency\n is the amount of time that elapses from when an event occurs to when it is serviced.\n\n\n\n\nTwo types of latencies affect the performance of real-time systems:\n\n\n\n\nInterrupt latency\n: the period of time from the arrival of an interrupt at the CPU to the start of the routine that services the interrupt\n\n\nFist, complete the instruction it is executing and determine the type of interrupt that occurred.\n\n\nSecond, save the state of the current process before servicing the interrupt using the specific interrupt service routine\n\n\nOne important factor contributing to interrupt latency is the amount of time interrupts may be disabled while kernel data structures are being updated. Real-time operating systems require that interrupts be disabled for only very short periods of time.\n\n\n\n\n\n\nDispatch latency\n: the time required for the dispatcher to stop one process and start another is known as dispatch latency.\n\n\n\n\n\n\nRate-Monotonic Scheduling\n\n\nThe \nrate-monotonic scheduling\n(\u5355\u8c03\u901f\u7387\u8c03\u5ea6) algorithm schedules periodic tasks using a static priority policy with preemption. \n\n\n\n\nUpon entering the system, each periodic task is assigned a \npriority inversely based on its period\n . The shorter the period, the higher the priority; the longer the period, the lower the priority.\n\n\nIt assumes that the processing time of a periodic process is the same for each CPU burst. That is, every time a process acquires the CPU, the duration of its CPU burst is the same.\n\n\n\n\nBefore we proceed with the details, we must define certain characteristics of the processes that are to be scheduled.\n\n\n\n\nThe processes are considered \nperiodic\n.\n\n\nOnce a periodic process has acquired the CPU, it has a fixed processing \ntime\n \nt\nt\n, a \ndeadline\n \nd\nd\n by which it must be serviced by the CPU, and a \nperiod\n \np\np\n.\n\n\nThe \nrate\n of a periodic task is \n1/p\n1/p\n.\n\n\n\n\n\nLet's consider an example. We have two processes, \nP_1\nP_1\n and \nP_2\nP_2\n. \n\n\n\n\nThe periods: - \nP_1=50\nP_1=50\n and \nP_2=100\nP_2=100\n \n\n\nThe processing time: \nt_1=20\nt_1=20\n and \nt_2=35\nt_2=35\n \n\n\nThe deadline requires that it complete its CPU burst by the start of its next period.\n\n\n\n\n\n\nNow suppose we use rate-monotonic scheduling:\n\n\n\n\nWe assign \nP_1\nP_1\n a higher priority than \nP_2\nP_2\n because the period of \nP_1\nP_1\n is shorter than that of \nP_2\nP_2\n. \n\n\nP_1\nP_1\n starts first and completes its CPU burst at time 20, thereby meeting its first deadline. \n\n\nP_2\nP_2\n starts running at this point and runs until time 50. At this time, it is preempted by \nP_1\nP_1\n , although it still has 5 milliseconds remaining in its CPU burst. \n\n\nP_1\nP_1\n completes its CPU burst at time 70, at which point the scheduler resumes \nP_2\nP_2\n . \n\n\nP_2\nP_2\n completes its CPU burst at time 75, also meeting its first deadline. \n\n\nThe system is idle until time 100, when \nP_1\nP_1\n is scheduled again.\n\n\n\n\n7 Linux Scheduling\n\n\nThe \nCompletely Fair Scheduler\n(CFS\uff0c\u5b8c\u5168\u516c\u5e73\u8c03\u5ea6\u7b97\u6cd5) is the default Linux scheduling algorithm after release 2.6.23 of the kernel.\n\n\n\n\nEach task has a \nvirtual runtime\n(\u865a\u62df\u8fd0\u884c\u65f6) value, which is its actual runtime normalized to the number of ready tasks.\n\n\nTask priority is incorporated as a \ndecay factor\n into this formula. \n\n\nLower-priority tasks have higher rates of decay than higher-priority tasks.\n\n\n\n\n\n\nThe CPU is allocated to the task with the \nsmallest\n virtual runtime value.\n\n\n\n\nStandard Linux kernels implement two \nscheduling classes\n(\u8c03\u5ea6\u7c7b): \n\n\n\n\na default scheduling class using the CFS scheduling algorithm \n\n\na real-time scheduling class.\n\n\n\n\nEach runnable task is placed in a \nred-black tree\n - a balanced binary search tree whose key is based on the value of virtual runtime \nvruntime\n.\n\n\n\n\ndiscover the leftmost node will require \nO(\\log N)\nO(\\log N)\n operations.\n\n\nLinux scheduler caches the leftmost node in the variable \nrb_leftmost\n, and requires only retrieving the cached value.\n\n\n\n\n\n\nLoad Balancing on NUMA systems\n\n\nProblem: On NUMA systems, migrating a thread may result in a memory access penalty due to either having to invalidate cache contents or, incurring longer memory access times.\n\n\nSOLUTION: Linux identifies a hierarchical system of \nscheduling domains\n(\u8c03\u5ea6\u57df) \u2014\u2014  a set of CPU cores that can be balanced against one another.\n\n\n\n\nThe cores in each scheduling domain are grouped according to how they share the resources of the system.\n\n\n\n\nPairs of cores share a level 2 (L2) cache and are thus organized into separate domain 0 and domain 1 .\n\n\nThese two domains may share a level 3 (L3) cache, and are therefore organized into a processor-level domain (also known as a NUMA node).\n\n\n\n\nThe general strategy behind CFS is \nto balance loads within domains, beginning at the lowest level of the hierarchy\n.", 
            "title": "Chapter 5: CPU Scheduling"
        }, 
        {
            "location": "/osc/ch5/#operating-system-concepts-5-cpu-scheduling", 
            "text": "On modern operating systems it is  kernel-level threads  \u2014not processes\u2014that are in fact being scheduled by the operating system.    User-level threads are managed by a thread library, and the kernel is  unaware  of them.  To run on a CPU, user-level threads must ultimately be mapped to an associated kernel-level thread, although this mapping may be indirect and may use a lightweight process (LWP).", 
            "title": "Operating System Concepts 5 - CPU Scheduling"
        }, 
        {
            "location": "/osc/ch5/#1-basic-concepts", 
            "text": "", 
            "title": "1 Basic Concepts"
        }, 
        {
            "location": "/osc/ch5/#cpu-io-burst-cycle", 
            "text": "Process execution consists of a  cycle  of CPU execution and I/O wait. \u8fdb\u7a0b\u6267\u884c\u7531CPU\u6267\u884c\u5468\u671f\u548cI/O\u7b49\u5f85\u5468\u671f\u7ec4\u6210\u3002   Processes alternate between these two states. \u8fdb\u7a0b\u5728\u8fd9\u4e24\u4e2a\u72b6\u6001\u4e4b\u95f4\u5207\u6362\u3002  Process execution begins with a  CPU burst , which is followed by an  I/O burst  and so on. \u8fdb\u7a0b\u6267\u884c\u4eceCPU\u533a\u95f4\u5f00\u59cb\uff0c\u5728\u8fd9\u4e4b\u540e\u662fI/O\u533a\u95f4\u3002   \u8fdb\u7a0b\u5728CPU\u533a\u95f4\u548cI/O\u533a\u95f4\u4e4b\u95f4\u5207\u6362\uff1a   The durations of CPU bursts tend to have a frequency curve similar to the figure below.    The curve is generally characterized as  exponential  or hyperexpoential(\u8d85\u6307\u6570).  A large number of short CPU bursts and a small number of long CPU burst.  An I/O-bounded program typically has many short CPU bursts. I/O\u5bc6\u96c6\u7a0b\u5e8f\u901a\u5e38\u5177\u6709\u5f88\u591a\u77edCPU\u533a\u95f4\u3002  A CPU-bound program might have a few long CPU bursts.CPU\u5bc6\u96c6\u7a0b\u5e8f\u53ef\u80fd\u6709\u5c11\u91cf\u7684\u957fCPU\u533a\u95f4\u3002  The distribution can be important when implementing a CPU-scheduling algorithm. \u5206\u5e03\u6709\u52a9\u4e8e\u9009\u62e9\u5408\u9002\u7684CPU\u8c03\u5ea6\u7b97\u6cd5\u3002", 
            "title": "CPU-I/O Burst Cycle"
        }, 
        {
            "location": "/osc/ch5/#cpu-scheduler", 
            "text": "Whenever the CPU becomes idle, the operating system must select one of the processes in the  ready queue (\u5c31\u7eea\u961f\u5217) to be executed. \u6bcf\u5f53CPU\u7a7a\u95f2\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u5fc5\u987b\u4ece\u5c31\u7eea\u961f\u5217\u4e2d\u9009\u62e9\u4e00\u4e2a\u8fdb\u7a0b\u6765\u6267\u884c\u3002   The selection process is carried out by the  CPU scheduler (CPU\u8c03\u5ea6\u7a0b\u5e8f).  \u8fdb\u7a0b\u9009\u62e9\u7531CPU\u8c03\u5ea6\u7a0b\u5e8f\u6267\u884c\u3002  CPU scheduler selects a process from the processes in memory that are ready to execute and allocates the CPU to that process. \u8c03\u5ea6\u7a0b\u5e8f\u4ece\u5185\u5b58\u4e2d\u9009\u62e9\u4e00\u4e2a\u80fd\u591f\u6267\u884c\u7684\u8fdb\u7a0b\uff0c\u5e76\u4e3a\u4e4b\u5206\u914dCPU\u3002  A ready queue can be implemented as a FIFO queue, a priority queue, a tree, or simply an unordered linked list. \u5c31\u7eea\u961f\u5217\u53ef\u4ee5\u662fFIFO\u961f\u5217\uff0c\u4f18\u5148\u961f\u5217\u3001\u6811\u6216\u65e0\u5e8f\u94fe\u8868\u3002", 
            "title": "CPU Scheduler"
        }, 
        {
            "location": "/osc/ch5/#preemptive-and-nonpreemptive-scheduling", 
            "text": "CPU-scheduling decisions may take place under the following four circumstances:    When a process switches from the running state to the waiting state (for example, as the result of an I/O request or an invocation of  wait()  for the termination of a child process) \u5f53\u4e00\u4e2a\u8fdb\u7a0b\u4ece\u8fd0\u884c\u72b6\u6001\u5207\u6362\u5230\u7b49\u5f85\u72b6\u6001\uff08\u5982\uff1aI/O\u8bf7\u6c42\uff0c\u6216\u8005\u8c03\u7528wait\u7b49\u5f85\u4e00\u4e2a\u5b50\u8fdb\u7a0b\u7684\u7ec8\u6b62\uff09   When a process switches from the running state to the ready state (for example, when an interrupt occurs) \u5f53\u4e00\u4e2a\u8fdb\u7a0b\u4ece\u8fd0\u884c\u72b6\u6001\u5207\u6362\u5230\u5c31\u7eea\u72b6\u6001\uff08\u5982\uff1a\u51fa\u73b0\u4e2d\u65ad\uff09   When a process switches from the waiting state to the ready state (for example, at completion of I/O) \u5f53\u4e00\u4e2a\u8fdb\u7a0b\u4ece\u7b49\u5f85\u72b6\u6001\u5207\u6362\u5230\u5c31\u7eea\u72b6\u6001\uff08\u5982\uff1aI/O\u5b8c\u6210\uff09   When a process terminates \u5f53\u4e00\u4e2a\u8fdb\u7a0b\u7ec8\u6b62\u65f6   When scheduling takes place only under circumstances 1 and 4, the scheduling scheme is  nonpreemptive (\u975e\u62a2\u5360\u7684) or  cooperative (\u534f\u4f5c\u7684). Otherwise, it is  preemptive (\u62a2\u5360\u7684).   Under nonpreemptive scheduling, once the CPU has been allocated to a process, the process keeps the CPU until it releases it either by terminating or by switching to the waiting state.  Virtually all modern Operating systems use preemptive scheduling algorithms.", 
            "title": "Preemptive and Nonpreemptive Scheduling"
        }, 
        {
            "location": "/osc/ch5/#dispatcher", 
            "text": "The  dispatcher (\u5206\u6d3e\u7a0b\u5e8f) is the module that gives control of the CPU's core to the process selected by the CPU scheduler. This function involves the following:   Switching context from one process to another  Switching to user mode  Jumping to the proper location in the user program to resume that program   Dispatch latency  (\u5206\u6d3e\u5ef6\u8fdf) is the time it takes for the dispatcher to stop one process and start another running.", 
            "title": "Dispatcher"
        }, 
        {
            "location": "/osc/ch5/#2-scheduling-criteria", 
            "text": "Scheduling criteria\uff08\u8c03\u5ea6\u51c6\u5219) include the following:   CPU utilization (CPU\u5229\u7528\u7387)  Throughput (\u541e\u5410\u91cf): the number of processes that are completed per time unit.  Turnaround time (\u5468\u8f6c\u65f6\u95f4): the interval from the time of submission of a process to the time of completion.  Waiting time (\u7b49\u5f85\u65f6\u95f4): the sum of time spent waiting in the ready queue.  Response time (\u54cd\u5e94\u65f6\u95f4): the time from the submission of a request until the first response is produced.", 
            "title": "2 Scheduling Criteria"
        }, 
        {
            "location": "/osc/ch5/#3-scheduling-algorithms", 
            "text": "", 
            "title": "3 Scheduling Algorithms"
        }, 
        {
            "location": "/osc/ch5/#first-comefirst-serve-scheduling-fcfs", 
            "text": "By far the simplest CPU-scheduling algorithm is the  first-come first serve scheduling  (\u5148\u5230\u5148\u670d\u52a1\u8c03\u5ea6, FCFS) algorithm.   The implementation of FCFS policy is easily managed with a  FIFO queue .  The average  waiting time  under the FCFS policy is often quite  long .  Convoy effect (\u62a4\u822a\u6548\u679c) occurs when all the other processes wait for the one big process to get off the CPU. \u6240\u6709\u5176\u4ed6\u8fdb\u7a0b\u90fd\u7b49\u5f85\u4e00\u4e2a\u5927\u8fdb\u7a0b\u91ca\u653eCPU\uff0c\u8fd9\u79f0\u4e4b\u4e3a\u62a4\u822a\u6548\u679c\u3002  The FCFS scheduling algorithm is  nonpreemptive . FCFS\u8c03\u5ea6\u7b97\u6cd5\u662f\u975e\u62a2\u5360\u7684\u3002", 
            "title": "First-Come,First-Serve scheduling, FCFS"
        }, 
        {
            "location": "/osc/ch5/#shortest-job-first-scheduling-sjf", 
            "text": "The  shortest-job-first scheduling  (\u6700\u77ed\u4f5c\u4e1a\u4f18\u5148\u8c03\u5ea6, SJF) algorithm associates with each process the length of the process's next CPU burst.   When the CPU is available, it is assigned to the process that has the smallest  next  CPU burst.  It gives the  minimum  average waiting time for a given set of processes.  The SJF algorithm can be either preemptive or nonpreemptive.  Preempt the currently executing process: when a new process arrives at the ready queue while a previous process is still executing. The next CPU burst of the newly arrived process may be shorter than what is left of the currently executing process.      The next CPU burst is generally predicted as an  exponential average  of the measured lengths of previous CPU bursts. Let  t_n t_n  be the length of the  n n th CPU burst, and let  \\tau_{n+1} \\tau_{n+1}  be predicted value for the next CPU burst:   \\tau_{n+1}= \\alpha t_n + (1-\\alpha) \\tau_n  \\tau_{n+1}= \\alpha t_n + (1-\\alpha) \\tau_n   where  0\\le\\alpha \\le 1 0\\le\\alpha \\le 1 , commonly  \\alpha = 1/2 \\alpha = 1/2 .", 
            "title": "Shortest-job-first scheduling, SJF"
        }, 
        {
            "location": "/osc/ch5/#round-robin-scheduling-rr", 
            "text": "The  round-robin scheduling (\u8f6e\u8f6c\u8c03\u5ea6) algorithm is similar to FCFS scheduling, but switch occurs after 1  time quantum  (\u65f6\u95f4\u7247).   Time quantum is a small unit of time, generally from 10 to 100 milliseconds in length.  The ready queue is treated as a circular queue.  If the process have a CPU burst of less than 1 time quantum, the  process itself will release the CPU voluntarily.  otherwise, a context switch will be executed, and the process will be put at the tail of the ready queue.   The performance of the RR algorithm depends heavily on the size of the time quantum.   If extremely large, the RR policy is the same as the FCFS policy.  If extremely small, it'll result in a large number of context switches.", 
            "title": "Round-Robin scheduling, RR"
        }, 
        {
            "location": "/osc/ch5/#priority-scheduling-algorithm", 
            "text": "The  priority-scheduling (\u4f18\u5148\u7ea7\u8c03\u5ea6) algorithm associate each process a priority, and the CPU allocated to the process with the highest priority.   FCFS: equal-priority  SJF: the priority is the inverse of the next CPU burst.   ISSUE:  Indefinite blocking (\u65e0\u9650\u963b\u585e), or  starvation (\u9965\u997f)  occurs when some low-priority processes waiting indefinitely .  SOLUTION:  Aging (\u8001\u5316) involves gradually increasing the priority of processes that wait in the system for a long time.", 
            "title": "Priority scheduling algorithm"
        }, 
        {
            "location": "/osc/ch5/#multilevel-queue-scheduling", 
            "text": "For  multilevel queue scheduling (\u591a\u7ea7\u961f\u5217\u8c03\u5ea6), there are separate queues for each distinct priority, and priority scheduling simply schedules the process in the highest-priority queue.  A multilevel queue scheduling algorithm can be used to partition processes into several separate queues based on the process type:   In addition, there must be scheduling  among the queues  :   Fixed-priority preemptive scheduling (\u56fa\u5b9a\u4f18\u5148\u7ea7\u62a2\u5360\u8c03\u5ea6): Each queue has absolute priority over lower-priority queues  eg. no process in the batch queue, could run unless the queues for real-time processes, system processes, and interactive processes were all empty.     Time-slice among queues (\u961f\u5217\u4e4b\u95f4\u5212\u5206\u65f6\u95f4\u7247): each queue gets a certain portion of the CPU time.  eg. the foreground queue can be given 80 percent of the CPU time for RR scheduling among its processes, while the background queue receives 20 percent of the CPU to give to its processes on an FCFS basis.", 
            "title": "Multilevel Queue Scheduling"
        }, 
        {
            "location": "/osc/ch5/#multilevel-feedback-queue-scheduling", 
            "text": "The  multilevel feedback queue scheduling (\u591a\u7ea7\u53cd\u9988\u961f\u5217\u8c03\u5ea6) algorithm allows a process to move between queues.   If a process uses too much CPU time, it will be moved to a lower-priority queue.  It leaves I/O-bound and interactive processes\u2014which are typically characterized by short CPU bursts \u2014in the higher-priority queues.     A process that waits too long in a lower-priority queue may be moved to a higher-priority queue.  This form of aging prevent starvation.     In general, a multilevel feedback queue scheduler is defined by the following parameters:   The number of queues  The scheduling algorithm for each queue  The method used to determine when to upgrade a process to a higher priority queue  The method used to determine when to demote a process to a lower priority queue  The method used to determine which queue a process will enter when that process needs service", 
            "title": "Multilevel Feedback-Queue Scheduling"
        }, 
        {
            "location": "/osc/ch5/#4-thread-scheduling", 
            "text": "", 
            "title": "4 Thread Scheduling"
        }, 
        {
            "location": "/osc/ch5/#contention-scope", 
            "text": "Process contention scope (PCS\uff0c\u8fdb\u7a0b\u7ade\u4e89\u8303\u56f4), specifies that competition for the CPU takes place among threads belonging to the same process.   the thread library schedules user-level threads to run on an available LWP, on systems implementing the many-to-one and many-to-many models.   To decide which kernel-level thread to schedule onto a CPU, the kernel uses  system-contention scope (SCS, \u7cfb\u7edf\u7ade\u4e89\u8303\u56f4).   Systems using the one-to-one model, such as Windows and Linux schedule threads using only SCS.", 
            "title": "Contention Scope"
        }, 
        {
            "location": "/osc/ch5/#pthread-scheduling", 
            "text": "Pthreads  identifies the following contention scope values:   PTHREAD_SCOPE_PROCESS  schedules threads using PCS scheduling.  PTHREAD_SCOPE_SYSTEM  schedules threads using SCS scheduling.   The Pthread IPC (Interprocess Communication) provides two functions for setting\u2014and getting\u2014the contention scope policy:   pthread_attr_setscope(pthread_attr_t *attr, int scope)  pthread_attr_getscope(pthread_attr_t *attr, int *scope)   #include   pthread.h  #include   stdio.h  #define NUM_THREADS 5  /* the thread runs in this function */  void   * runner ( void   * param );   int   main ( int   argc ,   char   * argv [])  { \n     int   i ,   scope ; \n     pthread_t   tid [ NUM_THREADS ];       /* the thread identifier */ \n     pthread_attr_t   attr ;          /* set of attributes for the thread */ \n\n     /* get the default attributes */ \n     pthread_attr_init ( attr ); \n\n     /* first inquire on the current scope */ \n     if   ( pthread_attr_getscope ( attr , scope )   !=   0 ) \n         fprintf ( stderr ,   Unable to get scheduling scope. \\n ); \n     else   { \n         if   ( scope   ==   PTHREAD_SCOPE_PROCESS ) \n             printf ( PTHREAD_SCOPE_PROCESS \\n ); \n         else   if   ( scope   ==   PTHREAD_SCOPE_SYSTEM ) \n             printf ( PTHREAD_SCOPE_SYSTEM \\n ); \n         else  \n             fprintf ( stderr , Illegal scope value. \\n ); \n     } \n\n     /* set the scheduling algorithm to PCS or SCS */ \n     if   ( pthread_attr_setscope ( attr ,   PTHREAD_SCOPE_SYSTEM )   !=   0 ) \n         printf ( unable to set scheduling policy. \\n ); \n\n     /* create the threads */ \n     for   ( i   =   0 ;   i     NUM_THREADS ;   i ++ )  \n         pthread_create ( tid [ i ], attr , runner , NULL );  \n\n     /**       * Now join on each thread       */ \n     for   ( i   =   0 ;   i     NUM_THREADS ;   i ++ )  \n         pthread_join ( tid [ i ],   NULL );  }  /**   * The thread will begin control in this function.   */  void   * runner ( void   * param )   { \n     /* do some work ... */ \n\n     pthread_exit ( 0 );  }", 
            "title": "Pthread Scheduling"
        }, 
        {
            "location": "/osc/ch5/#5-multi-processor-scheduling", 
            "text": "", 
            "title": "5 Multi-Processor Scheduling"
        }, 
        {
            "location": "/osc/ch5/#approaches-to-multiple-processor-scheduling", 
            "text": "Asymmetric multiprocessing  (AMP\uff0c\u975e\u5bf9\u79f0\u591a\u5904\u7406)   All scheduling decisions, I/O processing, and other system activities handled by a single processor -- the master server; the other processors execute only user code.  It is simple because only one core accesses the system data structures, reducing the need for data sharing.  The master server becomes a potential bottleneck where overall system performance may be reduced.   Symmetric multiprocessing  (SMP\uff0c \u5bf9\u79f0\u591a\u5904\u7406)   Each processor is self-scheduling.  It provides two possible strategies for organizing the threads eligible to be scheduled:  All threads may be in a  common ready queue .  Use some form of locking to protect the common ready queue from race condition  All accesses to the queue would require lock ownership, it would be a performance bottleneck.    Each processor may have its own  private queue  of threads.  Most common approach on systems supporting SMP  More efficient use of cache memory.", 
            "title": "Approaches to Multiple-Processor Scheduling"
        }, 
        {
            "location": "/osc/ch5/#multicore-processors", 
            "text": "Issue  : memory stalls occurs when a processor accesses memory, it spends a significant amount of time waiting for the data to become available.   Occurs primarily because modern processors operate at much faster speeds than memory  Occur because of a cache miss as well    Solution  : many recent hardware designs have implemented multithreaded processing cores in which two (or more)  hardware threads (\u786c\u4ef6\u7ebf\u7a0b) are assigned to each core.   If one hardware thread stalls while waiting for memory, the core can switch to another thread.  From an operating system perspective, each hardware thread maintains its architectural state, such as instruction pointer and register set, and thus appears as a logical CPU that is available to run a software thread. This technique is known as  chip multithreading  (CMT, \u82af\u7247\u591a\u7ebf\u7a0b). Intel use the term  hyper-threading (\u8d85\u7ebf\u7a0b).  NOTE : The resources of the physical core (such as caches and pipelines) are shared among its hardware threads, and a processing core can only execute  one  hardware thread at a time.    Two levels of scheduling needed:   It chooses which software thread to run on each hardware thread.  It may choose any scheduling algorithm.     It chooses which hardware thread to run on CPU.  Use a simple round-robin algorithm  assigned to each hardware thread a dynamic urgency value ranging from 0 to 7, with 0 representing the lowest urgency and 7 the highest.", 
            "title": "Multicore Processors"
        }, 
        {
            "location": "/osc/ch5/#load-balancing", 
            "text": "Load balancing (\u8d1f\u8f7d\u5747\u8861) attempts to keep the workload evenly distributed across all processors in an SMP system.  Two general approaches to load balancing:   Push migration : a specific task periodically checks the load on each processor and -- if it finds an imbalance -- evenly distributes the load by moving (or pushing) threads from overloaded to idle or less-busy processors.  Pull migration : an idle processor pulls a waiting task from a busy processor.  They are not mutually exclusive and are, in fact, often implemented in parallel on load-balancing systems.", 
            "title": "Load Balancing"
        }, 
        {
            "location": "/osc/ch5/#processor-affinity", 
            "text": "Because of the high cost of invalidating and repopulating caches, most operating systems with SMP support try to  avoid migrating  a thread from one processor to another and instead attempt to keep a thread running on the same processor and take advantage of a warm cache. This is known as  processor affinity (\u5904\u7406\u5668\u4eb2\u548c\u6027)\u3002  Common ready queue and per-processor ready queue(section 5.1):   If we adopt the approach of a common ready queue, a thread may be selected for execution by any processor. Thus, if a thread is scheduled on a new processor, that processor\u2019s cache must be repopulated.  With private, per-processor ready queues, a thread is always scheduled on the same processor and can therefore benefit from the contents of a warm cache.   The main-memory architecture of a system can affect processor affinity issues as well.  Non-uniform memory access (NUMA, \u975e\u4e00\u81f4\u6027\u5185\u5b58\u8bbf\u95ee) where there are two physical processor chips each with their own CPU and local memory. A CPU has faster access to its local memory than to memory local to another CPU.   Interestingly, load balancing often  counteracts  the benefits of processor affinity.", 
            "title": "Processor Affinity"
        }, 
        {
            "location": "/osc/ch5/#6-real-time-cpu-scheduling", 
            "text": "Two kinds of real-time systems exist:   Soft real-time systems (\u8f6f\u5b9e\u65f6\u7cfb\u7edf) provide no guarantee as to when a critical real-time process will be scheduled.  Hard real-time system (\u786c\u5b9e\u65f6\u7cfb\u7edf) have stricter requirements, A task must be serviced by its deadline; service after the deadline has expired is the same as no service at all.", 
            "title": "6 Real-Time CPU Scheduling"
        }, 
        {
            "location": "/osc/ch5/#minimizing-latency", 
            "text": "When an event occurs, the system must respond to and service it as quickly as possible.   Event latency  is the amount of time that elapses from when an event occurs to when it is serviced.   Two types of latencies affect the performance of real-time systems:   Interrupt latency : the period of time from the arrival of an interrupt at the CPU to the start of the routine that services the interrupt  Fist, complete the instruction it is executing and determine the type of interrupt that occurred.  Second, save the state of the current process before servicing the interrupt using the specific interrupt service routine  One important factor contributing to interrupt latency is the amount of time interrupts may be disabled while kernel data structures are being updated. Real-time operating systems require that interrupts be disabled for only very short periods of time.    Dispatch latency : the time required for the dispatcher to stop one process and start another is known as dispatch latency.", 
            "title": "Minimizing latency"
        }, 
        {
            "location": "/osc/ch5/#rate-monotonic-scheduling", 
            "text": "The  rate-monotonic scheduling (\u5355\u8c03\u901f\u7387\u8c03\u5ea6) algorithm schedules periodic tasks using a static priority policy with preemption.    Upon entering the system, each periodic task is assigned a  priority inversely based on its period  . The shorter the period, the higher the priority; the longer the period, the lower the priority.  It assumes that the processing time of a periodic process is the same for each CPU burst. That is, every time a process acquires the CPU, the duration of its CPU burst is the same.   Before we proceed with the details, we must define certain characteristics of the processes that are to be scheduled.   The processes are considered  periodic .  Once a periodic process has acquired the CPU, it has a fixed processing  time   t t , a  deadline   d d  by which it must be serviced by the CPU, and a  period   p p .  The  rate  of a periodic task is  1/p 1/p .   Let's consider an example. We have two processes,  P_1 P_1  and  P_2 P_2 .    The periods: -  P_1=50 P_1=50  and  P_2=100 P_2=100    The processing time:  t_1=20 t_1=20  and  t_2=35 t_2=35    The deadline requires that it complete its CPU burst by the start of its next period.    Now suppose we use rate-monotonic scheduling:   We assign  P_1 P_1  a higher priority than  P_2 P_2  because the period of  P_1 P_1  is shorter than that of  P_2 P_2 .   P_1 P_1  starts first and completes its CPU burst at time 20, thereby meeting its first deadline.   P_2 P_2  starts running at this point and runs until time 50. At this time, it is preempted by  P_1 P_1  , although it still has 5 milliseconds remaining in its CPU burst.   P_1 P_1  completes its CPU burst at time 70, at which point the scheduler resumes  P_2 P_2  .   P_2 P_2  completes its CPU burst at time 75, also meeting its first deadline.   The system is idle until time 100, when  P_1 P_1  is scheduled again.", 
            "title": "Rate-Monotonic Scheduling"
        }, 
        {
            "location": "/osc/ch5/#7-linux-scheduling", 
            "text": "The  Completely Fair Scheduler (CFS\uff0c\u5b8c\u5168\u516c\u5e73\u8c03\u5ea6\u7b97\u6cd5) is the default Linux scheduling algorithm after release 2.6.23 of the kernel.   Each task has a  virtual runtime (\u865a\u62df\u8fd0\u884c\u65f6) value, which is its actual runtime normalized to the number of ready tasks.  Task priority is incorporated as a  decay factor  into this formula.   Lower-priority tasks have higher rates of decay than higher-priority tasks.    The CPU is allocated to the task with the  smallest  virtual runtime value.   Standard Linux kernels implement two  scheduling classes (\u8c03\u5ea6\u7c7b):    a default scheduling class using the CFS scheduling algorithm   a real-time scheduling class.   Each runnable task is placed in a  red-black tree  - a balanced binary search tree whose key is based on the value of virtual runtime  vruntime .   discover the leftmost node will require  O(\\log N) O(\\log N)  operations.  Linux scheduler caches the leftmost node in the variable  rb_leftmost , and requires only retrieving the cached value.", 
            "title": "7 Linux Scheduling"
        }, 
        {
            "location": "/osc/ch5/#load-balancing-on-numa-systems", 
            "text": "Problem: On NUMA systems, migrating a thread may result in a memory access penalty due to either having to invalidate cache contents or, incurring longer memory access times.  SOLUTION: Linux identifies a hierarchical system of  scheduling domains (\u8c03\u5ea6\u57df) \u2014\u2014  a set of CPU cores that can be balanced against one another.   The cores in each scheduling domain are grouped according to how they share the resources of the system.   Pairs of cores share a level 2 (L2) cache and are thus organized into separate domain 0 and domain 1 .  These two domains may share a level 3 (L3) cache, and are therefore organized into a processor-level domain (also known as a NUMA node).   The general strategy behind CFS is  to balance loads within domains, beginning at the lowest level of the hierarchy .", 
            "title": "Load Balancing on NUMA systems"
        }, 
        {
            "location": "/osc/ch6/", 
            "text": "Operating System Concepts 6 - Synchronization Tools\n\n\n1 Background\n\n\nA \nrace condition\n(\u7ade\u4e89\u6761\u4ef6) occurs when several processes access and manipulate the same data concurrently and the outcome of the execution depends on the particular order in which the access takes place.\n\n\n\u591a\u4e2a\u8fdb\u7a0b\u5e76\u53d1\u8bbf\u95ee\u548c\u64cd\u4f5c\u540c\u4e00\u6570\u636e\uff0c\u4e14\u6267\u884c\u7ed3\u679c\u4e0e\u8bbf\u95ee\u53d1\u751f\u7684\u7279\u5b9a\u987a\u5e8f\u6709\u5173\uff0c\u79f0\u4e4b\u4e3a\u7ade\u4e89\u6761\u4ef6\u3002\n\n\n2 The Critical-Section problem\n\n\nA \ncritical section\n(\u4e34\u754c\u533a) is a section of code, in which the process may be accessing and updating data that is shared with at least one other process.\n\n\n\n\nWhen one process is executing in its critical section, no other process is allowed to execute in its critical section.\n\n\n\n\nThe \ncritical-section problem\n(\u4e34\u754c\u533a\u95ee\u9898) is to design a protocol that the processes can use to synchronize their activity so as to cooperatively share data.\n\n\n\n\nEach process must request permission to enter its critical section.\n\n\nThe section of code implementing this request is the \nentry section\n(\u8fdb\u5165\u533a)\n\n\nThe critical section may be followed by an \nexit section\n(\u9000\u51fa\u533a)\u3002\n\n\nThe remaining code is the \nremainder section\n(\u5269\u4f59\u533a)\u3002\n\n\n\n\n\n\nA solution to the critical-section problem must satisfy the following three requirements:\n\n\n\n\nMutual exclusion\n (\u4e92\u65a5): If process \nP_i\nP_i\n is executing in its critical section, then no other processes can be executing in their critical sections. \u5982\u679c\u8fdb\u7a0b\nP_i\nP_i\n\u5728\u5176\u4e34\u754c\u533a\u5185\u6267\u884c\uff0c\u90a3\u4e48\u5176\u4ed6\u8fdb\u7a0b\u90fd\u4e0d\u80fd\u5728\u5176\u4e34\u754c\u533a\u5185\u6267\u884c\uff1b\n\n\nProgress\n (\u524d\u8fdb): If no process is executing in its critical section and some processes wish to enter their critical sections, then only those processes that are not executing in their remainder sections can participate in deciding which will enter its critical section next, and this selection cannot be postponed indefinitely. \u5982\u679c\u6ca1\u6709\u8fdb\u7a0b\u5728\u5176\u4e34\u754c\u533a\u5185\u6267\u884c\u4e14\u6709\u8fdb\u7a0b\u9700\u8fdb\u5165\u4e34\u754c\u533a\uff0c\u90a3\u4e48\u53ea\u6709\u90a3\u4e48\u4e0d\u5728\u5269\u4f59\u533a\u5185\u6267\u884c\u7684\u8fdb\u7a0b\u53ef\u53c2\u52a0\u9009\u62e9\uff0c\u4ee5\u786e\u5b9a\u8c01\u80fd\u4e0b\u4e00\u4e2a\u8fdb\u5165\u4e34\u754c\u533a\uff0c\u4e14\u8fd9\u79cd\u9009\u62e9\u4e0d\u80fd\u65e0\u9650\u63a8\u8fdf\uff1b\n\n\nBounded waiting\n (\u6709\u9650\u7b49\u5f85): There exists a bound, or limit, on the number of times that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted. \u4ece\u4e00\u4e2a\u8fdb\u7a0b\u505a\u51fa\u8fdb\u5165\u4e34\u754c\u533a\u7684\u8bf7\u6c42\uff0c\u76f4\u5230\u8be5\u8bf7\u6c42\u5141\u8bb8\u4e3a\u6b62\uff0c\u5176\u4ed6\u8fdb\u7a0b\u5141\u8bb8\u8fdb\u5165\u5176\u4e34\u754c\u533a\u5185\u7684\u6b21\u6570\u6709\u4e0a\u9650\u3002\n\n\n\n\nTwo general approaches are used to handle critical sections in operating systems: \npreemptive kernels\n\uff08\u62a2\u5360\u5185\u6838\uff09 and \nnonpreemptive kernels\n\uff08\u975e\u62a2\u5360\u5185\u6838\uff09.\n\n\n\n\nA preemptive kernel allows a process to be preempted while it is running in kernel mode. \u62a2\u5360\u5185\u6838\u5141\u8bb8\u5904\u4e8e\u5185\u6838\u6a21\u5f0f\u7684\u8fdb\u7a0b\u88ab\u62a2\u5360\u3002\n\n\nA nonpreemptive kernel does not allow a process running in kernel mode to be preempted.A kernel-model process will run until it exists kernel mode, blocks, or voluntarily yields control of the CPU.\u975e\u62a2\u5360\u5185\u6838\u4e0d\u5141\u8bb8\u5185\u6838\u6a21\u5f0f\u7684\u8fdb\u7a0b\u88ab\u62a2\u5360\u3002\n\n\nA nonpreemptive kernel is essentially free from race conditions on kernel data structures, as only on process is active in the kernel at at time. \u975e\u62a2\u5360\u5185\u6838\u7684\u5185\u6838\u4ece\u6839\u672c\u4e0a\u4e0d\u4f1a\u5bfc\u81f4\u7ade\u4e89\u6761\u4ef6\uff0c\u56e0\u4e3a\u5728\u5185\u6838\u4e2d\u4e00\u6b21\u53ea\u6709\u4e00\u4e2a\u8fdb\u7a0b\u662f\u6d3b\u8dc3\u7684\u3002\n\n\nPreemptive kernels must be carefully designed to ensure that shared kernel data are free from race conditions. \u5bf9\u4e8e\u62a2\u5360\u5185\u6838\u9700\u8981\u8ba4\u771f\u8bbe\u8ba1\u4ee5\u786e\u4fdd\u5171\u4eab\u5185\u548c\u6570\u636e\u514d\u4e8e\u7ade\u4e89\u6761\u4ef6\u3002\n\n\nA preemptive kernel may be more responsive, since there is less risk that a kernel-model process will run for an arbitrarily long period before relinquishing the processor to waiting process. \u62a2\u5360\u5185\u6838\u7684\u54cd\u5e94\u66f4\u5feb\uff0c\u56e0\u4e3a\u5904\u4e8e\u5185\u6838\u6a21\u5f0f\u7684\u8fdb\u7a0b\u5728\u91ca\u653eCPU\u4e4b\u524d\u4e0d\u4f1a\u8fd0\u884c\u8fc7\u4e45\u3002\n\n\nA preemptive kernel is more suitable for real-time programming, as it will allow a real-time process to preemptive a process currently running in the kernel. \u62a2\u5360\u5185\u6838\u66f4\u9002\u5408\u5b9e\u65f6\u7f16\u7a0b\uff0c\u56e0\u4e3a\u5b83\u80fd\u5141\u8bb8\u5b9e\u65f6\u8fdb\u7a0b\u62a2\u5360\u5904\u4e8e\u5185\u6838\u6a21\u5f0f\u8fd0\u884c\u7684\u5176\u4ed6\u8fdb\u7a0b\u3002\n\n\n\n\n3 Peterson's Solution\n\n\nPeterson\u2019s solution\n(Peterson \u7b97\u6cd5) is restricted to two processes that alternate execution between their critical sections and remainder sections. The processes are numbered \nP_0\nP_0\n and \nP_1\nP_1\n. For convenience, when presenting \nP_i\nP_i\n, we use \nP_j\nP_j\n to denote the other process; that is \nj\nj\n equals \n1-i\n1-i\n.\n\n\nPeterson's solution requires the two processes to share two data items:\n\n\nint\n \nturn\n;\n\n\nboolean\n \nflag\n[\n2\n];\n\n\n\n\n\nThe structure of process \nP_i\nP_i\n in Peterson's solution.\n\n\nwhile\n \n(\ntrue\n)\n \n{\n\n    \nflag\n[\ni\n]\n \n=\n \ntrue\n;\n \n    \nturn\n \n=\n \nj\n;\n \n    \nwhile\n \n(\nflag\n[\nj\n]\n \n \nturn\n \n==\n \nj\n)\n \n        \n;\n\n    \n/* critical section */\n\n    \nflag\n[\ni\n]\n \n=\n \nfalse\n;\n\n    \n/*remainder section */\n\n\n}\n\n\n\n\n\n\n\nThe variable \nturn\n indicates whose turn it is to enter its critical section.\n\n\nThe \nflag\n array is used to indicate if a process is ready to enter its critical section.\n\n\n\n\n\n\nNote\n\n\nPeterson\u2019s solution is \nnot guaranteed\n to work on modern computer architectures for the primary reason that, to improve system performance, \nprocessors and/or compilers may reorder read and write operations that have no dependencies\n.\n\n\n\n\nIf the assignments of the first two statements that appear in the entry section of Peterson's solution are reordered. It is possible that both threads may be active in their critical sections at the same time.\n\n\n\n\n4 Hardware support for Synchronization\n\n\nHardware support for the critical-section problem includes:\n\n\n\n\nMemory barriers\n\n\nHardware instructions\n\n\nAtomic variables\n\n\n\n\nMemory barriers\n\n\nHow a computer architecture determines what memory guarantees it will provide to an application program is known as its \nmemory model\n(\u5185\u5b58\u6a21\u578b). In general, a memory model falls into one of two categories:\n\n\n\n\nStrongly ordered\n, where a memory modification on one processor is immediately visible to all other processors.\n\n\nWeakly ordered\n, where modifications to memory on one processor may not be immediately visible to other processors.\n\n\n\n\nComputer architectures provide instructions that can \nforce\n any changes in memory to be propagated to all other processors, thereby ensuring that memory modifications are visible to threads running on other processors. Such instruction are known as \nmemory barriers\n(\u5185\u5b58\u5c4f\u969c).\n\n\n\n\nWhen a memory barrier instruction is performed, the system ensures that all loads and stores are completed before any subsequent load or store operations are performed.\n\n\n\n\nHardware instructions\n\n\nMany modern computer systems provide special hardware instructions that allow either to test and modify the content of a word or to swap the contents of two words atomically - that is, one uninterruptible unit.\n\n\nThe definition of the atomic \ntest_and_set()\n instruction:\n\n\nboolean\n \ntest_and_set\n(\nboolean\n \n*\ntarget\n)\n \n{\n \n    \nboolean\n \nrv\n \n=\n \n*\ntarget\n;\n \n    \n*\ntarget\n \n=\n \ntrue\n;\n\n    \nreturn\n \nrv\n;\n\n\n}\n\n\n\n\n\nMutual-exclusion implementation with \ntest_and_set()\n:\n\n\ndo\n \n{\n\n    \nwhile\n \n(\ntest_and_set\n(\nlock\n))\n \n        \n;\n \n/* do nothing */\n\n    \n/* critical section */\n\n    \nlock\n \n=\n \nfalse\n;\n\n    \n/* remainder section */\n \n}\n \n\nwhile\n \n(\ntrue\n);\n\n\n\n\n\nThe definition of the atomic \ncompare_and_swap()\n\uff08CAS\uff09instruction:\n\n\nint\n \ncompare_and_swap\n(\nint\n \n*\nvalue\n,\n \nint\n \nexpected\n,\n \nint\n \nnew\n \nvalue\n)\n \n{\n \n    \nint\n \ntemp\n \n=\n \n*\nvalue\n;\n\n    \nif\n \n(\n*\nvalue\n \n==\n \nexpected\n)\n \n        \n*\nvalue\n \n=\n \nnew\n \nvalue\n;\n\n    \nreturn\n \ntemp\n;\n\n\n}\n\n\n\n\n\nMutual exclusion with the \ncompare_and_swap()\n instruction:\n\n\nwhile\n \n(\ntrue\n)\n \n{\n\n    \nwhile\n \n(\ncompare_and_swap\n(\nlock\n,\n \n0\n,\n \n1\n)\n \n!=\n \n0\n)\n \n        \n;\n \n/* do nothing */\n\n    \n/* critical section */\n\n    \nlock\n \n=\n \n0\n;\n\n    \n/* remainder section */\n\n\n}\n\n\n\n\n\nAtomic variables\n\n\nAtomic variables\n (\u539f\u5b50\u53d8\u91cf) provides atomic operations on basic data types such as integers and booleans. Their use is often limited to single updates of shared data such as counters and sequence generators.\n\n\n5 Mutex locks\n\n\nISSUE: The hardware-based solutions are complicated as well as generally inaccessible to application programmers.\n\n\nSOLUTION: Operating-system designers build higher-level software tools. The simplest of these tools is the \nmutex lock\n(\u4e92\u65a5\u9501)\u3002\n\n\n\n\nA process must \nacquire\n the lock before entering a critical section; \n\n\nA process \nreleases\n the lock when it exists the critical section.\n\n\nA mutex lock has a boolean variable \navailable\n, whose value indicates if the lock is available or not.\n\n\nCalls to either \nacquire()\n or \nrelease()\n must be performed atomically. Thus mutex locks can be implemented using the CAS operation.\n\n\n\n\nSolution to the critical-section problem using mutex locks:\n\n\nwhile\n \n(\ntrue\n)\n \n{\n\n    \n/* acquire lock */\n\n\n    \n/* critical section */\n\n\n    \n/* release lock */\n\n\n    \n/* remainder section */\n\n\n}\n\n\n\n\n\nThe definition of \nacquire()\n is as follows:\n\n\nacquire\n()\n \n{\n \n    \nwhile\n \n(\n!\navailable\n)\n \n;\n\n        \n/* busy wait */\n \n    \navailable\n \n=\n \nfalse\n;\n \n\n}\n\n\n\n\n\nThe definition of \nrelease()\n is as follows:\n\n\nrelease\n(){\n\n    \navailable\n \n=\n \ntrue\n;\n\n\n}\n\n\n\n\n\nThe main disadvantage of the implementation is that it requires \nbusy waiting\n(\u5fd9\u7b49\u5f85).\n\n\n\n\nWhile  a process is in its critical section, any other process that tries enter its critical section must loop continuously in the call to \nacquire()\n.\n\n\nIt wastes CPU cycles.\n\n\n\n\nBecause the process \"spins\" while waiting for the lock to become available, this type of mutex lock is also called a \nspinlock\n\uff08\u81ea\u65cb\u9501\uff09\u3002\n\n\n\n\nAdvantage: no context switch is required\n\n\n\n\nSpinlocks are not appropriate for single-processor systems yet are often used in multiprocessor systems.\n\n\nPOSIX API for Spinlocks\n\n\n6 Semaphores\n\n\nA \nsemaphore\n(\u4fe1\u53f7\u91cf) S is an integer variable that, apart from initialization, is accessed only through two standard atomic operations: \nwait()\n and \nsignal()\n. \u4fe1\u53f7\u91cfS\u662f\u4e2a\u6574\u6570\u53d8\u91cf\uff0c\u9664\u4e86\u521d\u59cb\u5316\u5916\uff0c\u5b83\u53ea\u80fd\u901a\u8fc7\u4e24\u4e2a\u6807\u51c6\u539f\u5b50\u64cd\u4f5c\uff1a\nwait()\n\u548c\nsignal()\n\u6765\u8bbf\u95ee\u3002\n\n\nThe definition of \nwait()\n is as follows:\n\n\nwait\n(\nS\n){\n\n    \nwhile\n \n(\nS\n \n=\n \n0\n)\n\n        \n;\n// busy wait\n\n    \nS\n--\n;\n\n\n{\n\n\n\n\n\nThe definition of \nsignal()\n is as follows:\n\n\nsignal\n(\nS\n){\n\n    \nS\n++\n;\n\n\n}\n\n\n\n\n\nAll modifications to the integer value of the semaphore in the \nwait()\n and \nsignal()\n operations must be executed atomically.  \u5728\nwait()\n\u548c\nsignal()\n\u64cd\u4f5c\u4e2d\uff0c\u5bf9\u4fe1\u53f7\u91cf\u6574\u578b\u503c\u7684\u4fee\u6539\u5fc5\u987b\u4e0d\u53ef\u5206\u5730\u6267\u884c\u3002\n\n\nOperating systems often distinguish between counting and binary semaphores.\u901a\u5e38\u64cd\u4f5c\u7cfb\u7edf\u533a\u5206\u8ba1\u6570\u4fe1\u53f7\u91cf\u548c\u4e8c\u8fdb\u5236\u4fe1\u53f7\u91cf\u3002\n\n\n\n\nThe value of a \ncounting semaphore\n(\u8ba1\u6570\u4fe1\u53f7\u91cf) can range over an unrestricted domain.\u8ba1\u6570\u4fe1\u53f7\u91cf\u7684\u503c\u57df\u4e0d\u53d7\u9650\u5236\u3002\n\n\nThe value of a \nbinary semaphore\n(\u4e8c\u8fdb\u5236\u4fe1\u53f7\u91cf) can range only between 0 and 1. \u4e8c\u8fdb\u5236\u4fe1\u53f7\u91cf\u7684\u503c\u53ea\u80fd\u4e3a0\u62161\u3002\n\n\n\n\nCounting semaphores can be used to control access to  a given resource consisting of a finite number of instances.\n\n\n\n\nThe semaphore is initialized to the number of resources available. \n\n\nEach process that wishes to use a resource performs a \nwait()\noperation on the semaphore (thereby decrementing the count). \n\n\nWhen a process releases a resource, it performs a \nsignal()\n operation (incrementing the count). \n\n\nWhen the count for the semaphore goes to 0, all resources are being used. After that, processes that wish to use a resource will block until the count becomes greater than 0.\n\n\n\n\nPOSIX API for Semaphores\n\n\n7 Monitors\n\n\nMonitor Usage\n\n\nIssues: various types of errors can be generated easily when programmers use semaphores or mutex locks incorrectly to solve the critical-section problem.\n\n\n\n\ninterchanges the order of \nwait()\n and \nsignal()\n\n\nreplaces \nsignal()\n with \nwait()\n\n\nomits \nwait()\n or \nsignal()\n\n\n\n\nSolution: An abstract data type, \nmonitor\n(\u7ba1\u7a0b), includes a set of programmer-defined operation related to mutual exclusion within the monitor. The monitor construct ensures that only one process at a time is active within the monitor.\n\n\nPseudocode syntax of a monitor:\n\n\nmonitor\n \nmonitor\n \nname\n \n{\n \n/* shared variable declarations */\n\n    \nfunction\n \nP1\n \n(\n \n.\n \n.\n \n.\n \n)\n \n{\n \n.\n \n.\n \n.}\n\n    \nfunction\n \nP2\n \n(\n \n.\n \n.\n \n.\n \n)\n \n{\n \n.\n \n.\n \n.}\n\n        \n.\n\n        \n.\n\n    \nfunction\n \nPn\n \n(\n \n.\n \n.\n \n.\n \n)\n \n{\n \n.\n \n.\n \n.}\n\n    \ninitialization\n \ncode\n \n(\n \n.\n \n.\n \n.\n \n)\n \n{\n \n.\n \n.\n \n.}\n\n\n}\n\n\n\n\n\nA monitor uses \ncondition variables\n that allow processes to wait for certain conditions to become true and to signal one another when conditions have been set to true:\n\n\n\n\n\\text{condition x, y;}\n\n\n\\text{condition x, y;}\n\n\n\n\nThe only operations that can be invoked on a condition variable are \nwait()\n and \nsignal()\n.\n\n\n\n\nImplementing a Monitor Using Semaphores\n\n\n\n\nbinary semaphore \nnext\n: the signaling processes use it to suspend themselves.\n\n\ninteger variable \nnext_count\n: to count the number of processes suspended on \nnext\n.\n\n\ncondition \nx\n, binary semaphore \nx_sem\n, and integer variable \nx_count\n \n\n\n\n\nmonitor\n \nResourceAllocator\n \n{\n\n\n    \nboolean\n \nbusy\n;\n \n    \ncondition\n \nx\n;\n\n\n    \nvoid\n \nacquire\n(\nint\n \ntime\n)\n \n{\n \n        \nif\n \n(\nbusy\n)\n \n            \nx\n.\nwait\n(\ntime\n);\n \n        \nbusy\n \n=\n \ntrue\n;\n \n    \n}\n\n\n    \nvoid\n \nrelease\n()\n \n{\n \n        \nbusy\n \n=\n \nfalse\n;\n \n        \nx\n.\nsignal\n();\n \n    \n}\n\n\n    \ninitialization\n \ncode\n()\n \n{\n \n        \nbusy\n \n=\n \nfalse\n;\n \n    \n}\n\n\n    \nsignal\n()\n \n{\n\n        \nif\n \n(\nx_count\n \n \n0\n)\n \n{\n \n            \nnext_count\n++\n;\n \n            \nsignal\n(\nx_sem\n);\n \n            \nwait\n(\nnext\n);\n \n            \nnext_count\n--\n;\n \n        \n}\n\n    \n}\n\n\n    \nwait\n()\n \n{\n \n        \nx_count\n++\n;\n \n        \nif\n \n(\nnext_count\n \n \n0\n)\n\n            \nsignal\n(\nnext\n);\n \n        \nelse\n\n            \nsignal\n(\nmutex\n);\n \n        \nwait\n(\nx_sem\n);\n \n        \nx\n \ncount\n--\n;\n\n    \n}\n\n\n}\n\n\n\n\n\nMonitor in Java\n\n\n8 Liveness\n\n\nDeadlock\n\n\nConsider two threads A and B that both need \nsimultaneous\n access to resources 1 and 2:\n\n\n\n\nThread A\n runs, grabs the lock for \nResource 1\n.\n\n\n\u2192 CONTEXT SWITCH \u2190\n\n\nThread B\n runs, grabs the lock for \nResource 2\n.\n\n\n\u2192 CONTEXT SWITCH \u2190\n\n\nThread A\n runs, tries to acquire the lock for \nResource 2\n.\n\n\n\u2192 THREAD A SLEEPS \u2190\n\n\nThread B\n runs, tries to acquire the lock for \nResource 1\n.\n\n\n\u2192 THREAD B SLEEPS \u2190\n\n\n\n\nDeadlocked\n(\u6b7b\u9501): \ntwo or more processes are waiting indefinitely for an event\n.\n\n\nA set of processes is in a deadlocked state when every process in the set is waiting for an event that can be caused only by another process in the set.\n\n\nPriority Inversion\n\n\nA scheduling challenge arises when a higher-priority process needs to read or modify kernel data that are currently being accessed by a lower-priority process\u2014or a chain of lower-priority processes. \n\n\n\n\nSince kernel data are typically protected with a lock, the higher-priority process will have to wait for a lower-priority one to finish with the resource. \n\n\nThe situation becomes more complicated if the lower-priority process is preempted in favor of another process with a higher priority.\n\n\n\n\nAs an example, assume we have three processes\u2014\nL\nL\n, \nM\nM\n, and \nH\nH\n\u2014whose priorities follow the order \nL \n M \n H\nL < M < H\n. \n\n\n\n\nAssume that process \nH\nH\n requires a semaphore \nS\nS\n, which is currently being accessed by process \nL\nL\n. \n\n\nOrdinarily, process \nH\nH\n would wait for \nL\nL\n to finish using resource S. \n\n\nHowever, now suppose that process \nM\nM\n becomes runnable, thereby preempting process \nL\nL\n. \n\n\nIndirectly, a process with a lower priority\u2014process \nM\nM\n\u2014has affected how long process \nH\nH\n must wait for \nL\nL\n to relinquish resource \nS\nS\n.\n\n\n\n\n\n\nThis liveness problem is known as \npriority inversion\n(\u4f18\u5148\u7ea7\u53cd\u8f6c), and it can occur only in systems with more than two priorities. \n\n\nSolution\uff1a\npriority-inheritance protocol\n(\u4f18\u5148\u7ea7\u7ee7\u627f\u534f\u8bae)\uff1a\n\n\n\n\nAll processes that are accessing resources needed by a higher-priority process inherit the higher priority until they are finished with the resources. \n\n\nWhen they are finished, priorities revert to original values.\n\n\n\n\n9 Evaluation\n\n\nPerformance differences between CAS-based synchronization and traditional synchronization (such as mutex locks and semaphores) under varying contention loads:\n\n\n\n\nUncontended\n\uff1aAlthough both options are generally fast, CAS protection will be somewhat faster than traditional synchronization.\n\n\nModerate contention\n\uff1aCAS protection will be faster\u2014possibly much faster \u2014than traditional synchronization.\n\n\nHigh contention\n\uff1aUnder very highly contended loads, traditional synchronization will ultimately be faster than CAS-based synchronization.\n\n\n\n\nHigher-level tools such as monitors and condition variables may have significant overhead, and may be less likely to scale in highly contended situations.", 
            "title": "Chapter 6: Synchronization Tools"
        }, 
        {
            "location": "/osc/ch6/#operating-system-concepts-6-synchronization-tools", 
            "text": "", 
            "title": "Operating System Concepts 6 - Synchronization Tools"
        }, 
        {
            "location": "/osc/ch6/#1-background", 
            "text": "A  race condition (\u7ade\u4e89\u6761\u4ef6) occurs when several processes access and manipulate the same data concurrently and the outcome of the execution depends on the particular order in which the access takes place.  \u591a\u4e2a\u8fdb\u7a0b\u5e76\u53d1\u8bbf\u95ee\u548c\u64cd\u4f5c\u540c\u4e00\u6570\u636e\uff0c\u4e14\u6267\u884c\u7ed3\u679c\u4e0e\u8bbf\u95ee\u53d1\u751f\u7684\u7279\u5b9a\u987a\u5e8f\u6709\u5173\uff0c\u79f0\u4e4b\u4e3a\u7ade\u4e89\u6761\u4ef6\u3002", 
            "title": "1 Background"
        }, 
        {
            "location": "/osc/ch6/#2-the-critical-section-problem", 
            "text": "A  critical section (\u4e34\u754c\u533a) is a section of code, in which the process may be accessing and updating data that is shared with at least one other process.   When one process is executing in its critical section, no other process is allowed to execute in its critical section.   The  critical-section problem (\u4e34\u754c\u533a\u95ee\u9898) is to design a protocol that the processes can use to synchronize their activity so as to cooperatively share data.   Each process must request permission to enter its critical section.  The section of code implementing this request is the  entry section (\u8fdb\u5165\u533a)  The critical section may be followed by an  exit section (\u9000\u51fa\u533a)\u3002  The remaining code is the  remainder section (\u5269\u4f59\u533a)\u3002    A solution to the critical-section problem must satisfy the following three requirements:   Mutual exclusion  (\u4e92\u65a5): If process  P_i P_i  is executing in its critical section, then no other processes can be executing in their critical sections. \u5982\u679c\u8fdb\u7a0b P_i P_i \u5728\u5176\u4e34\u754c\u533a\u5185\u6267\u884c\uff0c\u90a3\u4e48\u5176\u4ed6\u8fdb\u7a0b\u90fd\u4e0d\u80fd\u5728\u5176\u4e34\u754c\u533a\u5185\u6267\u884c\uff1b  Progress  (\u524d\u8fdb): If no process is executing in its critical section and some processes wish to enter their critical sections, then only those processes that are not executing in their remainder sections can participate in deciding which will enter its critical section next, and this selection cannot be postponed indefinitely. \u5982\u679c\u6ca1\u6709\u8fdb\u7a0b\u5728\u5176\u4e34\u754c\u533a\u5185\u6267\u884c\u4e14\u6709\u8fdb\u7a0b\u9700\u8fdb\u5165\u4e34\u754c\u533a\uff0c\u90a3\u4e48\u53ea\u6709\u90a3\u4e48\u4e0d\u5728\u5269\u4f59\u533a\u5185\u6267\u884c\u7684\u8fdb\u7a0b\u53ef\u53c2\u52a0\u9009\u62e9\uff0c\u4ee5\u786e\u5b9a\u8c01\u80fd\u4e0b\u4e00\u4e2a\u8fdb\u5165\u4e34\u754c\u533a\uff0c\u4e14\u8fd9\u79cd\u9009\u62e9\u4e0d\u80fd\u65e0\u9650\u63a8\u8fdf\uff1b  Bounded waiting  (\u6709\u9650\u7b49\u5f85): There exists a bound, or limit, on the number of times that other processes are allowed to enter their critical sections after a process has made a request to enter its critical section and before that request is granted. \u4ece\u4e00\u4e2a\u8fdb\u7a0b\u505a\u51fa\u8fdb\u5165\u4e34\u754c\u533a\u7684\u8bf7\u6c42\uff0c\u76f4\u5230\u8be5\u8bf7\u6c42\u5141\u8bb8\u4e3a\u6b62\uff0c\u5176\u4ed6\u8fdb\u7a0b\u5141\u8bb8\u8fdb\u5165\u5176\u4e34\u754c\u533a\u5185\u7684\u6b21\u6570\u6709\u4e0a\u9650\u3002   Two general approaches are used to handle critical sections in operating systems:  preemptive kernels \uff08\u62a2\u5360\u5185\u6838\uff09 and  nonpreemptive kernels \uff08\u975e\u62a2\u5360\u5185\u6838\uff09.   A preemptive kernel allows a process to be preempted while it is running in kernel mode. \u62a2\u5360\u5185\u6838\u5141\u8bb8\u5904\u4e8e\u5185\u6838\u6a21\u5f0f\u7684\u8fdb\u7a0b\u88ab\u62a2\u5360\u3002  A nonpreemptive kernel does not allow a process running in kernel mode to be preempted.A kernel-model process will run until it exists kernel mode, blocks, or voluntarily yields control of the CPU.\u975e\u62a2\u5360\u5185\u6838\u4e0d\u5141\u8bb8\u5185\u6838\u6a21\u5f0f\u7684\u8fdb\u7a0b\u88ab\u62a2\u5360\u3002  A nonpreemptive kernel is essentially free from race conditions on kernel data structures, as only on process is active in the kernel at at time. \u975e\u62a2\u5360\u5185\u6838\u7684\u5185\u6838\u4ece\u6839\u672c\u4e0a\u4e0d\u4f1a\u5bfc\u81f4\u7ade\u4e89\u6761\u4ef6\uff0c\u56e0\u4e3a\u5728\u5185\u6838\u4e2d\u4e00\u6b21\u53ea\u6709\u4e00\u4e2a\u8fdb\u7a0b\u662f\u6d3b\u8dc3\u7684\u3002  Preemptive kernels must be carefully designed to ensure that shared kernel data are free from race conditions. \u5bf9\u4e8e\u62a2\u5360\u5185\u6838\u9700\u8981\u8ba4\u771f\u8bbe\u8ba1\u4ee5\u786e\u4fdd\u5171\u4eab\u5185\u548c\u6570\u636e\u514d\u4e8e\u7ade\u4e89\u6761\u4ef6\u3002  A preemptive kernel may be more responsive, since there is less risk that a kernel-model process will run for an arbitrarily long period before relinquishing the processor to waiting process. \u62a2\u5360\u5185\u6838\u7684\u54cd\u5e94\u66f4\u5feb\uff0c\u56e0\u4e3a\u5904\u4e8e\u5185\u6838\u6a21\u5f0f\u7684\u8fdb\u7a0b\u5728\u91ca\u653eCPU\u4e4b\u524d\u4e0d\u4f1a\u8fd0\u884c\u8fc7\u4e45\u3002  A preemptive kernel is more suitable for real-time programming, as it will allow a real-time process to preemptive a process currently running in the kernel. \u62a2\u5360\u5185\u6838\u66f4\u9002\u5408\u5b9e\u65f6\u7f16\u7a0b\uff0c\u56e0\u4e3a\u5b83\u80fd\u5141\u8bb8\u5b9e\u65f6\u8fdb\u7a0b\u62a2\u5360\u5904\u4e8e\u5185\u6838\u6a21\u5f0f\u8fd0\u884c\u7684\u5176\u4ed6\u8fdb\u7a0b\u3002", 
            "title": "2 The Critical-Section problem"
        }, 
        {
            "location": "/osc/ch6/#3-petersons-solution", 
            "text": "Peterson\u2019s solution (Peterson \u7b97\u6cd5) is restricted to two processes that alternate execution between their critical sections and remainder sections. The processes are numbered  P_0 P_0  and  P_1 P_1 . For convenience, when presenting  P_i P_i , we use  P_j P_j  to denote the other process; that is  j j  equals  1-i 1-i .  Peterson's solution requires the two processes to share two data items:  int   turn ;  boolean   flag [ 2 ];   The structure of process  P_i P_i  in Peterson's solution.  while   ( true )   { \n     flag [ i ]   =   true ;  \n     turn   =   j ;  \n     while   ( flag [ j ]     turn   ==   j )  \n         ; \n     /* critical section */ \n     flag [ i ]   =   false ; \n     /*remainder section */  }    The variable  turn  indicates whose turn it is to enter its critical section.  The  flag  array is used to indicate if a process is ready to enter its critical section.    Note  Peterson\u2019s solution is  not guaranteed  to work on modern computer architectures for the primary reason that, to improve system performance,  processors and/or compilers may reorder read and write operations that have no dependencies .   If the assignments of the first two statements that appear in the entry section of Peterson's solution are reordered. It is possible that both threads may be active in their critical sections at the same time.", 
            "title": "3 Peterson's Solution"
        }, 
        {
            "location": "/osc/ch6/#4-hardware-support-for-synchronization", 
            "text": "Hardware support for the critical-section problem includes:   Memory barriers  Hardware instructions  Atomic variables", 
            "title": "4 Hardware support for Synchronization"
        }, 
        {
            "location": "/osc/ch6/#memory-barriers", 
            "text": "How a computer architecture determines what memory guarantees it will provide to an application program is known as its  memory model (\u5185\u5b58\u6a21\u578b). In general, a memory model falls into one of two categories:   Strongly ordered , where a memory modification on one processor is immediately visible to all other processors.  Weakly ordered , where modifications to memory on one processor may not be immediately visible to other processors.   Computer architectures provide instructions that can  force  any changes in memory to be propagated to all other processors, thereby ensuring that memory modifications are visible to threads running on other processors. Such instruction are known as  memory barriers (\u5185\u5b58\u5c4f\u969c).   When a memory barrier instruction is performed, the system ensures that all loads and stores are completed before any subsequent load or store operations are performed.", 
            "title": "Memory barriers"
        }, 
        {
            "location": "/osc/ch6/#hardware-instructions", 
            "text": "Many modern computer systems provide special hardware instructions that allow either to test and modify the content of a word or to swap the contents of two words atomically - that is, one uninterruptible unit.  The definition of the atomic  test_and_set()  instruction:  boolean   test_and_set ( boolean   * target )   {  \n     boolean   rv   =   * target ;  \n     * target   =   true ; \n     return   rv ;  }   Mutual-exclusion implementation with  test_and_set() :  do   { \n     while   ( test_and_set ( lock ))  \n         ;   /* do nothing */ \n     /* critical section */ \n     lock   =   false ; \n     /* remainder section */   }   while   ( true );   The definition of the atomic  compare_and_swap() \uff08CAS\uff09instruction:  int   compare_and_swap ( int   * value ,   int   expected ,   int   new   value )   {  \n     int   temp   =   * value ; \n     if   ( * value   ==   expected )  \n         * value   =   new   value ; \n     return   temp ;  }   Mutual exclusion with the  compare_and_swap()  instruction:  while   ( true )   { \n     while   ( compare_and_swap ( lock ,   0 ,   1 )   !=   0 )  \n         ;   /* do nothing */ \n     /* critical section */ \n     lock   =   0 ; \n     /* remainder section */  }", 
            "title": "Hardware instructions"
        }, 
        {
            "location": "/osc/ch6/#atomic-variables", 
            "text": "Atomic variables  (\u539f\u5b50\u53d8\u91cf) provides atomic operations on basic data types such as integers and booleans. Their use is often limited to single updates of shared data such as counters and sequence generators.", 
            "title": "Atomic variables"
        }, 
        {
            "location": "/osc/ch6/#5-mutex-locks", 
            "text": "ISSUE: The hardware-based solutions are complicated as well as generally inaccessible to application programmers.  SOLUTION: Operating-system designers build higher-level software tools. The simplest of these tools is the  mutex lock (\u4e92\u65a5\u9501)\u3002   A process must  acquire  the lock before entering a critical section;   A process  releases  the lock when it exists the critical section.  A mutex lock has a boolean variable  available , whose value indicates if the lock is available or not.  Calls to either  acquire()  or  release()  must be performed atomically. Thus mutex locks can be implemented using the CAS operation.   Solution to the critical-section problem using mutex locks:  while   ( true )   { \n     /* acquire lock */ \n\n     /* critical section */ \n\n     /* release lock */ \n\n     /* remainder section */  }   The definition of  acquire()  is as follows:  acquire ()   {  \n     while   ( ! available )   ; \n         /* busy wait */  \n     available   =   false ;   }   The definition of  release()  is as follows:  release (){ \n     available   =   true ;  }   The main disadvantage of the implementation is that it requires  busy waiting (\u5fd9\u7b49\u5f85).   While  a process is in its critical section, any other process that tries enter its critical section must loop continuously in the call to  acquire() .  It wastes CPU cycles.   Because the process \"spins\" while waiting for the lock to become available, this type of mutex lock is also called a  spinlock \uff08\u81ea\u65cb\u9501\uff09\u3002   Advantage: no context switch is required   Spinlocks are not appropriate for single-processor systems yet are often used in multiprocessor systems.  POSIX API for Spinlocks", 
            "title": "5 Mutex locks"
        }, 
        {
            "location": "/osc/ch6/#6-semaphores", 
            "text": "A  semaphore (\u4fe1\u53f7\u91cf) S is an integer variable that, apart from initialization, is accessed only through two standard atomic operations:  wait()  and  signal() . \u4fe1\u53f7\u91cfS\u662f\u4e2a\u6574\u6570\u53d8\u91cf\uff0c\u9664\u4e86\u521d\u59cb\u5316\u5916\uff0c\u5b83\u53ea\u80fd\u901a\u8fc7\u4e24\u4e2a\u6807\u51c6\u539f\u5b50\u64cd\u4f5c\uff1a wait() \u548c signal() \u6765\u8bbf\u95ee\u3002  The definition of  wait()  is as follows:  wait ( S ){ \n     while   ( S   =   0 ) \n         ; // busy wait \n     S -- ;  {   The definition of  signal()  is as follows:  signal ( S ){ \n     S ++ ;  }   All modifications to the integer value of the semaphore in the  wait()  and  signal()  operations must be executed atomically.  \u5728 wait() \u548c signal() \u64cd\u4f5c\u4e2d\uff0c\u5bf9\u4fe1\u53f7\u91cf\u6574\u578b\u503c\u7684\u4fee\u6539\u5fc5\u987b\u4e0d\u53ef\u5206\u5730\u6267\u884c\u3002  Operating systems often distinguish between counting and binary semaphores.\u901a\u5e38\u64cd\u4f5c\u7cfb\u7edf\u533a\u5206\u8ba1\u6570\u4fe1\u53f7\u91cf\u548c\u4e8c\u8fdb\u5236\u4fe1\u53f7\u91cf\u3002   The value of a  counting semaphore (\u8ba1\u6570\u4fe1\u53f7\u91cf) can range over an unrestricted domain.\u8ba1\u6570\u4fe1\u53f7\u91cf\u7684\u503c\u57df\u4e0d\u53d7\u9650\u5236\u3002  The value of a  binary semaphore (\u4e8c\u8fdb\u5236\u4fe1\u53f7\u91cf) can range only between 0 and 1. \u4e8c\u8fdb\u5236\u4fe1\u53f7\u91cf\u7684\u503c\u53ea\u80fd\u4e3a0\u62161\u3002   Counting semaphores can be used to control access to  a given resource consisting of a finite number of instances.   The semaphore is initialized to the number of resources available.   Each process that wishes to use a resource performs a  wait() operation on the semaphore (thereby decrementing the count).   When a process releases a resource, it performs a  signal()  operation (incrementing the count).   When the count for the semaphore goes to 0, all resources are being used. After that, processes that wish to use a resource will block until the count becomes greater than 0.   POSIX API for Semaphores", 
            "title": "6 Semaphores"
        }, 
        {
            "location": "/osc/ch6/#7-monitors", 
            "text": "", 
            "title": "7 Monitors"
        }, 
        {
            "location": "/osc/ch6/#monitor-usage", 
            "text": "Issues: various types of errors can be generated easily when programmers use semaphores or mutex locks incorrectly to solve the critical-section problem.   interchanges the order of  wait()  and  signal()  replaces  signal()  with  wait()  omits  wait()  or  signal()   Solution: An abstract data type,  monitor (\u7ba1\u7a0b), includes a set of programmer-defined operation related to mutual exclusion within the monitor. The monitor construct ensures that only one process at a time is active within the monitor.  Pseudocode syntax of a monitor:  monitor   monitor   name   {   /* shared variable declarations */ \n     function   P1   (   .   .   .   )   {   .   .   .} \n     function   P2   (   .   .   .   )   {   .   .   .} \n         . \n         . \n     function   Pn   (   .   .   .   )   {   .   .   .} \n     initialization   code   (   .   .   .   )   {   .   .   .}  }   A monitor uses  condition variables  that allow processes to wait for certain conditions to become true and to signal one another when conditions have been set to true:   \\text{condition x, y;}  \\text{condition x, y;}   The only operations that can be invoked on a condition variable are  wait()  and  signal() .", 
            "title": "Monitor Usage"
        }, 
        {
            "location": "/osc/ch6/#implementing-a-monitor-using-semaphores", 
            "text": "binary semaphore  next : the signaling processes use it to suspend themselves.  integer variable  next_count : to count the number of processes suspended on  next .  condition  x , binary semaphore  x_sem , and integer variable  x_count     monitor   ResourceAllocator   { \n\n     boolean   busy ;  \n     condition   x ; \n\n     void   acquire ( int   time )   {  \n         if   ( busy )  \n             x . wait ( time );  \n         busy   =   true ;  \n     } \n\n     void   release ()   {  \n         busy   =   false ;  \n         x . signal ();  \n     } \n\n     initialization   code ()   {  \n         busy   =   false ;  \n     } \n\n     signal ()   { \n         if   ( x_count     0 )   {  \n             next_count ++ ;  \n             signal ( x_sem );  \n             wait ( next );  \n             next_count -- ;  \n         } \n     } \n\n     wait ()   {  \n         x_count ++ ;  \n         if   ( next_count     0 ) \n             signal ( next );  \n         else \n             signal ( mutex );  \n         wait ( x_sem );  \n         x   count -- ; \n     }  }   Monitor in Java", 
            "title": "Implementing a Monitor Using Semaphores"
        }, 
        {
            "location": "/osc/ch6/#8-liveness", 
            "text": "", 
            "title": "8 Liveness"
        }, 
        {
            "location": "/osc/ch6/#deadlock", 
            "text": "Consider two threads A and B that both need  simultaneous  access to resources 1 and 2:   Thread A  runs, grabs the lock for  Resource 1 .  \u2192 CONTEXT SWITCH \u2190  Thread B  runs, grabs the lock for  Resource 2 .  \u2192 CONTEXT SWITCH \u2190  Thread A  runs, tries to acquire the lock for  Resource 2 .  \u2192 THREAD A SLEEPS \u2190  Thread B  runs, tries to acquire the lock for  Resource 1 .  \u2192 THREAD B SLEEPS \u2190   Deadlocked (\u6b7b\u9501):  two or more processes are waiting indefinitely for an event .  A set of processes is in a deadlocked state when every process in the set is waiting for an event that can be caused only by another process in the set.", 
            "title": "Deadlock"
        }, 
        {
            "location": "/osc/ch6/#priority-inversion", 
            "text": "A scheduling challenge arises when a higher-priority process needs to read or modify kernel data that are currently being accessed by a lower-priority process\u2014or a chain of lower-priority processes.    Since kernel data are typically protected with a lock, the higher-priority process will have to wait for a lower-priority one to finish with the resource.   The situation becomes more complicated if the lower-priority process is preempted in favor of another process with a higher priority.   As an example, assume we have three processes\u2014 L L ,  M M , and  H H \u2014whose priorities follow the order  L   M   H L < M < H .    Assume that process  H H  requires a semaphore  S S , which is currently being accessed by process  L L .   Ordinarily, process  H H  would wait for  L L  to finish using resource S.   However, now suppose that process  M M  becomes runnable, thereby preempting process  L L .   Indirectly, a process with a lower priority\u2014process  M M \u2014has affected how long process  H H  must wait for  L L  to relinquish resource  S S .    This liveness problem is known as  priority inversion (\u4f18\u5148\u7ea7\u53cd\u8f6c), and it can occur only in systems with more than two priorities.   Solution\uff1a priority-inheritance protocol (\u4f18\u5148\u7ea7\u7ee7\u627f\u534f\u8bae)\uff1a   All processes that are accessing resources needed by a higher-priority process inherit the higher priority until they are finished with the resources.   When they are finished, priorities revert to original values.", 
            "title": "Priority Inversion"
        }, 
        {
            "location": "/osc/ch6/#9-evaluation", 
            "text": "Performance differences between CAS-based synchronization and traditional synchronization (such as mutex locks and semaphores) under varying contention loads:   Uncontended \uff1aAlthough both options are generally fast, CAS protection will be somewhat faster than traditional synchronization.  Moderate contention \uff1aCAS protection will be faster\u2014possibly much faster \u2014than traditional synchronization.  High contention \uff1aUnder very highly contended loads, traditional synchronization will ultimately be faster than CAS-based synchronization.   Higher-level tools such as monitors and condition variables may have significant overhead, and may be less likely to scale in highly contended situations.", 
            "title": "9 Evaluation"
        }, 
        {
            "location": "/osc/ch7/", 
            "text": "Operating System Concepts 7 - Synchronization Examples\n\n\n1 Classic Problems of Synchronization\n\n\nThe Bounded Buffer Problem\n\n\nWe consider the producer-consumer problem with \nbounded buffer\n. The producer and consumer processes share the following data structures:\n\n\nint\n \nn\n;\n\n\nsemaphore\n \nmutex\n \n=\n \n1\n;\n\n\nsemaphore\n \nempty\n \n=\n \nn\n;\n\n\nsemaphore\n \nfull\n \n=\n \n0\n;\n\n\n\n\n\n\n\nWe assume that the pool consists of \nn\nn\n buffers, each capable of holding one item.\n\n\nThe \nmutex\n binary semaphore provides mutual exclusion for accesses to the buffer pool and is initialized to the value 1.\n\n\nThe \nempty\n and \nfull\n semaphores count the number of empty and full buffers.\n\n\n\n\n// The code for the producer process:\n\n\nwhile\n \n(\ntrue\n)\n \n{\n\n    \n.\n \n.\n \n.\n\n    \n/* produce an item in next produced */\n \n    \n.\n \n.\n \n.\n \n    \nwait\n(\nempty\n);\n \n    \nwait\n(\nmutex\n);\n \n    \n.\n \n.\n \n.\n\n    \n/* add next produced to the buffer */\n \n    \n.\n \n.\n \n.\n \n    \nsignal\n(\nmutex\n);\n \n    \nsignal\n(\nfull\n);\n\n\n}\n\n\n\n\n//The code for the consumer process:\n\n\nwhile\n \n(\ntrue\n)\n \n{\n\n    \nwait\n(\nfull\n);\n \n    \nwait\n(\nmutex\n);\n\n    \n.\n \n.\n \n.\n\n    \n/* remove an item from buffer to next consumed */\n\n    \n.\n \n.\n \n.\n \n    \nsignal\n(\nmutex\n);\n \n    \nsignal\n(\nempty\n);\n\n    \n.\n \n.\n \n.\n\n    \n/* consume the item in next consumed */\n\n    \n.\n \n.\n \n.\n\n\n}\n\n\n\n\n\nThe Readers\u2013Writers Problem\n\n\nSuppose that a database is to be shared among several concurrent processes. \n\n\n\n\nSome of these processes may want only to read the database, whereas others may want to update(that is, read and write) the database.\n\n\nIf two readers access the shared data simultaneously, no adverse effects will result.\n\n\nIf a writer and some other processes (either a reader or a writer) access the database simultaneously, chaos may ensue.\n\n\n\n\nThree variables are used: \nmutex\n, \nrw_mutex\n, \nreadcnt\n to implement solution.\n\n\nsemaphore\n \nrw_mutex\n \n=\n \n1\n;\n \n\nsemaphore\n \nmutex\n \n=\n \n1\n;\n \n\nint\n \nread\n \ncount\n \n=\n \n0\n;\n\n\n\n\n\n\n\nsemaphore \nmutex\n:  used to ensure mutual exclusion when \nreadcnt\n is updated i.e. when any reader enters or exit from the critical section.\n\n\nsemaphore \nrw_mutex\n: used by both readers and writers.\n\n\nint \nreadcnt\n: the number of processes performing read in the critical section, initially 0.\n\n\n\n\nWriter processes:\n\n\n\n\nWriter requests the entry to critical section.\n\n\nIf allowed i.e. \nwait()\n gives a true value, it enters and performs the write. If not allowed, it keeps on waiting.\n\n\nIt exits the critical section.\n\n\n\n\ndo\n \n{\n\n    \n// writer requests for critical section\n\n    \nwait\n(\nrw_mutex\n);\n  \n\n    \n// performs the write\n\n\n    \n// leaves the critical section\n\n    \nsignal\n(\nrw_mutex\n);\n\n\n\n}\n \nwhile\n(\ntrue\n);\n\n\n\n\n\nReader process:\n\n\n\n\nReader requests the entry to critical section.\n\n\nIf allowed:\n\n\nIt increments the count of number of readers inside the critical section. If this reader is the first reader entering, it locks the \nrw_mutex\n semaphore to restrict the entry of writers if any reader is inside.\n\n\nIt then, signals \nmutex\n as any other reader is allowed to enter while others are already reading.\n\n\nAfter performing reading, it exits the critical section. When exiting, it checks if no more reader is inside, it signals the semaphore \nrw_mutex\n as now, writer can enter the critical section.\n\n\n\n\n\n\nIf not allowed, it keeps on waiting.\n\n\n\n\ndo\n \n{\n\n   \n// Reader wants to enter the critical section\n\n   \nwait\n(\nmutex\n);\n\n\n   \n// The number of readers has now increased by 1\n\n   \nreadcnt\n++\n;\n                          \n\n   \n// there is at least one reader in the critical section\n\n   \n// this ensure no writer can enter if there is even one reader\n\n   \n// thus we give preference to readers here\n\n   \nif\n \n(\nreadcnt\n==\n1\n)\n     \n      \nwait\n(\nrw_mutex\n);\n                    \n\n   \n// other readers can enter while this current reader is inside \n\n\n   \n// the critical section\n\n   \nsignal\n(\nmutex\n);\n                   \n\n        \n...\n\n   \n/* current reader performs reading here */\n\n        \n...\n\n\n   \nwait\n(\nmutex\n);\n   \n// a reader wants to leave\n\n\n   \nreadcnt\n--\n;\n\n\n   \n// that is, no reader is left in the critical section,\n\n   \nif\n \n(\nreadcnt\n \n==\n \n0\n)\n \n       \nsignal\n(\nrw_mutex\n);\n         \n// writers can enter\n\n\n   \nsignal\n(\nmutex\n);\n \n// reader leaves\n\n\n\n}\n \nwhile\n(\ntrue\n);\n\n\n\n\n\nThe Dining-Philosophers Problem\n\n\nThe dining-philosophers problem is an example of a large class of concurrency-control problems. It is a simple representation of the need to allocate several resources among several processes in a deadlock-free and starvation-free manner.\n\n\nConsider five philosophers who spend their lives thinking and eating. \n\n\n\n\nThe philosophers share a circular table surrounded by five chairs, each belonging to one philosopher. \n\n\nIn the center of the table is a bowl of rice, and the table is laid with five single chopsticks.\n\n\nWhen a philosopher thinks, she does not interact with her colleagues.\n\n\nFrom time to time, a philosopher gets hungry and tries to pick up the two chopsticks that are closest to her (the chopsticks that are between her and her left and right neighbors). \n\n\nA philosopher may pick up only one chopstick at a time. Obviously, she cannot pick up a chopstick that is already in the hand of a neighbor.\n\n\nWhen a hungry philosopher has both her chopsticks at the same time, she eats without releasing the chopsticks. \n\n\nWhen she is finished eating, she puts down both chopsticks and starts thinking again\n\n\n\n\n\n\n2 Synchronization within the Linux Kernel\n\n\nLinux provides several different mechanisms for synchronization in the kernel. \n\n\nThe synchronization methods discussed here to synchronization within the kernel and are therefore available only to kernel developers.\n\n\nAtomic integer\n\n\nThe simplest synchronization technique within the Linux kernel is an atomic integer, which is represented using the \nopaque data type\n \natomic_t\n. All math operations using atomic integers are performed without interruption.\n\n\nAtomic integers are particularly efficient in situations where an integer variable\u2014such as a counter\u2014needs to be updated, since atomic operations do not require the overhead of locking mechanisms:\n\n\n\n\nLocks\n\n\nIn situations where there are several variables contributing to a possible race condition, more sophisticated locking tools must be used. Mutex locks are available in Linux for protecting critical sections within the kernel. Here, a task must invoke the \nmutex_lock()\n function prior to entering a critical section and the\nmutex_unlock()\n function after exiting the critical section.\n\n\nLinux also provides spinlocks and semaphores (as well as reader\u2013writer versions of these two locks) for locking in the kernel. \n\n\nBoth spinlocks and mutex locks in the Linux kernel are \nnonrecursive\n, which means that if a thread has acquired one of these locks, it cannot acquire the same lock a second time without first releasing the lock. Otherwise, the second attempt at acquiring the lock will block.\n\n\nLinux provides two simple system calls \u2014 \npreempt_disable()\n and \npreempt_enable()\n \u2014for disabling and enabling kernel preemption.\n\n\n3 POSIX Synchronization\n\n\nThe POSIX API is available for programmers at the user level and is not part of any particular operating-system kernel.\n\n\nPOSIX Mutex Locks\n\n\nPthreads uses the \npthread_mutex_t\n data type for mutex locks.\n\n\n\n\nA mutex is created with the pthread \nmutex_init()\n function.\n\n\nThe mutex is acquired and released with the pthread \nmutex_lock()\n and pthread \nmutex_unlock()\n functions.\n\n\n\n\n#include\n \npthread.h\n\n\npthread_mutex_t\n \nmutex\n;\n \n\n\n/* create and initialize the mutex lock */\n \n\npthread_mutex_init\n(\nmutex\n,\n \nNULL\n);\n\n\n\n/* acquire the mutex lock */\n\n \npthread\n \nmutex_lock\n(\nmutex\n);\n \n\n\n/* critical section */\n \n\n\n/* release the mutex lock */\n \n\npthread\n \nmutex_unlock\n(\nmutex\n);\n\n\n\n\n\nPOSIX Spinlocks\n\n\n// \u521d\u59cb\u5316\u81ea\u65cb\u9501\uff1a \u7528\u6765\u7533\u8bf7\u4f7f\u7528\u81ea\u65cb\u9501\u6240\u9700\u8981\u7684\u8d44\u6e90\u5e76\u4e14\u5c06\u5b83\u521d\u59cb\u5316\u4e3a\u975e\u9501\u5b9a\u72b6\u6001\n\n\nint\n \npthread_spin_init\n(\npthread_spinlock_t\n \n*\n,\n \nint\n);\n\n\n// \u83b7\u5f97\u4e00\u4e2a\u81ea\u65cb\u9501\uff1a\u5982\u679c\u8be5\u81ea\u65cb\u9501\u5f53\u524d\u6ca1\u6709\u88ab\u5176\u5b83\u7ebf\u7a0b\u6240\u6301\u6709\uff0c\u5219\u8c03\u7528\u8be5\u51fd\u6570\u7684\u7ebf\u7a0b\u83b7\u5f97\u8be5\u81ea\u65cb\u9501.\n\n\n// \u5426\u5219\u8be5\u51fd\u6570\u5728\u83b7\u5f97\u81ea\u65cb\u9501\u4e4b\u524d\u4e0d\u4f1a\u8fd4\u56de\u3002\n\n\nint\n \npthread_spin_lock\n(\npthread_spinlock_t\n \n*\n);\n\n\n//\u91ca\u653e\u6307\u5b9a\u7684\u81ea\u65cb\u9501\n\n\nint\n \npthread_spin_unlock\n(\npthread_spinlock_t\n \n*\n);\n\n\n// \u9500\u6bc1\u4e00\u4e2a\u81ea\u65cb\u9501\n\n\nint\n \npthread_spin_destroy\n(\npthread_spinlock_t\n \n*\n);\n\n\n\n\n\nPOSIX Semaphores\n\n\nSemaphores are not part of the POSIX standard and instead belong to the POSIX SEM extension. POSIX specifies two types of semaphores - \nnamed\n and \nunnamed\n semaphores.\n\n\nThe advantage of named semaphores is that multiple unrelated processes can easily use a common semaphore as a synchronization mechanism by simply referring to the semaphore\u2019s name.\n\n\nBoth Linux and macOS systems provide POSIX named semaphores.\n\n\n#include\n \nsemaphore.h\n\n\nsem_t\n \n*\nsem\n;\n\n\n\n/* Create the semaphore and initialize it to 1 * Here, we are naming the semaphore SEM.\n\n\n* The O_CREAT flag indicates that the semaphore will be created if it does not already exist.\n\n\n* The parameter 0666 indicates that the semaphore has read/write access for other processes.\n\n\n* The parameter 1 indicates that the semaphore is initialized to 1.\n\n\n*/\n\n\n\nsem\n \n=\n \nsem_open\n(\nSEM\n,\n \nO_CREAT\n,\n \n0666\n,\n \n1\n);\n\n\n\n/* acquire the semaphore */\n\n\nsem_wait\n(\nsem\n);\n\n\n\n/* critical section */\n\n\n\n/* release the semaphore */\n\n\nsem_post\n(\nsem\n);\n\n\n\n\n\nPOSIX Condition Variables\n\n\n4 Synchronization in Java\n\n\nJava Monitors\n\n\nBounded buffer using Java synchronization\n\n\npublic\n \nclass\n \nBoundedBuffer\nE\n\n\n{\n\n    \nprivate\n \nstatic\n \nfinal\n \nint\n \nBUFFER_SIZE\n \n=\n \n5\n;\n\n\n    \nprivate\n \nint\n \ncount\n,\n \nin\n,\n \nout\n;\n\n    \nprivate\n \nE\n[]\n \nbuffer\n;\n\n\n    \npublic\n \nBoundedBuffer\n()\n \n{\n\n        \ncount\n \n=\n \n0\n;\n\n        \nin\n \n=\n \n0\n;\n\n        \nout\n \n=\n \n0\n;\n\n        \nbuffer\n \n=\n \n(\nE\n[])\n \nnew\n \nObject\n[\nBUFFER_SIZE\n];\n\n    \n}\n\n\n    \npublic\n \nsynchronized\n \nvoid\n \ninsert\n(\nE\n \nitem\n)\n \n{\n\n        \nwhile\n \n(\ncount\n \n==\n \nBUFFER_SIZE\n)\n \n{\n\n            \ntry\n \n{\n\n                \nwait\n();\n\n            \n}\n\n            \ncatch\n \n(\nInterruptedException\n \nie\n)\n \n{\n \n}\n\n        \n}\n\n\n        \nbuffer\n[\nin\n]\n \n=\n \nitem\n;\n\n        \nin\n \n=\n \n(\nin\n \n+\n \n1\n)\n \n%\n \nBUFFER_SIZE\n;\n\n        \ncount\n++;\n\n\n        \nnotify\n();\n\n    \n}\n\n\n    \npublic\n \nsynchronized\n \nE\n \nremove\n()\n \n{\n\n        \nE\n \nitem\n;\n\n\n        \nwhile\n \n(\ncount\n \n==\n \n0\n)\n \n{\n\n            \ntry\n \n{\n\n                \nwait\n();\n\n            \n}\n\n            \ncatch\n \n(\nInterruptedException\n \nie\n)\n \n{\n \n}\n\n        \n}\n\n\n        \nitem\n \n=\n \nbuffer\n[\nout\n];\n\n        \nout\n \n=\n \n(\nout\n \n+\n \n1\n)\n \n%\n \nBUFFER_SIZE\n;\n\n        \ncount\n--;\n\n\n        \nnotify\n();\n\n\n        \nreturn\n \nitem\n;\n\n    \n}\n\n\n}\n\n\n\n\n\nReentrant Locks\n\n\nSemaphores\n\n\nCondition Variables\n\n\n\u5f85\u7eed\uff0c\u8fd8\u6ca1\u5b66\u5b8cJAVA\u5462", 
            "title": "Chapter 7: Synchronization Examples"
        }, 
        {
            "location": "/osc/ch7/#operating-system-concepts-7-synchronization-examples", 
            "text": "", 
            "title": "Operating System Concepts 7 - Synchronization Examples"
        }, 
        {
            "location": "/osc/ch7/#1-classic-problems-of-synchronization", 
            "text": "", 
            "title": "1 Classic Problems of Synchronization"
        }, 
        {
            "location": "/osc/ch7/#the-bounded-buffer-problem", 
            "text": "We consider the producer-consumer problem with  bounded buffer . The producer and consumer processes share the following data structures:  int   n ;  semaphore   mutex   =   1 ;  semaphore   empty   =   n ;  semaphore   full   =   0 ;    We assume that the pool consists of  n n  buffers, each capable of holding one item.  The  mutex  binary semaphore provides mutual exclusion for accesses to the buffer pool and is initialized to the value 1.  The  empty  and  full  semaphores count the number of empty and full buffers.   // The code for the producer process:  while   ( true )   { \n     .   .   . \n     /* produce an item in next produced */  \n     .   .   .  \n     wait ( empty );  \n     wait ( mutex );  \n     .   .   . \n     /* add next produced to the buffer */  \n     .   .   .  \n     signal ( mutex );  \n     signal ( full );  }  //The code for the consumer process:  while   ( true )   { \n     wait ( full );  \n     wait ( mutex ); \n     .   .   . \n     /* remove an item from buffer to next consumed */ \n     .   .   .  \n     signal ( mutex );  \n     signal ( empty ); \n     .   .   . \n     /* consume the item in next consumed */ \n     .   .   .  }", 
            "title": "The Bounded Buffer Problem"
        }, 
        {
            "location": "/osc/ch7/#the-readerswriters-problem", 
            "text": "Suppose that a database is to be shared among several concurrent processes.    Some of these processes may want only to read the database, whereas others may want to update(that is, read and write) the database.  If two readers access the shared data simultaneously, no adverse effects will result.  If a writer and some other processes (either a reader or a writer) access the database simultaneously, chaos may ensue.   Three variables are used:  mutex ,  rw_mutex ,  readcnt  to implement solution.  semaphore   rw_mutex   =   1 ;   semaphore   mutex   =   1 ;   int   read   count   =   0 ;    semaphore  mutex :  used to ensure mutual exclusion when  readcnt  is updated i.e. when any reader enters or exit from the critical section.  semaphore  rw_mutex : used by both readers and writers.  int  readcnt : the number of processes performing read in the critical section, initially 0.   Writer processes:   Writer requests the entry to critical section.  If allowed i.e.  wait()  gives a true value, it enters and performs the write. If not allowed, it keeps on waiting.  It exits the critical section.   do   { \n     // writer requests for critical section \n     wait ( rw_mutex );   \n\n     // performs the write \n\n     // leaves the critical section \n     signal ( rw_mutex );  }   while ( true );   Reader process:   Reader requests the entry to critical section.  If allowed:  It increments the count of number of readers inside the critical section. If this reader is the first reader entering, it locks the  rw_mutex  semaphore to restrict the entry of writers if any reader is inside.  It then, signals  mutex  as any other reader is allowed to enter while others are already reading.  After performing reading, it exits the critical section. When exiting, it checks if no more reader is inside, it signals the semaphore  rw_mutex  as now, writer can enter the critical section.    If not allowed, it keeps on waiting.   do   { \n    // Reader wants to enter the critical section \n    wait ( mutex ); \n\n    // The number of readers has now increased by 1 \n    readcnt ++ ;                           \n\n    // there is at least one reader in the critical section \n    // this ensure no writer can enter if there is even one reader \n    // thus we give preference to readers here \n    if   ( readcnt == 1 )      \n       wait ( rw_mutex );                     \n\n    // other readers can enter while this current reader is inside  \n\n    // the critical section \n    signal ( mutex );                    \n\n         ... \n    /* current reader performs reading here */ \n         ... \n\n    wait ( mutex );     // a reader wants to leave \n\n    readcnt -- ; \n\n    // that is, no reader is left in the critical section, \n    if   ( readcnt   ==   0 )  \n        signal ( rw_mutex );           // writers can enter \n\n    signal ( mutex );   // reader leaves  }   while ( true );", 
            "title": "The Readers\u2013Writers Problem"
        }, 
        {
            "location": "/osc/ch7/#the-dining-philosophers-problem", 
            "text": "The dining-philosophers problem is an example of a large class of concurrency-control problems. It is a simple representation of the need to allocate several resources among several processes in a deadlock-free and starvation-free manner.  Consider five philosophers who spend their lives thinking and eating.    The philosophers share a circular table surrounded by five chairs, each belonging to one philosopher.   In the center of the table is a bowl of rice, and the table is laid with five single chopsticks.  When a philosopher thinks, she does not interact with her colleagues.  From time to time, a philosopher gets hungry and tries to pick up the two chopsticks that are closest to her (the chopsticks that are between her and her left and right neighbors).   A philosopher may pick up only one chopstick at a time. Obviously, she cannot pick up a chopstick that is already in the hand of a neighbor.  When a hungry philosopher has both her chopsticks at the same time, she eats without releasing the chopsticks.   When she is finished eating, she puts down both chopsticks and starts thinking again", 
            "title": "The Dining-Philosophers Problem"
        }, 
        {
            "location": "/osc/ch7/#2-synchronization-within-the-linux-kernel", 
            "text": "Linux provides several different mechanisms for synchronization in the kernel.   The synchronization methods discussed here to synchronization within the kernel and are therefore available only to kernel developers.", 
            "title": "2 Synchronization within the Linux Kernel"
        }, 
        {
            "location": "/osc/ch7/#atomic-integer", 
            "text": "The simplest synchronization technique within the Linux kernel is an atomic integer, which is represented using the  opaque data type   atomic_t . All math operations using atomic integers are performed without interruption.  Atomic integers are particularly efficient in situations where an integer variable\u2014such as a counter\u2014needs to be updated, since atomic operations do not require the overhead of locking mechanisms:", 
            "title": "Atomic integer"
        }, 
        {
            "location": "/osc/ch7/#locks", 
            "text": "In situations where there are several variables contributing to a possible race condition, more sophisticated locking tools must be used. Mutex locks are available in Linux for protecting critical sections within the kernel. Here, a task must invoke the  mutex_lock()  function prior to entering a critical section and the mutex_unlock()  function after exiting the critical section.  Linux also provides spinlocks and semaphores (as well as reader\u2013writer versions of these two locks) for locking in the kernel.   Both spinlocks and mutex locks in the Linux kernel are  nonrecursive , which means that if a thread has acquired one of these locks, it cannot acquire the same lock a second time without first releasing the lock. Otherwise, the second attempt at acquiring the lock will block.  Linux provides two simple system calls \u2014  preempt_disable()  and  preempt_enable()  \u2014for disabling and enabling kernel preemption.", 
            "title": "Locks"
        }, 
        {
            "location": "/osc/ch7/#3-posix-synchronization", 
            "text": "The POSIX API is available for programmers at the user level and is not part of any particular operating-system kernel.", 
            "title": "3 POSIX Synchronization"
        }, 
        {
            "location": "/osc/ch7/#posix-mutex-locks", 
            "text": "Pthreads uses the  pthread_mutex_t  data type for mutex locks.   A mutex is created with the pthread  mutex_init()  function.  The mutex is acquired and released with the pthread  mutex_lock()  and pthread  mutex_unlock()  functions.   #include   pthread.h  pthread_mutex_t   mutex ;   /* create and initialize the mutex lock */   pthread_mutex_init ( mutex ,   NULL );  /* acquire the mutex lock */ \n  pthread   mutex_lock ( mutex );   /* critical section */   /* release the mutex lock */   pthread   mutex_unlock ( mutex );", 
            "title": "POSIX Mutex Locks"
        }, 
        {
            "location": "/osc/ch7/#posix-spinlocks", 
            "text": "// \u521d\u59cb\u5316\u81ea\u65cb\u9501\uff1a \u7528\u6765\u7533\u8bf7\u4f7f\u7528\u81ea\u65cb\u9501\u6240\u9700\u8981\u7684\u8d44\u6e90\u5e76\u4e14\u5c06\u5b83\u521d\u59cb\u5316\u4e3a\u975e\u9501\u5b9a\u72b6\u6001  int   pthread_spin_init ( pthread_spinlock_t   * ,   int );  // \u83b7\u5f97\u4e00\u4e2a\u81ea\u65cb\u9501\uff1a\u5982\u679c\u8be5\u81ea\u65cb\u9501\u5f53\u524d\u6ca1\u6709\u88ab\u5176\u5b83\u7ebf\u7a0b\u6240\u6301\u6709\uff0c\u5219\u8c03\u7528\u8be5\u51fd\u6570\u7684\u7ebf\u7a0b\u83b7\u5f97\u8be5\u81ea\u65cb\u9501.  // \u5426\u5219\u8be5\u51fd\u6570\u5728\u83b7\u5f97\u81ea\u65cb\u9501\u4e4b\u524d\u4e0d\u4f1a\u8fd4\u56de\u3002  int   pthread_spin_lock ( pthread_spinlock_t   * );  //\u91ca\u653e\u6307\u5b9a\u7684\u81ea\u65cb\u9501  int   pthread_spin_unlock ( pthread_spinlock_t   * );  // \u9500\u6bc1\u4e00\u4e2a\u81ea\u65cb\u9501  int   pthread_spin_destroy ( pthread_spinlock_t   * );", 
            "title": "POSIX Spinlocks"
        }, 
        {
            "location": "/osc/ch7/#posix-semaphores", 
            "text": "Semaphores are not part of the POSIX standard and instead belong to the POSIX SEM extension. POSIX specifies two types of semaphores -  named  and  unnamed  semaphores.  The advantage of named semaphores is that multiple unrelated processes can easily use a common semaphore as a synchronization mechanism by simply referring to the semaphore\u2019s name.  Both Linux and macOS systems provide POSIX named semaphores.  #include   semaphore.h  sem_t   * sem ;  /* Create the semaphore and initialize it to 1 * Here, we are naming the semaphore SEM.  * The O_CREAT flag indicates that the semaphore will be created if it does not already exist.  * The parameter 0666 indicates that the semaphore has read/write access for other processes.  * The parameter 1 indicates that the semaphore is initialized to 1.  */  sem   =   sem_open ( SEM ,   O_CREAT ,   0666 ,   1 );  /* acquire the semaphore */  sem_wait ( sem );  /* critical section */  /* release the semaphore */  sem_post ( sem );", 
            "title": "POSIX Semaphores"
        }, 
        {
            "location": "/osc/ch7/#posix-condition-variables", 
            "text": "", 
            "title": "POSIX Condition Variables"
        }, 
        {
            "location": "/osc/ch7/#4-synchronization-in-java", 
            "text": "", 
            "title": "4 Synchronization in Java"
        }, 
        {
            "location": "/osc/ch7/#java-monitors", 
            "text": "Bounded buffer using Java synchronization  public   class   BoundedBuffer E  { \n     private   static   final   int   BUFFER_SIZE   =   5 ; \n\n     private   int   count ,   in ,   out ; \n     private   E []   buffer ; \n\n     public   BoundedBuffer ()   { \n         count   =   0 ; \n         in   =   0 ; \n         out   =   0 ; \n         buffer   =   ( E [])   new   Object [ BUFFER_SIZE ]; \n     } \n\n     public   synchronized   void   insert ( E   item )   { \n         while   ( count   ==   BUFFER_SIZE )   { \n             try   { \n                 wait (); \n             } \n             catch   ( InterruptedException   ie )   {   } \n         } \n\n         buffer [ in ]   =   item ; \n         in   =   ( in   +   1 )   %   BUFFER_SIZE ; \n         count ++; \n\n         notify (); \n     } \n\n     public   synchronized   E   remove ()   { \n         E   item ; \n\n         while   ( count   ==   0 )   { \n             try   { \n                 wait (); \n             } \n             catch   ( InterruptedException   ie )   {   } \n         } \n\n         item   =   buffer [ out ]; \n         out   =   ( out   +   1 )   %   BUFFER_SIZE ; \n         count --; \n\n         notify (); \n\n         return   item ; \n     }  }", 
            "title": "Java Monitors"
        }, 
        {
            "location": "/osc/ch7/#reentrant-locks", 
            "text": "", 
            "title": "Reentrant Locks"
        }, 
        {
            "location": "/osc/ch7/#semaphores", 
            "text": "", 
            "title": "Semaphores"
        }, 
        {
            "location": "/osc/ch7/#condition-variables", 
            "text": "\u5f85\u7eed\uff0c\u8fd8\u6ca1\u5b66\u5b8cJAVA\u5462", 
            "title": "Condition Variables"
        }, 
        {
            "location": "/osc/ch8/", 
            "text": "Operating System Concepts 8 - DeadLocks\n\n\n1 System Model\n\n\n2 Deadlock in Multithreaded Applications\n\n\n3 Deadlock Characterization\n\n\nNecessary Conditions\n\n\nResource-Allocation Graph\n\n\n4 Methods for Handling Deadlocks\n\n\n5 Deadlock Prevention\n\n\nMutual Exclusion\n\n\nHold and Wait\n\n\nNo Preemption\n\n\nCircular Wait\n\n\n6 Deadlock Avoidance\n\n\nSafe State\n\n\nResource-Allocation-Graph Algorithm\n\n\nBanker's Algorithm\n\n\n7 Deadlock Detection\n\n\nSingle Instance of Each Resource Type\n\n\nSeveral Instances of a Resource Type\n\n\nDetection-Algorithm Usage\n\n\n8 Recovery from Deadlock\n\n\nProcess and Thread Termination\n\n\nResource Preemption", 
            "title": "Chapter 8: Deadlocks"
        }, 
        {
            "location": "/osc/ch8/#operating-system-concepts-8-deadlocks", 
            "text": "", 
            "title": "Operating System Concepts 8 - DeadLocks"
        }, 
        {
            "location": "/osc/ch8/#1-system-model", 
            "text": "", 
            "title": "1 System Model"
        }, 
        {
            "location": "/osc/ch8/#2-deadlock-in-multithreaded-applications", 
            "text": "", 
            "title": "2 Deadlock in Multithreaded Applications"
        }, 
        {
            "location": "/osc/ch8/#3-deadlock-characterization", 
            "text": "", 
            "title": "3 Deadlock Characterization"
        }, 
        {
            "location": "/osc/ch8/#necessary-conditions", 
            "text": "", 
            "title": "Necessary Conditions"
        }, 
        {
            "location": "/osc/ch8/#resource-allocation-graph", 
            "text": "", 
            "title": "Resource-Allocation Graph"
        }, 
        {
            "location": "/osc/ch8/#4-methods-for-handling-deadlocks", 
            "text": "", 
            "title": "4 Methods for Handling Deadlocks"
        }, 
        {
            "location": "/osc/ch8/#5-deadlock-prevention", 
            "text": "", 
            "title": "5 Deadlock Prevention"
        }, 
        {
            "location": "/osc/ch8/#mutual-exclusion", 
            "text": "", 
            "title": "Mutual Exclusion"
        }, 
        {
            "location": "/osc/ch8/#hold-and-wait", 
            "text": "", 
            "title": "Hold and Wait"
        }, 
        {
            "location": "/osc/ch8/#no-preemption", 
            "text": "", 
            "title": "No Preemption"
        }, 
        {
            "location": "/osc/ch8/#circular-wait", 
            "text": "", 
            "title": "Circular Wait"
        }, 
        {
            "location": "/osc/ch8/#6-deadlock-avoidance", 
            "text": "", 
            "title": "6 Deadlock Avoidance"
        }, 
        {
            "location": "/osc/ch8/#safe-state", 
            "text": "", 
            "title": "Safe State"
        }, 
        {
            "location": "/osc/ch8/#resource-allocation-graph-algorithm", 
            "text": "", 
            "title": "Resource-Allocation-Graph Algorithm"
        }, 
        {
            "location": "/osc/ch8/#bankers-algorithm", 
            "text": "", 
            "title": "Banker's Algorithm"
        }, 
        {
            "location": "/osc/ch8/#7-deadlock-detection", 
            "text": "", 
            "title": "7 Deadlock Detection"
        }, 
        {
            "location": "/osc/ch8/#single-instance-of-each-resource-type", 
            "text": "", 
            "title": "Single Instance of Each Resource Type"
        }, 
        {
            "location": "/osc/ch8/#several-instances-of-a-resource-type", 
            "text": "", 
            "title": "Several Instances of a Resource Type"
        }, 
        {
            "location": "/osc/ch8/#detection-algorithm-usage", 
            "text": "", 
            "title": "Detection-Algorithm Usage"
        }, 
        {
            "location": "/osc/ch8/#8-recovery-from-deadlock", 
            "text": "", 
            "title": "8 Recovery from Deadlock"
        }, 
        {
            "location": "/osc/ch8/#process-and-thread-termination", 
            "text": "", 
            "title": "Process and Thread Termination"
        }, 
        {
            "location": "/osc/ch8/#resource-preemption", 
            "text": "", 
            "title": "Resource Preemption"
        }, 
        {
            "location": "/osc/ch9/", 
            "text": "Operating System Concepts 9 - Main Memory\n\n\n1 Background\n\n\nBasic Hardware\n\n\nMain memory and the registers built into each processing core are the only general-purpose storage that the CPU can access directly.\n\n\nRegisters that are built into each CPU core are generally accessible within one cycle of the CPU clock. Completing a memory access may take hundreds cycles of the CPU clock. In such cases, the processor normally needs to stall. The remedy is to add cache between the CPU and main memory for fast access.\n\n\nTable. Approximate timing for various operations on a typical PC\n\n\n\n\n\n\n\n\noperations\n\n\napproximate timing\n\n\n\n\n\n\n\n\n\n\nexecute typical instruction\n\n\n1/1,000,000,000 sec = 1 nanosec\n\n\n\n\n\n\nfetch from L1 cache memory\n\n\n0.5 nanosec\n\n\n\n\n\n\nbranch misprediction\n\n\n5 nanosec\n\n\n\n\n\n\nfetch from L2 cache memory\n\n\n7 nanosec\n\n\n\n\n\n\nMutex lock/unlock\n\n\n25 nanosec\n\n\n\n\n\n\nfetch from main memory\n\n\n100 nanosec\n\n\n\n\n\n\nsend 2K bytes over 1Gbps network\n\n\n20,000 nanosec\n\n\n\n\n\n\nread 1MB sequentially from memory\n\n\n250,000 nanosec\n\n\n\n\n\n\nfetch from new disk location (seek)\n\n\n8,000,000 nanosec\n\n\n\n\n\n\nread 1MB sequentially from disk\n\n\n20,000,000 nanosec\n\n\n\n\n\n\nsend packet US to Europe and back\n\n\n150 milliseconds = 150,000,000 nanosec\n\n\n\n\n\n\n\n\nWe also must protect the operating system from access by user processes, as well as protect user processes from one another.\n\n\n\n\nThis protection must be provided by the hardware, because the operating system doesn't usually intervene between the CPU and its memory access.\n\n\nHardware implements this production in several different ways.\n\n\n\n\nWe first need to make sure that each process have a separate memory space.\n\n\n\n\nSeparate per-process memory space protects the processes from each other and is fundamental to having multiple processes loading in memory for concurrent execution.\n\n\nTo separate memory spaces, we need the ability to determine the range of legal addresses that the process may access and to ensure that the process can access only these legal addresses.\n\n\nWe can provide this protection by using two registers, usually a base and a limit. The \nbase register\n holds the smallest legal physical memory address; the \nlimit register\n specifies the size of the range.\n\n\nThe base and limit registers can be loaded only by the operating system, which uses a special privileged instruction.\n\n\n\n\n\n\nAny attempt by a program executing in user mode to access operating-system memory or other users\u2019 memory results in a trap to the operating system, which treats the attempt as a fatal error.\n\n\n\n\nAddress Binding\n\n\nIn most cases, a user program goes through several steps. Addresses may be represented in different ways during these steps.\n\n\n\n\nAddresses in the source program are generally symbolic(\u7b26\u53f7).\n\n\nA compiler typically \nbinds\n these symbolic addresses to relocatable addresses(\u53ef\u91cd\u5b9a\u4f4d\u5730\u5740).\n\n\nThe linker or loader \nbinds\n the relocatable addresses to absolute addresses(\u7edd\u5bf9\u5730\u5740)\u3002\n\n\n\n\n\n\nLogical Versus Physical Address Space\n\n\nAn address generated by the CPU is commonly referred to as a \nlogical address\n(\u903b\u8f91\u5730\u5740), whereas an address loaded into \nmemory-address register\n (MAR) of the memory is commonly referred to as a \nphysical address\n(\u7269\u7406\u5730\u5740).\n\n\n\n\nWe usually refer to the logical address as a \nvirtual address\n(\u865a\u62df\u5730\u5740).\n\n\nThe run-time mapping from virtual to physical addresses is done by a hardware device called the \nmemory-management unit\n (MMU\uff0c\u5185\u5b58\u7ba1\u7406\u5355\u5143).\n\n\n\n\n\n\nNote\n\n\nProgram counter\n points to the next instruction to be fetched/executed , whereas \nmemory address register\n points to the memory location that contains data required (not an instruction).[\nref\n]\n\n\n\n\nDynamic Loading\n\n\nWith \ndynamic loading\n(\u52a8\u6001\u52a0\u8f7d), a routine is not loaded until it is called.\n\n\n\n\nAll routines are kept on disk in a relocatable load format. \n\n\n\n\nThe main program is loaded into memory and is executed. When a routine needs to call another routine, the calling routine first checks to see whether the other routine has been loaded. If it has not, the relocatable linking loader is called to load the desired routine into memory and to update the program\u2019s address tables to reflect this change. Then control is passed to the newly loaded routine.\n\n\n\n\n\n\nThe advantage of dynamic loading is that a routine is loaded only when it is needed.\n\n\n\n\nThis method is particularly useful when \nlarge\n amounts of code are needed to handle \ninfrequently\n occurring cases, such as error routines.\n\n\n\n\nA simple example:\n\n\nvoid\n \n*\nhndl\n \n=\n \ndlopen\n(\nlibnewshapes.so\n,\n \nRTLD_NOW\n);\n\n\nif\n(\nhndl\n \n==\n \nNULL\n){\n\n   \ncerr\n \n \ndlerror\n()\n \n \nendl\n;\n\n   \nexit\n(\n-\n1\n);\n\n\n}\n\n\nvoid\n \n*\nmkr\n \n=\n \ndlsym\n(\nhndl\n,\n \nmaker\n);\n\n\n\n\n\nDynamic Linking and Shared Libraries\n\n\nDynamically linked libraries\n(DLLs\uff0c\u52a8\u6001\u94fe\u63a5\u5e93) are system libraries that are linked to user programs when the programs are run\n\n\nDetailed information in CSAPP\n\n\n2 Contiguous Memory Allocation\n\n\nIn order to accommodate both the operating system and the various user processes, allocating main memory are needed to be in the most efficient way. In \nContiguous memory allocation\n(\u8fde\u7eed\u5185\u5b58\u5206\u914d), \none \nearly\n method, each process is contained in a single section of memory that is contiguous to the section containing the next process\n .\n\n\nThe memory is usually divided into two partitions: one for the operating system and one for the user processes. \n\n\n\n\nWe can place the operating system in either low memory addresses or high memory addresses.\n\n\nMany operating system(including Linux and windows) place the operating system in high memory.\n\n\n\n\nMemory Protection\n\n\nRelocation register (\u91cd\u5b9a\u4f4d\u5bc4\u5b58\u5668) and limit register (\u754c\u9650\u5730\u5740\u5bc4\u5b58\u5668) are used to prevent a process from accessing memory that it does not own.\n\n\n\n\nThe relocation register contains the value of the smallest physical address.\n\n\nThe limit register contains the range of logical addresses.\n\n\nEach logical address must fall within the range specified by the limit register.\n\n\nThe MMU maps the logical address dynamically by adding the value in the relocation register.\n\n\n\n\n\n\nMemory Allocation\n\n\nOne of the simplest methods of allocating memory is to assign processes to variably sized partitions in memory, where each partition may contain \nexactly one\n process.\n\n\n\n\nThe operating system keeps a table indicating which parts of memory are available and which are occupied.\n\n\nA block of available memory is a \nhole\n(\u5b54).\n\n\nWhen a process arrives and needs memory, the system searches for a hole that is large enough for this process.\n\n\n\n\n\n\nPlacement policy\n(\u653e\u7f6e\u7b56\u7565)\uff1aSeveral Ways to satisfy a request of size \nn\nn\n from a list of free holes.\n\n\n\n\nFirst fit\n(\u9996\u6b21\u9002\u914d). Allocate the first hole that is big enough.\n\n\nBest fit\n(\u6700\u4f73\u9002\u914d). Allocate the smallest hole that is big enough.\n\n\nWorst fit\n(\u6700\u5dee\u9002\u914d). Allocate the largest hole.\n\n\n\n\nBoth first fit and best fit are better than worst fit in terms of decreasing time and storage utilization. Neither first fit nor best fit is clearly better than the other in terms of storage utilization, but first fit is generally faster.\n\n\nFragmentation\n\n\nExternal fragmentation\n(\u5916\u90e8\u788e\u7247) exists when there is enough total memory space to satisfy a request but the available spaces are not contiguous: storage is fragmented into a large number of small holes.\n\n\n\n\nOne solution is \ncompaction\n\uff0cwhich shuffles the memory contents so as to place all free memory together in one large block.\n\n\nAnother solution is to permit the logical address space of processes to be noncontiguous, thus allowing a process to be allocated physical memory wherever such memory is available.( \npaging\n, \u5206\u9875, the most common memory-management technique for computer systems).\n\n\n\n\nInternal fragmentation\n(\u5185\u90e8\u788e\u7247) occurs when unused memory is internal to a partition, because of allocating memory in units based on block size.\n\n\n\n\nThe memory must be partitioned into variable sized blocks and assign the best fit block to the process.   \n\n\n\n\n3 Paging\n\n\nPaging\n(\u5206\u9875), is a memory management scheme that permits a process's physical address space to be non-contiguous. Paging avoids external fragmentation and the associated need for compaction.\n\n\nBasic Method\n\n\nThe basic method for implementing paging involves breaking physical memory info fixed-sized blocks called \nframes\n(\u5e27, also physical page), and breaking logical memory into blocks of the same size called \npages\n(\u9875, also virtual page).\n\n\n\n\nThe backing store is divided into fixed-sized blocks that are the same size as the memory frames or clusters of multiple frames.\n\n\n\n\nEvery address generated by the CPU is divided into two parts: a \npage number\n(p, \u9875\u53f7) and a \npage offset\n(d, \u9875\u504f\u79fb)\u3002\n\n\n\n\nThe page number is used as an index into a per-process \npage table\n.\n\n\nPage table\n contains the base address of each frame in physical memory and the offset is the location in the frame being referenced.\n\n\nThe base address of the frame is combined with the page offset to define the physical memory address.\n\n\n\n\n\n\nThe MMU translates a logical address generated by the CPU to a physical address by:\n\n\n\n\nExtract the page number \np\np\n and use it as an index into the page table.\n\n\nExtract the corresponding frame number \nf\nf\n from the page table.\n\n\nReplace the page number \np\np\n in the logical address with the frame number \nf\nf\n.\n\n\n\n\nThe page size is defined by the hardware, typically a power of 2. If the size of logical address space is $2^m $, and a page size is $2^n  $ bytes, then the high-order \nm-n\nm-n\n bits of a logical address designate the page number, and the \nn\nn\n low-order bits designate the page offset.\n\n\nInternal fragmentation still exists\uff1a\n\n\n\n\nIf process size is independent of page size, we expect internal fragmentation to average one-half page per process.\n\n\nThis consideration suggests that small page sizes are desirable.\n\n\nHowever, overhead is involved in each page table entry, and this overhead is reduced as the size of the pages increases.\n\n\nAlso, disk I/O is more efficient when the amount of data being transferred is larger\n\n\n\n\nHardware Suport\n\n\nThe hardware implementation of the page table can be done in several ways.\n\n\n\n\nIn the simplest case, the page table is implemented as a set of dedicated high-speed hardware registers.\n\n\nIt makes the page-address translation very efficient.\n\n\nIt increases context-switch time, as each one of these registers must be exchanged during a context switch.\n\n\nThe use of registers for the page table is satisfactory if the page table is reasonably small (for example, 256 entries).\n\n\nIt is not feasible for most contemporary CPUs, since much larger page tables needed.\n\n\n\n\n\n\nFor a much large page table, the page table is kept in main memory, and a \npage-table base register\n (PTBR, \u9875\u8868\u57fa\u5740\u5bc4\u5b58\u5668) points to the page table.\n\n\n\n\nISSUE: Although storing the page table in main memory can yield faster context switches, it may also result in slower memory access times. Because using page-table to find a physical address need one memory access, since the page-table is kept in main memory.\n\n\nSOLUTION: To use a special, small, fast-lookup hardware \ncache\n called a \ntranslation look-aside buffer\n(TLB, \u8f6c\u8bd1\u540e\u5907\u7f13\u51b2\u5668).\n\n\n\n\nEach entry in the TLB consists of two parts: a key(tag) and a value.\n\n\nWhen the associative memory is presented with an item, the item is compared with all keys \nsimultaneously\n. If the item is found, the corresponding value field is returned.\n\n\nTLB is kept small, typically between 32 and 1,024 entries in size.\n\n\n\n\n\n\nCPUs today may provide \nmultiple\n levels of TLBs. We take the Intel Core i7 as an example [\nsee detail here\n]:\n\n\n\n\nThe Intel Core i7 CPU has a 128-entry L1 instruction TLB and a 64-entry L1 data TLB. \n\n\nIn the case of a miss at L1, it takes the CPU six cycles to check for the entry in the L2 512-entry TLB. \n\n\nA miss in L2 means that the CPU must either walk through the page-table entries in memory to find the associated frame address, which can take hundreds of cycles, or interrupt to the operating system to have it do the work.\n\n\n\n\nProtection\n\n\nMemory protection in a paged environment is accomplished by \nprotection bits\n associated with each frame. Normally, these bits are kept in the page table.\n\n\n\n\nOne bit can define a page to be read\u2013write or read-only.\n\n\nOne additional bit is generally attached to each entry in the page table: a valid\u2013invalid bit. (When the bit is set to invalid, the page is not in the process\u2019s logical address space).\n\n\n\n\nShared Pages\n\n\nAn advantage of paging is the possibility of \nsharing\n common code. \n\n\nReentrant code is non-self-modifying code: it never changes during execution. If the code is reentrant code, it can be shared.\n\n\n\n\nTwo or more processes can execute the same code at the same time. \n\n\nEach process has its \nown\n copy of registers and data storage to hold the data for the process\u2019s execution.\n\n\nThe shared libraries are typically implemented with shared pages.\n\n\nSome operating systems implement \nshared memory\n using shared pages.\n\n\n\n\nExample: Sharing of standard C library in a paging environment.\n\n\n\n\n4 Structure of the Page Table\n\n\nHierarchical Paging\n\n\nProblem: Most modern computer systems support a large logical address space \n2^{32}-2^{64}\n2^{32}-2^{64}\n. In such an environment, the page table itself becomes excessively large.\n\n\nSOLUTION: \nHierarchical Paging\n(\u5c42\u6b21\u5316\u5206\u9875) uses \nmulti-level\n tables which break up the virtual address into multiple parts.\n\n\nThe simplest way is to use a \ntwo-level paging\n algorithm, in which the page table itself is also paged.\n\n\n\n\n\n\nFor a system with a 64-bit logical address space, a two-level paging scheme is no longer appropriate. \n\n\n\n\nSo we can page the outer page table, giving us a \nthree-level paging\n scheme. \n\n\nBut the outer page table is still large in size. \n\n\nThe next step would be a \nfour-level paging\n scheme, where the second-level outer page table itself is also paged, and so forth.\n\n\nFor 64-bit architectures, hierarchical page tables are generally considered inappropriate.\n\n\n\n\nHashed Page Tables\n\n\nOne approach for handling address spaces larger than 32 bits is to use a \nhashed page table\n(\u54c8\u5e0c\u9875\u8868), with the hash value being the virtual page number.\n\n\nEach entry in the hash table contains a linked list of elements that hash to the same location (to handle collisions). Each element consists of three fields: \n\n\n\n\nthe virtual page number\n\n\nthe value of the mapped page frame\n\n\na pointer to the next element in the linked list.\n\n\n\n\nThe algorithm works as follows:\n\n\n\n\nThe virtual page number in the virtual address is hashed into the hash table. \n\n\nThe virtual page number is compared with field 1 in the first element in the linked list. \n\n\nIf there is a match, the corresponding page frame (field 2) is used to form the desired physical address. \n\n\nIf there is no match, subsequent entries in the linked list are searched for a matching virtual page number.\n\n\n\n\n\n\nClustered page tables\n, which are similar to hashed page tables except that each entry in the hash table refers to several pages (such as 16) rather than a single page. It is particularly useful for sparse address spaces, where memory references are noncontiguous and scattered throughout the address space.\n\n\nInverted Page Tables\n\n\nProblem: One of the drawbacks of methods above is that each page table may consist of millions of entries. These tables may consume large amounts of physical memory just to keep track of how other physical memory is being used.\n\n\nSOLUTION: An \ninverted page table\n(\u53cd\u5411\u9875\u8868) has one entry for each real page (or frame) of memory.\n\n\n\n\nEach entry consists of the virtual address of the page stored in that real memory location, with information about the process that owns the page.\n\n\nOnly one page table is in the system, and it has only one entry for each page of physical memory.\n\n\n\n\n\n\nDISADVANTAGE: It increases the amount of time needed to search the table when a page reference occurs.\n\n\n5 Swapping\n\n\nA process, or a portion of a process, can be swapped temporarily out of memory to a backing store and then brought back into memory for continued execution. (The backing store is commonly fast secondary storage.)\n\n\nSwapping makes it possible for the total physical address space of all processes to \nexceed\n the real physical memory of the system, thus increasing the degree of multiprogramming in a system.\n\n\nStandard Swapping\n\n\nStandard swapping involves moving \nentire\n processes between main memory and a backing store.\n\n\n\n\nFor a multithreaded process, all per-thread data structures must be swapped as well.\n\n\nThe advantage of standard swapping is that it allows physical memory to be \noversubscribed\n, so that the system can accommodate more processes than there is actual physical memory to store them.\n\n\nIdle or mostly idle processes are good candidates for swapping.\n\n\n\n\n\n\nSwapping with paging\n\n\nISSUE: For standard swapping, the amount of time required to move entire processes between memory and the backing store is prohibitive. It was used in traditional UNIX systems, but it is generally no longer used in contemporary operating systems.\n\n\nSOLUTION: Most systems, including Linux and Windows, use a variation of swapping in which \npages\n of a process\u2014rather than an \nentire process\n \u2014can be swapped.\n\n\n\n\nA \npage out\n operation moves a page from memory to the backing store; the reverse process is known as a \npage in\n.\n\n\n\n\n\n\nSwapping on Mobile Systems\n\n\nISSUE: In contrast, mobile systems typically do \nnot\n support swapping in any form.\n\n\n\n\nSpace constraint: Mobile devices generally use flash memory rather than more spacious hard disks for nonvolatile storage.\n\n\nOther reasons include the limited number of writes that flash memory can tolerate before it becomes unreliable and the poor throughput between main memory and flash memory in these devices.\n\n\n\n\nSOLUTION: Instead of using swapping, when free memory falls below a certain threshold, Apple\u2019s iOS asks applications to voluntarily \nrelinquish\n allocated memory. Any applications that fail to free up sufficient memory may be terminated by the operating system.\n\n\n6 Example: Intel 64-bit Architectures\n\n\nCore i7 Memory System", 
            "title": "Chapter 9: Main Memory"
        }, 
        {
            "location": "/osc/ch9/#operating-system-concepts-9-main-memory", 
            "text": "", 
            "title": "Operating System Concepts 9 - Main Memory"
        }, 
        {
            "location": "/osc/ch9/#1-background", 
            "text": "", 
            "title": "1 Background"
        }, 
        {
            "location": "/osc/ch9/#basic-hardware", 
            "text": "Main memory and the registers built into each processing core are the only general-purpose storage that the CPU can access directly.  Registers that are built into each CPU core are generally accessible within one cycle of the CPU clock. Completing a memory access may take hundreds cycles of the CPU clock. In such cases, the processor normally needs to stall. The remedy is to add cache between the CPU and main memory for fast access.  Table. Approximate timing for various operations on a typical PC     operations  approximate timing      execute typical instruction  1/1,000,000,000 sec = 1 nanosec    fetch from L1 cache memory  0.5 nanosec    branch misprediction  5 nanosec    fetch from L2 cache memory  7 nanosec    Mutex lock/unlock  25 nanosec    fetch from main memory  100 nanosec    send 2K bytes over 1Gbps network  20,000 nanosec    read 1MB sequentially from memory  250,000 nanosec    fetch from new disk location (seek)  8,000,000 nanosec    read 1MB sequentially from disk  20,000,000 nanosec    send packet US to Europe and back  150 milliseconds = 150,000,000 nanosec     We also must protect the operating system from access by user processes, as well as protect user processes from one another.   This protection must be provided by the hardware, because the operating system doesn't usually intervene between the CPU and its memory access.  Hardware implements this production in several different ways.   We first need to make sure that each process have a separate memory space.   Separate per-process memory space protects the processes from each other and is fundamental to having multiple processes loading in memory for concurrent execution.  To separate memory spaces, we need the ability to determine the range of legal addresses that the process may access and to ensure that the process can access only these legal addresses.  We can provide this protection by using two registers, usually a base and a limit. The  base register  holds the smallest legal physical memory address; the  limit register  specifies the size of the range.  The base and limit registers can be loaded only by the operating system, which uses a special privileged instruction.    Any attempt by a program executing in user mode to access operating-system memory or other users\u2019 memory results in a trap to the operating system, which treats the attempt as a fatal error.", 
            "title": "Basic Hardware"
        }, 
        {
            "location": "/osc/ch9/#address-binding", 
            "text": "In most cases, a user program goes through several steps. Addresses may be represented in different ways during these steps.   Addresses in the source program are generally symbolic(\u7b26\u53f7).  A compiler typically  binds  these symbolic addresses to relocatable addresses(\u53ef\u91cd\u5b9a\u4f4d\u5730\u5740).  The linker or loader  binds  the relocatable addresses to absolute addresses(\u7edd\u5bf9\u5730\u5740)\u3002", 
            "title": "Address Binding"
        }, 
        {
            "location": "/osc/ch9/#logical-versus-physical-address-space", 
            "text": "An address generated by the CPU is commonly referred to as a  logical address (\u903b\u8f91\u5730\u5740), whereas an address loaded into  memory-address register  (MAR) of the memory is commonly referred to as a  physical address (\u7269\u7406\u5730\u5740).   We usually refer to the logical address as a  virtual address (\u865a\u62df\u5730\u5740).  The run-time mapping from virtual to physical addresses is done by a hardware device called the  memory-management unit  (MMU\uff0c\u5185\u5b58\u7ba1\u7406\u5355\u5143).    Note  Program counter  points to the next instruction to be fetched/executed , whereas  memory address register  points to the memory location that contains data required (not an instruction).[ ref ]", 
            "title": "Logical Versus Physical Address Space"
        }, 
        {
            "location": "/osc/ch9/#dynamic-loading", 
            "text": "With  dynamic loading (\u52a8\u6001\u52a0\u8f7d), a routine is not loaded until it is called.   All routines are kept on disk in a relocatable load format.    The main program is loaded into memory and is executed. When a routine needs to call another routine, the calling routine first checks to see whether the other routine has been loaded. If it has not, the relocatable linking loader is called to load the desired routine into memory and to update the program\u2019s address tables to reflect this change. Then control is passed to the newly loaded routine.    The advantage of dynamic loading is that a routine is loaded only when it is needed.   This method is particularly useful when  large  amounts of code are needed to handle  infrequently  occurring cases, such as error routines.   A simple example:  void   * hndl   =   dlopen ( libnewshapes.so ,   RTLD_NOW );  if ( hndl   ==   NULL ){ \n    cerr     dlerror ()     endl ; \n    exit ( - 1 );  }  void   * mkr   =   dlsym ( hndl ,   maker );", 
            "title": "Dynamic Loading"
        }, 
        {
            "location": "/osc/ch9/#dynamic-linking-and-shared-libraries", 
            "text": "Dynamically linked libraries (DLLs\uff0c\u52a8\u6001\u94fe\u63a5\u5e93) are system libraries that are linked to user programs when the programs are run  Detailed information in CSAPP", 
            "title": "Dynamic Linking and Shared Libraries"
        }, 
        {
            "location": "/osc/ch9/#2-contiguous-memory-allocation", 
            "text": "In order to accommodate both the operating system and the various user processes, allocating main memory are needed to be in the most efficient way. In  Contiguous memory allocation (\u8fde\u7eed\u5185\u5b58\u5206\u914d),  one  early  method, each process is contained in a single section of memory that is contiguous to the section containing the next process  .  The memory is usually divided into two partitions: one for the operating system and one for the user processes.    We can place the operating system in either low memory addresses or high memory addresses.  Many operating system(including Linux and windows) place the operating system in high memory.", 
            "title": "2 Contiguous Memory Allocation"
        }, 
        {
            "location": "/osc/ch9/#memory-protection", 
            "text": "Relocation register (\u91cd\u5b9a\u4f4d\u5bc4\u5b58\u5668) and limit register (\u754c\u9650\u5730\u5740\u5bc4\u5b58\u5668) are used to prevent a process from accessing memory that it does not own.   The relocation register contains the value of the smallest physical address.  The limit register contains the range of logical addresses.  Each logical address must fall within the range specified by the limit register.  The MMU maps the logical address dynamically by adding the value in the relocation register.", 
            "title": "Memory Protection"
        }, 
        {
            "location": "/osc/ch9/#memory-allocation", 
            "text": "One of the simplest methods of allocating memory is to assign processes to variably sized partitions in memory, where each partition may contain  exactly one  process.   The operating system keeps a table indicating which parts of memory are available and which are occupied.  A block of available memory is a  hole (\u5b54).  When a process arrives and needs memory, the system searches for a hole that is large enough for this process.    Placement policy (\u653e\u7f6e\u7b56\u7565)\uff1aSeveral Ways to satisfy a request of size  n n  from a list of free holes.   First fit (\u9996\u6b21\u9002\u914d). Allocate the first hole that is big enough.  Best fit (\u6700\u4f73\u9002\u914d). Allocate the smallest hole that is big enough.  Worst fit (\u6700\u5dee\u9002\u914d). Allocate the largest hole.   Both first fit and best fit are better than worst fit in terms of decreasing time and storage utilization. Neither first fit nor best fit is clearly better than the other in terms of storage utilization, but first fit is generally faster.", 
            "title": "Memory Allocation"
        }, 
        {
            "location": "/osc/ch9/#fragmentation", 
            "text": "External fragmentation (\u5916\u90e8\u788e\u7247) exists when there is enough total memory space to satisfy a request but the available spaces are not contiguous: storage is fragmented into a large number of small holes.   One solution is  compaction \uff0cwhich shuffles the memory contents so as to place all free memory together in one large block.  Another solution is to permit the logical address space of processes to be noncontiguous, thus allowing a process to be allocated physical memory wherever such memory is available.(  paging , \u5206\u9875, the most common memory-management technique for computer systems).   Internal fragmentation (\u5185\u90e8\u788e\u7247) occurs when unused memory is internal to a partition, because of allocating memory in units based on block size.   The memory must be partitioned into variable sized blocks and assign the best fit block to the process.", 
            "title": "Fragmentation"
        }, 
        {
            "location": "/osc/ch9/#3-paging", 
            "text": "Paging (\u5206\u9875), is a memory management scheme that permits a process's physical address space to be non-contiguous. Paging avoids external fragmentation and the associated need for compaction.", 
            "title": "3 Paging"
        }, 
        {
            "location": "/osc/ch9/#basic-method", 
            "text": "The basic method for implementing paging involves breaking physical memory info fixed-sized blocks called  frames (\u5e27, also physical page), and breaking logical memory into blocks of the same size called  pages (\u9875, also virtual page).   The backing store is divided into fixed-sized blocks that are the same size as the memory frames or clusters of multiple frames.   Every address generated by the CPU is divided into two parts: a  page number (p, \u9875\u53f7) and a  page offset (d, \u9875\u504f\u79fb)\u3002   The page number is used as an index into a per-process  page table .  Page table  contains the base address of each frame in physical memory and the offset is the location in the frame being referenced.  The base address of the frame is combined with the page offset to define the physical memory address.    The MMU translates a logical address generated by the CPU to a physical address by:   Extract the page number  p p  and use it as an index into the page table.  Extract the corresponding frame number  f f  from the page table.  Replace the page number  p p  in the logical address with the frame number  f f .   The page size is defined by the hardware, typically a power of 2. If the size of logical address space is $2^m $, and a page size is $2^n  $ bytes, then the high-order  m-n m-n  bits of a logical address designate the page number, and the  n n  low-order bits designate the page offset.  Internal fragmentation still exists\uff1a   If process size is independent of page size, we expect internal fragmentation to average one-half page per process.  This consideration suggests that small page sizes are desirable.  However, overhead is involved in each page table entry, and this overhead is reduced as the size of the pages increases.  Also, disk I/O is more efficient when the amount of data being transferred is larger", 
            "title": "Basic Method"
        }, 
        {
            "location": "/osc/ch9/#hardware-suport", 
            "text": "The hardware implementation of the page table can be done in several ways.   In the simplest case, the page table is implemented as a set of dedicated high-speed hardware registers.  It makes the page-address translation very efficient.  It increases context-switch time, as each one of these registers must be exchanged during a context switch.  The use of registers for the page table is satisfactory if the page table is reasonably small (for example, 256 entries).  It is not feasible for most contemporary CPUs, since much larger page tables needed.    For a much large page table, the page table is kept in main memory, and a  page-table base register  (PTBR, \u9875\u8868\u57fa\u5740\u5bc4\u5b58\u5668) points to the page table.   ISSUE: Although storing the page table in main memory can yield faster context switches, it may also result in slower memory access times. Because using page-table to find a physical address need one memory access, since the page-table is kept in main memory.  SOLUTION: To use a special, small, fast-lookup hardware  cache  called a  translation look-aside buffer (TLB, \u8f6c\u8bd1\u540e\u5907\u7f13\u51b2\u5668).   Each entry in the TLB consists of two parts: a key(tag) and a value.  When the associative memory is presented with an item, the item is compared with all keys  simultaneously . If the item is found, the corresponding value field is returned.  TLB is kept small, typically between 32 and 1,024 entries in size.    CPUs today may provide  multiple  levels of TLBs. We take the Intel Core i7 as an example [ see detail here ]:   The Intel Core i7 CPU has a 128-entry L1 instruction TLB and a 64-entry L1 data TLB.   In the case of a miss at L1, it takes the CPU six cycles to check for the entry in the L2 512-entry TLB.   A miss in L2 means that the CPU must either walk through the page-table entries in memory to find the associated frame address, which can take hundreds of cycles, or interrupt to the operating system to have it do the work.", 
            "title": "Hardware Suport"
        }, 
        {
            "location": "/osc/ch9/#protection", 
            "text": "Memory protection in a paged environment is accomplished by  protection bits  associated with each frame. Normally, these bits are kept in the page table.   One bit can define a page to be read\u2013write or read-only.  One additional bit is generally attached to each entry in the page table: a valid\u2013invalid bit. (When the bit is set to invalid, the page is not in the process\u2019s logical address space).", 
            "title": "Protection"
        }, 
        {
            "location": "/osc/ch9/#shared-pages", 
            "text": "An advantage of paging is the possibility of  sharing  common code.   Reentrant code is non-self-modifying code: it never changes during execution. If the code is reentrant code, it can be shared.   Two or more processes can execute the same code at the same time.   Each process has its  own  copy of registers and data storage to hold the data for the process\u2019s execution.  The shared libraries are typically implemented with shared pages.  Some operating systems implement  shared memory  using shared pages.   Example: Sharing of standard C library in a paging environment.", 
            "title": "Shared Pages"
        }, 
        {
            "location": "/osc/ch9/#4-structure-of-the-page-table", 
            "text": "", 
            "title": "4 Structure of the Page Table"
        }, 
        {
            "location": "/osc/ch9/#hierarchical-paging", 
            "text": "Problem: Most modern computer systems support a large logical address space  2^{32}-2^{64} 2^{32}-2^{64} . In such an environment, the page table itself becomes excessively large.  SOLUTION:  Hierarchical Paging (\u5c42\u6b21\u5316\u5206\u9875) uses  multi-level  tables which break up the virtual address into multiple parts.  The simplest way is to use a  two-level paging  algorithm, in which the page table itself is also paged.    For a system with a 64-bit logical address space, a two-level paging scheme is no longer appropriate.    So we can page the outer page table, giving us a  three-level paging  scheme.   But the outer page table is still large in size.   The next step would be a  four-level paging  scheme, where the second-level outer page table itself is also paged, and so forth.  For 64-bit architectures, hierarchical page tables are generally considered inappropriate.", 
            "title": "Hierarchical Paging"
        }, 
        {
            "location": "/osc/ch9/#hashed-page-tables", 
            "text": "One approach for handling address spaces larger than 32 bits is to use a  hashed page table (\u54c8\u5e0c\u9875\u8868), with the hash value being the virtual page number.  Each entry in the hash table contains a linked list of elements that hash to the same location (to handle collisions). Each element consists of three fields:    the virtual page number  the value of the mapped page frame  a pointer to the next element in the linked list.   The algorithm works as follows:   The virtual page number in the virtual address is hashed into the hash table.   The virtual page number is compared with field 1 in the first element in the linked list.   If there is a match, the corresponding page frame (field 2) is used to form the desired physical address.   If there is no match, subsequent entries in the linked list are searched for a matching virtual page number.    Clustered page tables , which are similar to hashed page tables except that each entry in the hash table refers to several pages (such as 16) rather than a single page. It is particularly useful for sparse address spaces, where memory references are noncontiguous and scattered throughout the address space.", 
            "title": "Hashed Page Tables"
        }, 
        {
            "location": "/osc/ch9/#inverted-page-tables", 
            "text": "Problem: One of the drawbacks of methods above is that each page table may consist of millions of entries. These tables may consume large amounts of physical memory just to keep track of how other physical memory is being used.  SOLUTION: An  inverted page table (\u53cd\u5411\u9875\u8868) has one entry for each real page (or frame) of memory.   Each entry consists of the virtual address of the page stored in that real memory location, with information about the process that owns the page.  Only one page table is in the system, and it has only one entry for each page of physical memory.    DISADVANTAGE: It increases the amount of time needed to search the table when a page reference occurs.", 
            "title": "Inverted Page Tables"
        }, 
        {
            "location": "/osc/ch9/#5-swapping", 
            "text": "A process, or a portion of a process, can be swapped temporarily out of memory to a backing store and then brought back into memory for continued execution. (The backing store is commonly fast secondary storage.)  Swapping makes it possible for the total physical address space of all processes to  exceed  the real physical memory of the system, thus increasing the degree of multiprogramming in a system.", 
            "title": "5 Swapping"
        }, 
        {
            "location": "/osc/ch9/#standard-swapping", 
            "text": "Standard swapping involves moving  entire  processes between main memory and a backing store.   For a multithreaded process, all per-thread data structures must be swapped as well.  The advantage of standard swapping is that it allows physical memory to be  oversubscribed , so that the system can accommodate more processes than there is actual physical memory to store them.  Idle or mostly idle processes are good candidates for swapping.", 
            "title": "Standard Swapping"
        }, 
        {
            "location": "/osc/ch9/#swapping-with-paging", 
            "text": "ISSUE: For standard swapping, the amount of time required to move entire processes between memory and the backing store is prohibitive. It was used in traditional UNIX systems, but it is generally no longer used in contemporary operating systems.  SOLUTION: Most systems, including Linux and Windows, use a variation of swapping in which  pages  of a process\u2014rather than an  entire process  \u2014can be swapped.   A  page out  operation moves a page from memory to the backing store; the reverse process is known as a  page in .", 
            "title": "Swapping with paging"
        }, 
        {
            "location": "/osc/ch9/#swapping-on-mobile-systems", 
            "text": "ISSUE: In contrast, mobile systems typically do  not  support swapping in any form.   Space constraint: Mobile devices generally use flash memory rather than more spacious hard disks for nonvolatile storage.  Other reasons include the limited number of writes that flash memory can tolerate before it becomes unreliable and the poor throughput between main memory and flash memory in these devices.   SOLUTION: Instead of using swapping, when free memory falls below a certain threshold, Apple\u2019s iOS asks applications to voluntarily  relinquish  allocated memory. Any applications that fail to free up sufficient memory may be terminated by the operating system.", 
            "title": "Swapping on Mobile Systems"
        }, 
        {
            "location": "/osc/ch9/#6-example-intel-64-bit-architectures", 
            "text": "Core i7 Memory System", 
            "title": "6 Example: Intel 64-bit Architectures"
        }, 
        {
            "location": "/osc/ch10/", 
            "text": "Operating System Concepts 10 - Virtual Memory\n\n\n1 Background\n\n\nVarious memory-management strategies discussed in \nChapter 9\n have the same goal to keep many processes in memory  simultaneously to allow multiprogramming.\n\n\nPROBLEM: However, they tend to require that an entire process be in memory before it can execute.  In many cases, the entire program is not needed:\n\n\n\n\nPrograms often have code to handle unusual error conditions. This code is almost never executed.\n\n\nArrays, lists, and tables are often allocated more memory than they actually needed.\n\n\nCertain options and features of a program may be used rarely.\n\n\n\n\nSOLUTION: Virtual memory allows the execution of processes that are not completely in memory.\n\n\nADVANTAGE:\n\n\n\n\nPrograms can be larger than physical memory.\n\n\nVirtual memory abstracts main memory as viewed by the programmer from physical memory. It frees programmers from the concerns of memory-storage limitations.\n\n\nVirtual memory allows processes to share files and memory through \npage sharing\n.\n\n\n\n\n\n\n2 Demand Paging\n\n\nQUESTION: How an executable program might be loaded from secondary storage into memory?\n\n\nOPTION: One option is to load the \nentire\n program in physical memory at program execution time.\n\n\nPROBLEM: We may not initially \nneed\n the entire program in memory. (e.g. a program starts with a list of available options from which the user is to select).\n\n\nSOLUTION: \nDemand paging\n(\u6309\u9700\u8c03\u9875) loads pages in memory only when they are needed.\n\n\n\n\nNote\n\n\nA demand-paging system is similar to a paging system with \nswapping\n where processes reside in secondary memory.\n\n\n\n\nBasic Concepts\n\n\nSince demand paging loads pages in memory only when they are needed, some pages will be in memory and some will be in secondary storage. \nThus, we need some form of hardware support to distinguish between the two.\n\n\nThe valid bit is set to ensure that the page is in the logical address space of the process and is currently in secondary storage. Access to a page marked invalid causes a \npage fault\n(\u7f3a\u9875).\n\n\nThe procedure for handling this page fault is straightforward:\n\n\n\n\nWe check page tables (usually kept with the process control block) for this process to determine whether the reference was a valid or an invalid memory access.\n\n\nIf the reference was invalid, we terminate the process. If it was valid but we have not yet brought in that page, we now page it in.\n\n\nWe find a free frame (by taking one from the free-frame list, for example).\n\n\nWe schedule a secondary storage operation to read the desired page into the newly allocated frame.\n\n\nWhen the storage read is complete, we modify the internal table kept with the process and the page table to indicate that the page is now in memory.\n\n\nWe restart the instruction that was interrupted by the trap. The process can now access the page as though it had always been in memory.\n\n\n\n\n\n\nIn the extreme case, we can start executing a process with \nno\n pages in memory. This scheme is \npure demand paging\n: \nnever bring a page into memory until it is required\n .\n\n\nFree-Frame List\n\n\nMost operating system maintain a \nfree-frame list\n, a pool of free frames for satisfying requests, that bring the desired pages from secondary storage into main memory.\n\n\n\n\nOperating system typically allocate free frames using a technique known as \nzero-fill-on-demand\n, which \"zero-out\" frames before it is allocated (i.e. \nerasing\n previous contents). \n\n\nPerformance of Demand Paging\n\n\nLet \np(0\\le p \\le 1)\np(0\\le p \\le 1)\n be \npage-fault rage\n(\u7f3a\u9875\u7387), the probability of a page fault. We would expect \np\np\n to be close to zero. The effective access time, is \n\n\n\n\n\\text{effective access time} = (1-p)\\times ma + p\\times \\text{page fault time}\n\n\n\\text{effective access time} = (1-p)\\times ma + p\\times \\text{page fault time}\n\n\n\n\nwhere \nma\nma\n denotes the memory-access time.\n\n\nWith an average page-fault service time of 8 milliseconds and a memory access time of 200 nanoseconds, the effective access time in nanoseconds is \n200+7,999,800\\times p\n200+7,999,800\\times p\n. The effective access time is \ndirectly proportional\n to the page-fault rate \np\np\n, so it is important to keep the page-fault rate \nlow\n in a demand-paging system.\n\n\nAn additional aspect of demand paging is the handling and overall use of swap space. \n\n\n\n\nI/O to swap space is generally faster than that to the file system, because swap space is allocated in much larger blocks, and file lookups an indirect allocation methods are not used (\nsee details in Chapter 11\n).\n\n\nOne OPTION: copying an entire file image into the swap space at process startup and then performing demand paging from the swap space.\n\n\nSecond OPTION: practiced by several operating system, including Linux and Windows \u2014\u2014\u2014 to demand-page from the file system initially but to write the pages to swap space as they are replaced.\n\n\n\n\nMobile operating system typically do not support swapping [\nChapter 9\n]. Instead, these systems demand-page from the file system and reclaim read-only pages (such as code) from applications if memory becomes constrained.\n\n\n3 Copy-on-Write\n\n\nCopy-on-write\n(\u5199\u65f6\u590d\u5236) works by allowing the parent and child processes initially to share the same pages, and if either process writes to a shared page, a copy of the shared page is created.\n\n\n\n\n4 Page Replacement\n\n\nWhen we increase degree of multiprogramming, over-allocating of memory results in page faults. The operating system determines where the desired page is residing on secondary storage but to find that there are \nno\n free frames on the free-frame list (i.e. all memory is in use).\n\n\nMost operating systems now combine swapping pages with \npage replacement\n(\u9875\u9762\u7f6e\u6362).\n\n\nBasic Page Replacement\n\n\nIf no frame is free, we find one that is not currently being used and free it. When we select a page for replacement, We examine its \nmodify bit\n (or \ndirty bit\n, see \nExample of Core i7\n).\n\n\n\n\nThe modify bit for a page is set by the hardware whenever any byte in the page is written into, indicating that the page has been modified.\n\n\nIf the bit is set, we must write the page to storage. Otherwise, we need not write the memory page to storage: it is already there.\n\n\n\n\nWe must solve two major problems to implement demand paging:\n\n\n\n\nframe-allocation algorithm\n: decide how many frames allocate to each process\n\n\npage-replacement algorithm\n: select the frames that are to be replaced. In general, we want the one with the lowest page-fault rate.\n\n\n\n\nFIFO Page Replacement\n\n\nThe simplest page-replacement algorithm is a first-in, first-out(FIFO) algorithm. \n\n\n\n\nWe can create a FIFO queue to hold all pages in memory. \n\n\nWe replace the page at the head of the queue. \n\n\nWhen a page is brought into memory, we insert it at the tail of the queue.\n\n\n\n\n\n\nDISADVANTAGE: Its performance is not \nalways\n good.\n\n\nBelady\u2019s anomaly\n: for some page-replacement algorithms, the page-fault rate may increase as the number of allocated frames increases.\n\n\nFigure below shows the curve of page faults for the reference string \n1,2,3,4,1,2,5,1,2,3,4,5\n versus the number of available frames, with a FIFO page-replacement algorithm.\n\n\n\n\nOptimal Page Replacement, OPT\n\n\nOptimal page-replacement\n(OPT, \u6700\u4f73\u9875\u9762\u7f6e\u6362) algorithm replaces the page that \nwill not be used for the longest period of time\n.\n\n\n\n\n\n\nIt has the \nlowest\n page-fault rate of all algorithms.\n\n\nIt will never suffer from Belady's anomaly.\n\n\nIt is different to implement, because it requires future knowledge of the reference string.\n\n\nIt is used mainly for comparison studies.\n\n\n\n\nLRU Page Replacement, LRU\n\n\nLeast recently used\n(LRU, \u6700\u8fd1\u6700\u5c11\u4f7f\u7528) algorithm chooses the page that has not been used for the longest period of time.\n\n\n\n\n\n\nWe can think of this strategy as the optimal page-replacement algorithm looking backward in time. ( If we let \nS^R\nS^R\n be the reverse of a reference string \nS\nS\n, then the page-fault rate for the OPT algorithm on \nS\nS\n is the same as the page-fault rate of OPT algorithm on \nS^R\nS^R\n). \n\n\nThe LRU policy is \noften\n used as a page-replacement algorithm and is considered to be good.\n\n\nBest way to implement LRU replacement with a stack of page numbers is using a doubly linked list with a head pointer and a tail pointer.\n\n\n\n\n\n\nNote\n\n\nImplementation of LRU would be not conceivable without hardware assistance beyond the standard TLB registers. The updating of stack must be done for every memory reference.\n\n\nIf we were to use an interrupt for every reference to allow software to update such data structures, it would slow every memory reference by a factor of at least ten, hence slowing every process by a factor of ten. Few systems could tolerate that level of overhead for memory management.\n\n\n\n\nLRU-Approximation Page Replacement\n\n\nIn fact, some systems provide no hardware support, using the form of a reference bit instead. The \nreference bit\n for a page is set by the hardware whenever that page is referenced(either a \nread\n or a \nwrite\n to any byte in the page).\n\n\nAdditional-Reference-Bits Algorithm\n\n\nWe can gain additional ordering information by recording the reference bits at regular intervals. \n\n\n\n\nWe can keep an 8-bit byte for each page in a table in memory. \n\n\nAt regular intervals (say, every 100 milliseconds), a timer interrupt transfers control to the operating system. \n\n\nThe operating system shifts the reference bit for each page into the high-order bit of its 8-bit byte, shifting the other bits right by 1 bit and discarding the low-order bit.\n\n\nThese 8-bit shift registers contain the history of page use for the last eight time periods.\n\n\nIf we interpret these 8-bit bytes as unsigned integers, the page with the lowest number is the LRU page, and it can be replaced.\n\n\n\n\nSecond-Chance Algorithm\n\n\nThe number of bits of history included in the shift register can be varied, the number can be reduced to zero, leaving only the reference bit itself.\n\n\n\n\nWhen a page has been selected, we inspect its reference bit. \n\n\nIf the value is 0, we proceed to replace this page; but if the reference bit is set to 1, we give the page a second chance and move on to select the next FIFO page.\n\n\nWhen a page gets a second chance, its reference bit is cleared, and its arrival time is reset to the current time. \n\n\nThus, a page that is given a second chance will not be replaced until all other pages have been replaced (or given second chances). I\n\n\nn addition, if a page is used often enough to keep its reference bit set, it will never be replaced.\n\n\n\n\nOne way to implement the second-chance algorithm (sometimes referred to as the clock algorithm) is as a circular queue.\n\n\n\n\nA pointer (that is, a hand on the clock) indicates which page is to be replaced next. \n\n\nWhen a frame is needed, the pointer advances until it finds a page with a 0 reference bit. \n\n\nAs it advances, it clears the reference bits. \n\n\nOnce a victim page is found, the page is replaced, and the new page is inserted in the circular queue in that position.\n\n\n\n\n\n\nA simple example is illustrated by the figure below, in which small blue digits denotes the reference bit and green arrow denotes the pointer.\n\n\n\n\n5 Allocation of Frames\n\n\nMinimum Number of Frames\n\n\nWe must allocate at least a minimum  number of frames.\n\n\n\n\nOne reason is performance. Obviously, as the number of frames allocated to each process decreases, the page-fault rate increases.\n\n\nAnother reason is that when a page fault occurs before an executing instruction complete, the instruction must be restarted. So we must have enough frames to hold all the different pages that any single instruction can reference.\n\n\n\n\nThe minimum number of frames is defined by the computer architecture.\n\n\nAllocation Algorithms\n\n\nEqual Allocation\n\n\nThe easiest way to split \nm\nm\n frames among \nn\nn\n processes is to give everyone an equal share, \nm/n\nm/n\n frames (ignoring frames needed by the operating system for the moment).\n\n\nProportional Allocation\n\n\nIn proportional allocation, we allocate available memory to each process according to its size. Let the size of the virtual memory for process \np_i\np_i\n be \ns_i\ns_i\n , and define \nS=\\sum s_i\nS=\\sum s_i\n. Then, if the total number of available frames is \nm\nm\n, we allocate \na_i\na_i\n frames to process \np_i\np_i\n , where \na_i\na_i\n is approximately \na_i=s_i/S\\times m\na_i=s_i/S\\times m\n.\n\n\nGlobal versus Local Allocation\n\n\nGlobal replacement\n allows a process to select a replacement frame from the set of \nall\n frames, even if that frame is currently allocated to some other process; that is, one process can take a frame from another. \n\n\nLocal replacement\n requires that each process select from only \nits own\n set of allocated frames.\n\n\nLocal replacement might \nhinder\n a process, however, by not making available to it other, less used pages of memory. Thus, global replacement generally results in \ngreater\n system throughput. It is therefore the more commonly used method.\n\n\nGlobal Page-Replacement Policy\n\n\nRather than waiting for the free-frame list to drop to zero before we begin selecting pages for replacement, we trigger page replacement when the list \nfalls below a certain threshold\n.\n\n\n\n\nIt attempts to ensure there is \nalways sufficient free\n memory to satisfy new requests.\n\n\nWhen the amount of free memory drops below minimum threshold, a kernel routine (\nreapers\n) is triggered that begins reclaiming pages from all processes in the system.\n\n\nWhen the amount of free memory reaches the maximum threshold, the reaper routine is suspended.\n\n\nThe kernel reaper routine typically uses some form of LRU approximation.\n\n\n\n\n\n\n6 Thrashing\n\n\nCause of Thrashing\n\n\nThrashing may be caused by programs or workloads that present insufficient \nlocality of reference\n(also principle of locality, \u8bbf\u95ee\u5c40\u90e8\u6027): if the \nworking set\n(\u5de5\u4f5c\u96c6) of a program or a workload cannot be effectively held within physical memory, then constant data swapping, i.e., thrashing, may occur.\n\n\nConsider the following scenario, which is based on the actual behavior of early paging systems.\n\n\n\n\nThe operating system monitors CPU utilization. \n\n\nIf CPU utilizition is too low, we increase the degree of multiprogramming by introducing a new process to the system. \n\n\nA global page-replacement algorithm is used; it replaces pages without regard to the process to which they belong. \n\n\nNow suppose that a process enters a new phase in its execution and needs more frames. It starts faulting and taking frames away from other processes. \n\n\nThese processes need those pages, however, and so they also fault, taking frames from other processes. \n\n\nThese faulting processes must use the paging device to swap pages in and out. As they queue up for the paging device, the ready queue empties. As processes wait for the paging device, CPU utilization decreases.\n\n\nThe CPU scheduler sees the decreasing CPU utilization and increases the degree of multiprogramming as a result. \n\n\nThe new process tries to get started by taking frames from running processes, causing more page faults and a longer queue for the paging device. \n\n\nAs a result, CPU utilization drops even further, and the CPU scheduler tries to increase the degree of multiprogramming even more. Thrashing has occurred, and system throughput plunges. \n\n\n\n\n\n\nQUESTION: To prevent thrashing, we must provide a process with as many frames as it needs. But how do we know how many frames it \"needs\"? \n\n\nThe \nlocality model\n of process execution, states that, as a process executes, it moves from locality to locality.\n\n\n\n\nA \nlocality\n is a set of pages that are actively used together.\n\n\nA running program is generally composed of several different localities, which may overlap.\n\n\nIf we do not allocate enough frames to accommodate the size of the current locality, the process will thrash, since it cannot keep in memory all the pages that it is actively using.\n\n\n\n\n\n\nExample\n\n\nFigure below illustrates the concept of locality and how a process\u2019s locality changes over time. At time (a), the locality is the set of pages {18, 19, 20, 21, 22, 23, 24, 29, 30, 33}. At time (b), the locality changes to {18, 19, 20, 24, 25, 26, 27, 28, 29, 31, 32, 33}. Notice the overlap, as some pages (for example, 18, 19, and 20) are part of both localities.\n\n\n\n\n\n\nWorking-Set Model\n\n\nThe group of physical memory pages currently dedicated to a specific process is known as the \nWorking set\n(WS, \u5de5\u4f5c\u96c6) for that process. \n\n\n\n\nExample\n\n\nFor example, the working set at time \nt_1\nt_1\n is {1, 2, 5, 6, 7}. By time \nt_2\nt_2\n , the working set has changed to {3, 4}.\n\n\n\n\n\n\nIf we compute the working-set size \nWSS_i\nWSS_i\n for each process in the system, the total demand for frames \nD\nD\n is \nD=\\sum WSS_i\nD=\\sum WSS_i\n.\n\n\nIf the total demand \nD\nD\n is greater than the total number of available frames (\nD\\gt m\nD\\gt m\n), thrashing will occur, because some processes will not have enough frames.\n\n\nWORKING SET SOLUTION TO THRASHING: \n\n\n\n\nThe operating system monitors the working set of each process and allocates to that working set enough frames to provide it with its working-set size. \n\n\nIf there are enough extra frames, another process can be initiated.\n\n\nIf the sum of the working-set sizes increases, exceeding the total number of available frames, the operating system selects a process to suspend. \n\n\nThe process\u2019s pages are written out (swapped), and its frames are reallocated to other processes. The suspended process can be restarted later.\n\n\n\n\nPage-Fault Frequency\n\n\nThe working-set model is successful but seems a clumsy way to control thrashing.\n\n\nA strategy that uses the \npage-fault frequency\n(PFF) takes a more direct approach:\n\n\n\n\nThrashing has a high page-fault rate. Thus, we control the page-fault rate.\n\n\nWhen the page fault rate is too high, we know that the process needs more frames.\n\n\nConversely, if it too low, then the process may have too many frames. \n\n\n\n\n\n\nWe can establish upper and lower bounds on the desired page-fault rate.\n\n\nIf the actual page-fault rate exceeds the upper limit, we allocate the process. another frame. \n\n\nIf the page-fault rate falls below the lower limit, we remove a frame from the process.\n\n\n\n\n\n\n\n\n\n\n7 Memory Compression\n\n\nWhen the number of free frames falls below a certain threshold that would triggers page replacement, rather than paging out modified frames to swap space, we \ncompress\n several frames into a single frame (\nmemory compression\n, \u5185\u5b58\u538b\u7f29), enabling the system to reduce memory usage without resorting to swapping pages.\n\n\n\n\nExample\n\n\nFor example, the free-frame list contains six frames: \n7,2,9,21,27,16\n, and the modified frame list contains four frames: \n15, 3, 35, 26\n.\nIn Figure below, frame 7 is removed from the free-frame list. Frames 15, 3, and 35 are compressed and stored in frame 7, which is then stored in the list of compressed frames. The frames 15, 3, and 35 can now be moved to the free-frame list. If one of the three compressed frames is later referenced, a page fault occurs, and the compressed frame is decompressed, restoring the three pages 15, 3, and 35 in memory.\n\n\n\n\n\n8 Allocating Kernel Memory\n\n\nKernel memory is often allocated from a free-memory pool different from the list used to satisfy ordinary user-mode processes discussed before. There are two primary reasons for this:\n\n\n\n\nThe kernel requests memory for data structures of varying sizes, some of which are less than a page in size. As a result, the kernel must use memory \nconservatively\n and attempt to \nminimize waste\n due to fragmentation.\n\n\nCertain hardware devices interact directly with physical memory \u2014\u2014 without the benefit of a virtual memory interface \u2014\u2014 and consequently may require memory residing in physically \ncontiguous\n pages.\n\n\n\n\nBuddy System\n\n\nThe buddy system allocates memory from a fixed-size segment consisting of physically contiguous pages.\n\n\n\n\nMemory is allocated from this segment using a power-of-2 allocator, which satisfies requests in units sized as a power of 2 (4 KB, 8 KB, 16 KB, and so forth).\n\n\nA request in units not appropriately sized is rounded up to the next highest power of 2.\n\n\n\n\nPro and Cons:\n\n\n\n\nAn advantage of the buddy system is how quickly adjacent buddies can be combined to form larger segments using a technique known as \ncoalescing\n(illustrated below in the Example section).\n\n\nRounding up to the next highest power of 2 is very likely to cause internal fragmentation.\n\n\n\n\n\n\nExample\n\n\nAssume the size of a memory segment is initially 256 KB and the kernel requests 21 KB of memory. The segment is initially divided into two buddies\u2014which we will call \nA_L\nA_L\n and \nA_R\nA_R\n \u2014\u2014 each 128 KB in size. One of these buddies is further divided into two 64-KB buddies\u2014 \nB_L\nB_L\n and \nB_R\nB_R\n . However, the next-highest power of 2 from 21 KB is 32 KB so either \nB_L\nB_L\n or \nB_R\nB_R\n is again divided into two 32-KB buddies, \nC_L\nC_L\n and \nC_R\nC_R\n . One of these buddies is used to satisfy the 21-KB request. This scheme is illustrated in Figure below, where \nC_L\nC_L\n is the segment allocated to the 21-KB request.\n\n\n\n\nwhen the kernel releases the \nC_L\nC_L\n unit it was allocated, the system can coalesce \nC_L\nC_L\n and \nC_R\nC_R\n into a 64-KB segment. This segment, \nB_L\nB_L\n , can in turn be coalesced with its buddy \nB_R\nB_R\n to form a 128-KB segment. Ultimately, we can end up with the original 256-KB segment.\n\n\n\n\nSlab Allocations\n\n\nA second strategy for allocating kernel memory is known as \nslab allocation\n.\n\n\n\n\nA \nslab\n is made up of one or more physically contiguous pages. \n\n\nA \ncache\n consists of one or more slabs.\n\n\nEach of caches stores a different type of object. There is one cache per object type.(e.g.  a separate cache for the data structure representing process descriptors, a separate cache for file objects).\n\n\nEach \ncache\n is populated with objects that are instantiations of the kernel data structure the cache represents.(e.g. the cache representing semaphores stores instances of semaphore objects).\n\n\n\n\n\n\nExample\n\n\nLinux kernel adopted the slab allocator after Version 2.2. Each slab contains some number of objects, which are the data structures being cached. \n\n\nEach slab is in one of three states: \nfull\n, \npartial\n, or \nempty\n.\n\n\n\n\nA full slab has no free objects. (All objects in the slab are allocated.) \n\n\nAn empty slab has no allocated objects. (All objects in the slab are free.) \n\n\nA partial slab has some allocated objects and some free objects.\n\n\n\n\nWhen some part of the kernel requests a new object, the request is satisfied from a partial slab, if one exists. Otherwise, the request is satisfied from an empty slab.\n\n\n\n\n\n\nThe slab allocator provides two main benefits:\n\n\n\n\nNo\n memory is \nwasted\n due to fragmentation. Each unique kernel data structure has an associated cache, and each cache is made up of one or more slabs that are divided into chunks the size of the objects being represented.\n\n\nMemory requests can be satisfied \nquickly\n. Objects are created in advance and thus can be quickly allocated from the cache. When the kernel has finished with an object and releases it, it is marked as free and returned to its cache, thus making it immediately available for subsequent requests from the kernel.", 
            "title": "Chapter 10: Virtual Memory"
        }, 
        {
            "location": "/osc/ch10/#operating-system-concepts-10-virtual-memory", 
            "text": "", 
            "title": "Operating System Concepts 10 - Virtual Memory"
        }, 
        {
            "location": "/osc/ch10/#1-background", 
            "text": "Various memory-management strategies discussed in  Chapter 9  have the same goal to keep many processes in memory  simultaneously to allow multiprogramming.  PROBLEM: However, they tend to require that an entire process be in memory before it can execute.  In many cases, the entire program is not needed:   Programs often have code to handle unusual error conditions. This code is almost never executed.  Arrays, lists, and tables are often allocated more memory than they actually needed.  Certain options and features of a program may be used rarely.   SOLUTION: Virtual memory allows the execution of processes that are not completely in memory.  ADVANTAGE:   Programs can be larger than physical memory.  Virtual memory abstracts main memory as viewed by the programmer from physical memory. It frees programmers from the concerns of memory-storage limitations.  Virtual memory allows processes to share files and memory through  page sharing .", 
            "title": "1 Background"
        }, 
        {
            "location": "/osc/ch10/#2-demand-paging", 
            "text": "QUESTION: How an executable program might be loaded from secondary storage into memory?  OPTION: One option is to load the  entire  program in physical memory at program execution time.  PROBLEM: We may not initially  need  the entire program in memory. (e.g. a program starts with a list of available options from which the user is to select).  SOLUTION:  Demand paging (\u6309\u9700\u8c03\u9875) loads pages in memory only when they are needed.   Note  A demand-paging system is similar to a paging system with  swapping  where processes reside in secondary memory.", 
            "title": "2 Demand Paging"
        }, 
        {
            "location": "/osc/ch10/#basic-concepts", 
            "text": "Since demand paging loads pages in memory only when they are needed, some pages will be in memory and some will be in secondary storage. \nThus, we need some form of hardware support to distinguish between the two.  The valid bit is set to ensure that the page is in the logical address space of the process and is currently in secondary storage. Access to a page marked invalid causes a  page fault (\u7f3a\u9875).  The procedure for handling this page fault is straightforward:   We check page tables (usually kept with the process control block) for this process to determine whether the reference was a valid or an invalid memory access.  If the reference was invalid, we terminate the process. If it was valid but we have not yet brought in that page, we now page it in.  We find a free frame (by taking one from the free-frame list, for example).  We schedule a secondary storage operation to read the desired page into the newly allocated frame.  When the storage read is complete, we modify the internal table kept with the process and the page table to indicate that the page is now in memory.  We restart the instruction that was interrupted by the trap. The process can now access the page as though it had always been in memory.    In the extreme case, we can start executing a process with  no  pages in memory. This scheme is  pure demand paging :  never bring a page into memory until it is required  .", 
            "title": "Basic Concepts"
        }, 
        {
            "location": "/osc/ch10/#free-frame-list", 
            "text": "Most operating system maintain a  free-frame list , a pool of free frames for satisfying requests, that bring the desired pages from secondary storage into main memory.   Operating system typically allocate free frames using a technique known as  zero-fill-on-demand , which \"zero-out\" frames before it is allocated (i.e.  erasing  previous contents).", 
            "title": "Free-Frame List"
        }, 
        {
            "location": "/osc/ch10/#performance-of-demand-paging", 
            "text": "Let  p(0\\le p \\le 1) p(0\\le p \\le 1)  be  page-fault rage (\u7f3a\u9875\u7387), the probability of a page fault. We would expect  p p  to be close to zero. The effective access time, is    \\text{effective access time} = (1-p)\\times ma + p\\times \\text{page fault time}  \\text{effective access time} = (1-p)\\times ma + p\\times \\text{page fault time}   where  ma ma  denotes the memory-access time.  With an average page-fault service time of 8 milliseconds and a memory access time of 200 nanoseconds, the effective access time in nanoseconds is  200+7,999,800\\times p 200+7,999,800\\times p . The effective access time is  directly proportional  to the page-fault rate  p p , so it is important to keep the page-fault rate  low  in a demand-paging system.  An additional aspect of demand paging is the handling and overall use of swap space.    I/O to swap space is generally faster than that to the file system, because swap space is allocated in much larger blocks, and file lookups an indirect allocation methods are not used ( see details in Chapter 11 ).  One OPTION: copying an entire file image into the swap space at process startup and then performing demand paging from the swap space.  Second OPTION: practiced by several operating system, including Linux and Windows \u2014\u2014\u2014 to demand-page from the file system initially but to write the pages to swap space as they are replaced.   Mobile operating system typically do not support swapping [ Chapter 9 ]. Instead, these systems demand-page from the file system and reclaim read-only pages (such as code) from applications if memory becomes constrained.", 
            "title": "Performance of Demand Paging"
        }, 
        {
            "location": "/osc/ch10/#3-copy-on-write", 
            "text": "Copy-on-write (\u5199\u65f6\u590d\u5236) works by allowing the parent and child processes initially to share the same pages, and if either process writes to a shared page, a copy of the shared page is created.", 
            "title": "3 Copy-on-Write"
        }, 
        {
            "location": "/osc/ch10/#4-page-replacement", 
            "text": "When we increase degree of multiprogramming, over-allocating of memory results in page faults. The operating system determines where the desired page is residing on secondary storage but to find that there are  no  free frames on the free-frame list (i.e. all memory is in use).  Most operating systems now combine swapping pages with  page replacement (\u9875\u9762\u7f6e\u6362).", 
            "title": "4 Page Replacement"
        }, 
        {
            "location": "/osc/ch10/#basic-page-replacement", 
            "text": "If no frame is free, we find one that is not currently being used and free it. When we select a page for replacement, We examine its  modify bit  (or  dirty bit , see  Example of Core i7 ).   The modify bit for a page is set by the hardware whenever any byte in the page is written into, indicating that the page has been modified.  If the bit is set, we must write the page to storage. Otherwise, we need not write the memory page to storage: it is already there.   We must solve two major problems to implement demand paging:   frame-allocation algorithm : decide how many frames allocate to each process  page-replacement algorithm : select the frames that are to be replaced. In general, we want the one with the lowest page-fault rate.", 
            "title": "Basic Page Replacement"
        }, 
        {
            "location": "/osc/ch10/#fifo-page-replacement", 
            "text": "The simplest page-replacement algorithm is a first-in, first-out(FIFO) algorithm.    We can create a FIFO queue to hold all pages in memory.   We replace the page at the head of the queue.   When a page is brought into memory, we insert it at the tail of the queue.    DISADVANTAGE: Its performance is not  always  good.  Belady\u2019s anomaly : for some page-replacement algorithms, the page-fault rate may increase as the number of allocated frames increases.  Figure below shows the curve of page faults for the reference string  1,2,3,4,1,2,5,1,2,3,4,5  versus the number of available frames, with a FIFO page-replacement algorithm.", 
            "title": "FIFO Page Replacement"
        }, 
        {
            "location": "/osc/ch10/#optimal-page-replacement-opt", 
            "text": "Optimal page-replacement (OPT, \u6700\u4f73\u9875\u9762\u7f6e\u6362) algorithm replaces the page that  will not be used for the longest period of time .    It has the  lowest  page-fault rate of all algorithms.  It will never suffer from Belady's anomaly.  It is different to implement, because it requires future knowledge of the reference string.  It is used mainly for comparison studies.", 
            "title": "Optimal Page Replacement, OPT"
        }, 
        {
            "location": "/osc/ch10/#lru-page-replacement-lru", 
            "text": "Least recently used (LRU, \u6700\u8fd1\u6700\u5c11\u4f7f\u7528) algorithm chooses the page that has not been used for the longest period of time.    We can think of this strategy as the optimal page-replacement algorithm looking backward in time. ( If we let  S^R S^R  be the reverse of a reference string  S S , then the page-fault rate for the OPT algorithm on  S S  is the same as the page-fault rate of OPT algorithm on  S^R S^R ).   The LRU policy is  often  used as a page-replacement algorithm and is considered to be good.  Best way to implement LRU replacement with a stack of page numbers is using a doubly linked list with a head pointer and a tail pointer.    Note  Implementation of LRU would be not conceivable without hardware assistance beyond the standard TLB registers. The updating of stack must be done for every memory reference.  If we were to use an interrupt for every reference to allow software to update such data structures, it would slow every memory reference by a factor of at least ten, hence slowing every process by a factor of ten. Few systems could tolerate that level of overhead for memory management.", 
            "title": "LRU Page Replacement, LRU"
        }, 
        {
            "location": "/osc/ch10/#lru-approximation-page-replacement", 
            "text": "In fact, some systems provide no hardware support, using the form of a reference bit instead. The  reference bit  for a page is set by the hardware whenever that page is referenced(either a  read  or a  write  to any byte in the page).  Additional-Reference-Bits Algorithm  We can gain additional ordering information by recording the reference bits at regular intervals.    We can keep an 8-bit byte for each page in a table in memory.   At regular intervals (say, every 100 milliseconds), a timer interrupt transfers control to the operating system.   The operating system shifts the reference bit for each page into the high-order bit of its 8-bit byte, shifting the other bits right by 1 bit and discarding the low-order bit.  These 8-bit shift registers contain the history of page use for the last eight time periods.  If we interpret these 8-bit bytes as unsigned integers, the page with the lowest number is the LRU page, and it can be replaced.   Second-Chance Algorithm  The number of bits of history included in the shift register can be varied, the number can be reduced to zero, leaving only the reference bit itself.   When a page has been selected, we inspect its reference bit.   If the value is 0, we proceed to replace this page; but if the reference bit is set to 1, we give the page a second chance and move on to select the next FIFO page.  When a page gets a second chance, its reference bit is cleared, and its arrival time is reset to the current time.   Thus, a page that is given a second chance will not be replaced until all other pages have been replaced (or given second chances). I  n addition, if a page is used often enough to keep its reference bit set, it will never be replaced.   One way to implement the second-chance algorithm (sometimes referred to as the clock algorithm) is as a circular queue.   A pointer (that is, a hand on the clock) indicates which page is to be replaced next.   When a frame is needed, the pointer advances until it finds a page with a 0 reference bit.   As it advances, it clears the reference bits.   Once a victim page is found, the page is replaced, and the new page is inserted in the circular queue in that position.    A simple example is illustrated by the figure below, in which small blue digits denotes the reference bit and green arrow denotes the pointer.", 
            "title": "LRU-Approximation Page Replacement"
        }, 
        {
            "location": "/osc/ch10/#5-allocation-of-frames", 
            "text": "", 
            "title": "5 Allocation of Frames"
        }, 
        {
            "location": "/osc/ch10/#minimum-number-of-frames", 
            "text": "We must allocate at least a minimum  number of frames.   One reason is performance. Obviously, as the number of frames allocated to each process decreases, the page-fault rate increases.  Another reason is that when a page fault occurs before an executing instruction complete, the instruction must be restarted. So we must have enough frames to hold all the different pages that any single instruction can reference.   The minimum number of frames is defined by the computer architecture.", 
            "title": "Minimum Number of Frames"
        }, 
        {
            "location": "/osc/ch10/#allocation-algorithms", 
            "text": "Equal Allocation  The easiest way to split  m m  frames among  n n  processes is to give everyone an equal share,  m/n m/n  frames (ignoring frames needed by the operating system for the moment).  Proportional Allocation  In proportional allocation, we allocate available memory to each process according to its size. Let the size of the virtual memory for process  p_i p_i  be  s_i s_i  , and define  S=\\sum s_i S=\\sum s_i . Then, if the total number of available frames is  m m , we allocate  a_i a_i  frames to process  p_i p_i  , where  a_i a_i  is approximately  a_i=s_i/S\\times m a_i=s_i/S\\times m .", 
            "title": "Allocation Algorithms"
        }, 
        {
            "location": "/osc/ch10/#global-versus-local-allocation", 
            "text": "Global replacement  allows a process to select a replacement frame from the set of  all  frames, even if that frame is currently allocated to some other process; that is, one process can take a frame from another.   Local replacement  requires that each process select from only  its own  set of allocated frames.  Local replacement might  hinder  a process, however, by not making available to it other, less used pages of memory. Thus, global replacement generally results in  greater  system throughput. It is therefore the more commonly used method.  Global Page-Replacement Policy  Rather than waiting for the free-frame list to drop to zero before we begin selecting pages for replacement, we trigger page replacement when the list  falls below a certain threshold .   It attempts to ensure there is  always sufficient free  memory to satisfy new requests.  When the amount of free memory drops below minimum threshold, a kernel routine ( reapers ) is triggered that begins reclaiming pages from all processes in the system.  When the amount of free memory reaches the maximum threshold, the reaper routine is suspended.  The kernel reaper routine typically uses some form of LRU approximation.", 
            "title": "Global versus Local Allocation"
        }, 
        {
            "location": "/osc/ch10/#6-thrashing", 
            "text": "", 
            "title": "6 Thrashing"
        }, 
        {
            "location": "/osc/ch10/#cause-of-thrashing", 
            "text": "Thrashing may be caused by programs or workloads that present insufficient  locality of reference (also principle of locality, \u8bbf\u95ee\u5c40\u90e8\u6027): if the  working set (\u5de5\u4f5c\u96c6) of a program or a workload cannot be effectively held within physical memory, then constant data swapping, i.e., thrashing, may occur.  Consider the following scenario, which is based on the actual behavior of early paging systems.   The operating system monitors CPU utilization.   If CPU utilizition is too low, we increase the degree of multiprogramming by introducing a new process to the system.   A global page-replacement algorithm is used; it replaces pages without regard to the process to which they belong.   Now suppose that a process enters a new phase in its execution and needs more frames. It starts faulting and taking frames away from other processes.   These processes need those pages, however, and so they also fault, taking frames from other processes.   These faulting processes must use the paging device to swap pages in and out. As they queue up for the paging device, the ready queue empties. As processes wait for the paging device, CPU utilization decreases.  The CPU scheduler sees the decreasing CPU utilization and increases the degree of multiprogramming as a result.   The new process tries to get started by taking frames from running processes, causing more page faults and a longer queue for the paging device.   As a result, CPU utilization drops even further, and the CPU scheduler tries to increase the degree of multiprogramming even more. Thrashing has occurred, and system throughput plunges.     QUESTION: To prevent thrashing, we must provide a process with as many frames as it needs. But how do we know how many frames it \"needs\"?   The  locality model  of process execution, states that, as a process executes, it moves from locality to locality.   A  locality  is a set of pages that are actively used together.  A running program is generally composed of several different localities, which may overlap.  If we do not allocate enough frames to accommodate the size of the current locality, the process will thrash, since it cannot keep in memory all the pages that it is actively using.    Example  Figure below illustrates the concept of locality and how a process\u2019s locality changes over time. At time (a), the locality is the set of pages {18, 19, 20, 21, 22, 23, 24, 29, 30, 33}. At time (b), the locality changes to {18, 19, 20, 24, 25, 26, 27, 28, 29, 31, 32, 33}. Notice the overlap, as some pages (for example, 18, 19, and 20) are part of both localities.", 
            "title": "Cause of Thrashing"
        }, 
        {
            "location": "/osc/ch10/#working-set-model", 
            "text": "The group of physical memory pages currently dedicated to a specific process is known as the  Working set (WS, \u5de5\u4f5c\u96c6) for that process.    Example  For example, the working set at time  t_1 t_1  is {1, 2, 5, 6, 7}. By time  t_2 t_2  , the working set has changed to {3, 4}.    If we compute the working-set size  WSS_i WSS_i  for each process in the system, the total demand for frames  D D  is  D=\\sum WSS_i D=\\sum WSS_i .  If the total demand  D D  is greater than the total number of available frames ( D\\gt m D\\gt m ), thrashing will occur, because some processes will not have enough frames.  WORKING SET SOLUTION TO THRASHING:    The operating system monitors the working set of each process and allocates to that working set enough frames to provide it with its working-set size.   If there are enough extra frames, another process can be initiated.  If the sum of the working-set sizes increases, exceeding the total number of available frames, the operating system selects a process to suspend.   The process\u2019s pages are written out (swapped), and its frames are reallocated to other processes. The suspended process can be restarted later.", 
            "title": "Working-Set Model"
        }, 
        {
            "location": "/osc/ch10/#page-fault-frequency", 
            "text": "The working-set model is successful but seems a clumsy way to control thrashing.  A strategy that uses the  page-fault frequency (PFF) takes a more direct approach:   Thrashing has a high page-fault rate. Thus, we control the page-fault rate.  When the page fault rate is too high, we know that the process needs more frames.  Conversely, if it too low, then the process may have too many frames.     We can establish upper and lower bounds on the desired page-fault rate.  If the actual page-fault rate exceeds the upper limit, we allocate the process. another frame.   If the page-fault rate falls below the lower limit, we remove a frame from the process.", 
            "title": "Page-Fault Frequency"
        }, 
        {
            "location": "/osc/ch10/#7-memory-compression", 
            "text": "When the number of free frames falls below a certain threshold that would triggers page replacement, rather than paging out modified frames to swap space, we  compress  several frames into a single frame ( memory compression , \u5185\u5b58\u538b\u7f29), enabling the system to reduce memory usage without resorting to swapping pages.   Example  For example, the free-frame list contains six frames:  7,2,9,21,27,16 , and the modified frame list contains four frames:  15, 3, 35, 26 .\nIn Figure below, frame 7 is removed from the free-frame list. Frames 15, 3, and 35 are compressed and stored in frame 7, which is then stored in the list of compressed frames. The frames 15, 3, and 35 can now be moved to the free-frame list. If one of the three compressed frames is later referenced, a page fault occurs, and the compressed frame is decompressed, restoring the three pages 15, 3, and 35 in memory.", 
            "title": "7 Memory Compression"
        }, 
        {
            "location": "/osc/ch10/#8-allocating-kernel-memory", 
            "text": "Kernel memory is often allocated from a free-memory pool different from the list used to satisfy ordinary user-mode processes discussed before. There are two primary reasons for this:   The kernel requests memory for data structures of varying sizes, some of which are less than a page in size. As a result, the kernel must use memory  conservatively  and attempt to  minimize waste  due to fragmentation.  Certain hardware devices interact directly with physical memory \u2014\u2014 without the benefit of a virtual memory interface \u2014\u2014 and consequently may require memory residing in physically  contiguous  pages.", 
            "title": "8 Allocating Kernel Memory"
        }, 
        {
            "location": "/osc/ch10/#buddy-system", 
            "text": "The buddy system allocates memory from a fixed-size segment consisting of physically contiguous pages.   Memory is allocated from this segment using a power-of-2 allocator, which satisfies requests in units sized as a power of 2 (4 KB, 8 KB, 16 KB, and so forth).  A request in units not appropriately sized is rounded up to the next highest power of 2.   Pro and Cons:   An advantage of the buddy system is how quickly adjacent buddies can be combined to form larger segments using a technique known as  coalescing (illustrated below in the Example section).  Rounding up to the next highest power of 2 is very likely to cause internal fragmentation.    Example  Assume the size of a memory segment is initially 256 KB and the kernel requests 21 KB of memory. The segment is initially divided into two buddies\u2014which we will call  A_L A_L  and  A_R A_R  \u2014\u2014 each 128 KB in size. One of these buddies is further divided into two 64-KB buddies\u2014  B_L B_L  and  B_R B_R  . However, the next-highest power of 2 from 21 KB is 32 KB so either  B_L B_L  or  B_R B_R  is again divided into two 32-KB buddies,  C_L C_L  and  C_R C_R  . One of these buddies is used to satisfy the 21-KB request. This scheme is illustrated in Figure below, where  C_L C_L  is the segment allocated to the 21-KB request.   when the kernel releases the  C_L C_L  unit it was allocated, the system can coalesce  C_L C_L  and  C_R C_R  into a 64-KB segment. This segment,  B_L B_L  , can in turn be coalesced with its buddy  B_R B_R  to form a 128-KB segment. Ultimately, we can end up with the original 256-KB segment.", 
            "title": "Buddy System"
        }, 
        {
            "location": "/osc/ch10/#slab-allocations", 
            "text": "A second strategy for allocating kernel memory is known as  slab allocation .   A  slab  is made up of one or more physically contiguous pages.   A  cache  consists of one or more slabs.  Each of caches stores a different type of object. There is one cache per object type.(e.g.  a separate cache for the data structure representing process descriptors, a separate cache for file objects).  Each  cache  is populated with objects that are instantiations of the kernel data structure the cache represents.(e.g. the cache representing semaphores stores instances of semaphore objects).    Example  Linux kernel adopted the slab allocator after Version 2.2. Each slab contains some number of objects, which are the data structures being cached.   Each slab is in one of three states:  full ,  partial , or  empty .   A full slab has no free objects. (All objects in the slab are allocated.)   An empty slab has no allocated objects. (All objects in the slab are free.)   A partial slab has some allocated objects and some free objects.   When some part of the kernel requests a new object, the request is satisfied from a partial slab, if one exists. Otherwise, the request is satisfied from an empty slab.    The slab allocator provides two main benefits:   No  memory is  wasted  due to fragmentation. Each unique kernel data structure has an associated cache, and each cache is made up of one or more slabs that are divided into chunks the size of the objects being represented.  Memory requests can be satisfied  quickly . Objects are created in advance and thus can be quickly allocated from the cache. When the kernel has finished with an object and releases it, it is marked as free and returned to its cache, thus making it immediately available for subsequent requests from the kernel.", 
            "title": "Slab Allocations"
        }, 
        {
            "location": "/osc/ch11/", 
            "text": "Operating System Concepts 11 - Mass-Storage Structure\n\n\n6 Swap-Space Management", 
            "title": "Chapter 11: Mass-Storage Structure"
        }, 
        {
            "location": "/osc/ch11/#operating-system-concepts-11-mass-storage-structure", 
            "text": "", 
            "title": "Operating System Concepts 11 - Mass-Storage Structure"
        }, 
        {
            "location": "/osc/ch11/#6-swap-space-management", 
            "text": "", 
            "title": "6 Swap-Space Management"
        }, 
        {
            "location": "/osc/ch13/", 
            "text": "Operating System Concepts 13 - File System Interface\n\n\nThe file system consists of two distinct parts: a collection of \nfiles\n, each storing related data, and a \ndirectory\n structure, which organizes and provides information about all the files in the system.\n\n\n1 File Concept\n\n\nA \nfile\n is named collection of related information that is recorded on secondary storage.(\u6587\u4ef6\u662f\u8bb0\u5f55\u5728\u5916\u5b58\u4e0a\u7684\u76f8\u5173\u4fe1\u606f\u7684\u5177\u6709\u540d\u79f0\u7684\u96c6\u5408)\u3002\n\n\nA file has a certain defined structure, which depends on its type.\n\n\n\n\nA text file is a sequence of characters organized into lines.\n\n\nAn executable file is a series of code sections.\n\n\n\n\nFile Attributes\n\n\nA file's attributes vary from one operating system to another but typically consist of these:\n\n\n\n\nName\n. The symbolic file name is the only information kept in human-readable form.\n\n\nIdentifier\n. This unique tag, usually a number, Identifier the file within the file system; it is the non-human-readable name for the file.\n\n\nType\n. This information is needed for systems that support different types of files.\n\n\nLocation\n. This information is a pointer to a device and to the location of the file on that device.\n\n\nSize\n. The current size of the file (in bytes, words, or blocks) and possibly the maximum allowed size are included in this attribute.\n\n\nProtection\n. Access-control information determines who can do reading, writing, executing, and so on.\n\n\nTimestamps and user identification\n. This information may be kept for creation, last modification, and last use. These data can be useful for protection, security, and usage monitoring.\n\n\n\n\nFile Operations\n\n\nThe operating system must do to perform each of these seven basic file operations.\n\n\n\n\nCreating a file\n. First, space must be allocated for the file. Second, an entry for the new file must be made in a directory.\n\n\nOpening a file\n. Check access permissions, and if successful, the open call returns a file handle that is used as an argument in the other calls.\n\n\nWriting a file\n: The system keeps a \nwrite pointer\n to the location in the file where the next write is to take place if it is sequential.\n\n\nRepositioning within a file\n: The \ncurrent-file-position pointer\n of the open file is repositioned to a given value.\n\n\nDeleting a file\n: Release all file space.\n\n\nTruncating a file\n: The length of a file can be reset to zero, and its file space be released with all  other attributes remain unchanged.\n\n\n\n\nThese seven basic operations comprise the minimal set of required file operations. These primitive operations can then be combined to perform other file operations.\n\n\nThe operating system keeps a table, called the \nopen-file-table\n, containing information about all open files.\n\n\n\n\nWhen a file operation is requested, the file is specified via an index into this table.\n\n\nWhen the file is no longer being actively used, it is closed by the process, and the operating system removes its entry from the open-file table, potentially releasing locks.\n\n\n\n\nISSUES: Several different applications open the same file at the same time.\n\n\nSOLUTION: The operating system uses two levels of internal tables: a per-process table and a system-wide table.\n\n\n\n\nThe per-process table tracks all files that a process has open.\n\n\nIt Stores information regarding the process's use of the file (e.g. the current file pointer for each file, access rights to the file and accounting information)\n\n\n\n\n\n\nEach entry in the per-process table in turn points to a system-wide open-file table. \n\n\nIt contains process-independent information(e.g. the location of the file on disk, access dates, and file size).\n\n\nOnce a file has been opened by one process, it includes an entry for the file.\n\n\nIt also has an \nopen count\n associated with each file to indicate how many processes have the file open.\n\n\n\n\n\n\n\n\nFile locks\n(\u6587\u4ef6\u9501) are useful for files that are shared by several processes. For example, a system log file that can be accessed and modified by a number of processes in the system.\n\n\nFile locks provide functionality similar to reader-writer locks in \nChapter 7\n. A \nshared lock\n(\u5171\u4eab\u9501) is akin to a reader lock in that several processes can acquire the lock concurrently. An \nexclusive lock\n(\u6392\u65a5\u9501) is akin to a writer lock in that only one process at a time can acquire such a lock.\n\n\nFurthermore, operating systems(e.g. Linux) may provide either \nmandatory\n  or \nadvisory\n file-locking mechanisms.\n\n\n\n\nWith mandatory locking, once a process acquires an exclusive lock, the operating system will prevent any other process from accessing the locked file.\n\n\nwith advisory locking, the operating system will not prevent other process from accessing to the locked file.\n\n\nFor advisory locking, it is up to software developers to ensure that locks are appropriately acquired and released.\n\n\n\n\nThe simple program in Java as follows demonstrating file locking. The program acquires an exclusive lock on the first half of the file and a shared lock on the second half.\n\n\nimport\n \njava.io.*\n;\n\n\nimport\n \njava.nio.channels.*\n;\n\n\n\npublic\n \nclass\n \nLockingExample\n \n{\n\n    \npublic\n \nstatic\n \nfinal\n \nboolean\n \nEXCLUSIVE\n \n=\n \nfalse\n;\n\n    \npublic\n \nstatic\n \nfinal\n \nboolean\n \nSHARED\n \n=\n \ntrue\n;\n\n\n   \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n \nargs\n[])\n \nthrows\n \nIOException\n \n{\n\n        \nif\n \n(\nargs\n.\nlength\n \n!=\n \n1\n)\n \n{\n\n            \nSystem\n.\nerr\n.\nprintln\n(\nUsage: java LockingExample \ninput file\n);\n\n            \nSystem\n.\nexit\n(\n0\n);\n\n       \n}\n\n\n    \nFileLock\n \nsharedLock\n \n=\n \nnull\n;\n\n    \nFileLock\n \nexclusiveLock\n \n=\n \nnull\n;\n\n\n    \ntry\n \n{\n\n       \nRandomAccessFile\n \nraf\n \n=\n \nnew\n \nRandomAccessFile\n(\nargs\n[\n0\n],\n \nrw\n);\n \n\n        \n// get the channel for the file\n\n        \nFileChannel\n \nchannel\n \n=\n \nraf\n.\ngetChannel\n();\n\n\n        \nSystem\n.\nout\n.\nprintln\n(\ntrying to acquire lock ...\n);\n\n        \n// this locks the first half of the file - exclusive\n\n        \nexclusiveLock\n \n=\n \nchannel\n.\nlock\n(\n0\n,\n \nraf\n.\nlength\n()/\n2\n,\n \nEXCLUSIVE\n);\n\n        \nSystem\n.\nout\n.\nprintln\n(\nlock acquired ...\n);\n\n\n        \n/**\n\n\n         * Now modify the data  . . .\n\n\n         */\n\n\n        \ntry\n \n{\n\n            \n// sleep for 10 seconds\n\n            \nThread\n.\nsleep\n(\n10000\n);\n\n        \n}\n\n        \ncatch\n \n(\nInterruptedException\n \nie\n)\n \n{\n \n}\n\n\n        \n// release the lock\n\n        \nexclusiveLock\n.\nrelease\n();\n\n        \nSystem\n.\nout\n.\nprintln\n(\nlock released ...\n);\n\n\n        \n// this locks the second half of the file - shared \n\n        \nsharedLock\n \n=\n \nchannel\n.\nlock\n(\nraf\n.\nlength\n()/\n2\n \n+\n \n1\n,\n \nraf\n.\nlength\n(),\n \nSHARED\n);\n\n\n        \n/**\n\n\n         * Now read the data  . . .\n\n\n         */\n\n\n        \n// release the lock\n\n        \nexclusiveLock\n.\nrelease\n();\n\n    \n}\n \ncatch\n \n(\njava\n.\nio\n.\nIOException\n \nioe\n)\n \n{\n\n        \nSystem\n.\nerr\n.\nprintln\n(\nioe\n);\n\n    \n}\n\n        \nfinally\n \n{\n\n        \nif\n \n(\nexclusiveLock\n \n!=\n \nnull\n)\n\n                \nexclusiveLock\n.\nrelease\n();\n\n        \nif\n \n(\nsharedLock\n \n!=\n \nnull\n)\n\n                \nsharedLock\n.\nrelease\n();\n\n        \n}\n\n   \n}\n\n\n}\n\n\n\n\n\nFile Types\n\n\nA common technique for implementing file types is to include the type as part of the file name. \n\n\n\n\nThe name is split into two parts\u2014a \nname\n and an \nextension\n, usually separated by a period. \n\n\nThe system uses the extension to indicate the type of the file and the type of operations that can be done on that file\n\n\nThe UNIX system uses a \nmagic number\n[\nWikipedia\n] stored at the beginning of some binary files to indicate the type of data in the file (for example, the format of an image file). Not all files have magic numbers.\n\n\n\n\nFile Structure\n\n\nCertain files must conform to a required structure that is understood by the operating system. \n\n\n\n\nFor example, the operating system requires that an executable file have a specific structure so that it can determine where in memory to load the file and what the location of the first instruction is.\n\n\nOne of the disadvantage of having the operating system support multiple file structures: it makes the operating system large and cumbersome.\n\n\nSome operating systems(UNIX, Windows) impose (and support) a minimal number of file structures.\n\n\nHowever, all operating systems must support at least one structure \u2014that of an executable file \u2014 so that the system is able to load and run programs.\n\n\n\n\nInternal File Structure\n\n\nISSUE: All disk I/O is performed in units of one block (physical record), and all blocks are the same size. It is unlikely that the physical record size will exactly match the length of the desired logical record.\n\n\nSOLUTION:\nPacking a number of logical records into physical blocks\n.\n\n\nEXAMPLE: The UNIX operating system defines all files to be simply streams of bytes. Each byte is individually addressable by its offset from the beginning (or end) of the file. In this case, the logical record size is 1 byte. The file system automatically packs and unpacks bytes into physical disk blocks - say, 512 bytes per block \u2014 as necessary.\n\n\n2 Access Methods\n\n\nFiles store information. The information in the file can be accessed in several ways.\n\n\nSequential Access\n\n\nThe simplest access method is \nsequential access\n(\u987a\u5e8f\u8bbf\u95ee). \n\n\n\n\nInformation in the file is processed in order, one record after the other.\n\n\nIt is by far the most common access method.\n\n\n\n\n\n\nDirect Access\n\n\nFor \ndirect access\n(\u76f4\u63a5\u8bbf\u95ee) or \nrelative access\n(\u76f8\u5bf9\u8bbf\u95ee), a file is made up of fixed-length logical records that allow programs to read and write records rapidly in no particular order.\n\n\n\n\nThe file is viewed as a \nnumbered\n sequence of blocks or records.\n\n\nDirect-access files are of great use for immediate access to large amounts of information. (e.g. databases, we compute which block contains the answer and then read that block directly when querying)\n\n\nA \nrelative block number\n is provided by the user to the operating system. It is an index relative to the beginning of the file.\n\n\n\n\nOther Access Methods\n\n\nOther access methods generally involve the construction of an index for the file. The \nindex\n contains pointers to the various blocks. To find a record in the file, we first search the index and then use the pointer to access the file directly and to find the desired record.\n\n\n3 Directory Structure\n\n\nThe directory can be viewed as a symbol table that translates file names into their file control blocks.\n\n\nThe directory can be \nsingle-level\n(\u5355\u5c42), \ntwo-level\n(\u53cc\u5c42), and \ntree-structured\n(\u6811\u72b6).\n\n\n\n\nWithin a file system, it is useful to create directories to allow files to be organized. \n\n\n\n\nA \nsingle-level directory\n in a multiuser system causes naming problems, since each file must have a unique name. \n\n\nA \ntwo-level directory \nsolves this problem by creating a separate directory for each user\u2019s files. The directory lists the files by name and includes the file\u2019s location on the disk, length, type, owner, time of creation, time of last use, and so on.\n\n\nThe natural generalization of a two-level directory is a \ntree-structured directory\n. A tree-structured directory allows a user to create subdirectories to organize files. \n\n\nAcyclic-graph directory\n structures enable users to share subdirectories and files but complicate searching and deletion.\n\n\nA general graph\n structure allows complete flexibility in the sharing of files and directories but sometimes requires garbage collection to recover unused disk space.\n\n\n\n\n4 Protection\n\n\nWhen information is stored in a computer system, we want to keep it safe from physical damage (the issue of \nreliability\n) and improper access (the issue of \nprotection\n).\n\n\nTypes of Access\n\n\nProtection mechanisms provide \ncontrolled access\n by limiting the \ntypes of file\n access that can be made. Access is permitted or denied depending on several factors, one of which is the type of access requested. Several different types of operations may be controlled:\n\n\n\n\nRead\n. Read from the file.\n\n\nWrite\n. Write or rewrite the file.\n\n\nExecute\n. Load the file into memory and execute it.\n\n\nAppend\n. Write new information at the end of the file.\n\n\nDelete\n. Delete the file and free its space for possible reuse.\n\n\nList\n. List the name and attributes of the file.\n\n\nAttribute change\n. Changing the attributes of the file.\n\n\n\n\nMany protection mechanism have been proposed and we have a more detailed description in \nChapter 17\n.\n\n\nAccess Control\n\n\nThe most common approach to the protection problem is to make access dependent on the identity of the user. \n\n\n\n\nDifferent users may need different types of access to a file or directory. \n\n\n\n\nThe most general scheme to implement identity dependent access is to associate with each file and directory an \naccess-control list\n(ACL, \u8bbf\u95ee\u63a7\u5236\u5217\u8868) specifying user names and the types of access allowed for each user.\n\n\n\n\nIf a user is listed for the requested access, the access is allowed.\n\n\nOtherwise, a protection violation occurs, and the user job is denied access to the file.\n\n\n\n\nISSUES: If we want to allow everyone to read a file, we must list all users with read accesses.\n\n\nSOLUTION: A condensed version of the access list, many system recognize three classifications of users in connection with each file:\n\n\n\n\nOwner. The user who created the file is the owner.\n\n\nGroup. A set of users who are sharing the file and need similar access is a group, or work group\n\n\nOther. All other users in the system.\n\n\n\n\nOther Protection Approaches\n\n\nAnother approach to the protection problem, is to associate a password with each file.\n\n\nPermissions in UNIX\n\n\nIn the UNIX system, directory protection and file protection are handled similarly. Associated with each file and directory are three fields - owner, group, and universe -- each consisting of the three bits \nrwx\n, where \nr\n controls read access, \nw\n controls write access, and \nx\n controls execution.\n\n\nA sample directory listing from a UNIX environment is shown in below:\n\n\n\n\n5 Memory-Mapped Files\n\n\nMemory mapping\n(\u5185\u5b58\u6620\u5c04) a file is accomplished by mapping a disk block to a page in memory.\n\n\n\n\nInitial access to the file, results in a page fault.\n\n\nA page-sized portion of the file is read from the file system into a physical page.\n\n\nSubsequent reads and writes to the file are handled as routine memory accesses.\n\n\n\n\nAdvantage\n\n\n\n\nManipulating files through memory rather than incurring the overhead of using \nread()\n and \nwrite()\n system calls simplifies and speeds up file access and usuage.\n\n\n\n\nMultiple processes may be allowed to map the same file concurrently, to allow sharing of data. The virtual memory map of each sharing process points to the same page of physical memory. The memory-mapping system calls can also support \ncopy-on-write\n functionality, allowing processes to share a file in read-only mode but to have their own copies of any data they modify.\n\n\nQuite often, shared memory is in fact implemented by memory mapping files. Under this scenario, processes can communicate using shared memory by having the communicating processes memory-map the same file into their virtual address spaces(e.g. \nPOSIX shared memory\n).", 
            "title": "Chapter 13: File-System Interfaces"
        }, 
        {
            "location": "/osc/ch13/#operating-system-concepts-13-file-system-interface", 
            "text": "The file system consists of two distinct parts: a collection of  files , each storing related data, and a  directory  structure, which organizes and provides information about all the files in the system.", 
            "title": "Operating System Concepts 13 - File System Interface"
        }, 
        {
            "location": "/osc/ch13/#1-file-concept", 
            "text": "A  file  is named collection of related information that is recorded on secondary storage.(\u6587\u4ef6\u662f\u8bb0\u5f55\u5728\u5916\u5b58\u4e0a\u7684\u76f8\u5173\u4fe1\u606f\u7684\u5177\u6709\u540d\u79f0\u7684\u96c6\u5408)\u3002  A file has a certain defined structure, which depends on its type.   A text file is a sequence of characters organized into lines.  An executable file is a series of code sections.", 
            "title": "1 File Concept"
        }, 
        {
            "location": "/osc/ch13/#file-attributes", 
            "text": "A file's attributes vary from one operating system to another but typically consist of these:   Name . The symbolic file name is the only information kept in human-readable form.  Identifier . This unique tag, usually a number, Identifier the file within the file system; it is the non-human-readable name for the file.  Type . This information is needed for systems that support different types of files.  Location . This information is a pointer to a device and to the location of the file on that device.  Size . The current size of the file (in bytes, words, or blocks) and possibly the maximum allowed size are included in this attribute.  Protection . Access-control information determines who can do reading, writing, executing, and so on.  Timestamps and user identification . This information may be kept for creation, last modification, and last use. These data can be useful for protection, security, and usage monitoring.", 
            "title": "File Attributes"
        }, 
        {
            "location": "/osc/ch13/#file-operations", 
            "text": "The operating system must do to perform each of these seven basic file operations.   Creating a file . First, space must be allocated for the file. Second, an entry for the new file must be made in a directory.  Opening a file . Check access permissions, and if successful, the open call returns a file handle that is used as an argument in the other calls.  Writing a file : The system keeps a  write pointer  to the location in the file where the next write is to take place if it is sequential.  Repositioning within a file : The  current-file-position pointer  of the open file is repositioned to a given value.  Deleting a file : Release all file space.  Truncating a file : The length of a file can be reset to zero, and its file space be released with all  other attributes remain unchanged.   These seven basic operations comprise the minimal set of required file operations. These primitive operations can then be combined to perform other file operations.  The operating system keeps a table, called the  open-file-table , containing information about all open files.   When a file operation is requested, the file is specified via an index into this table.  When the file is no longer being actively used, it is closed by the process, and the operating system removes its entry from the open-file table, potentially releasing locks.   ISSUES: Several different applications open the same file at the same time.  SOLUTION: The operating system uses two levels of internal tables: a per-process table and a system-wide table.   The per-process table tracks all files that a process has open.  It Stores information regarding the process's use of the file (e.g. the current file pointer for each file, access rights to the file and accounting information)    Each entry in the per-process table in turn points to a system-wide open-file table.   It contains process-independent information(e.g. the location of the file on disk, access dates, and file size).  Once a file has been opened by one process, it includes an entry for the file.  It also has an  open count  associated with each file to indicate how many processes have the file open.     File locks (\u6587\u4ef6\u9501) are useful for files that are shared by several processes. For example, a system log file that can be accessed and modified by a number of processes in the system.  File locks provide functionality similar to reader-writer locks in  Chapter 7 . A  shared lock (\u5171\u4eab\u9501) is akin to a reader lock in that several processes can acquire the lock concurrently. An  exclusive lock (\u6392\u65a5\u9501) is akin to a writer lock in that only one process at a time can acquire such a lock.  Furthermore, operating systems(e.g. Linux) may provide either  mandatory   or  advisory  file-locking mechanisms.   With mandatory locking, once a process acquires an exclusive lock, the operating system will prevent any other process from accessing the locked file.  with advisory locking, the operating system will not prevent other process from accessing to the locked file.  For advisory locking, it is up to software developers to ensure that locks are appropriately acquired and released.   The simple program in Java as follows demonstrating file locking. The program acquires an exclusive lock on the first half of the file and a shared lock on the second half.  import   java.io.* ;  import   java.nio.channels.* ;  public   class   LockingExample   { \n     public   static   final   boolean   EXCLUSIVE   =   false ; \n     public   static   final   boolean   SHARED   =   true ; \n\n    public   static   void   main ( String   args [])   throws   IOException   { \n         if   ( args . length   !=   1 )   { \n             System . err . println ( Usage: java LockingExample  input file ); \n             System . exit ( 0 ); \n        } \n\n     FileLock   sharedLock   =   null ; \n     FileLock   exclusiveLock   =   null ; \n\n     try   { \n        RandomAccessFile   raf   =   new   RandomAccessFile ( args [ 0 ],   rw );  \n\n         // get the channel for the file \n         FileChannel   channel   =   raf . getChannel (); \n\n         System . out . println ( trying to acquire lock ... ); \n         // this locks the first half of the file - exclusive \n         exclusiveLock   =   channel . lock ( 0 ,   raf . length ()/ 2 ,   EXCLUSIVE ); \n         System . out . println ( lock acquired ... ); \n\n         /**           * Now modify the data  . . .           */ \n\n         try   { \n             // sleep for 10 seconds \n             Thread . sleep ( 10000 ); \n         } \n         catch   ( InterruptedException   ie )   {   } \n\n         // release the lock \n         exclusiveLock . release (); \n         System . out . println ( lock released ... ); \n\n         // this locks the second half of the file - shared  \n         sharedLock   =   channel . lock ( raf . length ()/ 2   +   1 ,   raf . length (),   SHARED ); \n\n         /**           * Now read the data  . . .           */ \n\n         // release the lock \n         exclusiveLock . release (); \n     }   catch   ( java . io . IOException   ioe )   { \n         System . err . println ( ioe ); \n     } \n         finally   { \n         if   ( exclusiveLock   !=   null ) \n                 exclusiveLock . release (); \n         if   ( sharedLock   !=   null ) \n                 sharedLock . release (); \n         } \n    }  }", 
            "title": "File Operations"
        }, 
        {
            "location": "/osc/ch13/#file-types", 
            "text": "A common technique for implementing file types is to include the type as part of the file name.    The name is split into two parts\u2014a  name  and an  extension , usually separated by a period.   The system uses the extension to indicate the type of the file and the type of operations that can be done on that file  The UNIX system uses a  magic number [ Wikipedia ] stored at the beginning of some binary files to indicate the type of data in the file (for example, the format of an image file). Not all files have magic numbers.", 
            "title": "File Types"
        }, 
        {
            "location": "/osc/ch13/#file-structure", 
            "text": "Certain files must conform to a required structure that is understood by the operating system.    For example, the operating system requires that an executable file have a specific structure so that it can determine where in memory to load the file and what the location of the first instruction is.  One of the disadvantage of having the operating system support multiple file structures: it makes the operating system large and cumbersome.  Some operating systems(UNIX, Windows) impose (and support) a minimal number of file structures.  However, all operating systems must support at least one structure \u2014that of an executable file \u2014 so that the system is able to load and run programs.", 
            "title": "File Structure"
        }, 
        {
            "location": "/osc/ch13/#internal-file-structure", 
            "text": "ISSUE: All disk I/O is performed in units of one block (physical record), and all blocks are the same size. It is unlikely that the physical record size will exactly match the length of the desired logical record.  SOLUTION: Packing a number of logical records into physical blocks .  EXAMPLE: The UNIX operating system defines all files to be simply streams of bytes. Each byte is individually addressable by its offset from the beginning (or end) of the file. In this case, the logical record size is 1 byte. The file system automatically packs and unpacks bytes into physical disk blocks - say, 512 bytes per block \u2014 as necessary.", 
            "title": "Internal File Structure"
        }, 
        {
            "location": "/osc/ch13/#2-access-methods", 
            "text": "Files store information. The information in the file can be accessed in several ways.", 
            "title": "2 Access Methods"
        }, 
        {
            "location": "/osc/ch13/#sequential-access", 
            "text": "The simplest access method is  sequential access (\u987a\u5e8f\u8bbf\u95ee).    Information in the file is processed in order, one record after the other.  It is by far the most common access method.", 
            "title": "Sequential Access"
        }, 
        {
            "location": "/osc/ch13/#direct-access", 
            "text": "For  direct access (\u76f4\u63a5\u8bbf\u95ee) or  relative access (\u76f8\u5bf9\u8bbf\u95ee), a file is made up of fixed-length logical records that allow programs to read and write records rapidly in no particular order.   The file is viewed as a  numbered  sequence of blocks or records.  Direct-access files are of great use for immediate access to large amounts of information. (e.g. databases, we compute which block contains the answer and then read that block directly when querying)  A  relative block number  is provided by the user to the operating system. It is an index relative to the beginning of the file.", 
            "title": "Direct Access"
        }, 
        {
            "location": "/osc/ch13/#other-access-methods", 
            "text": "Other access methods generally involve the construction of an index for the file. The  index  contains pointers to the various blocks. To find a record in the file, we first search the index and then use the pointer to access the file directly and to find the desired record.", 
            "title": "Other Access Methods"
        }, 
        {
            "location": "/osc/ch13/#3-directory-structure", 
            "text": "The directory can be viewed as a symbol table that translates file names into their file control blocks.  The directory can be  single-level (\u5355\u5c42),  two-level (\u53cc\u5c42), and  tree-structured (\u6811\u72b6).   Within a file system, it is useful to create directories to allow files to be organized.    A  single-level directory  in a multiuser system causes naming problems, since each file must have a unique name.   A  two-level directory  solves this problem by creating a separate directory for each user\u2019s files. The directory lists the files by name and includes the file\u2019s location on the disk, length, type, owner, time of creation, time of last use, and so on.  The natural generalization of a two-level directory is a  tree-structured directory . A tree-structured directory allows a user to create subdirectories to organize files.   Acyclic-graph directory  structures enable users to share subdirectories and files but complicate searching and deletion.  A general graph  structure allows complete flexibility in the sharing of files and directories but sometimes requires garbage collection to recover unused disk space.", 
            "title": "3 Directory Structure"
        }, 
        {
            "location": "/osc/ch13/#4-protection", 
            "text": "When information is stored in a computer system, we want to keep it safe from physical damage (the issue of  reliability ) and improper access (the issue of  protection ).", 
            "title": "4 Protection"
        }, 
        {
            "location": "/osc/ch13/#types-of-access", 
            "text": "Protection mechanisms provide  controlled access  by limiting the  types of file  access that can be made. Access is permitted or denied depending on several factors, one of which is the type of access requested. Several different types of operations may be controlled:   Read . Read from the file.  Write . Write or rewrite the file.  Execute . Load the file into memory and execute it.  Append . Write new information at the end of the file.  Delete . Delete the file and free its space for possible reuse.  List . List the name and attributes of the file.  Attribute change . Changing the attributes of the file.   Many protection mechanism have been proposed and we have a more detailed description in  Chapter 17 .", 
            "title": "Types of Access"
        }, 
        {
            "location": "/osc/ch13/#access-control", 
            "text": "The most common approach to the protection problem is to make access dependent on the identity of the user.    Different users may need different types of access to a file or directory.    The most general scheme to implement identity dependent access is to associate with each file and directory an  access-control list (ACL, \u8bbf\u95ee\u63a7\u5236\u5217\u8868) specifying user names and the types of access allowed for each user.   If a user is listed for the requested access, the access is allowed.  Otherwise, a protection violation occurs, and the user job is denied access to the file.   ISSUES: If we want to allow everyone to read a file, we must list all users with read accesses.  SOLUTION: A condensed version of the access list, many system recognize three classifications of users in connection with each file:   Owner. The user who created the file is the owner.  Group. A set of users who are sharing the file and need similar access is a group, or work group  Other. All other users in the system.", 
            "title": "Access Control"
        }, 
        {
            "location": "/osc/ch13/#other-protection-approaches", 
            "text": "Another approach to the protection problem, is to associate a password with each file.", 
            "title": "Other Protection Approaches"
        }, 
        {
            "location": "/osc/ch13/#permissions-in-unix", 
            "text": "In the UNIX system, directory protection and file protection are handled similarly. Associated with each file and directory are three fields - owner, group, and universe -- each consisting of the three bits  rwx , where  r  controls read access,  w  controls write access, and  x  controls execution.  A sample directory listing from a UNIX environment is shown in below:", 
            "title": "Permissions in UNIX"
        }, 
        {
            "location": "/osc/ch13/#5-memory-mapped-files", 
            "text": "Memory mapping (\u5185\u5b58\u6620\u5c04) a file is accomplished by mapping a disk block to a page in memory.   Initial access to the file, results in a page fault.  A page-sized portion of the file is read from the file system into a physical page.  Subsequent reads and writes to the file are handled as routine memory accesses.   Advantage   Manipulating files through memory rather than incurring the overhead of using  read()  and  write()  system calls simplifies and speeds up file access and usuage.   Multiple processes may be allowed to map the same file concurrently, to allow sharing of data. The virtual memory map of each sharing process points to the same page of physical memory. The memory-mapping system calls can also support  copy-on-write  functionality, allowing processes to share a file in read-only mode but to have their own copies of any data they modify.  Quite often, shared memory is in fact implemented by memory mapping files. Under this scenario, processes can communicate using shared memory by having the communicating processes memory-map the same file into their virtual address spaces(e.g.  POSIX shared memory ).", 
            "title": "5 Memory-Mapped Files"
        }, 
        {
            "location": "/csapp/", 
            "text": "CSAPP\n\n\n\n\nChapter 1: \u8ba1\u7b97\u673a\u7cfb\u7edf\u6f2b\u6e38\n\n\nChapter 2: \u4fe1\u606f\u7684\u8868\u793a\u548c\u5904\u7406\n\n\nChapter 3: \u7a0b\u5e8f\u7684\u673a\u5668\u7ea7\u8868\u793a\n\n\nChapter 4: \u5904\u7406\u5668\u4f53\u7cfb\u7ed3\u6784\n\n\nChapter 5: \u4f18\u5316\u7a0b\u5e8f\u6027\u80fd\n\n\nChapter 6: \u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784\n\n\nChapter 7: \u94fe\u63a5\n\n\nChapter 8: \u5f02\u5e38\u63a7\u5236\u6d41\n\n\nChapter 9: \u865a\u62df\u5185\u5b58\n\n\nChapter 10: \u7cfb\u7edf\u7ea7I/O\n\n\nChapter 11: \u7f51\u7edc\u7f16\u7a0b", 
            "title": "Contents"
        }, 
        {
            "location": "/csapp/#csapp", 
            "text": "Chapter 1: \u8ba1\u7b97\u673a\u7cfb\u7edf\u6f2b\u6e38  Chapter 2: \u4fe1\u606f\u7684\u8868\u793a\u548c\u5904\u7406  Chapter 3: \u7a0b\u5e8f\u7684\u673a\u5668\u7ea7\u8868\u793a  Chapter 4: \u5904\u7406\u5668\u4f53\u7cfb\u7ed3\u6784  Chapter 5: \u4f18\u5316\u7a0b\u5e8f\u6027\u80fd  Chapter 6: \u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784  Chapter 7: \u94fe\u63a5  Chapter 8: \u5f02\u5e38\u63a7\u5236\u6d41  Chapter 9: \u865a\u62df\u5185\u5b58  Chapter 10: \u7cfb\u7edf\u7ea7I/O  Chapter 11: \u7f51\u7edc\u7f16\u7a0b", 
            "title": "CSAPP"
        }, 
        {
            "location": "/csapp/ch1/", 
            "text": "Chapter 1 \u8ba1\u7b97\u673a\u7cfb\u7edf\u6f2b\u6e38", 
            "title": "Chapter 1: \u8ba1\u7b97\u673a\u7cfb\u7edf\u6f2b\u6e38"
        }, 
        {
            "location": "/csapp/ch1/#chapter-1", 
            "text": "", 
            "title": "Chapter 1 \u8ba1\u7b97\u673a\u7cfb\u7edf\u6f2b\u6e38"
        }, 
        {
            "location": "/csapp/ch2/", 
            "text": "Chapter 2 \u4fe1\u606f\u7684\u8868\u793a\u548c\u5904\u7406\n\n\n1 \u4fe1\u606f\u5b58\u50a8\n\n\n\u5927\u591a\u6570\u8ba1\u7b97\u673a\u4f7f\u75288\u4f4d\u7684\u5757\uff0c\u6216\u8005\u5b57\u8282(byte),\u4f5c\u4e3a\n\u6700\u5c0f\u7684\u53ef\u5bfb\u5740\u7684\u5185\u5b58\u5355\u4f4d\n\uff0c\u800c\u4e0d\u662f\u8bbf\u95ee\u5185\u5b58\u4e2d\u5355\u72ec\u7684\u4f4d\u3002\u5185\u5b58\u7684\u6bcf\u4e2a\u5b57\u8282\u90fd\u6709\u4e00\u4e2a\u552f\u4e00\u7684\u6570\u5b57\u6765\u6807\u8bc6\uff0c\u79f0\u4e3a\u5b83\u7684\n\u5730\u5740\n(address)\u3002\n\n\n\u5341\u516d\u8fdb\u5236\u8868\u793a\u6cd5\n\n\n\u4e00\u4e2a\u5b57\u8282\u75318\u4f4d\u7ec4\u6210\u3002\u5728\u4e8c\u8fdb\u5236\u8868\u793a\u6cd5\u4e2d\uff0c\u5b83\u7684\u503c\u57df\u662f\n00000000_2\\sim 11111111_2\n00000000_2\\sim 11111111_2\n\u3002\u5982\u679c\u770b\u6210\u5341\u8fdb\u5236\u6570\uff0c\u5b83\u7684\u503c\u57df\u662f\n0_{10}\\sim 255_{10}\n0_{10}\\sim 255_{10}\n\u3002\n\n\n\u8fd9\u4e24\u79cd\u7b26\u53f7\u8868\u8ff0\u6cd5\u5bf9\u4e8e\u63cf\u8ff0\u4f4d\u6a21\u5f0f\u6765\u8bf4\u90fd\u4e0d\u662f\u975e\u5e38\u65b9\u4fbf\u3002\n\n\n\n\n\u4e8c\u8fdb\u5236\u8868\u793a\u6cd5\u592a\u5197\u957f\uff1b\n\n\n\u5341\u8fdb\u5236\u8868\u793a\u6cd5\u4e0e\u4f4d\u6a21\u5f0f\u7684\u76f8\u4e92\u8f6c\u5316\u5f88\u9ebb\u70e6\u3002\n\n\n\n\n\u66ff\u4ee3\u7684\u65b9\u6cd5\u662f\uff0c\u4ee516\u4e3a\u6280\u672f\uff0c\u4ee5\u5341\u516d\u8fdb\u5236(hexiademical)\u6570\u6765\u8868\u793a\u4f4d\u6a21\u5f0f\u3002\n\n\n\n\n\u5b57\u548c\u6570\u636e\u5927\u5c0f\n\n\n\u6bcf\u53f0\u8ba1\u7b97\u673a\u90fd\u6709\u2f00\u4e2a\n\u5b57\u2ed3\n(word size)\uff0c\u6807\u660e\u6307\u9488\u6570\u636e\u7684\n\u6807\u79f0\u5927\u5c0f\n(norminal size)\u3002\u5b57\u2ed3\u51b3\u5b9a\u7684\u6700\u91cd\u8981\u7684\u7cfb\u7edf\u53c2\u6570\u5c31\u662f\u865a\u62df\u7a7a\u95f4\u7684\u2f24\u2f29\u3002\u5bf9\u4e8e\u2f00\u4e2a\u5b57\u2ed3\u4e3a\nw\nw\n\u4f4d\u7684\u673a\u5668\u2f7d\u2f94\uff0c\u865a\u62df\u5730\u5740\u7684\u8303\u56f4\u4e3a\n0\\sim 2^w\u22121\n0\\sim 2^w\u22121\n\u3002\n\n\nC\u8bed\u8a00\u652f\u6301\u6574\u6570\u548c\u6d6e\u70b9\u6570\u7684\u591a\u79cd\u6570\u636e\u683c\u5f0f\u3002\u4e0b\u8868\u4e3aC\u8bed\u8a00\u5404\u79cd\u6570\u636e\u7c7b\u884c\u5206\u914d\u7684\u5b57\u8282\u6570\u3002\n\n\n\n\n\u5bfb\u5740\u548c\u5b57\u8282\u987a\u5e8f\n\n\n\u8003\u8651\u4e00\u4e2a\nw\nw\n\u4f4d\u7684\u6574\u6570\uff0c\u5176\u4f4d\u8868\u793a\u4e3a\n[x_{w-1}, x_{w-2}, x_1, x_0]\n[x_{w-1}, x_{w-2}, x_1, x_0]\n\uff0c\u5176\u4e2d\nx_{w-1}\nx_{w-1}\n\u662f\n\u6700\u9ad8\u6709\u6548\u4f4d\n(the most significant bit)\uff0c\u800c\nx_0\nx_0\n\u662f\n\u6700\u4f4e\u6709\u6548\u4f4d\n(the least significant bit).\n\n\n\u5047\u8bbe\nw\nw\n\u662f8\u7684\u500d\u6570\uff0c\u8fd9\u4e9b\u4f4d\u5c31\u80fd\u88ab\u5206\u7ec4\u6210\u5b57\u8282\uff0c\u5176\u4e2d\n\u6700\u9ad8\u6709\u6548\u5b57\u8282\n(the most significant byte)\u5305\u542b\u4f4d\n[x_{w-1}, x_{w-2},..., x_{w-8}]\n[x_{w-1}, x_{w-2},..., x_{w-8}]\n\uff0c\u800c\n\u6700\u4f4e\u6709\u6548\u5b57\u8282\n(the least significant byte)\u5305\u542b\u4f4d\n[x_7, x_6,..., x_0]\n[x_7, x_6,..., x_0]\n\uff0c\u5176\u4ed6\u5b57\u8282\u5305\u542b\u4e2d\u95f4\u7684\u4f4d\u3002\n\n\n\u6709\u4e9b\u673a\u5668\u9009\u5728\u5728\u5185\u5b58\u4e2d\u6309\u7167\u4ece\u6700\u4f4e\u6709\u6548\u5b57\u8282\u5230\u6700\u9ad8\u6709\u6548\u5b57\u8282\u7684\u987a\u5e8f\u5b58\u50a8\u5bf9\u8c61\uff0c\u8fd9\u79cd\u65b9\u5f0f\u79f0\u4e3a\n\u5c0f\u7aef\u6cd5\n(little endian). \u6700\u9ad8\u6709\u6548\u5b57\u8282\u5728\u524d\u9762\u7684\u65b9\u5f0f\uff0c\u79f0\u4e3a\n\u5927\u7aef\u6cd5\n(big endian).\n\n\n\n\n\n\nNote\n\n\n\u5927\u591a\u6570Intel\u517c\u5bb9\u673a\u90fd\u53ea\u7528\u5c0f\u7aef\u6a21\u5f0f\u3002\n\n\n\n\n2 \u6574\u6570\u8868\u793a", 
            "title": "Chapter 2: \u4fe1\u606f\u7684\u8868\u793a\u548c\u5904\u7406"
        }, 
        {
            "location": "/csapp/ch2/#chapter-2", 
            "text": "", 
            "title": "Chapter 2 \u4fe1\u606f\u7684\u8868\u793a\u548c\u5904\u7406"
        }, 
        {
            "location": "/csapp/ch2/#1", 
            "text": "\u5927\u591a\u6570\u8ba1\u7b97\u673a\u4f7f\u75288\u4f4d\u7684\u5757\uff0c\u6216\u8005\u5b57\u8282(byte),\u4f5c\u4e3a \u6700\u5c0f\u7684\u53ef\u5bfb\u5740\u7684\u5185\u5b58\u5355\u4f4d \uff0c\u800c\u4e0d\u662f\u8bbf\u95ee\u5185\u5b58\u4e2d\u5355\u72ec\u7684\u4f4d\u3002\u5185\u5b58\u7684\u6bcf\u4e2a\u5b57\u8282\u90fd\u6709\u4e00\u4e2a\u552f\u4e00\u7684\u6570\u5b57\u6765\u6807\u8bc6\uff0c\u79f0\u4e3a\u5b83\u7684 \u5730\u5740 (address)\u3002", 
            "title": "1 \u4fe1\u606f\u5b58\u50a8"
        }, 
        {
            "location": "/csapp/ch2/#_1", 
            "text": "\u4e00\u4e2a\u5b57\u8282\u75318\u4f4d\u7ec4\u6210\u3002\u5728\u4e8c\u8fdb\u5236\u8868\u793a\u6cd5\u4e2d\uff0c\u5b83\u7684\u503c\u57df\u662f 00000000_2\\sim 11111111_2 00000000_2\\sim 11111111_2 \u3002\u5982\u679c\u770b\u6210\u5341\u8fdb\u5236\u6570\uff0c\u5b83\u7684\u503c\u57df\u662f 0_{10}\\sim 255_{10} 0_{10}\\sim 255_{10} \u3002  \u8fd9\u4e24\u79cd\u7b26\u53f7\u8868\u8ff0\u6cd5\u5bf9\u4e8e\u63cf\u8ff0\u4f4d\u6a21\u5f0f\u6765\u8bf4\u90fd\u4e0d\u662f\u975e\u5e38\u65b9\u4fbf\u3002   \u4e8c\u8fdb\u5236\u8868\u793a\u6cd5\u592a\u5197\u957f\uff1b  \u5341\u8fdb\u5236\u8868\u793a\u6cd5\u4e0e\u4f4d\u6a21\u5f0f\u7684\u76f8\u4e92\u8f6c\u5316\u5f88\u9ebb\u70e6\u3002   \u66ff\u4ee3\u7684\u65b9\u6cd5\u662f\uff0c\u4ee516\u4e3a\u6280\u672f\uff0c\u4ee5\u5341\u516d\u8fdb\u5236(hexiademical)\u6570\u6765\u8868\u793a\u4f4d\u6a21\u5f0f\u3002", 
            "title": "\u5341\u516d\u8fdb\u5236\u8868\u793a\u6cd5"
        }, 
        {
            "location": "/csapp/ch2/#_2", 
            "text": "\u6bcf\u53f0\u8ba1\u7b97\u673a\u90fd\u6709\u2f00\u4e2a \u5b57\u2ed3 (word size)\uff0c\u6807\u660e\u6307\u9488\u6570\u636e\u7684 \u6807\u79f0\u5927\u5c0f (norminal size)\u3002\u5b57\u2ed3\u51b3\u5b9a\u7684\u6700\u91cd\u8981\u7684\u7cfb\u7edf\u53c2\u6570\u5c31\u662f\u865a\u62df\u7a7a\u95f4\u7684\u2f24\u2f29\u3002\u5bf9\u4e8e\u2f00\u4e2a\u5b57\u2ed3\u4e3a w w \u4f4d\u7684\u673a\u5668\u2f7d\u2f94\uff0c\u865a\u62df\u5730\u5740\u7684\u8303\u56f4\u4e3a 0\\sim 2^w\u22121 0\\sim 2^w\u22121 \u3002  C\u8bed\u8a00\u652f\u6301\u6574\u6570\u548c\u6d6e\u70b9\u6570\u7684\u591a\u79cd\u6570\u636e\u683c\u5f0f\u3002\u4e0b\u8868\u4e3aC\u8bed\u8a00\u5404\u79cd\u6570\u636e\u7c7b\u884c\u5206\u914d\u7684\u5b57\u8282\u6570\u3002", 
            "title": "\u5b57\u548c\u6570\u636e\u5927\u5c0f"
        }, 
        {
            "location": "/csapp/ch2/#_3", 
            "text": "\u8003\u8651\u4e00\u4e2a w w \u4f4d\u7684\u6574\u6570\uff0c\u5176\u4f4d\u8868\u793a\u4e3a [x_{w-1}, x_{w-2}, x_1, x_0] [x_{w-1}, x_{w-2}, x_1, x_0] \uff0c\u5176\u4e2d x_{w-1} x_{w-1} \u662f \u6700\u9ad8\u6709\u6548\u4f4d (the most significant bit)\uff0c\u800c x_0 x_0 \u662f \u6700\u4f4e\u6709\u6548\u4f4d (the least significant bit).  \u5047\u8bbe w w \u662f8\u7684\u500d\u6570\uff0c\u8fd9\u4e9b\u4f4d\u5c31\u80fd\u88ab\u5206\u7ec4\u6210\u5b57\u8282\uff0c\u5176\u4e2d \u6700\u9ad8\u6709\u6548\u5b57\u8282 (the most significant byte)\u5305\u542b\u4f4d [x_{w-1}, x_{w-2},..., x_{w-8}] [x_{w-1}, x_{w-2},..., x_{w-8}] \uff0c\u800c \u6700\u4f4e\u6709\u6548\u5b57\u8282 (the least significant byte)\u5305\u542b\u4f4d [x_7, x_6,..., x_0] [x_7, x_6,..., x_0] \uff0c\u5176\u4ed6\u5b57\u8282\u5305\u542b\u4e2d\u95f4\u7684\u4f4d\u3002  \u6709\u4e9b\u673a\u5668\u9009\u5728\u5728\u5185\u5b58\u4e2d\u6309\u7167\u4ece\u6700\u4f4e\u6709\u6548\u5b57\u8282\u5230\u6700\u9ad8\u6709\u6548\u5b57\u8282\u7684\u987a\u5e8f\u5b58\u50a8\u5bf9\u8c61\uff0c\u8fd9\u79cd\u65b9\u5f0f\u79f0\u4e3a \u5c0f\u7aef\u6cd5 (little endian). \u6700\u9ad8\u6709\u6548\u5b57\u8282\u5728\u524d\u9762\u7684\u65b9\u5f0f\uff0c\u79f0\u4e3a \u5927\u7aef\u6cd5 (big endian).    Note  \u5927\u591a\u6570Intel\u517c\u5bb9\u673a\u90fd\u53ea\u7528\u5c0f\u7aef\u6a21\u5f0f\u3002", 
            "title": "\u5bfb\u5740\u548c\u5b57\u8282\u987a\u5e8f"
        }, 
        {
            "location": "/csapp/ch2/#2", 
            "text": "", 
            "title": "2 \u6574\u6570\u8868\u793a"
        }, 
        {
            "location": "/csapp/ch3/", 
            "text": "Chapter 3 \u7a0b\u5e8f\u7684\u673a\u5668\u7ea7\u8868\u793a\n\n\n1 \u5386\u53f2\u89c2\u70b9\n\n\nIntel\u5904\u7406\u5668\u7cfb\u5217\u4fd7\u79f0x86\uff0c\u7ecf\u5386\u4e86\u4e00\u4e2a\u957f\u671f\u7684\u3001\u4e0d\u65ad\u8fdb\u5316\u7684\u53d1\u5c55\u8fc7\u7a0b\u3002\n\n\n\n\n8086(1978\u5e74\uff0c29K\u4e2a\u6676\u4f53\u7ba1)\u3002\u7b2c\u4e00\u4ee3\u5355\u82af\u7247\u300116\u4f4d\u5fae\u5904\u7406\u5668\u4e4b\u4e00\u3002\n\n\ni386(1985\u5e74\uff0c 275K\u4e2a\u6676\u4f53\u7ba1)\u3002\u5c06\u4f53\u7cfb\u7ed3\u6784\u6269\u5c55\u523032\u4f4d\u3002\n\n\nCore i7(2008\u5e74\uff0c781M\u4e2a\u6676\u4f53\u7ba1)\u3002\u652f\u6301\u8d85\u7ebf\u7a0b\u3001\u591a\u6838\u3002\n\n\n\n\nIntel\u5904\u7406\u5668\u7cfb\u5217\u6709\u597d\u51e0\u4e2a\u540d\u5b57\uff0c\u5305\u62ecIA32\uff0c\u4e5f\u5c31\u662f\u201cIntel 32\u4f4d\u4f53\u7cfb\u7ed3\u6784\u201d(Intel Architecture 32-bit)\uff0c\u4ee5\u53ca\u6700\u65b0\u7684Intel64\uff0c\u5373IA32\u768464\u4f4d\u6269\u5c55\uff0c\u4e5f\u79f0\u4e3ax86-64\u3002\n\n\n2 \u7a0b\u5e8f\u7f16\u7801\n\n\n\u5bf9\u4e8e\u673a\u5668\u7f16\u7a0b\u6765\u8bf4\uff0c\u5176\u4e2d\u4e24\u79cd\u62bd\u8c61\u5c24\u4e3a\u91cd\u8981\u3002\n\n\n\n\n\u6307\u4ee4\u96c6\u4f53\u7cfb\u7ed3\u6784(Instruction Set Architecture, ISA)\uff0c\u5b9a\u4e49\u4e86\u673a\u5668\u7ea7\u7a0b\u5e8f\u7684\u683c\u5f0f\u548c\u884c\u4e3a\uff0c\u5b83\u5b9a\u4e49\u4e86\u5904\u7406\u5668\u72b6\u6001\u3001\u6307\u4ee4\u7684\u683c\u5f0f\u4ee5\u53ca\u6bcf\u6761\u6307\u4ee4\u5bf9\u72b6\u6001\u7684\u5f71\u54cd\u3002\u5927\u591a\u6570ISA\uff0c\u5c06\u7a0b\u5e8f\u7684\u884c\u4e3a\u63cf\u8ff0\u6210\u597d\u50cf\u6bcf\u6761\u6307\u4ee4\u90fd\u662f\u6309\u987a\u5e8f\u6267\u884c\u7684\u3002\u5e38\u89c1\u7684ISA\u6709x86\u3001ARM v8\u3001MIPS\u3002\n\n\n\u865a\u62df\u5730\u5740\uff0c\u63d0\u4f9b\u7684\u5185\u5b58\u6a21\u578b\u770b\u4e0a\u53bb\u662f\u4e00\u4e2a\u975e\u5e38\u5927\u7684\u5b57\u8282\u6570\u7ec4\u3002\n\n\n\n\n3 \u6570\u636e\u683c\u5f0f\n\n\nIntel\u7528\u672f\u8bed\"\u5b57(word)\"\u8868\u793a16\u4f4d\u6570\u636e\u7c7b\u578b\uff0c32\u4f4d\u6570\u79f0\u4e3a\"\u53cc\u5b57(double words)\"\uff0c64\u4f4d\u6570\u79f0\u4e3a\"\u56db\u5b57(quad words)\"\u3002\n\n\n4 \u8bbf\u95ee\u4fe1\u606f\n\n\n\u4e00\u4e2ax86-64\u7684CPU\u5305\u542b\u4e00\u7ec416\u4e2a\u5b58\u50a864\u4f4d\u503c\u7684\n\u901a\u7528\u76ee\u7684\u5bc4\u5b58\u5668\n\uff0c\u7528\u6765\u5b58\u50a8\u6574\u6570\u6570\u636e\u548c\u6307\u9488\u3002\n\n\n\n\n4.1 \u64cd\u4f5c\u6570\u6307\u793a\u7b26\n\n\n\u5927\u591a\u6570\u6307\u4ee4\u6709\u4e00\u4e2a\u6216\u591a\u4e2a\u64cd\u4f5c\u6570(operand)\uff0c\u6307\u793a\u51fa\u6267\u884c\u4e00\u4e2a\u64cd\u4f5c\u4e2d\u8981\u4f7f\u7528\u7684\u6e90\u6570\u636e\u503c\uff0c\u4ee5\u53ca\u653e\u7f6e\u7ed3\u679c\u7684\u76ee\u7684\u4f4d\u7f6e\u3002x86-64\u652f\u6301\u591a\u79cd\u64cd\u4f5c\u6570\u683c\u5f0f\uff1a\n\n\n\n\n\u7acb\u5373\u6570(immediate)\uff0c\u7528\u6765\u8868\u793a\u5e38\u6570\u503c\u3002\u4e66\u5199\u65b9\u5f0f\u662f$\u540e\u9762\u8ddf\u4e00\u4e2a\u6574\u6570\n\n\n\u5bc4\u5b58\u5668(register)\uff0c\u8868\u793a\u67d0\u4e2a\u5bc4\u5b58\u5668\u7684\u5185\u5bb9\u3002\u7528\u7b26\u53f7\nr_a\nr_a\n\u6765\u8868\u793a\u4efb\u610f\u5bc4\u5b58\u5668\na\na\n\uff0c\u7528\u5f15\u7528\nR[r_a]\nR[r_a]\n\u8868\u793a\u5bc4\u5b58\u5668\u7684\u503c\n\n\n\u5185\u5b58\u5f15\u7528\u3002\u6839\u636e\u8ba1\u7b97\u51fa\u6765\u7684\u5730\u5740(\u901a\u5e38\u79f0\u4e3a\u6709\u6548\u5730\u5740)\u8bbf\u95ee\u67d0\u4e2a\u5185\u5b58\u4f4d\u7f6e\u3002\u56e0\u4e3a\u5c06\u5185\u5b58\u770b\u6210\u4e00\u4e2a\u5f88\u5927\u7684\u5b57\u8282\u6570\u7ec4\uff0c\u7528\u7b26\u53f7\nM_b[Addr]\nM_b[Addr]\n\u8868\u793a\u5bf9\u5b58\u50a8\u5728\u5185\u5b58\u4e2d\u4ece\u5730\u5740\nAdrr\nAdrr\n\u5f00\u59cb\u7684\nb\nb\n\u5b57\u8282\u503c\u7684\u5f15\u7528\u3002\n\n\n\n\n\n\n4.2 \u6570\u636e\u4f20\u9001\u6307\u4ee4\n\n\n\u6570\u636e\u4f20\u9001\u6307\u4ee4--MOV\u7c7b--\u628a\u6570\u636e\u4ece\u539f\u4f4d\u7f6e\u590d\u5236\u5230\u76ee\u7684\u4f4d\u7f6e\u3002MOV\u7c7b\u7531\u56db\u6761\u6307\u4ee4\u7ec4\u6210\uff1amovb\u3001movw\u3001movl\u3001movq\u3002\u8fd9\u4e9b\u6307\u4ee4\u90fd\u6267\u884c\u540c\u6837\u7684\u64cd\u4f5c\uff0c\u4e3b\u8981\u533a\u522b\u662f\u5b83\u4eec\u64cd\u4f5c\u7684\u6570\u636e\u5927\u5c0f\u4e0d\u540c\uff1a\u5206\u522b\u662f1\u30012\u30014\u548c8\u5b57\u8282\u3002\n\n\n\u6570\u636e\u4f20\u9001\u6307\u4ee4\u7684\u4e24\u4e2a\u64cd\u4f5c\u6570\u4e0d\u80fd\u90fd\u6307\u5411\u5185\u5b58\u4f4d\u7f6e\u3002\u5c06\u4e00\u4e2a\u503c\u4ece\u5185\u5b58\u4f4d\u7f6e\u590d\u5236\u5230\u53e6\u4e00\u4e2a\u5185\u5b58\u4f4d\u7f6e\u9700\u8981\u4e24\u6761\u6307\u4ee4 - \u7b2c\u4e00\u6761\u6307\u4ee4\u5c06\u6e90\u503c\u52a0\u8f7d\u5230\u5bc4\u5b58\u5668\u4e2d\uff0c\u7b2c\u4e8c\u6761\u6307\u4ee4\u5c06\u8be5\u5bc4\u5b58\u5668\u503c\u5199\u5165\u76ee\u7684\u4f4d\u7f6e\u3002\n\n\n\n\nMOVZ\u7c7b\u4e2d\u7684\u6307\u4ee4\u628a\u76ee\u7684\u4e2d\u5269\u4f59\u7684\u5b57\u8282\u586b\u5145\u4e3a0\uff1b\u800cMOVS\u7c7b\u4e2d\u7684\u6307\u4ee4\u901a\u8fc7\u7b26\u53f7\u6269\u5c55\u6765\u586b\u5145\uff0c\u5373\u628a\u6e90\u64cd\u4f5c\u6570\u7684\u6700\u9ad8\u4f4d\u8fdb\u884c\u590d\u5236\u3002\n\n\n4.3 \u538b\u5165\u548c\u5f39\u51fa\u6808\u6570\u636e\n\n\npushq\u6307\u4ee4\u628a\u6570\u636e\u538b\u5165\u5230\u6808\u4e0a\uff0c\u800cpopq\u6307\u4ee4\u5f39\u51fa\u6570\u636e\u3002\n\n\n\n\n5 \u7b97\u6570\u548c\u903b\u8f91\u64cd\u4f5c\n\n\n\u64cd\u4f5c\u88ab\u5206\u4e3a\u56db\u7ec4\uff1a\u52a0\u8f7d\u6709\u6548\u5730\u5740\u3001\u4e00\u5143\u64cd\u4f5c\u3001\u4e8c\u5143\u64cd\u4f5c\u548c\u79fb\u4f4d\u3002\n\n\n\n\n\u52a0\u8f7d\u6709\u6548\u5730\u5740\n(load effective address)\u6307\u4ee4leaq\u5b9e\u9645\u4e0a\u662fmovq\u6307\u4ee4\u7684\u53d8\u5f62\uff0c\u5c06\u6709\u6548\u5730\u5740\u5199\u5165\u5230\u76ee\u7684\u64cd\u4f5c\u6570\u3002\n\n\n\u53e6\u5916\u4e00\u4e2aleaq\u7684\u4f5c\u2f64\u5c31\u662f\u2f64\u6765\u4f5c\u4e3a\u7b97\u672f\u8fd0\u7b97\u3002\u4f8b\u5982\uff0c\u5982\u679c\u5bc4\u5b58\u5668\n%rdx\n\u7684\u503c\u4e3ax\uff0c\u90a3\u4e48\u6307\u4ee4\nleaq 7(%rdx, %rdx, 4), %rax\n\u5c06\u8bbe\u7f6e\u5bc4\u5b58\u5668\n%rax\n\u7684\u503c\u4e3a5x+7\u3002\n\n\n\u4e00\u5143\u64cd\u4f5c\u53ea\u6709\u4e00\u4e2a\u64cd\u4f5c\u6570\uff0c\u5373\u662f\u6e90\u53c8\u662f\u76ee\u7684\u3002\u8fd9\u4e2a\u64cd\u4f5c\u6570\u53ef\u4ee5\u662f\u4e00\u4e2a\u5bc4\u5b58\u5668\uff0c\u4e5f\u53ef\u4ee5\u662f\u4e00\u4e2a\u5185\u5b58\u4f4d\u7f6e\u3002\u6bd4\u5982\u8bf4\uff0c\u6307\u4ee4\nincq(%rsp)\n\u4f1a\u4f7f\u6808\u9876\u76848\u5b57\u8282\u5143\u7d20\u52a01\u3002\n\n\n6 \u63a7\u5236\n\n\n6.1 \u6761\u4ef6\u7801\n\n\n\u6761\u4ef6\u7801\n(condition code)\u5bc4\u5b58\u5668\uff0c\u63cf\u8ff0\u4e86\u6700\u8fd1\u7684\u7b97\u6570\u548c\u903b\u8f91\u64cd\u4f5c\u7684\u5c5e\u6027\u3002\u53ef\u4ee5\u68c0\u6d4b\u6761\u4ef6\u7801\u5bc4\u5b58\u5668\u6765\u6267\u884c\u6761\u4ef6\u5206\u652f\u6307\u4ee4\u3002\u6700\u5e38\u7528\u7684\u6761\u4ef6\u7801\u6709\uff1a\n\n\n\n\nCF\uff1a\u8fdb\u4f4d\u6807\u5fd7\u3002\u6700\u8fd1\u7684\u64cd\u4f5c\u4f7f\u6700\u9ad8\u4f4d\u4ea7\u751f\u4e86\u8fdb\u4f4d\u3002\u53ef\u4ee5\u7528\u6765\u68c0\u67e5\u65e0\u7b26\u53f7\u64cd\u4f5c\u7684\u6ea2\u51fa\u3002\n\n\nZF\uff1a\u96f6\u6807\u5fd7\u3002\u6700\u8fd1\u7684\u64cd\u4f5c\u5f97\u51fa\u7684\u7ed3\u679c\u4e3a0.\n\n\nSF\uff1a\u7b26\u53f7\u6807\u5fd7\u3002\u6700\u8fd1\u7684\u64cd\u4f5c\u5f97\u5230\u7684\u7ed3\u679c\u4e3a\u8d1f\u6570\u3002\n\n\nOF\uff1a\u6ea2\u51fa\u6807\u5fd7\u3002\u6700\u8fd1\u7684\u64cd\u4f5c\u5bfc\u81f4\u4e00\u4e2a\u8865\u7801\u6ea2\u51fa -- \u6b63\u6ea2\u51fa\u6216\u8d1f\u6ea2\u51fa\u3002\n\n\n\n\n\u9664\u4e86\u7b2c6\u5c0f\u8282\u6240\u63d0\u53ca\u7684\u6307\u4ee4\u4f1a\u8bbe\u7f6e\u6761\u4ef6\u7801\u4e4b\u5916\uff0c\u8fd8\u6709\u4e24\u7c7b\u6307\u4ee4\u53ea\u8bbe\u7f6e\u6761\u4ef6\u7801\u800c\u4e0d\u6539\u53d8\u4efb\u4f55\u5176\u4ed6\u5bc4\u5b58\u5668\u7684\u503c\uff0c\u8fd9\u4e24\u7c7b\u6307\u4ee4\u90fd\u652f\u6301\u56db\u79cd\u957f\u5ea6\u53d8\u79cd\u540e\u7f00(b, w, l, q)\n\n\n\n\n7 \u8fc7\u7a0b\n\n\n\u8fc7\u7a0b\n(procedure)\u662f\u8f6f\u4ef6\u4e2d\u4e00\u79cd\u5f88\u91cd\u8981\u7684\u62bd\u8c61\u3002\u5b83\u63d0\u4f9b\u4e86\u4e00\u79cd\u5c01\u88c5\u4ee3\u7801\u7684\u65b9\u5f0f\uff0c\u7528\u4e00\u7ec4\u5236\u5b9a\u7684\u53c2\u6570\u548c\u4e00\u4e2a\u53ef\u9009\u7684\u8fd4\u56de\u503c\u5b9e\u73b0\u4e86\u67d0\u8fd9\u529f\u80fd\u3002\u7136\u540e\uff0c\u53ef\u4ee5\u5728\u7a0b\u5e8f\u4e2d\u4e0d\u540c\u7684\u5730\u65b9\u8c03\u7528\u8fd9\u4e2a\u51fd\u6570\u3002\u4e0d\u540c\u7f16\u7a0b\u8bed\u8a00\u4e2d\uff0c\u8fc7\u7a0b\u7684\u5f62\u5f0f\u591a\u6837\uff1a\u51fd\u6570(function)\u3001\u65b9\u6cd5(method)\u3001\u5b50\u4f8b\u7a0b(subroutine)\u3001\u5904\u7406\u51fd\u6570(handler)\u7b49\u7b49\u3002\n\n\n\u5047\u8bbe\u8fc7\u7a0bP\u8c03\u7528\u8fc7\u7a0bQ\uff0cQ\u6267\u884c\u540e\u8fd4\u56de\u5230P\uff0c\u5305\u542b\u4e0b\u9762\u4e00\u4e2a\u6216\u591a\u4e2a\u673a\u5236\uff1a\n\n\n\n\n\u4f20\u9012\u63a7\u5236\u3002\u5728\u8fdb\u5165\u8fc7\u7a0bQ\u7684\u65f6\u5019\uff0c\u7a0b\u5e8f\u8ba1\u6570\u5668\u5fc5\u987b\u88ab\u8bbe\u7f6e\u4e3aQ\u7684\u4ee3\u7801\u7684\u8d77\u59cb\u5730\u5740\uff0c\u7136\u540e\u5728\u8fd4\u56de\u65f6\uff0c\u8981\u628a\u7a0b\u5e8f\u8ba1\u6570\u5668\u8bbe\u7f6e\u4e3aP\u4e2d\u8c03\u7528Q\u540e\u9762\u90a3\u6761\u6307\u4ee4\u7684\u5730\u5740\u3002\n\n\n\u4f20\u9012\u6570\u636e\u3002P\u5fc5\u987b\u80fd\u591f\u5411Q\u63d0\u4f9b\u4e00\u4e2a\u6216\u591a\u4e2a\u53c2\u6570\uff0cQ\u5fc5\u987b\u80fd\u591f\u5411P\u8fd4\u56de\u4e00\u4e2a\u503c\u3002\n\n\n\u5206\u914d\u548c\u91ca\u653e\u5185\u5b58\u3002\u5728\u5f00\u59cb\u65f6\uff0cQ\u53ef\u80fd\u9700\u8981\u4e3a\u5c40\u90e8\u53d8\u91cf\u5206\u914d\u7a7a\u95f4\uff0c\u800c\u5728\u8fd4\u56de\u524d\uff0c\u53c8\u5fc5\u987b\u91ca\u653e\u8fd9\u4e9b\u5b58\u50a8\u7a7a\u95f4\u3002\n\n\n\n\n7.1 \u8fd0\u884c\u65f6\u6808\n\n\n\u5728\u51fd\u6570\u8c03\u7528\u65f6\uff0c\u5f80\u5f80\u4f7f\u7528\u4e86\u6808(\nStack\n)\u8fd9\u4e00\u6570\u636e\u7ed3\u6784\u3002\u5f53x86-64\u8fc7\u7a0b\u9700\u8981\u7684\u5b58\u50a8\u7a7a\u95f4\u8d85\u51fa\u5bc4\u5b58\u5668\u80fd\u591f\u5b58\u653e\u7684\u5927\u5c0f\u65f6(\u610f\u5473\u7740\u5176\u5b9e\u5f88\u591a\u51fd\u6570\u6839\u672c\u4e0d\u9700\u8981\u5e27\u6808)\uff0c\u5c31\u4f1a\u5728\u6808\u4e0a\u5206\u914d\u7a7a\u95f4\uff0c\u79f0\u4e3a\n\u5e27\u6808\n(stack frame)\u3002\n\n\nCurrent Stack Frame (\u201cTop\u201d to Bottom) contains:\n\n\n\n\nArgument build(\u53c2\u6570\u6784\u9020\u533a):\n\n\nParameters for function about to call\n\n\n\u53ef\u4ee5\u901a\u8fc7\u5bc4\u5b58\u5668\u6700\u591a\u4f20\u90126\u4e2a\u6574\u5f62\u53c2\u6570\uff0c\u8d85\u51fa6\u4e2a\u90e8\u5206\u5c31\u8981\u901a\u8fc7\u6808\u6765\u4f20\u9012\n\n\n\n\n\n\nLocal variables(\u5c40\u90e8\u53d8\u91cf):\n\n\n\u5bc4\u5b58\u5668\u4e0d\u8db3\u591f\u5b58\u653e\u6240\u6709\u7684\u672c\u5730\u6570\u636e\n\n\n\u4f7f\u7528\u5730\u5740\u8fd0\u7b97\u7b26\n\uff0c\u5fc5\u987b\u80fd\u591f\u4ea7\u751f\u4e00\u4e2a\u5730\u5740\n\n\n\n\n\n\nSaved register context(\u88ab\u4fdd\u5b58\u7684\u5bc4\u5b58\u5668)\n\n\n\u4fdd\u5b58\u5bc4\u5b58\u5668\u7684\u503c\u5230\u6808\u4e2d\n\n\n\n\n\n\nOld frame pointer (optional)", 
            "title": "Chapter 3: \u7a0b\u5e8f\u7684\u673a\u5668\u7ea7\u8868\u793a"
        }, 
        {
            "location": "/csapp/ch3/#chapter-3", 
            "text": "", 
            "title": "Chapter 3 \u7a0b\u5e8f\u7684\u673a\u5668\u7ea7\u8868\u793a"
        }, 
        {
            "location": "/csapp/ch3/#1", 
            "text": "Intel\u5904\u7406\u5668\u7cfb\u5217\u4fd7\u79f0x86\uff0c\u7ecf\u5386\u4e86\u4e00\u4e2a\u957f\u671f\u7684\u3001\u4e0d\u65ad\u8fdb\u5316\u7684\u53d1\u5c55\u8fc7\u7a0b\u3002   8086(1978\u5e74\uff0c29K\u4e2a\u6676\u4f53\u7ba1)\u3002\u7b2c\u4e00\u4ee3\u5355\u82af\u7247\u300116\u4f4d\u5fae\u5904\u7406\u5668\u4e4b\u4e00\u3002  i386(1985\u5e74\uff0c 275K\u4e2a\u6676\u4f53\u7ba1)\u3002\u5c06\u4f53\u7cfb\u7ed3\u6784\u6269\u5c55\u523032\u4f4d\u3002  Core i7(2008\u5e74\uff0c781M\u4e2a\u6676\u4f53\u7ba1)\u3002\u652f\u6301\u8d85\u7ebf\u7a0b\u3001\u591a\u6838\u3002   Intel\u5904\u7406\u5668\u7cfb\u5217\u6709\u597d\u51e0\u4e2a\u540d\u5b57\uff0c\u5305\u62ecIA32\uff0c\u4e5f\u5c31\u662f\u201cIntel 32\u4f4d\u4f53\u7cfb\u7ed3\u6784\u201d(Intel Architecture 32-bit)\uff0c\u4ee5\u53ca\u6700\u65b0\u7684Intel64\uff0c\u5373IA32\u768464\u4f4d\u6269\u5c55\uff0c\u4e5f\u79f0\u4e3ax86-64\u3002", 
            "title": "1 \u5386\u53f2\u89c2\u70b9"
        }, 
        {
            "location": "/csapp/ch3/#2", 
            "text": "\u5bf9\u4e8e\u673a\u5668\u7f16\u7a0b\u6765\u8bf4\uff0c\u5176\u4e2d\u4e24\u79cd\u62bd\u8c61\u5c24\u4e3a\u91cd\u8981\u3002   \u6307\u4ee4\u96c6\u4f53\u7cfb\u7ed3\u6784(Instruction Set Architecture, ISA)\uff0c\u5b9a\u4e49\u4e86\u673a\u5668\u7ea7\u7a0b\u5e8f\u7684\u683c\u5f0f\u548c\u884c\u4e3a\uff0c\u5b83\u5b9a\u4e49\u4e86\u5904\u7406\u5668\u72b6\u6001\u3001\u6307\u4ee4\u7684\u683c\u5f0f\u4ee5\u53ca\u6bcf\u6761\u6307\u4ee4\u5bf9\u72b6\u6001\u7684\u5f71\u54cd\u3002\u5927\u591a\u6570ISA\uff0c\u5c06\u7a0b\u5e8f\u7684\u884c\u4e3a\u63cf\u8ff0\u6210\u597d\u50cf\u6bcf\u6761\u6307\u4ee4\u90fd\u662f\u6309\u987a\u5e8f\u6267\u884c\u7684\u3002\u5e38\u89c1\u7684ISA\u6709x86\u3001ARM v8\u3001MIPS\u3002  \u865a\u62df\u5730\u5740\uff0c\u63d0\u4f9b\u7684\u5185\u5b58\u6a21\u578b\u770b\u4e0a\u53bb\u662f\u4e00\u4e2a\u975e\u5e38\u5927\u7684\u5b57\u8282\u6570\u7ec4\u3002", 
            "title": "2 \u7a0b\u5e8f\u7f16\u7801"
        }, 
        {
            "location": "/csapp/ch3/#3", 
            "text": "Intel\u7528\u672f\u8bed\"\u5b57(word)\"\u8868\u793a16\u4f4d\u6570\u636e\u7c7b\u578b\uff0c32\u4f4d\u6570\u79f0\u4e3a\"\u53cc\u5b57(double words)\"\uff0c64\u4f4d\u6570\u79f0\u4e3a\"\u56db\u5b57(quad words)\"\u3002", 
            "title": "3 \u6570\u636e\u683c\u5f0f"
        }, 
        {
            "location": "/csapp/ch3/#4", 
            "text": "\u4e00\u4e2ax86-64\u7684CPU\u5305\u542b\u4e00\u7ec416\u4e2a\u5b58\u50a864\u4f4d\u503c\u7684 \u901a\u7528\u76ee\u7684\u5bc4\u5b58\u5668 \uff0c\u7528\u6765\u5b58\u50a8\u6574\u6570\u6570\u636e\u548c\u6307\u9488\u3002", 
            "title": "4 \u8bbf\u95ee\u4fe1\u606f"
        }, 
        {
            "location": "/csapp/ch3/#41", 
            "text": "\u5927\u591a\u6570\u6307\u4ee4\u6709\u4e00\u4e2a\u6216\u591a\u4e2a\u64cd\u4f5c\u6570(operand)\uff0c\u6307\u793a\u51fa\u6267\u884c\u4e00\u4e2a\u64cd\u4f5c\u4e2d\u8981\u4f7f\u7528\u7684\u6e90\u6570\u636e\u503c\uff0c\u4ee5\u53ca\u653e\u7f6e\u7ed3\u679c\u7684\u76ee\u7684\u4f4d\u7f6e\u3002x86-64\u652f\u6301\u591a\u79cd\u64cd\u4f5c\u6570\u683c\u5f0f\uff1a   \u7acb\u5373\u6570(immediate)\uff0c\u7528\u6765\u8868\u793a\u5e38\u6570\u503c\u3002\u4e66\u5199\u65b9\u5f0f\u662f$\u540e\u9762\u8ddf\u4e00\u4e2a\u6574\u6570  \u5bc4\u5b58\u5668(register)\uff0c\u8868\u793a\u67d0\u4e2a\u5bc4\u5b58\u5668\u7684\u5185\u5bb9\u3002\u7528\u7b26\u53f7 r_a r_a \u6765\u8868\u793a\u4efb\u610f\u5bc4\u5b58\u5668 a a \uff0c\u7528\u5f15\u7528 R[r_a] R[r_a] \u8868\u793a\u5bc4\u5b58\u5668\u7684\u503c  \u5185\u5b58\u5f15\u7528\u3002\u6839\u636e\u8ba1\u7b97\u51fa\u6765\u7684\u5730\u5740(\u901a\u5e38\u79f0\u4e3a\u6709\u6548\u5730\u5740)\u8bbf\u95ee\u67d0\u4e2a\u5185\u5b58\u4f4d\u7f6e\u3002\u56e0\u4e3a\u5c06\u5185\u5b58\u770b\u6210\u4e00\u4e2a\u5f88\u5927\u7684\u5b57\u8282\u6570\u7ec4\uff0c\u7528\u7b26\u53f7 M_b[Addr] M_b[Addr] \u8868\u793a\u5bf9\u5b58\u50a8\u5728\u5185\u5b58\u4e2d\u4ece\u5730\u5740 Adrr Adrr \u5f00\u59cb\u7684 b b \u5b57\u8282\u503c\u7684\u5f15\u7528\u3002", 
            "title": "4.1 \u64cd\u4f5c\u6570\u6307\u793a\u7b26"
        }, 
        {
            "location": "/csapp/ch3/#42", 
            "text": "\u6570\u636e\u4f20\u9001\u6307\u4ee4--MOV\u7c7b--\u628a\u6570\u636e\u4ece\u539f\u4f4d\u7f6e\u590d\u5236\u5230\u76ee\u7684\u4f4d\u7f6e\u3002MOV\u7c7b\u7531\u56db\u6761\u6307\u4ee4\u7ec4\u6210\uff1amovb\u3001movw\u3001movl\u3001movq\u3002\u8fd9\u4e9b\u6307\u4ee4\u90fd\u6267\u884c\u540c\u6837\u7684\u64cd\u4f5c\uff0c\u4e3b\u8981\u533a\u522b\u662f\u5b83\u4eec\u64cd\u4f5c\u7684\u6570\u636e\u5927\u5c0f\u4e0d\u540c\uff1a\u5206\u522b\u662f1\u30012\u30014\u548c8\u5b57\u8282\u3002  \u6570\u636e\u4f20\u9001\u6307\u4ee4\u7684\u4e24\u4e2a\u64cd\u4f5c\u6570\u4e0d\u80fd\u90fd\u6307\u5411\u5185\u5b58\u4f4d\u7f6e\u3002\u5c06\u4e00\u4e2a\u503c\u4ece\u5185\u5b58\u4f4d\u7f6e\u590d\u5236\u5230\u53e6\u4e00\u4e2a\u5185\u5b58\u4f4d\u7f6e\u9700\u8981\u4e24\u6761\u6307\u4ee4 - \u7b2c\u4e00\u6761\u6307\u4ee4\u5c06\u6e90\u503c\u52a0\u8f7d\u5230\u5bc4\u5b58\u5668\u4e2d\uff0c\u7b2c\u4e8c\u6761\u6307\u4ee4\u5c06\u8be5\u5bc4\u5b58\u5668\u503c\u5199\u5165\u76ee\u7684\u4f4d\u7f6e\u3002   MOVZ\u7c7b\u4e2d\u7684\u6307\u4ee4\u628a\u76ee\u7684\u4e2d\u5269\u4f59\u7684\u5b57\u8282\u586b\u5145\u4e3a0\uff1b\u800cMOVS\u7c7b\u4e2d\u7684\u6307\u4ee4\u901a\u8fc7\u7b26\u53f7\u6269\u5c55\u6765\u586b\u5145\uff0c\u5373\u628a\u6e90\u64cd\u4f5c\u6570\u7684\u6700\u9ad8\u4f4d\u8fdb\u884c\u590d\u5236\u3002", 
            "title": "4.2 \u6570\u636e\u4f20\u9001\u6307\u4ee4"
        }, 
        {
            "location": "/csapp/ch3/#43", 
            "text": "pushq\u6307\u4ee4\u628a\u6570\u636e\u538b\u5165\u5230\u6808\u4e0a\uff0c\u800cpopq\u6307\u4ee4\u5f39\u51fa\u6570\u636e\u3002", 
            "title": "4.3 \u538b\u5165\u548c\u5f39\u51fa\u6808\u6570\u636e"
        }, 
        {
            "location": "/csapp/ch3/#5", 
            "text": "\u64cd\u4f5c\u88ab\u5206\u4e3a\u56db\u7ec4\uff1a\u52a0\u8f7d\u6709\u6548\u5730\u5740\u3001\u4e00\u5143\u64cd\u4f5c\u3001\u4e8c\u5143\u64cd\u4f5c\u548c\u79fb\u4f4d\u3002   \u52a0\u8f7d\u6709\u6548\u5730\u5740 (load effective address)\u6307\u4ee4leaq\u5b9e\u9645\u4e0a\u662fmovq\u6307\u4ee4\u7684\u53d8\u5f62\uff0c\u5c06\u6709\u6548\u5730\u5740\u5199\u5165\u5230\u76ee\u7684\u64cd\u4f5c\u6570\u3002  \u53e6\u5916\u4e00\u4e2aleaq\u7684\u4f5c\u2f64\u5c31\u662f\u2f64\u6765\u4f5c\u4e3a\u7b97\u672f\u8fd0\u7b97\u3002\u4f8b\u5982\uff0c\u5982\u679c\u5bc4\u5b58\u5668 %rdx \u7684\u503c\u4e3ax\uff0c\u90a3\u4e48\u6307\u4ee4 leaq 7(%rdx, %rdx, 4), %rax \u5c06\u8bbe\u7f6e\u5bc4\u5b58\u5668 %rax \u7684\u503c\u4e3a5x+7\u3002  \u4e00\u5143\u64cd\u4f5c\u53ea\u6709\u4e00\u4e2a\u64cd\u4f5c\u6570\uff0c\u5373\u662f\u6e90\u53c8\u662f\u76ee\u7684\u3002\u8fd9\u4e2a\u64cd\u4f5c\u6570\u53ef\u4ee5\u662f\u4e00\u4e2a\u5bc4\u5b58\u5668\uff0c\u4e5f\u53ef\u4ee5\u662f\u4e00\u4e2a\u5185\u5b58\u4f4d\u7f6e\u3002\u6bd4\u5982\u8bf4\uff0c\u6307\u4ee4 incq(%rsp) \u4f1a\u4f7f\u6808\u9876\u76848\u5b57\u8282\u5143\u7d20\u52a01\u3002", 
            "title": "5 \u7b97\u6570\u548c\u903b\u8f91\u64cd\u4f5c"
        }, 
        {
            "location": "/csapp/ch3/#6", 
            "text": "", 
            "title": "6 \u63a7\u5236"
        }, 
        {
            "location": "/csapp/ch3/#61", 
            "text": "\u6761\u4ef6\u7801 (condition code)\u5bc4\u5b58\u5668\uff0c\u63cf\u8ff0\u4e86\u6700\u8fd1\u7684\u7b97\u6570\u548c\u903b\u8f91\u64cd\u4f5c\u7684\u5c5e\u6027\u3002\u53ef\u4ee5\u68c0\u6d4b\u6761\u4ef6\u7801\u5bc4\u5b58\u5668\u6765\u6267\u884c\u6761\u4ef6\u5206\u652f\u6307\u4ee4\u3002\u6700\u5e38\u7528\u7684\u6761\u4ef6\u7801\u6709\uff1a   CF\uff1a\u8fdb\u4f4d\u6807\u5fd7\u3002\u6700\u8fd1\u7684\u64cd\u4f5c\u4f7f\u6700\u9ad8\u4f4d\u4ea7\u751f\u4e86\u8fdb\u4f4d\u3002\u53ef\u4ee5\u7528\u6765\u68c0\u67e5\u65e0\u7b26\u53f7\u64cd\u4f5c\u7684\u6ea2\u51fa\u3002  ZF\uff1a\u96f6\u6807\u5fd7\u3002\u6700\u8fd1\u7684\u64cd\u4f5c\u5f97\u51fa\u7684\u7ed3\u679c\u4e3a0.  SF\uff1a\u7b26\u53f7\u6807\u5fd7\u3002\u6700\u8fd1\u7684\u64cd\u4f5c\u5f97\u5230\u7684\u7ed3\u679c\u4e3a\u8d1f\u6570\u3002  OF\uff1a\u6ea2\u51fa\u6807\u5fd7\u3002\u6700\u8fd1\u7684\u64cd\u4f5c\u5bfc\u81f4\u4e00\u4e2a\u8865\u7801\u6ea2\u51fa -- \u6b63\u6ea2\u51fa\u6216\u8d1f\u6ea2\u51fa\u3002   \u9664\u4e86\u7b2c6\u5c0f\u8282\u6240\u63d0\u53ca\u7684\u6307\u4ee4\u4f1a\u8bbe\u7f6e\u6761\u4ef6\u7801\u4e4b\u5916\uff0c\u8fd8\u6709\u4e24\u7c7b\u6307\u4ee4\u53ea\u8bbe\u7f6e\u6761\u4ef6\u7801\u800c\u4e0d\u6539\u53d8\u4efb\u4f55\u5176\u4ed6\u5bc4\u5b58\u5668\u7684\u503c\uff0c\u8fd9\u4e24\u7c7b\u6307\u4ee4\u90fd\u652f\u6301\u56db\u79cd\u957f\u5ea6\u53d8\u79cd\u540e\u7f00(b, w, l, q)", 
            "title": "6.1 \u6761\u4ef6\u7801"
        }, 
        {
            "location": "/csapp/ch3/#7", 
            "text": "\u8fc7\u7a0b (procedure)\u662f\u8f6f\u4ef6\u4e2d\u4e00\u79cd\u5f88\u91cd\u8981\u7684\u62bd\u8c61\u3002\u5b83\u63d0\u4f9b\u4e86\u4e00\u79cd\u5c01\u88c5\u4ee3\u7801\u7684\u65b9\u5f0f\uff0c\u7528\u4e00\u7ec4\u5236\u5b9a\u7684\u53c2\u6570\u548c\u4e00\u4e2a\u53ef\u9009\u7684\u8fd4\u56de\u503c\u5b9e\u73b0\u4e86\u67d0\u8fd9\u529f\u80fd\u3002\u7136\u540e\uff0c\u53ef\u4ee5\u5728\u7a0b\u5e8f\u4e2d\u4e0d\u540c\u7684\u5730\u65b9\u8c03\u7528\u8fd9\u4e2a\u51fd\u6570\u3002\u4e0d\u540c\u7f16\u7a0b\u8bed\u8a00\u4e2d\uff0c\u8fc7\u7a0b\u7684\u5f62\u5f0f\u591a\u6837\uff1a\u51fd\u6570(function)\u3001\u65b9\u6cd5(method)\u3001\u5b50\u4f8b\u7a0b(subroutine)\u3001\u5904\u7406\u51fd\u6570(handler)\u7b49\u7b49\u3002  \u5047\u8bbe\u8fc7\u7a0bP\u8c03\u7528\u8fc7\u7a0bQ\uff0cQ\u6267\u884c\u540e\u8fd4\u56de\u5230P\uff0c\u5305\u542b\u4e0b\u9762\u4e00\u4e2a\u6216\u591a\u4e2a\u673a\u5236\uff1a   \u4f20\u9012\u63a7\u5236\u3002\u5728\u8fdb\u5165\u8fc7\u7a0bQ\u7684\u65f6\u5019\uff0c\u7a0b\u5e8f\u8ba1\u6570\u5668\u5fc5\u987b\u88ab\u8bbe\u7f6e\u4e3aQ\u7684\u4ee3\u7801\u7684\u8d77\u59cb\u5730\u5740\uff0c\u7136\u540e\u5728\u8fd4\u56de\u65f6\uff0c\u8981\u628a\u7a0b\u5e8f\u8ba1\u6570\u5668\u8bbe\u7f6e\u4e3aP\u4e2d\u8c03\u7528Q\u540e\u9762\u90a3\u6761\u6307\u4ee4\u7684\u5730\u5740\u3002  \u4f20\u9012\u6570\u636e\u3002P\u5fc5\u987b\u80fd\u591f\u5411Q\u63d0\u4f9b\u4e00\u4e2a\u6216\u591a\u4e2a\u53c2\u6570\uff0cQ\u5fc5\u987b\u80fd\u591f\u5411P\u8fd4\u56de\u4e00\u4e2a\u503c\u3002  \u5206\u914d\u548c\u91ca\u653e\u5185\u5b58\u3002\u5728\u5f00\u59cb\u65f6\uff0cQ\u53ef\u80fd\u9700\u8981\u4e3a\u5c40\u90e8\u53d8\u91cf\u5206\u914d\u7a7a\u95f4\uff0c\u800c\u5728\u8fd4\u56de\u524d\uff0c\u53c8\u5fc5\u987b\u91ca\u653e\u8fd9\u4e9b\u5b58\u50a8\u7a7a\u95f4\u3002", 
            "title": "7 \u8fc7\u7a0b"
        }, 
        {
            "location": "/csapp/ch3/#71", 
            "text": "\u5728\u51fd\u6570\u8c03\u7528\u65f6\uff0c\u5f80\u5f80\u4f7f\u7528\u4e86\u6808( Stack )\u8fd9\u4e00\u6570\u636e\u7ed3\u6784\u3002\u5f53x86-64\u8fc7\u7a0b\u9700\u8981\u7684\u5b58\u50a8\u7a7a\u95f4\u8d85\u51fa\u5bc4\u5b58\u5668\u80fd\u591f\u5b58\u653e\u7684\u5927\u5c0f\u65f6(\u610f\u5473\u7740\u5176\u5b9e\u5f88\u591a\u51fd\u6570\u6839\u672c\u4e0d\u9700\u8981\u5e27\u6808)\uff0c\u5c31\u4f1a\u5728\u6808\u4e0a\u5206\u914d\u7a7a\u95f4\uff0c\u79f0\u4e3a \u5e27\u6808 (stack frame)\u3002  Current Stack Frame (\u201cTop\u201d to Bottom) contains:   Argument build(\u53c2\u6570\u6784\u9020\u533a):  Parameters for function about to call  \u53ef\u4ee5\u901a\u8fc7\u5bc4\u5b58\u5668\u6700\u591a\u4f20\u90126\u4e2a\u6574\u5f62\u53c2\u6570\uff0c\u8d85\u51fa6\u4e2a\u90e8\u5206\u5c31\u8981\u901a\u8fc7\u6808\u6765\u4f20\u9012    Local variables(\u5c40\u90e8\u53d8\u91cf):  \u5bc4\u5b58\u5668\u4e0d\u8db3\u591f\u5b58\u653e\u6240\u6709\u7684\u672c\u5730\u6570\u636e  \u4f7f\u7528\u5730\u5740\u8fd0\u7b97\u7b26 \uff0c\u5fc5\u987b\u80fd\u591f\u4ea7\u751f\u4e00\u4e2a\u5730\u5740    Saved register context(\u88ab\u4fdd\u5b58\u7684\u5bc4\u5b58\u5668)  \u4fdd\u5b58\u5bc4\u5b58\u5668\u7684\u503c\u5230\u6808\u4e2d    Old frame pointer (optional)", 
            "title": "7.1 \u8fd0\u884c\u65f6\u6808"
        }, 
        {
            "location": "/csapp/ch4/", 
            "text": "Chapter 4 \u5904\u7406\u5668\u4f53\u7cfb\u7ed3\u6784", 
            "title": "Chapter 4: \u5904\u7406\u5668\u4f53\u7cfb\u7ed3\u6784"
        }, 
        {
            "location": "/csapp/ch4/#chapter-4", 
            "text": "", 
            "title": "Chapter 4 \u5904\u7406\u5668\u4f53\u7cfb\u7ed3\u6784"
        }, 
        {
            "location": "/csapp/ch5/", 
            "text": "Chapter 5 \u4f18\u5316\u7a0b\u5e8f\u6027\u80fd", 
            "title": "Chapter 5: \u4f18\u5316\u7a0b\u5e8f\u6027\u80fd"
        }, 
        {
            "location": "/csapp/ch5/#chapter-5", 
            "text": "", 
            "title": "Chapter 5 \u4f18\u5316\u7a0b\u5e8f\u6027\u80fd"
        }, 
        {
            "location": "/csapp/ch6/", 
            "text": "Chapter 6 \u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784\n\n\n\u5b58\u50a8\u5668\u7cfb\u7edf\n(memory system)\u662f\u4e00\u4e2a\u5177\u6709\u4e0d\u540c \n\u5bb9\u91cf\n \u3001 \n\u6210\u672c\n \u548c \n\u8bbf\u95ee\u65f6\u95f4\n \u7684\u5b58\u50a8\u8bbe\u5907\u7684\u5c42\u6b21\u7ed3\u6784\u3002\n\n\n\u5c40\u90e8\u6027\n(locality)\uff1a\u5177\u6709\u826f\u597d\u5c40\u90e8\u6027\u7684\u7a0b\u5e8f\u503e\u5411\u4e8e\u4e00\u6b21\u53c8\u4e00\u6b21\u5730\u8bbf\u95ee\u76f8\u540c\u7684\u6570\u636e\u9879\u96c6\u5408\uff0c\u6216\u662f\u503e\u5411\u4e8e\u8bbf\u95ee\u90bb\u8fd1\u7684\u6570\u636e\u9879\u96c6\u5408\u3002\n\n\n1 \u5b58\u50a8\u6280\u672f\n\n\n\u968f\u673a\u8bbf\u95ee\u5b58\u50a8\u5668\n\n\n\u968f\u673a\u8bbf\u95ee\u5b58\u50a8\u5668\n(Random-Access Memory, RAM)\u5206\u4e3a\u4e24\u7c7b\uff1a\n\u9759\u6001\n(SRAM)\u548c\n\u52a8\u6001\n(DRAM)\u7684\u3002\n\n\n\n\nSRAM\u6bd4DRAM\u66f4\u5feb\uff0c\u4f46\u4e5f\u8d35\u5f97\u591a\u3002\n\n\nSRAM\u7528\u6765\u4f5c\u4e3a\u9ad8\u901f\u7f13\u5b58\u5b58\u50a8\u5668\u3002\n\n\nDRAM\u7528\u6765\u4f5c\u4e3a\u4e3b\u5b58\u4ee5\u53ca\u56fe\u5f62\u7cfb\u7edf\u7684\u6862\u7f13\u51b2\u533a\u3002\n\n\nSRAM\u4e00\u822c\u4e0d\u4f1a\u8d85\u8fc7\u51e0\u5146\u5b57\u8282\u3002\n\n\nDRAM\u6709\u51e0\u767e\u6216\u51e0\u5343\u5146\u5b57\u8282\u3002\n\n\n\n\n\u78c1\u76d8\u5b58\u50a8\n\n\n\u78c1\u76d8\u662f\u7531\n\u76d8\u7247\n(platter)\u6784\u6210\u7684\u3002\u6bcf\u4e2a\u76d8\u7247\u5982\u540c\u5207\u897f\u74dc\u4e00\u6837\u88ab\u201c\u5207\u201d\u6210\u4e00\u5757\u4e00\u5757\u7684\u6247\u9762\uff0c\u540c\u65f6\u6cbf\u7740\u534a\u5f84\u7684\u65b9\u5411\u88ab\u5212\u5206\u6210\u4e86\u4e00\u7ec4\u540c\u5fc3\u5706(\n\u78c1\u9053\n, track)\uff0c\u6bcf\u6761\u78c1\u9053\u88ab\u6247\u9762\u5207\u6210\u5f88\u591a\u7684\u6247\u5f62\u533a\u57df\u53eb\u505a\n\u6247\u533a\n\uff08sector, \u6247\u533a\u662f\u4ece\u78c1\u76d8\u8bfb\u51fa\u548c\u5199\u5165\u4fe1\u606f\u7684\u6700\u5c0f\u5355\u4f4d\uff0c\u5305\u542b\u76f8\u7b49\u6570\u91cf\u7684\u6570\u636e\u4f4d\uff0c\u901a\u5e38\u4e3a512\u5b57\u8282\uff09\uff0c\u4e0d\u540c\u76d8\u7247\u4e0a\u7684\u540c\u534a\u5f84\u78c1\u9053\u7ec4\u6210\u4e86\u67f1\u9762\u3002\n\n\n\n\n\u78c1\u76d8\u7684\u5bb9\u91cf\uff1a \u78c1\u5934\u6570 \u00d7 \u78c1\u9053\u6570 \u00d7 \u6bcf\u9053\u6247\u533a\u6570 \u00d7 \u6bcf\u6247\u533a\u5b57\u8282\u6570\n\n\n\u56fa\u6001\u786c\u76d8\n\n\n\u56fa\u6001\u786c\u76d8\n(Solid State Disk, SSD)\uff0c\u7531\u4e00\u4e2a\u6216\u591a\u4e2a\u95ea\u5b58\u82af\u7247\u548c\u95ea\u5b58\u7ffb\u8bd1\u5c42(flash translation layer)\u7ec4\u6210\u3002\n\n\n\n\n\u95ea\u5b58\u82af\u7247\u5b58\u50a8\u5185\u5bb9\u3002\n\n\n\u95ea\u5b58\u7ffb\u8bd1\u5c42\u5bf9\u903b\u8f91\u5757\u7684\u8bf7\u6c42\u7ffb\u8bd1\u6210\u5bf9\u5e95\u5c42\u7269\u7406\u8bbe\u5907\u7684\u8bbf\u95ee\u3002\n\n\n\n\n\n\n2 \u5c40\u90e8\u6027\n\n\n\u4e00\u4e2a\u7f16\u5199\u826f\u597d\u7684\u8ba1\u7b97\u673a\u7a0b\u5e8f\u5e38\u5e38\u5177\u6709\u826f\u597d\u7684\n\u5c40\u90e8\u6027\n(locality)\u3002\u4e5f\u5c31\u662f\uff0c\u5b83\u4eec\u503e\u5411\u4e8e\u5f15\u7528\n\u90bb\u8fd1\u4e8e\n\u5176\u4ed6\u6700\u8fd1\u5f15\u7528\u8fc7\u7684\u6570\u636e\u9879\u7684\u6570\u636e\u9879(\n\u7a7a\u95f4\u5c40\u90e8\u6027\n)\uff0c\u6216\u8005\n\u6700\u8fd1\n\u5f15\u7528\u8fc7\u7684\u6570\u636e\u9879\u672c\u8eab(\n\u65f6\u95f4\u5c40\u90e8\u6027\n)\u3002 \u8fd9\u79cd\u503e\u5411\u6027\uff0c\u88ab\u79f0\u4e3a\n\u5c40\u90e8\u6027\u539f\u7406\n(principle of locality)\u6216\u8bbf\n\u95ee\u5c40\u90e8\u6027\n(locality of reference)\u3002\n\n\n\u6709\u826f\u597d\u5c40\u90e8\u6027\u7684\u7a0b\u5e8f\u6bd4\u5c40\u90e8\u6027\u5dee\u7684\u7a0b\u5e8f\u8fd0\u884c\u5f97\u66f4\u5feb\u3002\u73b0\u4ee3\u8ba1\u7b97\u673a\u7cfb\u7edf\u7684\u5404\u4e2a\u5c42\u6b21\uff0c\u4ece\u786c\u4ef6\u5230\u64cd\u4f5c\u7cfb\u7edf\u3001\u518d\u5230\u5e94\u7528\u7a0b\u5e8f\uff0c\u5b83\u4eec\u7684\u8bbe\u8ba1\u90fd\u5229\u7528\u4e86\u5c40\u90e8\u6027\u3002\n\n\n\n\n\u5728\u786c\u4ef6\u5c42\uff0c\u901a\u8fc7\u5f15\u5165\u9ad8\u901f\u7f13\u5b58\u6765\u4fdd\u5b58\u6700\u8fd1\u88ab\u5f15\u7528\u7684\u6307\u4ee4\u548c\u6570\u636e\u9879\uff0c\u4ece\u800c\u63d0\u9ad8\u8d2e\u5b58\u7684\u8bbf\u95ee\u901f\u5ea6\u3002\n\n\n\u5728\u64cd\u4f5c\u7cfb\u7edf\u7ea7\uff0c\u7cfb\u7edf\u4f7f\u7528\u4e3b\u5b58\u4f5c\u4e3a\u865a\u62df\u5730\u5740\u7a7a\u95f4\u6700\u8fd1\u88ab\u5f15\u7528\u5757\u7684\u9ad8\u901f\u7f13\u5b58\u3002\n\n\nWeb\u6d4f\u89c8\u5668\u5c06\u6700\u8fd1\u88ab\u5f15\u7528\u7684\u6587\u6863\u653e\u5728\u672c\u5730\u78c1\u76d8\u4e0a\u3002\n\n\n\n\n\u91cf\u5316\u8bc4\u4ef7\u7a0b\u5e8f\u4e2d\u5c40\u90e8\u6027\u7684\u4e00\u4e9b\u7b80\u5355\u539f\u5219\uff1a\n\n\n\n\n\u91cd\u590d\u5f15\u7528\u76f8\u540c\u53d8\u91cf\u7684\u7a0b\u5e8f\u5177\u6709\u826f\u597d\u7684\u65f6\u95f4\u5c40\u90e8\u6027\u3002\n\n\n\u5bf9\u4e8e\u5177\u6709\u6b65\u957f\u4e3a\nk\nk\n\u7684\u5f15\u7528\u6a21\u5f0f\u7684\u7a0b\u5e8f\uff0c\u6b65\u957f\u8d8a\u597d\uff0c\u7a7a\u95f4\u5c40\u90e8\u6027\u8d8a\u597d\u3002\n\n\n\u5bf9\u4e8e\u53d6\u6307\u4ee4\u6765\u8bf4\uff0c\u5faa\u73af\u6709\u597d\u7684\u65f6\u95f4\u548c\u7a7a\u95f4\u5c40\u90e8\u6027\u3002\n\n\n\n\n// for\u5faa\u73af\u4f53\u91cc\u7684\u6307\u4ee4\u662f\u6309\u7167\u8fde\u7eed\u7684\u987a\u5e8f\u6267\u884c\u7684\uff0c\u56e0\u6b64\u5faa\u73af\u5177\u6709\u826f\u597d\u7684\u7a7a\u95f4\u5c40\u90e8\u6027\u3002\u56e0\u4e3a\u5faa\u73af\u4f53\u4f1a\u88ab\u6267\u884c\u591a\u6b21\uff0c\u56e0\u6b64\u4e5f\u6709\u826f\u597d\u7684\u65f6\u95f4\u5c40\u90e8\u6027\u3002\n\n\nint\n \nsumvec\n(\nint\n \nv\n[\nN\n]){\n\n    \nint\n \ni\n,\n \nsum\n \n=\n \n0\n;\n\n    \nfor\n \n(\ni\n=\n0\n;\n \ni\n \nN\n;\n \ni\n++\n)\n\n        \nsum\n \n+=\n \nv\n[\ni\n];\n\n    \nreturn\n \nsum\n;\n\n\n}\n\n\n\n\n\n3 \u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784 Memory Hierarchy\n\n\n\u4e00\u822c\u800c\u8a00\uff0c\u4ece\u9ad8\u5c42\u5f80\u4f4e\u5c42\u8d70\uff0c\u5b58\u50a8\u8bbe\u5907\u53d8\u5f97\u66f4\u6162\u3001\u66f4\u4fbf\u5b9c\u548c\u66f4\u5927\u3002\n\n\n\n\n\u5728\u6700\u9ad8\u5c42(L0)\uff0c\u662f\u5c11\u91cf\u5feb\u901f\u7684CPU\u5bc4\u5b58\u5668\uff0cCPU\u53ef\u4ee5\u5728\u4e00\u4e2a\u65f6\u949f\u5468\u671f\u5185\u8bbf\u95ee\u5b83\u4eec\u3002\n\n\n\u63a5\u4e0b\u6765\u662f\u4e00\u4e2a\u6216\u591a\u4e2a\u5c0f\u578b\u5230\u4e2d\u578b\u7684\u57fa\u4e8eSRAM\u7684\u9ad8\u901f\u7f13\u5b58\u5b58\u50a8\u5668\uff0c\u53ef\u4ee5\u5728\u51e0\u4e2aCPU\u65f6\u949f\u5468\u671f\u5185\u8bbf\u95ee\u5b83\u4eec\u3002\n\n\n\u7136\u540e\u662f\u4e00\u4e2a\u5927\u7684\u57fa\u4e8eDRAM\u7684\u8d2e\u5b58\uff0c\u53ef\u4ee5\u5728\u51e0\u5341\u5230\u51e0\u767e\u4e2a\u65f6\u949f\u5468\u671f\u5185\u8bbf\u95ee\u5b83\u4eec\u3002\n\n\n\u63a5\u4e0b\u6765\u662f\u6162\u901f\u4f46\u5bb9\u91cf\u5f88\u5927\u7684\u672c\u5730\u78c1\u76d8\u3002\n\n\n\u6700\u540e\uff0c\u6709\u4e9b\u7cfb\u7edf\u5305\u62ec\u4e86\u8fdc\u7a0b\u670d\u52a1\u5668\u4e0a\u7684\u78c1\u76d8\uff0c\u8981\u901a\u8fc7\u7f51\u7edc\u6765\u8bbf\u95ee\u5b83\u4eec\u3002\n\n\n\n\n\n\n\u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784\u4e2d\u7684\u7f13\u5b58\n\n\n\u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784\u7684\u4e2d\u5fc3\u601d\u60f3\u662f\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\nk\nk\n\uff0c\u4f4d\u4e8e\nk\nk\n\u5c42\u7684\u66f4\u5feb\u66f4\u5c0f\u7684\u5b58\u50a8\u8bbe\u5907\u4f5c\u4e3a\u4f4d\u4e8e\nk+1\nk+1\n\u5c42\u7684\u66f4\u5927\u66f4\u6162\u7684\u5b58\u50a8\u8bbe\u5907\u7684\u7f13\u5b58\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u5c42\u6b21\u7ed3\u6784\u4e2d\u7684\u6bcf\u4e00\u5c42\u90fd\u7f13\u5b58\u6765\u81ea\u8f83\u4f4e\u4e00\u5c42\u7684\u6570\u636e\u5bf9\u8c61\u3002\n\n\n\n\n\u7b2c\nk+1\nk+1\n\u5c42\u7684\u5b58\u50a8\u5668\u88ab\u5212\u5206\u4e3a\u8fde\u7eed\u7684\u6570\u636e\u5bf9\u8c61\u7ec4\u5757(chunk)\uff0c\u79f0\u4e3a\u5757(block)\u3002\n\n\n\u6bcf\u4e2a\u5757\u90fd\u6709\u4e00\u4e2a\u552f\u4e00\u7684\u5730\u5740\u3002\n\n\n\u5757\u7684\u5927\u5c0f\u53ef\u4ee5\u662f\u56fa\u5b9a\u7684(\u901a\u5e38)\uff0c\u4e5f\u53ef\u4ee5\u662f\u53ef\u53d8\u7684(\u4f8b\u5982\u5b58\u50a8\u5728Web\u670d\u52a1\u5668\u4e0a\u7684HMTL\u6587\u4ef6).\n\n\n\u6570\u636e\u603b\u662f\u4ee5\u5757\u5927\u5c0f\u4e3a\u4f20\u9001\u5355\u5143\u5728\u7b2c\nk\nk\n\u5c42\u548c\u7b2c\nk+1\nk+1\n\u5c42\u4e4b\u95f4\u6765\u56de\u590d\u5236\u3002\u5728\u5c42\u6b21\u7ed3\u6784\u4e2d\u4efb\u4f55\u4e00\u5bf9\u76f8\u90bb\u7684\u5c42\u6b21\u4e4b\u95f4\u5757\u5927\u5c0f\u662f\u56fa\u5b9a\u7684(\u7b2c\nk\nk\n\u5c42\u548c\u7b2c\nk+1\nk+1\n\u5c42\u5757\u5927\u5c0f\u4e00\u81f4)\uff0c\u4f46\u662f\u5176\u4ed6\u7684\u5c42\u6b21\u5bf9\u4e4b\u95f4\u53ef\u4ee5\u6709\u4e0d\u540c\u7684\u5757\u5927\u5c0f\u3002\n\n\n\n\n\n\n\u5f53\u7a0b\u5e8f\u9700\u8981\u7b2c\nk+1\nk+1\n\u5c42\u7684\u67d0\u4e2a\u6570\u636e\u5bf9\u8c61\nd\nd\n\u65f6\uff0c\u5b83\u9996\u5148\u5728\u5f53\u524d\u5b58\u50a8\u5728\u7b2c\nk\nk\n\u5c42\u7684\u4e00\u4e2a\u5757\u4e2d\u67e5\u627e\nd\nd\n\u3002\u5982\u679c\nd\nd\n\u521a\u597d\u7f13\u5b58\u5728\u7b2c\nk\nk\n\u5c42\u4e2d\uff0c\u5373\n\u7f13\u5b58\u547d\u4e2d\n(cache hit)\uff0c\u5426\u5219\n\u7f13\u5b58\u4e0d\u547d\u4e2d\n(cache miss)\u3002\n\n\n\u73b0\u4ee3\u7cfb\u7edf\u4e2d\u5230\u5904\u90fd\u4f7f\u7528\u4e86\u7f13\u5b58\u3002\n\n\n\n\n4 \u9ad8\u901f\u7f13\u5b58\u5b58\u50a8\u5668\n\n\n\u901a\u7528\u7684\u9ad8\u901f\u7f13\u5b58\u5b58\u50a8\u5668\u7ec4\u7ec7\u7ed3\u6784\n\n\n\u8003\u8651\u4e00\u4e2a\u8ba1\u7b97\u673a\u7cfb\u7edf\uff0c\u5176\u4e2d\u6bcf\u4e2a\u5b58\u50a8\u5668\u5730\u5740\u6709\nm\nm\n\u4f4d\uff0c\u5f62\u6210$M=2^m \n\u4e2a\u4e0d\u540c\u7684\u5730\u5740\u3002\u8fd9\u6837\u4e00\u4e2a\u673a\u5668\u7684\u9ad8\u901f\u7f13\u5b58\u88ab\u7ec4\u7ec7\u6210\u4e00\u4e2a\u6709\n\u4e2a\u4e0d\u540c\u7684\u5730\u5740\u3002\u8fd9\u6837\u4e00\u4e2a\u673a\u5668\u7684\u9ad8\u901f\u7f13\u5b58\u88ab\u7ec4\u7ec7\u6210\u4e00\u4e2a\u6709\nS=2^s $\u4e2a\n\u9ad8\u901f\u7f13\u5b58\u7ec4\n(cache set)\u7684\u6570\u7ec4\u3002\n\n\n\n\n\u6bcf\u4e2a\u7ec4\u5305\u542b\nE\nE\n\u4e2a\n\u9ad8\u901f\u7f13\u5b58\u884c\n(cache line)\u3002\n\n\n\u6bcf\u4e2a\u884c\u662f\u7531\u4e00\u4e2a$B=2^b $\u5b57\u8282\u7684\u6570\u636e\u5757(block)\u7ec4\u6210\u7684\u3002\n\n\n\u4e00\u4e2a\n\u6709\u6548\u4f4d\n(valid bit)\u6307\u660e\u8fd9\u4e2a\u884c\u662f\u5426\u5305\u542b\u6709\u610f\u4e49\u7684\u4fe1\u606f\u3002\n\n\n\u6709\nt=m-(b+s)\nt=m-(b+s)\n\u4e2a\n\u6807\u8bb0\u4f4d\n(tag bit)\u552f\u4e00\u5730\u6807\u8bc6\u5b58\u50a8\u5728\u8fd9\u4e2a\u9ad8\u901f\u7f13\u5b58\u884c\u4e2d\u7684\u5757\u3002\n\n\n\n\n\n\n\u9ad8\u901f\u7f13\u5b58\u7684\u5927\u5c0f\nC\nC\n\u662f\u6307\u6240\u6709\u5757\u7684\u5927\u5c0f\u7684\u548c\uff0c\nC=S\\times E\\times B\nC=S\\times E\\times B\n.\n\n\n\n\n\u6bcf\u4e2a\u7ec4\u53ea\u6709\u4e00\u884c(\nE=1\nE=1\n)\u7684\u9ad8\u901f\u7f13\u5b58\u79f0\u4e3a\n\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\n\uff1b\n\n\n\u6bcf\u4e2a\u7ec4\u6709\u591a\u884c(\nE\n1\nE>1\n)\u7684\u9ad8\u901f\u7f13\u5b58\u79f0\u4e3a\n\u7ec4\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\n\uff1b\n\n\n\u4e00\u4e2a\u5305\u542b\u6240\u6709\u9ad8\u901f\u7f13\u5b58\u884c\u7684\u7ec4(\nE=C/B\nE=C/B\n)\uff0c\u79f0\u4e3a\n\u5168\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\n\u3002\n\n\n\n\n\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\n\n\n\u6bcf\u4e2a\u7ec4\u53ea\u6709\u4e00\u884c(\nE=1\nE=1\n)\u7684\u9ad8\u901f\u7f13\u5b58\u79f0\u4e3a\n\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\n(Direct-Mapped Caches)\u3002\n\n\n\n\n\u5047\u8bbe\u6211\u4eec\u6709\u8fd9\u6837\u4e00\u4e2a\u7cfb\u7edf\uff0c\u5b83\u6709\u4e00\u4e2aCPU\u3001\u4e00\u4e2a\u5bc4\u5b58\u5668\u6587\u4ef6\u3001\u4e00\u4e2aL1\u9ad8\u901f\u7f13\u5b58\u548c\u4e00\u4e2a\u4e3b\u5b58\u3002\u5f53CPU\u6267\u884c\u4e00\u6761\u8bfb\u5185\u5b58\u5b57\nw\nw\n\u7684\u6307\u4ee4\uff0c\u5b83\u5411L1\u9ad8\u901f\u7f13\u5b58\u8bf7\u6c42\u8fd9\u4e2a\u5b57\u3002\n\n\n\n\n\u5982\u679cL1\u9ad8\u901f\u7f13\u5b58\u6709\nw\nw\n\u7684\u4e00\u4e2a\u7f13\u5b58\u7684\u526f\u672c\uff0c\u90a3\u4e48\u5c31\u5f97\u5230L1\u9ad8\u901f\u7f13\u5b58\u547d\u4e2d\u3002\u9ad8\u901f\u7f13\u5b58\u4f1a\u5f88\u5feb\u62bd\u53d6\u51fa\nw\nw\n\uff0c\u5e76\u5c06\u5b83\u8fd4\u56de\u7ed9CPU\u3002\n\n\n\u5426\u5219\u5c31\u662f\u7f13\u5b58\u4e0d\u547d\u4e2d\uff0cCPU\u5fc5\u987b\u7b49\u5f85\u88ab\u8bf7\u6c42\u7684\u5757\u6700\u7ec8\u4ece\u5185\u5b58\u8fbe\u5230\u65f6\uff0cL1\u9ad8\u901f\u7f13\u5b58\u5c06\u8fd9\u4e2a\u5757\u623f\u5b50\u5b83\u7684\u4e00\u4e2a\u9ad8\u901f\u7f13\u5b58\u884c\u91cc\uff0c\u4ece\u88ab\u5b58\u50a8\u7684\u5757\u4e2d\u62bd\u53d6\u51fa\u5b57\nw\nw\n\uff0c\u7136\u540e\u5c06\u5b83\u8fd4\u56de\u7ed9CPU\u3002\n\n\n\n\n\u9ad8\u901f\u7f13\u5b58\u786e\u5b9a\u4e00\u4e2a\u8bf7\u6c42\u662f\u5426\u547d\u4e2d\uff0c\u7136\u540e\u62bd\u53d6\u51fa\u88ab\u8bf7\u6c42\u7684\u5b57\u7684\u8fc7\u7a0b\uff0c\u5206\u4e3a\u4e09\u6b65\uff1a\n\n\n\n\n\u7ec4\u9009\u62e9(set selection)\n\n\n\u884c\u5339\u914d(line matching)\n\n\n\u5b57\u62bd\u53d6(word extraction)\n\n\n\n\n1.\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u4e2d\u7684\u7ec4\u9009\u62e9\n\n\n\u9ad8\u901f\u7f13\u5b58\u4ece\nw\nw\n\u7684\u5730\u5740\u4e2d\u95f4\u62bd\u53d6\u51fa\ns\ns\n\u4e2a\n\u7ec4\u7d22\u5f15\n(Set index)\u4f4d\u3002\n\n\n\n\n2.\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u4e2d\u7684\u884c\u5339\u914d\n\n\n\u7531\u4e8e\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u4e2d\u7684\u6bcf\u4e2a\u7ec4\u53ea\u6709\u4e00\u884c\uff0c\u56e0\u6b64\u5f53\u4e14\u4ec5\u5f53\u8bbe\u7f6e\u4e86\u6709\u6548\u4f4d(valid bit)\uff0c\u800c\u4e14\u9ad8\u901f\u7f13\u5b58\u884c\u4e2d\u7684\u6807\u8bb0(tag)\u4e0e\nw\nw\n\u7684\u5730\u5740\u4e2d\u7684\u6807\u8bb0\u76f8\u5339\u914d\u65f6\uff0c\u8fd9\u4e00\u884c\u4e2d\u5305\u542b\nw\nw\n\u7684\u4e00\u4e2a\u526f\u672c\u3002\n\n\n\n\n3.\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u4e2d\u7684\u5b57\u9009\u62e9\n\n\n\u4e00\u65e6\u547d\u4e2d\uff0c\u6211\u4eec\u77e5\u9053\nw\nw\n\u5c31\u5728\u8fd9\u4e2a\u5757\u4e2d\u7684\u67d0\u4e2a\u5730\u65b9\u3002\u6700\u540e\u4e00\u6b65\u786e\u5b9a\u6240\u9700\u8981\u7684\u5b57\u5728\u5757\u4e2d\u662f\u4ece\u54ea\u91cc\u5f00\u59cb\u7684\u3002\u5757\u504f\u79fb(block offset)\u63d0\u4f9b\u4e86\u6240\u9700\u8981\u7684\u5b57\u7684\u7b2c\u4e00\u4e2a\u5b57\u8282\u7684\u504f\u79fb\u3002\n\n\n4.\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u4e2d\u4e0d\u547d\u4e2d\u65f6\u7684\u884c\u66ff\u6362\n\n\n\u5982\u679c\u7f13\u5b58\u4e0d\u547d\u4e2d\uff0c\u90a3\u4e48\u5b83\u9700\u8981\u4ece\u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784\u7684\u4e0b\u4e00\u5c42\u53bb\u9664\u88ab\u8bf7\u6c42\u7684\u5757\uff0c\u7136\u540e\u5c06\u65b0\u7684\u5757\u5b58\u50a8\u5728\u7ec4\u7d22\u5f15\u4f4d\u6307\u793a\u7684\u7ec4\u4e2d\u7684\u4e00\u4e2a\u9ad8\u901f\u7f13\u5b58\u884c\u4e2d\u3002\n\n\n\n\n\u5982\u679c\u7ec4\u4e2d\u90fd\u662f\u6709\u6548\u9ad8\u901f\u7f13\u5b58\u884c\uff0c\u5219\u5fc5\u987b\u8981\u9a71\u9664\u51fa\u4e00\u4e2a\u73b0\u5b58\u7684\u884c\u3002\n\n\n\u5bf9\u4e8e\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u6765\u8bf4\uff0c\u6bcf\u4e2a\u7ec4\u53ea\u5305\u542b\u4e00\u884c\uff0c\u7528\u65b0\u53d6\u51fa\u7684\u884c\u66ff\u6362\u5f53\u524d\u7684\u884c\u3002\n\n\n\n\n5.\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u4e2d\u7684\u51b2\u7a81\u4e0d\u547d\u4e2d\n\n\n\u5f53\u7a0b\u5e8f\u8bbf\u95ee\u5927\u5c0f\u4e3a2\u7684\u5e42\u7684\u6570\u7ec4\u65f6\uff0c\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u901a\u5e38\u4f1a\u53d1\u751f\n\u51b2\u7a81\u4e0d\u547d\u4e2d\n(conflit miss)\u3002\u4f8b\u5982\uff0c\u8003\u8651\u4e00\u4e2a\u8ba1\u7b97\u4e24\u4e2a\u5411\u91cf\u70b9\u79ef\u7684\u51fd\u6570\uff1a\n\n\nfloat\n \ndotprod\n(\nfloat\n \nx\n[\n8\n],\n \nfloat\n \ny\n[\n8\n])\n \n{\n \n    \nfloat\n \nsum\n \n=\n \n0.0\n;\n \nint\n \ni\n;\n\n    \nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n \n8\n;\n \ni\n++\n)\n \n        \nsum\n \n+=\n \nx\n[\ni\n]\n \n*\n \ny\n[\ni\n];\n\n    \nreturn\n \nsum\n;\n\n\n}\n\n\n\n\n\n\u5047\u8bbe\u9ad8\u901f\u6df7\u5b58\u7531\u4e24\u4e2a\u7ec4\u7ec4\u6210\uff0c\u6bcf\u4e2a\u7ec4\u5bb9\u7eb34\u4e2a\u6d6e\u70b9\u6570\u3002\u6d6e\u70b9\u6570\u662f4\u4e2a\u5b57\u8282\uff0c\nx\nx\n\u88ab\u52a0\u8f7d\u5230\u4ece\u5730\u57400\u5f00\u59cb\u768432\u5b57\u8282\u8fde\u7eed\u5185\u5b58\u4e2d\uff0c\u800c\ny\ny\n\u7d27\u8ddf\u5728\nx\nx\n\u4e4b\u540e\uff0c\u4ece\u5730\u574032\u5f00\u59cb\u3002 \u6bcf\u4e2a\nx[i]\nx[i]\n\u548c\ny[i]\ny[i]\n\u4f1a\u6620\u5c04\u5230\u76f8\u540c\u7684\u9ad8\u901f\u7f13\u5b58\u7ec4\uff1a\n\n\n\n\n\n\n\u5728\u8fd0\u884c\u65f6\uff0c\u5faa\u73af\u7684\u7b2c\u4e00\u6b21\u8fed\u4ee3\u5f15\u7528\nx[0]\nx[0]\n\uff0c\u7f13\u5b58\u4e0d\u547d\u4e2d\u4f1a\u5bfc\u81f4\u5305\u542b\nx[0]-x[3]\nx[0]-x[3]\n\u7684\u5757\u88ab\u52a0\u8f7d\u5230\u7ec40.\n\n\n\u63a5\u4e0b\u6765\uff0c\u5f15\u7528\ny[0]\ny[0]\n\uff0c\u7f13\u5b58\u4e0d\u547d\u4e2d\u4f1a\u5bfc\u81f4\u5305\u542b\ny[0]-y[3]\ny[0]-y[3]\n\u7684\u5757\u88ab\u52a0\u8f7d\u5230\u7ec40\uff0c\u8986\u76d6\u524d\u4e00\u6b21\u5f15\u7528\u590d\u5236\u8fdb\u6765\u7684x\u7684\u503c\u3002\n\n\n\u5728\u4e0b\u4e00\u6b21\u8fed\u4ee3\u4e2d\uff0c\u5bf9\nx[1]\nx[1]\n\u7684\u5f15\u7528\u4e0d\u547d\u4e2d\uff0c\u5bfc\u81f4\nx[0]-x[3]\nx[0]-x[3]\n\u7684\u5757\u88ab\u91cd\u65b0\u52a0\u8f7d\u5230\u7ec40\uff0c\u8986\u76d6\u6389\ny[0]-y[3]\ny[0]-y[3]\n\u7684\u5757\u3002\n\n\n\n\n\u8fd9\u79cd\u73b0\u8c61\uff0c\n\u9ad8\u901f\u7f13\u5b58\u53cd\u590d\u5730\u52a0\u8f7d\u548c\u9a71\u9010\u76f8\u540c\u7684\u9ad8\u901f\u7f13\u5b58\u7ec4\n\uff0c\u53eb\u505a\n\u6296\u52a8\n(thrashing)\u3002\n\n\n\u7ec4\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\n\n\n\u7ec4\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\n(set associative cache)\u7684\u6bcf\u4e2a\u7ec4\u90fd\u4fdd\u5b58\u6709\u591a\u4e8e\u4e00\u4e2a\u7684\u9ad8\u901f\u7f13\u5b58\u884c\u3002\u4e00\u4e2a\n1\nE\nC/B\n1<E<C/B\n\u7684\u9ad8\u901f\u7f13\u5b58\u901a\u5e38\u79f0\u4e3a\nE\u8def\u7ec4\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\n(E-way set associative cache)\u3002\n\n\n\n\n1. \u7ec4\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\u4e2d\u7684\u7ec4\u9009\u62e9\n\n\n\u5b83\u7684\u7ec4\u9009\u62e9\u548c\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u7684\u7ec4\u9009\u62e9\u4e00\u6837\uff0c\u7ec4\u7d22\u5f15(set index)\u4f4d\u6807\u8bc6\u7ec4\u3002\n\n\n\n\n2. \u7ec4\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\u4e2d\u7684\u884c\u5339\u914d\u548c\u5b57\u9009\u62e9\n\n\n\u5b83\u5fc5\u987b\u68c0\u67e5\u591a\u4e2a\u884c\u7684\u6807\u8bb0\u4f4d\u548c\u6709\u6548\u4f4d\uff0c\u4ee5\u786e\u5b9a\u6240\u8bf7\u6c42\u7684\u5b57\u662f\u5426\u5728\u7ec4\u4e2d\u3002\n\n\n\u76f8\u8054\u5b58\u50a8\u5668\n(associative memory)\u662f\u4e00\u4e2a(key, value)\u5bf9\u7684\u6570\u7ec4\uff0c\u4ee5key\u4e3a\u8f93\u5165\uff0c\u8fd4\u56de\u4e0e\u8f93\u5165\u7684key\u76f8\u5339\u914d\u7684(key, value\uff09\u5bf9\u4e2d\u7684value\u503c\u3002\u6211\u4eec\u53ef\u4ee5\u628a\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\u7684\u6bcf\u4e2a\u7ec4\u770b\u6210\u4e00\u4e2a\u5c0f\u7684\u76f8\u8054\u5b58\u50a8\u5668\uff0ckey\u662f\u6807\u8bb0\u548c\u6709\u6548\u4f4d\uff0c\u800cvalue\u5c31\u662f\u5757\u7684\u5185\u5bb9\u3002\n\n\n\u7ec4\u4e2d\u7684\u4efb\u4f55\u4e00\u884c\u90fd\u53ef\u4ee5\u5305\u542b\u4efb\u4f55\u6620\u5c04\u5230\u8fd9\u4e2a\u7ec4\u7684\u5185\u5b58\u5757\u3002\u6240\u4ee5\u9ad8\u901f\u7f13\u5b58\u5fc5\u987b\u641c\u7d22\u7ec4\u4e2d\u7684\u6bcf\u4e00\u884c\uff0c\u5bfb\u627e\u4e00\u4e2a\u6709\u6548\u7684\u884c\uff0c\u5176\u6807\u8bb0\u4e0e\u5730\u5740\u4e2d\u7684\u6807\u8bb0\u76f8\u5339\u914d\u3002\u5982\u679c\u627e\u5230\u4e86\u8fd9\u6837\u4e00\u884c\uff0c\u90a3\u4e48\u5757\u504f\u79fb\u5c31\u4ece\u8fd9\u4e2a\u5757\u4e2d\u9009\u62e9\u4e00\u4e2a\u5b57\u3002\n\n\n\n\n3. \u7ec4\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\u4e2d\u4e0d\u547d\u4e2d\u65f6\u7684\u884c\u66ff\u6362\n\n\n\u5982\u679cCPU\u8bf7\u6c42\u7684\u5b57\u4e0d\u5728\u7ec4\u7684\u4efb\u4f55\u4e00\u884c\u4e2d\uff0c\u90a3\u4e48\u5c31\u662f\u7f13\u5b58\u4e0d\u547d\u4e2d\uff0c\u9ad8\u901f\u7f13\u5b58\u5fc5\u987b\u4ece\u5185\u5b58\u4e2d\u53d6\u51fa\u5305\u542b\u8fd9\u4e2a\u5b57\u7684\u5757\uff0c\u7136\u540e\u8fdb\u884c\u66ff\u6362\u3002\u8be5\u66ff\u6362\u54ea\u4e2a\u884c\u5462\uff1f\n\n\n\n\n\u5982\u679c\u7ec4\u4e2d\u6709\u4e00\u4e2a\u7a7a\u884c\uff0c\u90a3\u4e48\u5b83\u5c31\u662f\u4e2a\u5f88\u597d\u7684\u5019\u9009\u3002\n\n\n\u5982\u679c\u7ec4\u4e2d\u6ca1\u6709\u7a7a\u884c\uff0c\u5fc5\u987b\u4ece\u4e2d\u9009\u62e9\u4e00\u4e2a\u975e\u7a7a\u7684\u884c\u3002\u6709\u5982\u4e0b\u51e0\u4e2a\u66ff\u6362\u7b56\u7565\uff1a\n\n\n\u6700\u4e0d\u5e38\u4f7f\u7528\n(Least-Frequently-Used, LFU)\u7b56\u7565\u4f1a\u66ff\u6362\u5728\u8fc7\u53bb\u67d0\u4e2a\u65f6\u95f4\u7a97\u53e3\u5185\u5f15\u7528\u6b21\u6570\u6700\u5c11\u7684\u90a3\u4e00\u884c\u3002\n\n\n\u6700\u8fd1\u6700\u5c11\u4f7f\u7528\n(Least-Recently-Used, LRU)\u7b56\u7565\u4f1a\u66ff\u6362\u6700\u540e\u4e00\u4e2a\u8bbf\u95ee\u65f6\u95f4\u6700\u4e45\u8fdc\u7684\u90a3\u4e00\u884c\u3002 \n\n\n\n\n\n\n\n\n\u5168\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\n\n\n\u4e00\u4e2a\u5305\u542b\u6240\u6709\u9ad8\u901f\u7f13\u5b58\u884c\u7684\u7ec4(\nE=C/B\nE=C/B\n)\uff0c\u79f0\u4e3a\n\u5168\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\n\u3002 \u56e0\u4e3a\u9ad8\u901f\u7f13\u5b58\u7535\u8def\u5fc5\u987b\u5e76\u884c\u5730\u641c\u7d22\u8bb8\u591a\u76f8\u5339\u914d\u7684\u6807\u8bb0\uff0c\u6784\u9020\u4e00\u4e2a\u53c8\u5927\u53c8\u5feb\u7684\u5168\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\u5f88\u56f0\u96be\uff0c\u5e76\u4e14\u5f88\u6602\u8d35\u3002\u56e0\u6b64\uff0c\u5168\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\u53ea\u9002\u5408\u505a\u5c0f\u7684\u9ad8\u901f\u7f13\u5b58(\u4f8b\u5982MMC\u4e2d\u7684TLB)\u3002\n\n\n\n\n5 \u7f16\u5199\u9ad8\u901f\u7f13\u5b58\u53cb\u597d\u7684\u4ee3\u7801\n\n\n6 \u9ad8\u901f\u7f13\u5b58\u5bf9\u7a0b\u5e8f\u6027\u80fd\u7684\u5f71\u54cd\n\n\n\u5b58\u50a8\u5668\u5c71\n\n\n\u4e00\u4e2a\u7a0b\u5e8f\u4ece\u5b58\u50a8\u7cfb\u7edf\u4e2d\u8bfb\u6570\u636e\u7684\u901f\u7387\u79f0\u4e3a \n\u8bfb\u541e\u5410\u91cf\n(read throughput)\u3002\n\u5b58\u50a8\u5668\u5c71\n(memory mountain)\u662f\u4e00\u4e2a\u8bfb\u541e\u5410\u91cf\u7684\u65f6\u95f4\u548c\u7a7a\u95f4\u5c40\u90e8\u6027\u7684\u4e8c\u7ef4\u51fd\u6570\u3002\n\n\n\n\n\u901a\u8fc7\u4e0d\u540c\u7684size(\u5bf9\u5e94\u65f6\u95f4\u5c40\u90e8\u6027)\u548cstride(\u5bf9\u5e94\u7a7a\u95f4\u5c40\u90e8\u6027)\u7684\u503c\u4ea7\u751f\u5b58\u50a8\u5668\u5c71\u3002\n\n\nsize\u503c\u8d8a\u5c0f\uff0c\u5f97\u5230\u7684\u5de5\u4f5c\u96c6\u8d8a\u5c0f\uff0c\u65f6\u95f4\u5c40\u90e8\u6027\u8d8a\u597d\u3002\n\n\nstride\u503c\u8d8a\u5c0f\uff0c\u7a7a\u95f4\u5c40\u90e8\u6027\u8d8a\u597d\u3002\n\n\n\n\nIntel Core i7\u7684\u5b58\u50a8\u5668\u5c71\uff1a\n\n\n\n\nCore i7\u7684\u5b58\u50a8\u5668\u5c71\u5c55\u73b0\u4e86\u4e00\u4e2a\u5f88\u4e30\u5bcc\u7684\u7ed3\u6784\uff1a\n\n\n\n\n\u5782\u76f4\u4e8esize\u8f74\u7684\u662f\u56db\u6761\u5c71\u810a\uff0c\u5206\u522b\u5bf9\u5e94\u4e8e\u5b8c\u5168\u5728L1\u9ad8\u901f\u7f13\u5b58\u3001L2\u9ad8\u901f\u7f13\u5b58\u3001L3\u9ad8\u901f\u7f13\u5b58\u548c\u4e3b\u5b58\u5185\u7684\u65f6\u95f4\u5c40\u90e8\u6027\u533a\u57df\u3002\n\n\n\u5728L2\u3001L3\u548c\u4e3b\u5b58\u5c71\u810a\u4e0a\uff0c\u968f\u7740\u6b65\u957f\u7684\u589e\u52a0\uff0c\u6709\u4e00\u4e2a\u7a7a\u95f4\u5c40\u90e8\u6027\u7684\u659c\u5761\uff0c\u7a7a\u95f4\u5c40\u90e8\u6027\u4e0b\u964d\u3002", 
            "title": "Chapter 6: \u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784"
        }, 
        {
            "location": "/csapp/ch6/#chapter-6", 
            "text": "\u5b58\u50a8\u5668\u7cfb\u7edf (memory system)\u662f\u4e00\u4e2a\u5177\u6709\u4e0d\u540c  \u5bb9\u91cf  \u3001  \u6210\u672c  \u548c  \u8bbf\u95ee\u65f6\u95f4  \u7684\u5b58\u50a8\u8bbe\u5907\u7684\u5c42\u6b21\u7ed3\u6784\u3002  \u5c40\u90e8\u6027 (locality)\uff1a\u5177\u6709\u826f\u597d\u5c40\u90e8\u6027\u7684\u7a0b\u5e8f\u503e\u5411\u4e8e\u4e00\u6b21\u53c8\u4e00\u6b21\u5730\u8bbf\u95ee\u76f8\u540c\u7684\u6570\u636e\u9879\u96c6\u5408\uff0c\u6216\u662f\u503e\u5411\u4e8e\u8bbf\u95ee\u90bb\u8fd1\u7684\u6570\u636e\u9879\u96c6\u5408\u3002", 
            "title": "Chapter 6 \u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784"
        }, 
        {
            "location": "/csapp/ch6/#1", 
            "text": "", 
            "title": "1 \u5b58\u50a8\u6280\u672f"
        }, 
        {
            "location": "/csapp/ch6/#_1", 
            "text": "\u968f\u673a\u8bbf\u95ee\u5b58\u50a8\u5668 (Random-Access Memory, RAM)\u5206\u4e3a\u4e24\u7c7b\uff1a \u9759\u6001 (SRAM)\u548c \u52a8\u6001 (DRAM)\u7684\u3002   SRAM\u6bd4DRAM\u66f4\u5feb\uff0c\u4f46\u4e5f\u8d35\u5f97\u591a\u3002  SRAM\u7528\u6765\u4f5c\u4e3a\u9ad8\u901f\u7f13\u5b58\u5b58\u50a8\u5668\u3002  DRAM\u7528\u6765\u4f5c\u4e3a\u4e3b\u5b58\u4ee5\u53ca\u56fe\u5f62\u7cfb\u7edf\u7684\u6862\u7f13\u51b2\u533a\u3002  SRAM\u4e00\u822c\u4e0d\u4f1a\u8d85\u8fc7\u51e0\u5146\u5b57\u8282\u3002  DRAM\u6709\u51e0\u767e\u6216\u51e0\u5343\u5146\u5b57\u8282\u3002", 
            "title": "\u968f\u673a\u8bbf\u95ee\u5b58\u50a8\u5668"
        }, 
        {
            "location": "/csapp/ch6/#_2", 
            "text": "\u78c1\u76d8\u662f\u7531 \u76d8\u7247 (platter)\u6784\u6210\u7684\u3002\u6bcf\u4e2a\u76d8\u7247\u5982\u540c\u5207\u897f\u74dc\u4e00\u6837\u88ab\u201c\u5207\u201d\u6210\u4e00\u5757\u4e00\u5757\u7684\u6247\u9762\uff0c\u540c\u65f6\u6cbf\u7740\u534a\u5f84\u7684\u65b9\u5411\u88ab\u5212\u5206\u6210\u4e86\u4e00\u7ec4\u540c\u5fc3\u5706( \u78c1\u9053 , track)\uff0c\u6bcf\u6761\u78c1\u9053\u88ab\u6247\u9762\u5207\u6210\u5f88\u591a\u7684\u6247\u5f62\u533a\u57df\u53eb\u505a \u6247\u533a \uff08sector, \u6247\u533a\u662f\u4ece\u78c1\u76d8\u8bfb\u51fa\u548c\u5199\u5165\u4fe1\u606f\u7684\u6700\u5c0f\u5355\u4f4d\uff0c\u5305\u542b\u76f8\u7b49\u6570\u91cf\u7684\u6570\u636e\u4f4d\uff0c\u901a\u5e38\u4e3a512\u5b57\u8282\uff09\uff0c\u4e0d\u540c\u76d8\u7247\u4e0a\u7684\u540c\u534a\u5f84\u78c1\u9053\u7ec4\u6210\u4e86\u67f1\u9762\u3002   \u78c1\u76d8\u7684\u5bb9\u91cf\uff1a \u78c1\u5934\u6570 \u00d7 \u78c1\u9053\u6570 \u00d7 \u6bcf\u9053\u6247\u533a\u6570 \u00d7 \u6bcf\u6247\u533a\u5b57\u8282\u6570", 
            "title": "\u78c1\u76d8\u5b58\u50a8"
        }, 
        {
            "location": "/csapp/ch6/#_3", 
            "text": "\u56fa\u6001\u786c\u76d8 (Solid State Disk, SSD)\uff0c\u7531\u4e00\u4e2a\u6216\u591a\u4e2a\u95ea\u5b58\u82af\u7247\u548c\u95ea\u5b58\u7ffb\u8bd1\u5c42(flash translation layer)\u7ec4\u6210\u3002   \u95ea\u5b58\u82af\u7247\u5b58\u50a8\u5185\u5bb9\u3002  \u95ea\u5b58\u7ffb\u8bd1\u5c42\u5bf9\u903b\u8f91\u5757\u7684\u8bf7\u6c42\u7ffb\u8bd1\u6210\u5bf9\u5e95\u5c42\u7269\u7406\u8bbe\u5907\u7684\u8bbf\u95ee\u3002", 
            "title": "\u56fa\u6001\u786c\u76d8"
        }, 
        {
            "location": "/csapp/ch6/#2", 
            "text": "\u4e00\u4e2a\u7f16\u5199\u826f\u597d\u7684\u8ba1\u7b97\u673a\u7a0b\u5e8f\u5e38\u5e38\u5177\u6709\u826f\u597d\u7684 \u5c40\u90e8\u6027 (locality)\u3002\u4e5f\u5c31\u662f\uff0c\u5b83\u4eec\u503e\u5411\u4e8e\u5f15\u7528 \u90bb\u8fd1\u4e8e \u5176\u4ed6\u6700\u8fd1\u5f15\u7528\u8fc7\u7684\u6570\u636e\u9879\u7684\u6570\u636e\u9879( \u7a7a\u95f4\u5c40\u90e8\u6027 )\uff0c\u6216\u8005 \u6700\u8fd1 \u5f15\u7528\u8fc7\u7684\u6570\u636e\u9879\u672c\u8eab( \u65f6\u95f4\u5c40\u90e8\u6027 )\u3002 \u8fd9\u79cd\u503e\u5411\u6027\uff0c\u88ab\u79f0\u4e3a \u5c40\u90e8\u6027\u539f\u7406 (principle of locality)\u6216\u8bbf \u95ee\u5c40\u90e8\u6027 (locality of reference)\u3002  \u6709\u826f\u597d\u5c40\u90e8\u6027\u7684\u7a0b\u5e8f\u6bd4\u5c40\u90e8\u6027\u5dee\u7684\u7a0b\u5e8f\u8fd0\u884c\u5f97\u66f4\u5feb\u3002\u73b0\u4ee3\u8ba1\u7b97\u673a\u7cfb\u7edf\u7684\u5404\u4e2a\u5c42\u6b21\uff0c\u4ece\u786c\u4ef6\u5230\u64cd\u4f5c\u7cfb\u7edf\u3001\u518d\u5230\u5e94\u7528\u7a0b\u5e8f\uff0c\u5b83\u4eec\u7684\u8bbe\u8ba1\u90fd\u5229\u7528\u4e86\u5c40\u90e8\u6027\u3002   \u5728\u786c\u4ef6\u5c42\uff0c\u901a\u8fc7\u5f15\u5165\u9ad8\u901f\u7f13\u5b58\u6765\u4fdd\u5b58\u6700\u8fd1\u88ab\u5f15\u7528\u7684\u6307\u4ee4\u548c\u6570\u636e\u9879\uff0c\u4ece\u800c\u63d0\u9ad8\u8d2e\u5b58\u7684\u8bbf\u95ee\u901f\u5ea6\u3002  \u5728\u64cd\u4f5c\u7cfb\u7edf\u7ea7\uff0c\u7cfb\u7edf\u4f7f\u7528\u4e3b\u5b58\u4f5c\u4e3a\u865a\u62df\u5730\u5740\u7a7a\u95f4\u6700\u8fd1\u88ab\u5f15\u7528\u5757\u7684\u9ad8\u901f\u7f13\u5b58\u3002  Web\u6d4f\u89c8\u5668\u5c06\u6700\u8fd1\u88ab\u5f15\u7528\u7684\u6587\u6863\u653e\u5728\u672c\u5730\u78c1\u76d8\u4e0a\u3002   \u91cf\u5316\u8bc4\u4ef7\u7a0b\u5e8f\u4e2d\u5c40\u90e8\u6027\u7684\u4e00\u4e9b\u7b80\u5355\u539f\u5219\uff1a   \u91cd\u590d\u5f15\u7528\u76f8\u540c\u53d8\u91cf\u7684\u7a0b\u5e8f\u5177\u6709\u826f\u597d\u7684\u65f6\u95f4\u5c40\u90e8\u6027\u3002  \u5bf9\u4e8e\u5177\u6709\u6b65\u957f\u4e3a k k \u7684\u5f15\u7528\u6a21\u5f0f\u7684\u7a0b\u5e8f\uff0c\u6b65\u957f\u8d8a\u597d\uff0c\u7a7a\u95f4\u5c40\u90e8\u6027\u8d8a\u597d\u3002  \u5bf9\u4e8e\u53d6\u6307\u4ee4\u6765\u8bf4\uff0c\u5faa\u73af\u6709\u597d\u7684\u65f6\u95f4\u548c\u7a7a\u95f4\u5c40\u90e8\u6027\u3002   // for\u5faa\u73af\u4f53\u91cc\u7684\u6307\u4ee4\u662f\u6309\u7167\u8fde\u7eed\u7684\u987a\u5e8f\u6267\u884c\u7684\uff0c\u56e0\u6b64\u5faa\u73af\u5177\u6709\u826f\u597d\u7684\u7a7a\u95f4\u5c40\u90e8\u6027\u3002\u56e0\u4e3a\u5faa\u73af\u4f53\u4f1a\u88ab\u6267\u884c\u591a\u6b21\uff0c\u56e0\u6b64\u4e5f\u6709\u826f\u597d\u7684\u65f6\u95f4\u5c40\u90e8\u6027\u3002  int   sumvec ( int   v [ N ]){ \n     int   i ,   sum   =   0 ; \n     for   ( i = 0 ;   i   N ;   i ++ ) \n         sum   +=   v [ i ]; \n     return   sum ;  }", 
            "title": "2 \u5c40\u90e8\u6027"
        }, 
        {
            "location": "/csapp/ch6/#3-memory-hierarchy", 
            "text": "\u4e00\u822c\u800c\u8a00\uff0c\u4ece\u9ad8\u5c42\u5f80\u4f4e\u5c42\u8d70\uff0c\u5b58\u50a8\u8bbe\u5907\u53d8\u5f97\u66f4\u6162\u3001\u66f4\u4fbf\u5b9c\u548c\u66f4\u5927\u3002   \u5728\u6700\u9ad8\u5c42(L0)\uff0c\u662f\u5c11\u91cf\u5feb\u901f\u7684CPU\u5bc4\u5b58\u5668\uff0cCPU\u53ef\u4ee5\u5728\u4e00\u4e2a\u65f6\u949f\u5468\u671f\u5185\u8bbf\u95ee\u5b83\u4eec\u3002  \u63a5\u4e0b\u6765\u662f\u4e00\u4e2a\u6216\u591a\u4e2a\u5c0f\u578b\u5230\u4e2d\u578b\u7684\u57fa\u4e8eSRAM\u7684\u9ad8\u901f\u7f13\u5b58\u5b58\u50a8\u5668\uff0c\u53ef\u4ee5\u5728\u51e0\u4e2aCPU\u65f6\u949f\u5468\u671f\u5185\u8bbf\u95ee\u5b83\u4eec\u3002  \u7136\u540e\u662f\u4e00\u4e2a\u5927\u7684\u57fa\u4e8eDRAM\u7684\u8d2e\u5b58\uff0c\u53ef\u4ee5\u5728\u51e0\u5341\u5230\u51e0\u767e\u4e2a\u65f6\u949f\u5468\u671f\u5185\u8bbf\u95ee\u5b83\u4eec\u3002  \u63a5\u4e0b\u6765\u662f\u6162\u901f\u4f46\u5bb9\u91cf\u5f88\u5927\u7684\u672c\u5730\u78c1\u76d8\u3002  \u6700\u540e\uff0c\u6709\u4e9b\u7cfb\u7edf\u5305\u62ec\u4e86\u8fdc\u7a0b\u670d\u52a1\u5668\u4e0a\u7684\u78c1\u76d8\uff0c\u8981\u901a\u8fc7\u7f51\u7edc\u6765\u8bbf\u95ee\u5b83\u4eec\u3002", 
            "title": "3 \u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784 Memory Hierarchy"
        }, 
        {
            "location": "/csapp/ch6/#_4", 
            "text": "\u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784\u7684\u4e2d\u5fc3\u601d\u60f3\u662f\uff0c\u5bf9\u4e8e\u6bcf\u4e2a k k \uff0c\u4f4d\u4e8e k k \u5c42\u7684\u66f4\u5feb\u66f4\u5c0f\u7684\u5b58\u50a8\u8bbe\u5907\u4f5c\u4e3a\u4f4d\u4e8e k+1 k+1 \u5c42\u7684\u66f4\u5927\u66f4\u6162\u7684\u5b58\u50a8\u8bbe\u5907\u7684\u7f13\u5b58\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u5c42\u6b21\u7ed3\u6784\u4e2d\u7684\u6bcf\u4e00\u5c42\u90fd\u7f13\u5b58\u6765\u81ea\u8f83\u4f4e\u4e00\u5c42\u7684\u6570\u636e\u5bf9\u8c61\u3002   \u7b2c k+1 k+1 \u5c42\u7684\u5b58\u50a8\u5668\u88ab\u5212\u5206\u4e3a\u8fde\u7eed\u7684\u6570\u636e\u5bf9\u8c61\u7ec4\u5757(chunk)\uff0c\u79f0\u4e3a\u5757(block)\u3002  \u6bcf\u4e2a\u5757\u90fd\u6709\u4e00\u4e2a\u552f\u4e00\u7684\u5730\u5740\u3002  \u5757\u7684\u5927\u5c0f\u53ef\u4ee5\u662f\u56fa\u5b9a\u7684(\u901a\u5e38)\uff0c\u4e5f\u53ef\u4ee5\u662f\u53ef\u53d8\u7684(\u4f8b\u5982\u5b58\u50a8\u5728Web\u670d\u52a1\u5668\u4e0a\u7684HMTL\u6587\u4ef6).  \u6570\u636e\u603b\u662f\u4ee5\u5757\u5927\u5c0f\u4e3a\u4f20\u9001\u5355\u5143\u5728\u7b2c k k \u5c42\u548c\u7b2c k+1 k+1 \u5c42\u4e4b\u95f4\u6765\u56de\u590d\u5236\u3002\u5728\u5c42\u6b21\u7ed3\u6784\u4e2d\u4efb\u4f55\u4e00\u5bf9\u76f8\u90bb\u7684\u5c42\u6b21\u4e4b\u95f4\u5757\u5927\u5c0f\u662f\u56fa\u5b9a\u7684(\u7b2c k k \u5c42\u548c\u7b2c k+1 k+1 \u5c42\u5757\u5927\u5c0f\u4e00\u81f4)\uff0c\u4f46\u662f\u5176\u4ed6\u7684\u5c42\u6b21\u5bf9\u4e4b\u95f4\u53ef\u4ee5\u6709\u4e0d\u540c\u7684\u5757\u5927\u5c0f\u3002    \u5f53\u7a0b\u5e8f\u9700\u8981\u7b2c k+1 k+1 \u5c42\u7684\u67d0\u4e2a\u6570\u636e\u5bf9\u8c61 d d \u65f6\uff0c\u5b83\u9996\u5148\u5728\u5f53\u524d\u5b58\u50a8\u5728\u7b2c k k \u5c42\u7684\u4e00\u4e2a\u5757\u4e2d\u67e5\u627e d d \u3002\u5982\u679c d d \u521a\u597d\u7f13\u5b58\u5728\u7b2c k k \u5c42\u4e2d\uff0c\u5373 \u7f13\u5b58\u547d\u4e2d (cache hit)\uff0c\u5426\u5219 \u7f13\u5b58\u4e0d\u547d\u4e2d (cache miss)\u3002  \u73b0\u4ee3\u7cfb\u7edf\u4e2d\u5230\u5904\u90fd\u4f7f\u7528\u4e86\u7f13\u5b58\u3002", 
            "title": "\u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784\u4e2d\u7684\u7f13\u5b58"
        }, 
        {
            "location": "/csapp/ch6/#4", 
            "text": "", 
            "title": "4 \u9ad8\u901f\u7f13\u5b58\u5b58\u50a8\u5668"
        }, 
        {
            "location": "/csapp/ch6/#_5", 
            "text": "\u8003\u8651\u4e00\u4e2a\u8ba1\u7b97\u673a\u7cfb\u7edf\uff0c\u5176\u4e2d\u6bcf\u4e2a\u5b58\u50a8\u5668\u5730\u5740\u6709 m m \u4f4d\uff0c\u5f62\u6210$M=2^m  \u4e2a\u4e0d\u540c\u7684\u5730\u5740\u3002\u8fd9\u6837\u4e00\u4e2a\u673a\u5668\u7684\u9ad8\u901f\u7f13\u5b58\u88ab\u7ec4\u7ec7\u6210\u4e00\u4e2a\u6709 \u4e2a\u4e0d\u540c\u7684\u5730\u5740\u3002\u8fd9\u6837\u4e00\u4e2a\u673a\u5668\u7684\u9ad8\u901f\u7f13\u5b58\u88ab\u7ec4\u7ec7\u6210\u4e00\u4e2a\u6709 S=2^s $\u4e2a \u9ad8\u901f\u7f13\u5b58\u7ec4 (cache set)\u7684\u6570\u7ec4\u3002   \u6bcf\u4e2a\u7ec4\u5305\u542b E E \u4e2a \u9ad8\u901f\u7f13\u5b58\u884c (cache line)\u3002  \u6bcf\u4e2a\u884c\u662f\u7531\u4e00\u4e2a$B=2^b $\u5b57\u8282\u7684\u6570\u636e\u5757(block)\u7ec4\u6210\u7684\u3002  \u4e00\u4e2a \u6709\u6548\u4f4d (valid bit)\u6307\u660e\u8fd9\u4e2a\u884c\u662f\u5426\u5305\u542b\u6709\u610f\u4e49\u7684\u4fe1\u606f\u3002  \u6709 t=m-(b+s) t=m-(b+s) \u4e2a \u6807\u8bb0\u4f4d (tag bit)\u552f\u4e00\u5730\u6807\u8bc6\u5b58\u50a8\u5728\u8fd9\u4e2a\u9ad8\u901f\u7f13\u5b58\u884c\u4e2d\u7684\u5757\u3002    \u9ad8\u901f\u7f13\u5b58\u7684\u5927\u5c0f C C \u662f\u6307\u6240\u6709\u5757\u7684\u5927\u5c0f\u7684\u548c\uff0c C=S\\times E\\times B C=S\\times E\\times B .   \u6bcf\u4e2a\u7ec4\u53ea\u6709\u4e00\u884c( E=1 E=1 )\u7684\u9ad8\u901f\u7f13\u5b58\u79f0\u4e3a \u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58 \uff1b  \u6bcf\u4e2a\u7ec4\u6709\u591a\u884c( E 1 E>1 )\u7684\u9ad8\u901f\u7f13\u5b58\u79f0\u4e3a \u7ec4\u76f8\u8054\u9ad8\u901f\u7f13\u5b58 \uff1b  \u4e00\u4e2a\u5305\u542b\u6240\u6709\u9ad8\u901f\u7f13\u5b58\u884c\u7684\u7ec4( E=C/B E=C/B )\uff0c\u79f0\u4e3a \u5168\u76f8\u8054\u9ad8\u901f\u7f13\u5b58 \u3002", 
            "title": "\u901a\u7528\u7684\u9ad8\u901f\u7f13\u5b58\u5b58\u50a8\u5668\u7ec4\u7ec7\u7ed3\u6784"
        }, 
        {
            "location": "/csapp/ch6/#_6", 
            "text": "\u6bcf\u4e2a\u7ec4\u53ea\u6709\u4e00\u884c( E=1 E=1 )\u7684\u9ad8\u901f\u7f13\u5b58\u79f0\u4e3a \u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58 (Direct-Mapped Caches)\u3002   \u5047\u8bbe\u6211\u4eec\u6709\u8fd9\u6837\u4e00\u4e2a\u7cfb\u7edf\uff0c\u5b83\u6709\u4e00\u4e2aCPU\u3001\u4e00\u4e2a\u5bc4\u5b58\u5668\u6587\u4ef6\u3001\u4e00\u4e2aL1\u9ad8\u901f\u7f13\u5b58\u548c\u4e00\u4e2a\u4e3b\u5b58\u3002\u5f53CPU\u6267\u884c\u4e00\u6761\u8bfb\u5185\u5b58\u5b57 w w \u7684\u6307\u4ee4\uff0c\u5b83\u5411L1\u9ad8\u901f\u7f13\u5b58\u8bf7\u6c42\u8fd9\u4e2a\u5b57\u3002   \u5982\u679cL1\u9ad8\u901f\u7f13\u5b58\u6709 w w \u7684\u4e00\u4e2a\u7f13\u5b58\u7684\u526f\u672c\uff0c\u90a3\u4e48\u5c31\u5f97\u5230L1\u9ad8\u901f\u7f13\u5b58\u547d\u4e2d\u3002\u9ad8\u901f\u7f13\u5b58\u4f1a\u5f88\u5feb\u62bd\u53d6\u51fa w w \uff0c\u5e76\u5c06\u5b83\u8fd4\u56de\u7ed9CPU\u3002  \u5426\u5219\u5c31\u662f\u7f13\u5b58\u4e0d\u547d\u4e2d\uff0cCPU\u5fc5\u987b\u7b49\u5f85\u88ab\u8bf7\u6c42\u7684\u5757\u6700\u7ec8\u4ece\u5185\u5b58\u8fbe\u5230\u65f6\uff0cL1\u9ad8\u901f\u7f13\u5b58\u5c06\u8fd9\u4e2a\u5757\u623f\u5b50\u5b83\u7684\u4e00\u4e2a\u9ad8\u901f\u7f13\u5b58\u884c\u91cc\uff0c\u4ece\u88ab\u5b58\u50a8\u7684\u5757\u4e2d\u62bd\u53d6\u51fa\u5b57 w w \uff0c\u7136\u540e\u5c06\u5b83\u8fd4\u56de\u7ed9CPU\u3002   \u9ad8\u901f\u7f13\u5b58\u786e\u5b9a\u4e00\u4e2a\u8bf7\u6c42\u662f\u5426\u547d\u4e2d\uff0c\u7136\u540e\u62bd\u53d6\u51fa\u88ab\u8bf7\u6c42\u7684\u5b57\u7684\u8fc7\u7a0b\uff0c\u5206\u4e3a\u4e09\u6b65\uff1a   \u7ec4\u9009\u62e9(set selection)  \u884c\u5339\u914d(line matching)  \u5b57\u62bd\u53d6(word extraction)   1.\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u4e2d\u7684\u7ec4\u9009\u62e9  \u9ad8\u901f\u7f13\u5b58\u4ece w w \u7684\u5730\u5740\u4e2d\u95f4\u62bd\u53d6\u51fa s s \u4e2a \u7ec4\u7d22\u5f15 (Set index)\u4f4d\u3002   2.\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u4e2d\u7684\u884c\u5339\u914d  \u7531\u4e8e\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u4e2d\u7684\u6bcf\u4e2a\u7ec4\u53ea\u6709\u4e00\u884c\uff0c\u56e0\u6b64\u5f53\u4e14\u4ec5\u5f53\u8bbe\u7f6e\u4e86\u6709\u6548\u4f4d(valid bit)\uff0c\u800c\u4e14\u9ad8\u901f\u7f13\u5b58\u884c\u4e2d\u7684\u6807\u8bb0(tag)\u4e0e w w \u7684\u5730\u5740\u4e2d\u7684\u6807\u8bb0\u76f8\u5339\u914d\u65f6\uff0c\u8fd9\u4e00\u884c\u4e2d\u5305\u542b w w \u7684\u4e00\u4e2a\u526f\u672c\u3002   3.\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u4e2d\u7684\u5b57\u9009\u62e9  \u4e00\u65e6\u547d\u4e2d\uff0c\u6211\u4eec\u77e5\u9053 w w \u5c31\u5728\u8fd9\u4e2a\u5757\u4e2d\u7684\u67d0\u4e2a\u5730\u65b9\u3002\u6700\u540e\u4e00\u6b65\u786e\u5b9a\u6240\u9700\u8981\u7684\u5b57\u5728\u5757\u4e2d\u662f\u4ece\u54ea\u91cc\u5f00\u59cb\u7684\u3002\u5757\u504f\u79fb(block offset)\u63d0\u4f9b\u4e86\u6240\u9700\u8981\u7684\u5b57\u7684\u7b2c\u4e00\u4e2a\u5b57\u8282\u7684\u504f\u79fb\u3002  4.\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u4e2d\u4e0d\u547d\u4e2d\u65f6\u7684\u884c\u66ff\u6362  \u5982\u679c\u7f13\u5b58\u4e0d\u547d\u4e2d\uff0c\u90a3\u4e48\u5b83\u9700\u8981\u4ece\u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784\u7684\u4e0b\u4e00\u5c42\u53bb\u9664\u88ab\u8bf7\u6c42\u7684\u5757\uff0c\u7136\u540e\u5c06\u65b0\u7684\u5757\u5b58\u50a8\u5728\u7ec4\u7d22\u5f15\u4f4d\u6307\u793a\u7684\u7ec4\u4e2d\u7684\u4e00\u4e2a\u9ad8\u901f\u7f13\u5b58\u884c\u4e2d\u3002   \u5982\u679c\u7ec4\u4e2d\u90fd\u662f\u6709\u6548\u9ad8\u901f\u7f13\u5b58\u884c\uff0c\u5219\u5fc5\u987b\u8981\u9a71\u9664\u51fa\u4e00\u4e2a\u73b0\u5b58\u7684\u884c\u3002  \u5bf9\u4e8e\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u6765\u8bf4\uff0c\u6bcf\u4e2a\u7ec4\u53ea\u5305\u542b\u4e00\u884c\uff0c\u7528\u65b0\u53d6\u51fa\u7684\u884c\u66ff\u6362\u5f53\u524d\u7684\u884c\u3002   5.\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u4e2d\u7684\u51b2\u7a81\u4e0d\u547d\u4e2d  \u5f53\u7a0b\u5e8f\u8bbf\u95ee\u5927\u5c0f\u4e3a2\u7684\u5e42\u7684\u6570\u7ec4\u65f6\uff0c\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u901a\u5e38\u4f1a\u53d1\u751f \u51b2\u7a81\u4e0d\u547d\u4e2d (conflit miss)\u3002\u4f8b\u5982\uff0c\u8003\u8651\u4e00\u4e2a\u8ba1\u7b97\u4e24\u4e2a\u5411\u91cf\u70b9\u79ef\u7684\u51fd\u6570\uff1a  float   dotprod ( float   x [ 8 ],   float   y [ 8 ])   {  \n     float   sum   =   0.0 ;   int   i ; \n     for   ( i   =   0 ;   i     8 ;   i ++ )  \n         sum   +=   x [ i ]   *   y [ i ]; \n     return   sum ;  }   \u5047\u8bbe\u9ad8\u901f\u6df7\u5b58\u7531\u4e24\u4e2a\u7ec4\u7ec4\u6210\uff0c\u6bcf\u4e2a\u7ec4\u5bb9\u7eb34\u4e2a\u6d6e\u70b9\u6570\u3002\u6d6e\u70b9\u6570\u662f4\u4e2a\u5b57\u8282\uff0c x x \u88ab\u52a0\u8f7d\u5230\u4ece\u5730\u57400\u5f00\u59cb\u768432\u5b57\u8282\u8fde\u7eed\u5185\u5b58\u4e2d\uff0c\u800c y y \u7d27\u8ddf\u5728 x x \u4e4b\u540e\uff0c\u4ece\u5730\u574032\u5f00\u59cb\u3002 \u6bcf\u4e2a x[i] x[i] \u548c y[i] y[i] \u4f1a\u6620\u5c04\u5230\u76f8\u540c\u7684\u9ad8\u901f\u7f13\u5b58\u7ec4\uff1a    \u5728\u8fd0\u884c\u65f6\uff0c\u5faa\u73af\u7684\u7b2c\u4e00\u6b21\u8fed\u4ee3\u5f15\u7528 x[0] x[0] \uff0c\u7f13\u5b58\u4e0d\u547d\u4e2d\u4f1a\u5bfc\u81f4\u5305\u542b x[0]-x[3] x[0]-x[3] \u7684\u5757\u88ab\u52a0\u8f7d\u5230\u7ec40.  \u63a5\u4e0b\u6765\uff0c\u5f15\u7528 y[0] y[0] \uff0c\u7f13\u5b58\u4e0d\u547d\u4e2d\u4f1a\u5bfc\u81f4\u5305\u542b y[0]-y[3] y[0]-y[3] \u7684\u5757\u88ab\u52a0\u8f7d\u5230\u7ec40\uff0c\u8986\u76d6\u524d\u4e00\u6b21\u5f15\u7528\u590d\u5236\u8fdb\u6765\u7684x\u7684\u503c\u3002  \u5728\u4e0b\u4e00\u6b21\u8fed\u4ee3\u4e2d\uff0c\u5bf9 x[1] x[1] \u7684\u5f15\u7528\u4e0d\u547d\u4e2d\uff0c\u5bfc\u81f4 x[0]-x[3] x[0]-x[3] \u7684\u5757\u88ab\u91cd\u65b0\u52a0\u8f7d\u5230\u7ec40\uff0c\u8986\u76d6\u6389 y[0]-y[3] y[0]-y[3] \u7684\u5757\u3002   \u8fd9\u79cd\u73b0\u8c61\uff0c \u9ad8\u901f\u7f13\u5b58\u53cd\u590d\u5730\u52a0\u8f7d\u548c\u9a71\u9010\u76f8\u540c\u7684\u9ad8\u901f\u7f13\u5b58\u7ec4 \uff0c\u53eb\u505a \u6296\u52a8 (thrashing)\u3002", 
            "title": "\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58"
        }, 
        {
            "location": "/csapp/ch6/#_7", 
            "text": "\u7ec4\u76f8\u8054\u9ad8\u901f\u7f13\u5b58 (set associative cache)\u7684\u6bcf\u4e2a\u7ec4\u90fd\u4fdd\u5b58\u6709\u591a\u4e8e\u4e00\u4e2a\u7684\u9ad8\u901f\u7f13\u5b58\u884c\u3002\u4e00\u4e2a 1 E C/B 1<E<C/B \u7684\u9ad8\u901f\u7f13\u5b58\u901a\u5e38\u79f0\u4e3a E\u8def\u7ec4\u76f8\u8054\u9ad8\u901f\u7f13\u5b58 (E-way set associative cache)\u3002   1. \u7ec4\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\u4e2d\u7684\u7ec4\u9009\u62e9  \u5b83\u7684\u7ec4\u9009\u62e9\u548c\u76f4\u63a5\u6620\u5c04\u9ad8\u901f\u7f13\u5b58\u7684\u7ec4\u9009\u62e9\u4e00\u6837\uff0c\u7ec4\u7d22\u5f15(set index)\u4f4d\u6807\u8bc6\u7ec4\u3002   2. \u7ec4\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\u4e2d\u7684\u884c\u5339\u914d\u548c\u5b57\u9009\u62e9  \u5b83\u5fc5\u987b\u68c0\u67e5\u591a\u4e2a\u884c\u7684\u6807\u8bb0\u4f4d\u548c\u6709\u6548\u4f4d\uff0c\u4ee5\u786e\u5b9a\u6240\u8bf7\u6c42\u7684\u5b57\u662f\u5426\u5728\u7ec4\u4e2d\u3002  \u76f8\u8054\u5b58\u50a8\u5668 (associative memory)\u662f\u4e00\u4e2a(key, value)\u5bf9\u7684\u6570\u7ec4\uff0c\u4ee5key\u4e3a\u8f93\u5165\uff0c\u8fd4\u56de\u4e0e\u8f93\u5165\u7684key\u76f8\u5339\u914d\u7684(key, value\uff09\u5bf9\u4e2d\u7684value\u503c\u3002\u6211\u4eec\u53ef\u4ee5\u628a\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\u7684\u6bcf\u4e2a\u7ec4\u770b\u6210\u4e00\u4e2a\u5c0f\u7684\u76f8\u8054\u5b58\u50a8\u5668\uff0ckey\u662f\u6807\u8bb0\u548c\u6709\u6548\u4f4d\uff0c\u800cvalue\u5c31\u662f\u5757\u7684\u5185\u5bb9\u3002  \u7ec4\u4e2d\u7684\u4efb\u4f55\u4e00\u884c\u90fd\u53ef\u4ee5\u5305\u542b\u4efb\u4f55\u6620\u5c04\u5230\u8fd9\u4e2a\u7ec4\u7684\u5185\u5b58\u5757\u3002\u6240\u4ee5\u9ad8\u901f\u7f13\u5b58\u5fc5\u987b\u641c\u7d22\u7ec4\u4e2d\u7684\u6bcf\u4e00\u884c\uff0c\u5bfb\u627e\u4e00\u4e2a\u6709\u6548\u7684\u884c\uff0c\u5176\u6807\u8bb0\u4e0e\u5730\u5740\u4e2d\u7684\u6807\u8bb0\u76f8\u5339\u914d\u3002\u5982\u679c\u627e\u5230\u4e86\u8fd9\u6837\u4e00\u884c\uff0c\u90a3\u4e48\u5757\u504f\u79fb\u5c31\u4ece\u8fd9\u4e2a\u5757\u4e2d\u9009\u62e9\u4e00\u4e2a\u5b57\u3002   3. \u7ec4\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\u4e2d\u4e0d\u547d\u4e2d\u65f6\u7684\u884c\u66ff\u6362  \u5982\u679cCPU\u8bf7\u6c42\u7684\u5b57\u4e0d\u5728\u7ec4\u7684\u4efb\u4f55\u4e00\u884c\u4e2d\uff0c\u90a3\u4e48\u5c31\u662f\u7f13\u5b58\u4e0d\u547d\u4e2d\uff0c\u9ad8\u901f\u7f13\u5b58\u5fc5\u987b\u4ece\u5185\u5b58\u4e2d\u53d6\u51fa\u5305\u542b\u8fd9\u4e2a\u5b57\u7684\u5757\uff0c\u7136\u540e\u8fdb\u884c\u66ff\u6362\u3002\u8be5\u66ff\u6362\u54ea\u4e2a\u884c\u5462\uff1f   \u5982\u679c\u7ec4\u4e2d\u6709\u4e00\u4e2a\u7a7a\u884c\uff0c\u90a3\u4e48\u5b83\u5c31\u662f\u4e2a\u5f88\u597d\u7684\u5019\u9009\u3002  \u5982\u679c\u7ec4\u4e2d\u6ca1\u6709\u7a7a\u884c\uff0c\u5fc5\u987b\u4ece\u4e2d\u9009\u62e9\u4e00\u4e2a\u975e\u7a7a\u7684\u884c\u3002\u6709\u5982\u4e0b\u51e0\u4e2a\u66ff\u6362\u7b56\u7565\uff1a  \u6700\u4e0d\u5e38\u4f7f\u7528 (Least-Frequently-Used, LFU)\u7b56\u7565\u4f1a\u66ff\u6362\u5728\u8fc7\u53bb\u67d0\u4e2a\u65f6\u95f4\u7a97\u53e3\u5185\u5f15\u7528\u6b21\u6570\u6700\u5c11\u7684\u90a3\u4e00\u884c\u3002  \u6700\u8fd1\u6700\u5c11\u4f7f\u7528 (Least-Recently-Used, LRU)\u7b56\u7565\u4f1a\u66ff\u6362\u6700\u540e\u4e00\u4e2a\u8bbf\u95ee\u65f6\u95f4\u6700\u4e45\u8fdc\u7684\u90a3\u4e00\u884c\u3002", 
            "title": "\u7ec4\u76f8\u8054\u9ad8\u901f\u7f13\u5b58"
        }, 
        {
            "location": "/csapp/ch6/#_8", 
            "text": "\u4e00\u4e2a\u5305\u542b\u6240\u6709\u9ad8\u901f\u7f13\u5b58\u884c\u7684\u7ec4( E=C/B E=C/B )\uff0c\u79f0\u4e3a \u5168\u76f8\u8054\u9ad8\u901f\u7f13\u5b58 \u3002 \u56e0\u4e3a\u9ad8\u901f\u7f13\u5b58\u7535\u8def\u5fc5\u987b\u5e76\u884c\u5730\u641c\u7d22\u8bb8\u591a\u76f8\u5339\u914d\u7684\u6807\u8bb0\uff0c\u6784\u9020\u4e00\u4e2a\u53c8\u5927\u53c8\u5feb\u7684\u5168\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\u5f88\u56f0\u96be\uff0c\u5e76\u4e14\u5f88\u6602\u8d35\u3002\u56e0\u6b64\uff0c\u5168\u76f8\u8054\u9ad8\u901f\u7f13\u5b58\u53ea\u9002\u5408\u505a\u5c0f\u7684\u9ad8\u901f\u7f13\u5b58(\u4f8b\u5982MMC\u4e2d\u7684TLB)\u3002", 
            "title": "\u5168\u76f8\u8054\u9ad8\u901f\u7f13\u5b58"
        }, 
        {
            "location": "/csapp/ch6/#5", 
            "text": "", 
            "title": "5 \u7f16\u5199\u9ad8\u901f\u7f13\u5b58\u53cb\u597d\u7684\u4ee3\u7801"
        }, 
        {
            "location": "/csapp/ch6/#6", 
            "text": "", 
            "title": "6 \u9ad8\u901f\u7f13\u5b58\u5bf9\u7a0b\u5e8f\u6027\u80fd\u7684\u5f71\u54cd"
        }, 
        {
            "location": "/csapp/ch6/#_9", 
            "text": "\u4e00\u4e2a\u7a0b\u5e8f\u4ece\u5b58\u50a8\u7cfb\u7edf\u4e2d\u8bfb\u6570\u636e\u7684\u901f\u7387\u79f0\u4e3a  \u8bfb\u541e\u5410\u91cf (read throughput)\u3002 \u5b58\u50a8\u5668\u5c71 (memory mountain)\u662f\u4e00\u4e2a\u8bfb\u541e\u5410\u91cf\u7684\u65f6\u95f4\u548c\u7a7a\u95f4\u5c40\u90e8\u6027\u7684\u4e8c\u7ef4\u51fd\u6570\u3002   \u901a\u8fc7\u4e0d\u540c\u7684size(\u5bf9\u5e94\u65f6\u95f4\u5c40\u90e8\u6027)\u548cstride(\u5bf9\u5e94\u7a7a\u95f4\u5c40\u90e8\u6027)\u7684\u503c\u4ea7\u751f\u5b58\u50a8\u5668\u5c71\u3002  size\u503c\u8d8a\u5c0f\uff0c\u5f97\u5230\u7684\u5de5\u4f5c\u96c6\u8d8a\u5c0f\uff0c\u65f6\u95f4\u5c40\u90e8\u6027\u8d8a\u597d\u3002  stride\u503c\u8d8a\u5c0f\uff0c\u7a7a\u95f4\u5c40\u90e8\u6027\u8d8a\u597d\u3002   Intel Core i7\u7684\u5b58\u50a8\u5668\u5c71\uff1a   Core i7\u7684\u5b58\u50a8\u5668\u5c71\u5c55\u73b0\u4e86\u4e00\u4e2a\u5f88\u4e30\u5bcc\u7684\u7ed3\u6784\uff1a   \u5782\u76f4\u4e8esize\u8f74\u7684\u662f\u56db\u6761\u5c71\u810a\uff0c\u5206\u522b\u5bf9\u5e94\u4e8e\u5b8c\u5168\u5728L1\u9ad8\u901f\u7f13\u5b58\u3001L2\u9ad8\u901f\u7f13\u5b58\u3001L3\u9ad8\u901f\u7f13\u5b58\u548c\u4e3b\u5b58\u5185\u7684\u65f6\u95f4\u5c40\u90e8\u6027\u533a\u57df\u3002  \u5728L2\u3001L3\u548c\u4e3b\u5b58\u5c71\u810a\u4e0a\uff0c\u968f\u7740\u6b65\u957f\u7684\u589e\u52a0\uff0c\u6709\u4e00\u4e2a\u7a7a\u95f4\u5c40\u90e8\u6027\u7684\u659c\u5761\uff0c\u7a7a\u95f4\u5c40\u90e8\u6027\u4e0b\u964d\u3002", 
            "title": "\u5b58\u50a8\u5668\u5c71"
        }, 
        {
            "location": "/csapp/ch7/", 
            "text": "Chapter 7 \u94fe\u63a5\n\n\n\u94fe\u63a5\n(Linking)\u662f\u5c06\u5404\u79cd\n\u4ee3\u7801\n\u548c\n\u6570\u636e\u7247\u6bb5\n\u6536\u96c6\u5e76\u7ec4\u5408\u6210\u4e3a\u4e00\u4e2a\u5355\u4e00\u6587\u4ef6\u7684\u8fc7\u7a0b\u3002\u94fe\u63a5\u53ef\u4ee5\u5728\u7f16\u8bd1\u3001\u52a0\u8f7d\u3001\u8fd0\u884c\u65f6\u6267\u884c\u3002\u5728\u73b0\u4ee3\u7cfb\u7edf\u4e2d\uff0c\u94fe\u63a5\u7531\n\u94fe\u63a5\u5668\n(Linker)\u81ea\u52a8\u6267\u884c\u3002\n\n\n\u94fe\u63a5\u5668\u4f7f\u5f97\n\u5206\u79bb\u7f16\u8bd1\n(separate compilation)\u6210\u4e3a\u53ef\u80fd\uff1a\n\n\n\n\n\u53ef\u4ee5\u5c06\u6e90\u6587\u4ef6\u5206\u89e3\u4e3a\u66f4\u5c0f\u3001\u66f4\u597d\u7ba1\u7406\u7684\u6a21\u5757\uff0c\u53ef\u4ee5\u72ec\u7acb\u5730\u4fee\u6539\u548c\u7f16\u8bd1\u8fd9\u4e9b\u6a21\u5757\n\n\n\u4fee\u6539\u4e00\u4e2a\u6a21\u5757\u540e\uff0c\u53ea\u9700\u91cd\u65b0\u7f16\u8bd1\u5b83\uff0c\u5e76\u91cd\u65b0\u94fe\u63a5\uff0c\u4e0d\u5fc5\u7f16\u8bd1\u5176\u4ed6\u6587\u4ef6\n\n\n\n\n1 \u7f16\u8bd1\u5668\u9a71\u52a8\u7a0b\u5e8f\n\n\n\u7f16\u8bd1\u5668\u9a71\u52a8\u7a0b\u5e8f\n(\ncompiler driver\n)\uff0c\u4ee3\u8868\u7528\u6237\u5728\u9700\u8981\u65f6\u8c03\u7528\u9884\u5904\u7406\u5668(cpp)\u3001\u7f16\u8bd1\u5668(ccl)\u3001\u6c47\u7f16\u5668(as)\u548c\u94fe\u63a5\u5668(ld)\u3002\u5178\u578b\u7684\u7f16\u8bd1\u5668\u9a71\u52a8\u7a0b\u5e8f\uff0c\u5305\u62ecGNU GCC, Clang\u3002\n\n\n\u4f8b\u5982\uff0c\u4e00\u4e2a\u7b80\u5355\u6253\u5370hello\u7684\nhello.c\n\u7a0b\u5e8f\uff0c\u7ecf\u8fc7\u4e0b\u9762\u56db\u4e2a\u9636\u6bb5\uff0c\u751f\u6210\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\uff1a\n\n\n//file: hello.c\n\n\n#include\n \nstdio.h\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nint\n \ni\n;\n\n    \nprintf\n(\nHello World\n);\n\n\n}\n\n\n\n\n\nlinux \n cpp \n[\nother arguments\n]\n hello.c hello.i // C\u9884\u5904\u7406\u5668cpp\uff0c\u5c06\u6e90\u7a0b\u5e8f\u7ffb\u8bd1\u6210\u4e00\u4e2aASCII\u7801\u7684\u4e2d\u95f4\u6587\u4ef6\nlinux \n cc1 hello.i -Og \n[\nother arguments\n]\n  -o hello.s //C\u7f16\u8bd1\u5668cc1, \u7ffb\u8bd1\u6210\u4e00\u4e2aASCII\u6c47\u7f16\u8bed\u8a00\u6587\u4ef6\nlinux \n as \n[\nother arguments\n]\n  -o hello.o hello.s //\u6c47\u7f16\u5668as, \u7ffb\u8bd1\u6210\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\nlinux \n ld -o hello \n[\nsystem object files and args\n]\n hello.o //\u94fe\u63a5\u5668ld\uff0c\u521b\u5efa\u4e00\u4e2a\u53ef\u6267\u884c\u6587\u4ef6\n* linux \n ./hello //\u8c03\u7528\u52a0\u8f7d\u5668\n\n\n\n\n\n\n2 \u9759\u6001\u94fe\u63a5\n\n\n\u9759\u6001\u94fe\u63a5\u5668\u6709\u4e24\u4e2a\u4e3b\u8981\u4efb\u52a1\uff1a\n\n\n\n\n\u7b26\u53f7\u89e3\u6790\n(symbol resolution): \u5c06\u6bcf\u4e2a\u7b26\u53f7 \n\u5f15\u7528\n \u6b63\u597d\u548c\u4e00\u4e2a\u7b26\u53f7 \n\u5b9a\u4e49\n \u5173\u8054\u8d77\u6765\u3002\n\n\n\u91cd\u5b9a\u4f4d\n(relocation): \u628a\u6bcf\u4e2a\u7b26\u53f7\u5b9a\u4e49\u4e0e\u4e00\u4e2a\u5185\u5b58\u4f4d\u7f6e\u5173\u8054\u8d77\u6765\uff0c\u5e76\u4fee\u6539\u6240\u6709\u5bf9\u8fd9\u4e9b\u7b26\u53f7\u7684\u5f15\u7528\uff0c\u4f7f\u5f97\u5b83\u4eec\u6307\u5411\u8fd9\u4e2a\u5185\u5b58\u4f4d\u7f6e\u3002\n\n\n\n\n3 \u76ee\u6807\u6587\u4ef6\n\n\n\u76ee\u6807\u6587\u4ef6\u6709\u4e09\u79cd\u683c\u5f0f\uff1a\n\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\n(\n.o\n)\uff0c\n\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\n(\n.out\n)\uff0c\n\u5171\u4eab\u76ee\u6807\u6587\u4ef6\n(\n.so\n)\n\n\n\n\n\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\n(.o\u6587\u4ef6)\u3002\u5305\u542b\u4e8c\u8fdb\u5236\u4ee3\u7801\u548c\u6570\u636e\uff0c\u5176\u5f62\u5f0f\u53ef\u4ee5\u5728\u7f16\u8bd1\u65f6\u4e0e\u5176\u4ed6\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\u5408\u5e76\u8d77\u6765\uff0c\u521b\u5efa\u4e00\u4e2a\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\u3002\n\n\n\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\n(a.out\u6587\u4ef6)\u3002\u5305\u542b\u4e8c\u8fdb\u5236\u4ee3\u7801\u548c\u6570\u636e\uff0c\u5176\u5f62\u5f0f\u53ef\u4ee5\u88ab\u76f4\u63a5\u590d\u5236\u5230\u5185\u5b58\u5e76\u6267\u884c\u3002\n\n\n\u5171\u4eab\u76ee\u6807\u6587\u4ef6\n(.so\u6587\u4ef6)\u3002\u5728\u52a0\u8f7d\u6216\u8005\u8fd0\u884c\u65f6\u88ab\u52a8\u6001\u5730\u52a0\u8f7d\u8fdb\u5185\u5b58\u5e76\u94fe\u63a5\n\n\n\n\n\u5404\u4e2a\u7cfb\u7edf\u7684\u76ee\u6807\u6587\u4ef6\u683c\u5f0f\u4e0d\u540c\uff0cWindows\u4f7f\u7528\n\u53ef\u79fb\u690d\u53ef\u6267\u884c\n(Portable Executable, \nPE\n)\u683c\u5f0f\u3002\u73b0\u4ee3x86-64\u7cfb\u7edf\u4f7f\u7528\n\u53ef\u6267\u884c\u53ef\u94fe\u63a5\u683c\u5f0f\n(Executable and Linkable Format, \nELF\n)\u3002\n\n\n4 \u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\n\n\n\u4ee5\u53ef\u6267\u884c\u53ef\u94fe\u63a5(ELF)\u683c\u5f0f\u4e3a\u4f8b\uff0c\u4e00\u4e2a\u5178\u578b\u7684\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\u5305\u62ec\u4ee5\u4e0b\u51e0\u4e2a\u8282\uff1a\n\n\n\n\nELF\u5934\u548c\u8282\u5934\u90e8\u8868\n\n\n.text\n \u5df2\u7f16\u8bd1\u7a0b\u5e8f\u7684\u673a\u5668\u4ee3\u7801\n\n\n.rodata\n \u53ea\u8bfb\u6570\u636e\n\n\n.data\n  \u5df2\u521d\u59cb\u5316\u7684\u5168\u5c40\u548c\u9759\u6001C\u53d8\u91cf\n\n\n.bss\n  \u672a\u521d\u59cb\u5316\u7684\u5168\u5c40\u548c\u9759\u6001C\u53d8\u91cf\n\n\n.symtab\n \u4e00\u4e2a\u7b26\u53f7\u8868\n\n\n.rel.text\n \u4e00\u4e2a.text\u8282\u4e2d\u4f4d\u7f6e\u7684\u5217\u8868\n\n\n.rel.data\n \u91cd\u5b9a\u4f4d\u4fe1\u606f\n\n\n.debug\n \u8c03\u8bd5\u7b26\u53f7\u8868\n\n\n.line\n  \u539f\u59cb\u7a0b\u5e8f\u884c\u53f7\u548c\u673a\u5668\u6307\u4ee4\u4e4b\u95f4\u7684\u6620\u5c04\n\n\n.strtab\n  \u5b57\u7b26\u4e32\u8868\n\n\n\n\n\n\n\u5229\u7528\nREADELF\n\u7a0b\u5e8f\u53ef\u4ee5\u663e\u793a\u7a0b\u5e8f\nhello.c\n\u751f\u6210\u7684\u53ef\u6267\u884c\u53ef\u94fe\u63a5\u6587\u4ef6\u7684\u4fe1\u606f\uff1a\n\n\ngcc hello.c -c\nreadelf -a hello.o \n### UNIX/LINUX\n\ngreadelf -a hello.o \n### MAC, after brew install binutils\n\n\n\n\n\n\n\nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n  Class:                             ELF64\n  Data:                              2\ns complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              REL (Relocatable file)\n  Machine:                           Advanced Micro Devices X86-64\n  Version:                           0x1\n  Entry point address:               0x0\n  Start of program headers:          0 (bytes into file)\n  Start of section headers:          304 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           0 (bytes)\n  Number of program headers:         0\n  Size of section headers:           64 (bytes)\n  Number of section headers:         13\n  Section header string table index: 10\n\nSection Headers:\n  [Nr] Name              Type             Address           Offset\n       Size              EntSize          Flags  Link  Info  Align\n  [ 0]                   NULL             0000000000000000  00000000\n       0000000000000000  0000000000000000           0     0     0\n  [ 1] .text             PROGBITS         0000000000000000  00000040\n       0000000000000015  0000000000000000  AX       0     0     1\n  [ 2] .rela.text        RELA             0000000000000000  00000590\n       0000000000000030  0000000000000018          11     1     8\n  [ 3] .data             PROGBITS         0000000000000000  00000055\n       0000000000000000  0000000000000000  WA       0     0     1\n  [ 4] .bss              NOBITS           0000000000000000  00000055\n       0000000000000000  0000000000000000  WA       0     0     1\n  [ 5] .rodata           PROGBITS         0000000000000000  00000055\n       000000000000000c  0000000000000000   A       0     0     1\n  [ 6] .comment          PROGBITS         0000000000000000  00000061\n       000000000000002c  0000000000000001  MS       0     0     1\n  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  0000008d\n       0000000000000000  0000000000000000           0     0     1\n  [ 8] .eh_frame         PROGBITS         0000000000000000  00000090\n       0000000000000038  0000000000000000   A       0     0     8\n  [ 9] .rela.eh_frame    RELA             0000000000000000  000005c0\n       0000000000000018  0000000000000018          11     8     8\n  [10] .shstrtab         STRTAB           0000000000000000  000000c8\n       0000000000000061  0000000000000000           0     0     1\n  [11] .symtab           SYMTAB           0000000000000000  00000470\n       0000000000000108  0000000000000018          12     9     8\n  [12] .strtab           STRTAB           0000000000000000  00000578\n       0000000000000015  0000000000000000           0     0     1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)\n  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n  O (extra OS processing required) o (OS specific), p (processor specific)\n\nThere are no section groups in this file.\n\nThere are no program headers in this file.\n\nRelocation section \n.rela.text\n at offset 0x590 contains 2 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000000005  00050000000a R_X86_64_32       0000000000000000 .rodata + 0\n00000000000f  000a00000002 R_X86_64_PC32     0000000000000000 printf - 4\n\nRelocation section \n.rela.eh_frame\n at offset 0x5c0 contains 1 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0\n\nThe decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.\n\nSymbol table \n.symtab\n contains 11 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND\n     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c\n     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1\n     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3\n     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4\n     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5\n     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7\n     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8\n     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6\n     9: 0000000000000000    21 FUNC    GLOBAL DEFAULT    1 main\n    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf\n\nNo version information found in this file.\n\n\n\n\n\n5 \u7b26\u53f7\u548c\u7b26\u53f7\u8868\n\n\n.symtab\n\u4e2d\u7684\n\u7b26\u53f7\u8868\n\uff0c\u6709\u4e09\u79cd\u4e0d\u540c\u7684\u7b26\u53f7(\u4e0d\u5305\u62ec\u672c\u5730\u975e\u9759\u6001\u53d8\u91cf)\uff1a\n\n\n\n\n\u7531\u6a21\u5757\nm\nm\n\u5b9a\u4e49\u5e76\u80fd\u88ab\u5176\u4ed6\u6a21\u5757\u5f15\u7528\u7684\n\u5168\u5c40\u7b26\u53f7\n\u3002\n\n\n\u975e\u9759\u6001C\u51fd\u6570\u548c\u5168\u5c40\u53d8\u91cf\n\n\n\n\n\n\n\u7531\u5176\u4ed6\u6a21\u5757\u5b9a\u4e49\u5e76\u88ab\u6a21\u5757\nm\nm\n\u5f15\u7528\u7684\u5168\u5c40\u7b26\u53f7\u3002\n\n\n\u5bf9\u5e94\u4e8e\u5176\u4ed6\u6a21\u5757\u4e2d\u5b9a\u4e49\u7684\u975e\u9759\u6001C\u51fd\u6570\u548c\u5168\u5c40\u53d8\u91cf\n\n\n\n\n\n\n\u53ea\u88ab\u6a21\u5757\nm\nm\n\u5b9a\u4e49\u548c\u5f15\u7528\u7684\u5c40\u90e8\u7b26\u53f7\u3002\n\n\n\u9759\u6001C\u51fd\u6570\u548c\u5168\u5c40\u53d8\u91cf \n\n\n\n\n\n\n\n\n6 \u7b26\u53f7\u89e3\u6790\n\n\n\u7b26\u53f7\u89e3\u6790\n\u662f\u5c06\u6bcf\u4e2a\n\u7b26\u53f7\u5f15\u7528\n\u548c\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\u4e2d\u7684\n\u7b26\u53f7\u5b9a\u4e49\n\u5173\u8054\u8d77\u6765\u3002\u94fe\u63a5\u5668\u7684\u8f93\u5165\u662f\u4e00\u7ec4\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6(\u6a21\u5757)\uff0c\u6709\u4e9b\u662f\u5c40\u90e8\u7684( \n\u5c40\u90e8\u7b26\u53f7\n \uff0c\u53ea\u5bf9\u5b9a\u4e49\u8be5\u7b26\u53f7\u7684\u6a21\u5757\u53ef\u89c1)\uff0c\u6709\u4e9b\u662f\u5168\u5c40\u7684( \n\u5168\u5c40\u7b26\u53f7\n \uff0c\u5bf9\u5176\u4ed6\u6a21\u5757\u53ef\u89c1)\u3002\n\n\n\n\n\u5c40\u90e8\u7b26\u53f7\n\uff1a\u6bcf\u4e2a\u6a21\u5757\u4e2d\u6bcf\u4e2a\u5c40\u90e8\u7b26\u53f7\u6709\u4e00\u4e2a\u5b9a\u4e49\n\n\n\n\n\u5168\u5c40\u7b26\u53f7\n\uff1a\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\u7684\u7b26\u53f7\u8868\u91cc\u7684\u5168\u5c40\u7b26\u53f7\u662f\u533a\u5206\n\u5f3a\n\u548c\n\u5f31\n\u7684\uff0c\u94fe\u63a5\u5668\u6839\u636e\u4ee5\u4e0b\u89c4\u5219\u6765\u5904\u7406\u591a\u91cd\u5b9a\u4e49\u7684\u7b26\u53f7\u540d\uff1a\n\n\n\n\n\u89c4\u52191: \u4e0d\u5141\u8bb8\u6709\u591a\u4e2a\u540c\u540d\u7684\u5f3a\u7b26\u53f7\n\n\n\u89c4\u52192: \u5982\u679c\u6709\u4e00\u4e2a\u5f3a\u7b26\u53f7\u548c\u591a\u4e2a\u5f31\u7b26\u53f7\u540c\u540d\uff0c\u90a3\u4e48\u9009\u62e9\u5f3a\u7b26\u53f7\n\n\n\u89c4\u52193\uff1a\u5982\u679c\u6709\u591a\u4e2a\u5f31\u7b26\u53f7\u540c\u540d\uff0c\u90a3\u4e48\u4efb\u9009\u4e00\u4e2a \n\n\n\n\n\n\n\n\n7 \u91cd\u5b9a\u4f4d\n\n\n\u91cd\u5b9a\u4f4d\u5408\u5e76\u8f93\u5165\u6a21\u5757\uff0c\u5e76\u4e3a\u6bcf\u4e2a\u7b26\u53f7\u5206\u914d\u8fd0\u884c\u65f6\u5730\u5740\uff1a\n\n\n\n\n\u91cd\u5b9a\u4f4d\u8282\u548c\u7b26\u53f7\u5b9a\u4e49\uff1a\u5c06\u6240\u6709\u76f8\u540c\u7c7b\u578b\u7684\u8282\u5408\u5e76\u4e3a\u540c\u4e00\u7c7b\u578b\u7684\u65b0\u7684\u805a\u5408\u8282\uff0c\u5e76\u5c06\u8fd0\u884c\u65f6\u5185\u5b58\u5730\u5740\u8d4b\u7ed9\u65b0\u7684\u805a\u5408\u8282\u548c\u6bcf\u4e2a\u7b26\u53f7\u5b9a\u4e49\u3002\n\n\n\u4f8b\u5982\uff0c\u6765\u81ea\u6240\u6709\u8f93\u5165\u6a21\u5757\u7684\n.data\n\u8282\u88ab\u5168\u90e8\u5408\u5e76\u6210\u8f93\u51fa\u7684\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\u7684\n.data\n\u8282   \n\n\n\n\n\n\n\u91cd\u5b9a\u4f4d\u8282\u4e2d\u7684\u7b26\u53f7\u5f15\u7528\uff1a\u5c06\u8fd0\u884c\u65f6\u5730\u5740\u4ed8\u7ed9\u6bcf\u4e2a\u7b26\u53f7\u5f15\u7528\n\n\n\n\n8 \u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\n\n\n\u4e0b\u56fe\u6982\u62ec\u4e86\u4e00\u4e2a\u5178\u578b\u7684ELF\u53ef\u6267\u884c\u6587\u4ef6\u7684\u7ed9\u7c7b\u4fe1\u606f\u3002\n\n\n\n\n9 \u52a0\u8f7d\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\n\n\n\u5f53\u5728shell\u4e2d\u6267\u884c\u76ee\u6807\u6587\u4ef6\u65f6\uff0c\u9996\u5148\u901a\u8fc7\u8c03\u7528\n\u52a0\u8f7d\u5668\n(\nloader\n)\u7684\u64cd\u4f5c\u7cfb\u7edf\u4ee3\u7801\u6765\u8fd0\u884c\u5b83\uff0c\u52a0\u8f7d\u5668\u5c06\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\u7684\u4ee3\u7801\u548c\u6570\u636e\u590d\u5236\u5230\u4e3b\u5b58\uff0c\u8df3\u8f6c\u5230\u7a0b\u5e8f\u7684\u7b2c\u4e00\u6761\u6307\u4ee4(\u5165\u53e3\u70b9\uff0c\n_start_\n\u51fd\u6570\u7684\u5730\u5740)\u8fd0\u884c\u8be5\u7a0b\u5e8f\u3002\n\n\n\u5728Unix\u7cfb\u7edf\u4e2d\uff0c\u52a0\u8f7d\u5668\u662f\u7cfb\u7edf\u8c03\u7528(system call)\nexecve()\n\u7684\u56de\u8c03(call back)\uff0c\u5176\u4efb\u52a1\u5305\u62ec\uff1a\n\n\n\n\n\u786e\u8ba4(\u6743\u9650\uff0c\u5185\u5b58\u8981\u6c42\u7b49)\n\n\n\u590d\u5236\u7a0b\u5e8f\u5230\u4e3b\u5b58\n\n\n\u590d\u5236\u547d\u4ee4\u884c\u53c2\u6570\u5230\u6808\n\n\n\u521d\u59cb\u5316\u5bc4\u5b58\u5668(\u4f8b\u5982\u6808\u9488)\n\n\n\u8df3\u5230\u5165\u53e3\u70b9(\n_start_\n)\n\n\n\n\n10 \u52a8\u6001\u94fe\u63a5\u5171\u4eab\u5e93\n\n\n\u9759\u6001\u5e93\u67092\u5927\u7f3a\u9677\uff1a\n\n\n\n\n\u9759\u6001\u5e93\u66f4\u65b0\u65f6\uff0c\u9700\u8981\u663e\u793a\u5730\u5c06\u7a0b\u5e8f\u4e0e\u66f4\u65b0\u4e86\u7684\u5e93\u91cd\u65b0\u94fe\u63a5\n\n\n\u6d6a\u8d39\u5185\u5b58\u8d44\u6e90\uff1a\u51e0\u4e4e\u6bcf\u4e2aC\u7a0b\u5e8f\u90fd\u4f7f\u7528\u6807\u51c6I/O\u51fd\u6570\uff0c\u8fd9\u4e9b\u51fd\u6570\u4ee3\u7801\u4f1a\u88ab\u590d\u5236\u5230\u6bcf\u4e2a\u8fd0\u884c\u8fdb\u7a0b\u7684\u6587\u672c\u6bb5\u4e2d\n\n\n\n\n\u5171\u4eab\u5e93(shared library)\u662f\u81f4\u529b\u4e8e\u89e3\u51b3\u9759\u6001\u5e93\u7f3a\u9677\u7684\u4ea7\u7269\u3002\n\n\n\u52a8\u6001\u94fe\u63a5\n(dynamic linking)\uff1a\u5171\u4eab\u5e93\u5728\u8fd0\u884c\u6216\u52a0\u8f7d\u65f6\uff0c\u53ef\u4ee5\u52a0\u8f7d\u5230\u4efb\u610f\u7684\u5185\u5b58\u5730\u5740\uff0c\u5e76\u548c\u4e00\u4e2a\u5728\u5185\u5b58\u4e2d\u7684\u7a0b\u5e8f\u94fe\u63a5\u8d77\u6765\u3002\n\n \u7531\n\u52a8\u6001\u94fe\u63a5\u5668\n(dynamic linker)\u6267\u884c\uff1b\n\n \u5728linux\u7cfb\u7edf\u4e2d\u5e38\u7528\n.so\n\u540e\u7f00\u8868\u793a\u3002\n\n\n\n\n14 \u5904\u7406\u76ee\u6807\u6587\u4ef6\u7684\u5de5\u5177\n\n\nUnix\u7cfb\u7edf\u63d0\u4f9b\u4e86\u4e00\u7cfb\u5217\u547d\u4ee4\u5e2e\u52a9\u7406\u89e3\u548c\u5904\u7406\u76ee\u6807\u6587\u4ef6\u3002\u8fd9\u4e9b\u5de5\u5177\u5305\u62ec\uff1a\n\n\n\n\nar\n \uff1a\u521b\u5efa\u9759\u6001\u5e93\uff0c\u63d2\u5165\u3001\u5220\u9664\u3001\u5217\u51fa\u548c\u63d0\u53d6\u6210\u5458\uff1b\n\n\nSTRINGS\n \uff1a\u5217\u51fa\u76ee\u6807\u6587\u4ef6\u4e2d\u6240\u6709\u53ef\u4ee5\u6253\u5370\u7684\u5b57\u7b26\u4e32\uff1b\n\n\nSTRIP\n \uff1a\u4ece\u76ee\u6807\u6587\u4ef6\u4e2d\u5220\u9664\u7b26\u53f7\u8868\u4fe1\u606f\uff1b\n\n\nNM\n \uff1a\u5217\u51fa\u76ee\u6807\u6587\u4ef6\u7b26\u53f7\u8868\u4e2d\u5b9a\u4e49\u7684\u7b26\u53f7\uff1b\n\n\nSIZE\n \uff1a\u5217\u51fa\u76ee\u6807\u6587\u4ef6\u4e2d\u8282\u7684\u540d\u5b57\u548c\u5927\u5c0f\uff1b\n\n\nREADELF\n \uff1a\u663e\u793a\u4e00\u4e2a\u76ee\u6807\u6587\u4ef6\u7684\u5b8c\u6574\u7ed3\u6784\uff0c\u5305\u62ecELF \u5934\u4e2d\u7f16\u7801\u7684\u6240\u6709\u4fe1\u606f\u3002\n\n\nOBJDUMP\n \uff1a\u663e\u793a\u76ee\u6807\u6587\u4ef6\u7684\u6240\u6709\u4fe1\u606f\uff0c\u6700\u6709\u7528\u7684\u529f\u80fd\u662f\u53cd\u6c47\u7f16.text\u8282\u4e2d\u7684\u4e8c\u8fdb\u5236\u6307\u4ee4\u3002\n\n\nLDD\n \uff1a\u5217\u51fa\u53ef\u6267\u884c\u6587\u4ef6\u5728\u8fd0\u884c\u65f6\u9700\u8981\u7684\u5171\u4eab\u5e93\u3002", 
            "title": "Chapter 7: \u94fe\u63a5"
        }, 
        {
            "location": "/csapp/ch7/#chapter-7", 
            "text": "\u94fe\u63a5 (Linking)\u662f\u5c06\u5404\u79cd \u4ee3\u7801 \u548c \u6570\u636e\u7247\u6bb5 \u6536\u96c6\u5e76\u7ec4\u5408\u6210\u4e3a\u4e00\u4e2a\u5355\u4e00\u6587\u4ef6\u7684\u8fc7\u7a0b\u3002\u94fe\u63a5\u53ef\u4ee5\u5728\u7f16\u8bd1\u3001\u52a0\u8f7d\u3001\u8fd0\u884c\u65f6\u6267\u884c\u3002\u5728\u73b0\u4ee3\u7cfb\u7edf\u4e2d\uff0c\u94fe\u63a5\u7531 \u94fe\u63a5\u5668 (Linker)\u81ea\u52a8\u6267\u884c\u3002  \u94fe\u63a5\u5668\u4f7f\u5f97 \u5206\u79bb\u7f16\u8bd1 (separate compilation)\u6210\u4e3a\u53ef\u80fd\uff1a   \u53ef\u4ee5\u5c06\u6e90\u6587\u4ef6\u5206\u89e3\u4e3a\u66f4\u5c0f\u3001\u66f4\u597d\u7ba1\u7406\u7684\u6a21\u5757\uff0c\u53ef\u4ee5\u72ec\u7acb\u5730\u4fee\u6539\u548c\u7f16\u8bd1\u8fd9\u4e9b\u6a21\u5757  \u4fee\u6539\u4e00\u4e2a\u6a21\u5757\u540e\uff0c\u53ea\u9700\u91cd\u65b0\u7f16\u8bd1\u5b83\uff0c\u5e76\u91cd\u65b0\u94fe\u63a5\uff0c\u4e0d\u5fc5\u7f16\u8bd1\u5176\u4ed6\u6587\u4ef6", 
            "title": "Chapter 7 \u94fe\u63a5"
        }, 
        {
            "location": "/csapp/ch7/#1", 
            "text": "\u7f16\u8bd1\u5668\u9a71\u52a8\u7a0b\u5e8f ( compiler driver )\uff0c\u4ee3\u8868\u7528\u6237\u5728\u9700\u8981\u65f6\u8c03\u7528\u9884\u5904\u7406\u5668(cpp)\u3001\u7f16\u8bd1\u5668(ccl)\u3001\u6c47\u7f16\u5668(as)\u548c\u94fe\u63a5\u5668(ld)\u3002\u5178\u578b\u7684\u7f16\u8bd1\u5668\u9a71\u52a8\u7a0b\u5e8f\uff0c\u5305\u62ecGNU GCC, Clang\u3002  \u4f8b\u5982\uff0c\u4e00\u4e2a\u7b80\u5355\u6253\u5370hello\u7684 hello.c \u7a0b\u5e8f\uff0c\u7ecf\u8fc7\u4e0b\u9762\u56db\u4e2a\u9636\u6bb5\uff0c\u751f\u6210\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\uff1a  //file: hello.c  #include   stdio.h  int   main ()  { \n     int   i ; \n     printf ( Hello World );  }   linux   cpp  [ other arguments ]  hello.c hello.i // C\u9884\u5904\u7406\u5668cpp\uff0c\u5c06\u6e90\u7a0b\u5e8f\u7ffb\u8bd1\u6210\u4e00\u4e2aASCII\u7801\u7684\u4e2d\u95f4\u6587\u4ef6\nlinux   cc1 hello.i -Og  [ other arguments ]   -o hello.s //C\u7f16\u8bd1\u5668cc1, \u7ffb\u8bd1\u6210\u4e00\u4e2aASCII\u6c47\u7f16\u8bed\u8a00\u6587\u4ef6\nlinux   as  [ other arguments ]   -o hello.o hello.s //\u6c47\u7f16\u5668as, \u7ffb\u8bd1\u6210\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\nlinux   ld -o hello  [ system object files and args ]  hello.o //\u94fe\u63a5\u5668ld\uff0c\u521b\u5efa\u4e00\u4e2a\u53ef\u6267\u884c\u6587\u4ef6\n* linux   ./hello //\u8c03\u7528\u52a0\u8f7d\u5668", 
            "title": "1 \u7f16\u8bd1\u5668\u9a71\u52a8\u7a0b\u5e8f"
        }, 
        {
            "location": "/csapp/ch7/#2", 
            "text": "\u9759\u6001\u94fe\u63a5\u5668\u6709\u4e24\u4e2a\u4e3b\u8981\u4efb\u52a1\uff1a   \u7b26\u53f7\u89e3\u6790 (symbol resolution): \u5c06\u6bcf\u4e2a\u7b26\u53f7  \u5f15\u7528  \u6b63\u597d\u548c\u4e00\u4e2a\u7b26\u53f7  \u5b9a\u4e49  \u5173\u8054\u8d77\u6765\u3002  \u91cd\u5b9a\u4f4d (relocation): \u628a\u6bcf\u4e2a\u7b26\u53f7\u5b9a\u4e49\u4e0e\u4e00\u4e2a\u5185\u5b58\u4f4d\u7f6e\u5173\u8054\u8d77\u6765\uff0c\u5e76\u4fee\u6539\u6240\u6709\u5bf9\u8fd9\u4e9b\u7b26\u53f7\u7684\u5f15\u7528\uff0c\u4f7f\u5f97\u5b83\u4eec\u6307\u5411\u8fd9\u4e2a\u5185\u5b58\u4f4d\u7f6e\u3002", 
            "title": "2 \u9759\u6001\u94fe\u63a5"
        }, 
        {
            "location": "/csapp/ch7/#3", 
            "text": "\u76ee\u6807\u6587\u4ef6\u6709\u4e09\u79cd\u683c\u5f0f\uff1a \u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6 ( .o )\uff0c \u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6 ( .out )\uff0c \u5171\u4eab\u76ee\u6807\u6587\u4ef6 ( .so )   \u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6 (.o\u6587\u4ef6)\u3002\u5305\u542b\u4e8c\u8fdb\u5236\u4ee3\u7801\u548c\u6570\u636e\uff0c\u5176\u5f62\u5f0f\u53ef\u4ee5\u5728\u7f16\u8bd1\u65f6\u4e0e\u5176\u4ed6\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\u5408\u5e76\u8d77\u6765\uff0c\u521b\u5efa\u4e00\u4e2a\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\u3002  \u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6 (a.out\u6587\u4ef6)\u3002\u5305\u542b\u4e8c\u8fdb\u5236\u4ee3\u7801\u548c\u6570\u636e\uff0c\u5176\u5f62\u5f0f\u53ef\u4ee5\u88ab\u76f4\u63a5\u590d\u5236\u5230\u5185\u5b58\u5e76\u6267\u884c\u3002  \u5171\u4eab\u76ee\u6807\u6587\u4ef6 (.so\u6587\u4ef6)\u3002\u5728\u52a0\u8f7d\u6216\u8005\u8fd0\u884c\u65f6\u88ab\u52a8\u6001\u5730\u52a0\u8f7d\u8fdb\u5185\u5b58\u5e76\u94fe\u63a5   \u5404\u4e2a\u7cfb\u7edf\u7684\u76ee\u6807\u6587\u4ef6\u683c\u5f0f\u4e0d\u540c\uff0cWindows\u4f7f\u7528 \u53ef\u79fb\u690d\u53ef\u6267\u884c (Portable Executable,  PE )\u683c\u5f0f\u3002\u73b0\u4ee3x86-64\u7cfb\u7edf\u4f7f\u7528 \u53ef\u6267\u884c\u53ef\u94fe\u63a5\u683c\u5f0f (Executable and Linkable Format,  ELF )\u3002", 
            "title": "3 \u76ee\u6807\u6587\u4ef6"
        }, 
        {
            "location": "/csapp/ch7/#4", 
            "text": "\u4ee5\u53ef\u6267\u884c\u53ef\u94fe\u63a5(ELF)\u683c\u5f0f\u4e3a\u4f8b\uff0c\u4e00\u4e2a\u5178\u578b\u7684\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\u5305\u62ec\u4ee5\u4e0b\u51e0\u4e2a\u8282\uff1a   ELF\u5934\u548c\u8282\u5934\u90e8\u8868  .text  \u5df2\u7f16\u8bd1\u7a0b\u5e8f\u7684\u673a\u5668\u4ee3\u7801  .rodata  \u53ea\u8bfb\u6570\u636e  .data   \u5df2\u521d\u59cb\u5316\u7684\u5168\u5c40\u548c\u9759\u6001C\u53d8\u91cf  .bss   \u672a\u521d\u59cb\u5316\u7684\u5168\u5c40\u548c\u9759\u6001C\u53d8\u91cf  .symtab  \u4e00\u4e2a\u7b26\u53f7\u8868  .rel.text  \u4e00\u4e2a.text\u8282\u4e2d\u4f4d\u7f6e\u7684\u5217\u8868  .rel.data  \u91cd\u5b9a\u4f4d\u4fe1\u606f  .debug  \u8c03\u8bd5\u7b26\u53f7\u8868  .line   \u539f\u59cb\u7a0b\u5e8f\u884c\u53f7\u548c\u673a\u5668\u6307\u4ee4\u4e4b\u95f4\u7684\u6620\u5c04  .strtab   \u5b57\u7b26\u4e32\u8868    \u5229\u7528 READELF \u7a0b\u5e8f\u53ef\u4ee5\u663e\u793a\u7a0b\u5e8f hello.c \u751f\u6210\u7684\u53ef\u6267\u884c\u53ef\u94fe\u63a5\u6587\u4ef6\u7684\u4fe1\u606f\uff1a  gcc hello.c -c\nreadelf -a hello.o  ### UNIX/LINUX \ngreadelf -a hello.o  ### MAC, after brew install binutils    ELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n  Class:                             ELF64\n  Data:                              2 s complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              REL (Relocatable file)\n  Machine:                           Advanced Micro Devices X86-64\n  Version:                           0x1\n  Entry point address:               0x0\n  Start of program headers:          0 (bytes into file)\n  Start of section headers:          304 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           0 (bytes)\n  Number of program headers:         0\n  Size of section headers:           64 (bytes)\n  Number of section headers:         13\n  Section header string table index: 10\n\nSection Headers:\n  [Nr] Name              Type             Address           Offset\n       Size              EntSize          Flags  Link  Info  Align\n  [ 0]                   NULL             0000000000000000  00000000\n       0000000000000000  0000000000000000           0     0     0\n  [ 1] .text             PROGBITS         0000000000000000  00000040\n       0000000000000015  0000000000000000  AX       0     0     1\n  [ 2] .rela.text        RELA             0000000000000000  00000590\n       0000000000000030  0000000000000018          11     1     8\n  [ 3] .data             PROGBITS         0000000000000000  00000055\n       0000000000000000  0000000000000000  WA       0     0     1\n  [ 4] .bss              NOBITS           0000000000000000  00000055\n       0000000000000000  0000000000000000  WA       0     0     1\n  [ 5] .rodata           PROGBITS         0000000000000000  00000055\n       000000000000000c  0000000000000000   A       0     0     1\n  [ 6] .comment          PROGBITS         0000000000000000  00000061\n       000000000000002c  0000000000000001  MS       0     0     1\n  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  0000008d\n       0000000000000000  0000000000000000           0     0     1\n  [ 8] .eh_frame         PROGBITS         0000000000000000  00000090\n       0000000000000038  0000000000000000   A       0     0     8\n  [ 9] .rela.eh_frame    RELA             0000000000000000  000005c0\n       0000000000000018  0000000000000018          11     8     8\n  [10] .shstrtab         STRTAB           0000000000000000  000000c8\n       0000000000000061  0000000000000000           0     0     1\n  [11] .symtab           SYMTAB           0000000000000000  00000470\n       0000000000000108  0000000000000018          12     9     8\n  [12] .strtab           STRTAB           0000000000000000  00000578\n       0000000000000015  0000000000000000           0     0     1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)\n  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n  O (extra OS processing required) o (OS specific), p (processor specific)\n\nThere are no section groups in this file.\n\nThere are no program headers in this file.\n\nRelocation section  .rela.text  at offset 0x590 contains 2 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000000005  00050000000a R_X86_64_32       0000000000000000 .rodata + 0\n00000000000f  000a00000002 R_X86_64_PC32     0000000000000000 printf - 4\n\nRelocation section  .rela.eh_frame  at offset 0x5c0 contains 1 entries:\n  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0\n\nThe decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.\n\nSymbol table  .symtab  contains 11 entries:\n   Num:    Value          Size Type    Bind   Vis      Ndx Name\n     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND\n     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS hello.c\n     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1\n     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3\n     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4\n     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5\n     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7\n     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    8\n     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    6\n     9: 0000000000000000    21 FUNC    GLOBAL DEFAULT    1 main\n    10: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf\n\nNo version information found in this file.", 
            "title": "4 \u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6"
        }, 
        {
            "location": "/csapp/ch7/#5", 
            "text": ".symtab \u4e2d\u7684 \u7b26\u53f7\u8868 \uff0c\u6709\u4e09\u79cd\u4e0d\u540c\u7684\u7b26\u53f7(\u4e0d\u5305\u62ec\u672c\u5730\u975e\u9759\u6001\u53d8\u91cf)\uff1a   \u7531\u6a21\u5757 m m \u5b9a\u4e49\u5e76\u80fd\u88ab\u5176\u4ed6\u6a21\u5757\u5f15\u7528\u7684 \u5168\u5c40\u7b26\u53f7 \u3002  \u975e\u9759\u6001C\u51fd\u6570\u548c\u5168\u5c40\u53d8\u91cf    \u7531\u5176\u4ed6\u6a21\u5757\u5b9a\u4e49\u5e76\u88ab\u6a21\u5757 m m \u5f15\u7528\u7684\u5168\u5c40\u7b26\u53f7\u3002  \u5bf9\u5e94\u4e8e\u5176\u4ed6\u6a21\u5757\u4e2d\u5b9a\u4e49\u7684\u975e\u9759\u6001C\u51fd\u6570\u548c\u5168\u5c40\u53d8\u91cf    \u53ea\u88ab\u6a21\u5757 m m \u5b9a\u4e49\u548c\u5f15\u7528\u7684\u5c40\u90e8\u7b26\u53f7\u3002  \u9759\u6001C\u51fd\u6570\u548c\u5168\u5c40\u53d8\u91cf", 
            "title": "5 \u7b26\u53f7\u548c\u7b26\u53f7\u8868"
        }, 
        {
            "location": "/csapp/ch7/#6", 
            "text": "\u7b26\u53f7\u89e3\u6790 \u662f\u5c06\u6bcf\u4e2a \u7b26\u53f7\u5f15\u7528 \u548c\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\u4e2d\u7684 \u7b26\u53f7\u5b9a\u4e49 \u5173\u8054\u8d77\u6765\u3002\u94fe\u63a5\u5668\u7684\u8f93\u5165\u662f\u4e00\u7ec4\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6(\u6a21\u5757)\uff0c\u6709\u4e9b\u662f\u5c40\u90e8\u7684(  \u5c40\u90e8\u7b26\u53f7  \uff0c\u53ea\u5bf9\u5b9a\u4e49\u8be5\u7b26\u53f7\u7684\u6a21\u5757\u53ef\u89c1)\uff0c\u6709\u4e9b\u662f\u5168\u5c40\u7684(  \u5168\u5c40\u7b26\u53f7  \uff0c\u5bf9\u5176\u4ed6\u6a21\u5757\u53ef\u89c1)\u3002   \u5c40\u90e8\u7b26\u53f7 \uff1a\u6bcf\u4e2a\u6a21\u5757\u4e2d\u6bcf\u4e2a\u5c40\u90e8\u7b26\u53f7\u6709\u4e00\u4e2a\u5b9a\u4e49   \u5168\u5c40\u7b26\u53f7 \uff1a\u53ef\u91cd\u5b9a\u4f4d\u76ee\u6807\u6587\u4ef6\u7684\u7b26\u53f7\u8868\u91cc\u7684\u5168\u5c40\u7b26\u53f7\u662f\u533a\u5206 \u5f3a \u548c \u5f31 \u7684\uff0c\u94fe\u63a5\u5668\u6839\u636e\u4ee5\u4e0b\u89c4\u5219\u6765\u5904\u7406\u591a\u91cd\u5b9a\u4e49\u7684\u7b26\u53f7\u540d\uff1a   \u89c4\u52191: \u4e0d\u5141\u8bb8\u6709\u591a\u4e2a\u540c\u540d\u7684\u5f3a\u7b26\u53f7  \u89c4\u52192: \u5982\u679c\u6709\u4e00\u4e2a\u5f3a\u7b26\u53f7\u548c\u591a\u4e2a\u5f31\u7b26\u53f7\u540c\u540d\uff0c\u90a3\u4e48\u9009\u62e9\u5f3a\u7b26\u53f7  \u89c4\u52193\uff1a\u5982\u679c\u6709\u591a\u4e2a\u5f31\u7b26\u53f7\u540c\u540d\uff0c\u90a3\u4e48\u4efb\u9009\u4e00\u4e2a", 
            "title": "6 \u7b26\u53f7\u89e3\u6790"
        }, 
        {
            "location": "/csapp/ch7/#7", 
            "text": "\u91cd\u5b9a\u4f4d\u5408\u5e76\u8f93\u5165\u6a21\u5757\uff0c\u5e76\u4e3a\u6bcf\u4e2a\u7b26\u53f7\u5206\u914d\u8fd0\u884c\u65f6\u5730\u5740\uff1a   \u91cd\u5b9a\u4f4d\u8282\u548c\u7b26\u53f7\u5b9a\u4e49\uff1a\u5c06\u6240\u6709\u76f8\u540c\u7c7b\u578b\u7684\u8282\u5408\u5e76\u4e3a\u540c\u4e00\u7c7b\u578b\u7684\u65b0\u7684\u805a\u5408\u8282\uff0c\u5e76\u5c06\u8fd0\u884c\u65f6\u5185\u5b58\u5730\u5740\u8d4b\u7ed9\u65b0\u7684\u805a\u5408\u8282\u548c\u6bcf\u4e2a\u7b26\u53f7\u5b9a\u4e49\u3002  \u4f8b\u5982\uff0c\u6765\u81ea\u6240\u6709\u8f93\u5165\u6a21\u5757\u7684 .data \u8282\u88ab\u5168\u90e8\u5408\u5e76\u6210\u8f93\u51fa\u7684\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\u7684 .data \u8282       \u91cd\u5b9a\u4f4d\u8282\u4e2d\u7684\u7b26\u53f7\u5f15\u7528\uff1a\u5c06\u8fd0\u884c\u65f6\u5730\u5740\u4ed8\u7ed9\u6bcf\u4e2a\u7b26\u53f7\u5f15\u7528", 
            "title": "7 \u91cd\u5b9a\u4f4d"
        }, 
        {
            "location": "/csapp/ch7/#8", 
            "text": "\u4e0b\u56fe\u6982\u62ec\u4e86\u4e00\u4e2a\u5178\u578b\u7684ELF\u53ef\u6267\u884c\u6587\u4ef6\u7684\u7ed9\u7c7b\u4fe1\u606f\u3002", 
            "title": "8 \u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6"
        }, 
        {
            "location": "/csapp/ch7/#9", 
            "text": "\u5f53\u5728shell\u4e2d\u6267\u884c\u76ee\u6807\u6587\u4ef6\u65f6\uff0c\u9996\u5148\u901a\u8fc7\u8c03\u7528 \u52a0\u8f7d\u5668 ( loader )\u7684\u64cd\u4f5c\u7cfb\u7edf\u4ee3\u7801\u6765\u8fd0\u884c\u5b83\uff0c\u52a0\u8f7d\u5668\u5c06\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\u7684\u4ee3\u7801\u548c\u6570\u636e\u590d\u5236\u5230\u4e3b\u5b58\uff0c\u8df3\u8f6c\u5230\u7a0b\u5e8f\u7684\u7b2c\u4e00\u6761\u6307\u4ee4(\u5165\u53e3\u70b9\uff0c _start_ \u51fd\u6570\u7684\u5730\u5740)\u8fd0\u884c\u8be5\u7a0b\u5e8f\u3002  \u5728Unix\u7cfb\u7edf\u4e2d\uff0c\u52a0\u8f7d\u5668\u662f\u7cfb\u7edf\u8c03\u7528(system call) execve() \u7684\u56de\u8c03(call back)\uff0c\u5176\u4efb\u52a1\u5305\u62ec\uff1a   \u786e\u8ba4(\u6743\u9650\uff0c\u5185\u5b58\u8981\u6c42\u7b49)  \u590d\u5236\u7a0b\u5e8f\u5230\u4e3b\u5b58  \u590d\u5236\u547d\u4ee4\u884c\u53c2\u6570\u5230\u6808  \u521d\u59cb\u5316\u5bc4\u5b58\u5668(\u4f8b\u5982\u6808\u9488)  \u8df3\u5230\u5165\u53e3\u70b9( _start_ )", 
            "title": "9 \u52a0\u8f7d\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6"
        }, 
        {
            "location": "/csapp/ch7/#10", 
            "text": "\u9759\u6001\u5e93\u67092\u5927\u7f3a\u9677\uff1a   \u9759\u6001\u5e93\u66f4\u65b0\u65f6\uff0c\u9700\u8981\u663e\u793a\u5730\u5c06\u7a0b\u5e8f\u4e0e\u66f4\u65b0\u4e86\u7684\u5e93\u91cd\u65b0\u94fe\u63a5  \u6d6a\u8d39\u5185\u5b58\u8d44\u6e90\uff1a\u51e0\u4e4e\u6bcf\u4e2aC\u7a0b\u5e8f\u90fd\u4f7f\u7528\u6807\u51c6I/O\u51fd\u6570\uff0c\u8fd9\u4e9b\u51fd\u6570\u4ee3\u7801\u4f1a\u88ab\u590d\u5236\u5230\u6bcf\u4e2a\u8fd0\u884c\u8fdb\u7a0b\u7684\u6587\u672c\u6bb5\u4e2d   \u5171\u4eab\u5e93(shared library)\u662f\u81f4\u529b\u4e8e\u89e3\u51b3\u9759\u6001\u5e93\u7f3a\u9677\u7684\u4ea7\u7269\u3002  \u52a8\u6001\u94fe\u63a5 (dynamic linking)\uff1a\u5171\u4eab\u5e93\u5728\u8fd0\u884c\u6216\u52a0\u8f7d\u65f6\uff0c\u53ef\u4ee5\u52a0\u8f7d\u5230\u4efb\u610f\u7684\u5185\u5b58\u5730\u5740\uff0c\u5e76\u548c\u4e00\u4e2a\u5728\u5185\u5b58\u4e2d\u7684\u7a0b\u5e8f\u94fe\u63a5\u8d77\u6765\u3002  \u7531 \u52a8\u6001\u94fe\u63a5\u5668 (dynamic linker)\u6267\u884c\uff1b  \u5728linux\u7cfb\u7edf\u4e2d\u5e38\u7528 .so \u540e\u7f00\u8868\u793a\u3002", 
            "title": "10 \u52a8\u6001\u94fe\u63a5\u5171\u4eab\u5e93"
        }, 
        {
            "location": "/csapp/ch7/#14", 
            "text": "Unix\u7cfb\u7edf\u63d0\u4f9b\u4e86\u4e00\u7cfb\u5217\u547d\u4ee4\u5e2e\u52a9\u7406\u89e3\u548c\u5904\u7406\u76ee\u6807\u6587\u4ef6\u3002\u8fd9\u4e9b\u5de5\u5177\u5305\u62ec\uff1a   ar  \uff1a\u521b\u5efa\u9759\u6001\u5e93\uff0c\u63d2\u5165\u3001\u5220\u9664\u3001\u5217\u51fa\u548c\u63d0\u53d6\u6210\u5458\uff1b  STRINGS  \uff1a\u5217\u51fa\u76ee\u6807\u6587\u4ef6\u4e2d\u6240\u6709\u53ef\u4ee5\u6253\u5370\u7684\u5b57\u7b26\u4e32\uff1b  STRIP  \uff1a\u4ece\u76ee\u6807\u6587\u4ef6\u4e2d\u5220\u9664\u7b26\u53f7\u8868\u4fe1\u606f\uff1b  NM  \uff1a\u5217\u51fa\u76ee\u6807\u6587\u4ef6\u7b26\u53f7\u8868\u4e2d\u5b9a\u4e49\u7684\u7b26\u53f7\uff1b  SIZE  \uff1a\u5217\u51fa\u76ee\u6807\u6587\u4ef6\u4e2d\u8282\u7684\u540d\u5b57\u548c\u5927\u5c0f\uff1b  READELF  \uff1a\u663e\u793a\u4e00\u4e2a\u76ee\u6807\u6587\u4ef6\u7684\u5b8c\u6574\u7ed3\u6784\uff0c\u5305\u62ecELF \u5934\u4e2d\u7f16\u7801\u7684\u6240\u6709\u4fe1\u606f\u3002  OBJDUMP  \uff1a\u663e\u793a\u76ee\u6807\u6587\u4ef6\u7684\u6240\u6709\u4fe1\u606f\uff0c\u6700\u6709\u7528\u7684\u529f\u80fd\u662f\u53cd\u6c47\u7f16.text\u8282\u4e2d\u7684\u4e8c\u8fdb\u5236\u6307\u4ee4\u3002  LDD  \uff1a\u5217\u51fa\u53ef\u6267\u884c\u6587\u4ef6\u5728\u8fd0\u884c\u65f6\u9700\u8981\u7684\u5171\u4eab\u5e93\u3002", 
            "title": "14 \u5904\u7406\u76ee\u6807\u6587\u4ef6\u7684\u5de5\u5177"
        }, 
        {
            "location": "/csapp/ch8/", 
            "text": "Chapter 8 \u5f02\u5e38\u63a7\u5236\u6d41\n\n\n\u4ece\u7ed9\u5904\u7406\u5668\u52a0\u7535\u5f00\u59cb\uff0c\u76f4\u5230\u4f60\u65ad\u7535\u4e3a\u6b62\uff0c\u7a0b\u5e8f\u8ba1\u6570\u5668\u5047\u8bbe\u6210\u4e00\u4e2a\u503c\u7684\u5e8f\u5217\n\n\n\n\na_0, a_1, ..., a_{n-1}\n\n\na_0, a_1, ..., a_{n-1}\n\n\n\n\n\u5176\u4e2d\uff0c\u6bcf\u4e2a\na_k\na_k\n\u662f\u67d0\u4e2a\u76f8\u5e94\u7684\u6307\u4ee4\nI_k\nI_k\n\u7684 \n\u5730\u5740\n \u3002\u6bcf\u6b21\u4ece\na_k\na_k\n\u5230\na_{k+1}\na_{k+1}\n\u7684\u8fc7\u6e21\u79f0\u4e3a\n\u63a7\u5236\u8f6c\u79fb\n(control transfer)\u3002\u8fd9\u6837\u7684\u63a7\u5236\u8f6c\u79fb\u5e8f\u5217\u53eb\u505a\u5904\u7406\u5668\u7684\n\u63a7\u5236\u6d41\n(control flow)\u3002\n\n\n\u73b0\u5728\u7cfb\u7edf\u901a\u8fc7\u4f7f\u63a7\u5236\u6d41\u53d1\u751f\u7a81\u53d8\u6765\u5e94\u5bf9\u7cfb\u7edf\u72b6\u6001\u7684\u53d8\u5316(eg.\u7f3a\u9875\u5f02\u5e38\uff0c\u7f51\u7edc\u7b49\u5f85)\uff0c\u628a\u8fd9\u4e9b\u7a81\u53d8\u79f0\u4e3a\n\u5f02\u5e38\u63a7\u5236\u6d41\n(Exceptional Control Flow, ECF)\u3002\n\n\n1 \u5f02\u5e38\n\n\n\u5f02\u5e38\u7684\u5904\u7406\n\n\n\u7cfb\u7edf\u4e3a\u6bcf\n\u7c7b\n\u53ef\u80fd\u7684\u5f02\u5e38\u90fd\u5206\u914d\u4e86\u4e00\u4e2a\u552f\u4e00\u7684\u975e\u8d1f\u6574\u6570\u7684\n\u5f02\u5e38\u53f7\n(exception number)\u3002\u5728\u7cfb\u7edf\u542f\u52a8\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5206\u914d\u548c\u521d\u59cb\u5316\u4e00\u5f20\u79f0\u4e3a\n\u5f02\u5e38\u8868\n\u7684\u8df3\u8f6c\u8868\uff0c\u4f7f\u5f97\u8868\u76ee\nk\nk\n\u5305\u542b\u5f02\u5e38\nk\nk\n\u7684\u5904\u7406\u7a0b\u5e8f\u7684\u5730\u5740\u3002\n\n\n\n\n\u5f53\u68c0\u6d4b\u5230\u53d1\u751f\u4e86\u4e00\u4e2a\u4e8b\u4ef6\uff0c\u5e76\u4e14\u786e\u5b9a\u4e86\u76f8\u5e94\u7684\u5f02\u5e38\u53f7\nk\nk\n\uff0c\u5904\u7406\u5668\u89e6\u53d1\u5f02\u5e38\uff0c\u6267\u884c\u95f4\u63a5\u8fc7\u7a0b\u8c03\u7528\uff0c\u901a\u8fc7\u5f02\u5e38\u8868\u7684\u8868\u76ee\nk\nk\n\uff0c\u8f6c\u5230\u76f8\u5e94\u7684\u5904\u7406\u7a0b\u5e8f\u3002\n\n\n\u5f02\u5e38\u7684\u7c7b\u522b\n\n\n\u5f02\u5e38(exceptions)\u53ef\u4ee5\u5206\u4e3a\u56db\u7c7b\uff1a\u4e2d\u65ad(interrupt)\u3001\u9677\u9631(trap)\u3001\u6545\u969c(fault)\u548c\u7ec8\u6b62(abort)\u3002\n\n\n\n\n\n\n\u4e2d\u65ad\n\u662f\u5f02\u6b65\u53d1\u751f\u7684\uff0c\u662f\u6765\u81ea\u5904\u7406\u5668\u5916\u90e8\u7684I/O\u8bbe\u5907\u7684\u4fe1\u53f7\u7684\u7ed3\u679c\u3002\n\n\n\u9677\u9631\n\u662f\u6709\u610f\u7684\u5f02\u5e38\uff0c\u662f\u6267\u884c\u4e00\u6761\u6307\u4ee4\u7684\u7ed3\u679c\u3002\n\n\n\u5176\u7528\u9014\u662f\u5728\u7528\u6237\u7a0b\u5e8f\u548c\u5185\u6838\u4e4b\u95f4\u63d0\u4f9b\u4e00\u4e2a\u50cf\u8fc7\u7a0b\u4e00\u6837\u7684\u63a5\u53e3(\u7cfb\u7edf\u8c03\u7528)\n\n\n\n\n\n\n\u6545\u969c\n\u662f\u7531\u9519\u8bef\u60c5\u51b5\u5f15\u8d77\u7684\uff0c\u53ef\u80fd\u80fd\u591f\u88ab\u6545\u969c\u5904\u7406\u7a0b\u5e8f\u4fee\u6b63\u3002\n\n\n\u4f8b\u5982\u7f3a\u9875\u5f02\u5e38\n\n\n\n\n\n\n\u7ec8\u6b62\n\u662f\u4e0d\u53ef\u6062\u590d\u7684\u81f4\u547d\u9519\u8bef\u9020\u6210\u7684\u7ed3\u679c\uff0c\u901a\u5e38\u662f\u4e00\u4e9b\u786c\u4ef6\u9519\u8bef\u3002   \n\n\n\n\n2 \u8fdb\u7a0b\n\n\n\u8fdb\u7a0b\n(Process)\u7684\u7ecf\u5178\u5b9a\u4e49\u5c31\u662f \n\u4e00\u4e2a\u6267\u884c\u4e2d\u7a0b\u5e8f\u7684\u5b9e\u4f8b\n (A process is a program in execuation) \u3002\u7cfb\u7edf\u4e2d\u7684\u6bcf\u4e2a\u7a0b\u5e8f\u90fd\u8fd0\u884c\u5728\u67d0\u4e2a\u8fdb\u7a0b\u7684\u4e0a\u4e0b\u6587(context)\u4e2d\u3002\u4e0a\u4e0b\u6587\u662f\u7531\u7a0b\u5e8f\u6b63\u786e\u8fd0\u884c\u6240\u9700\u7684\u72b6\u6001\u7ec4\u6210\u7684\u3002\u8fd9\u4e2a\u72b6\u6001\u5305\u62ec\u5b58\u653e\u5728\u5185\u5b58\u4e2d\u7684\u7a0b\u5e8f\u7684\u4ee3\u7801\u548c\u6570\u636e\uff0c\u5b83\u7684\u6808\u3001\u901a\u7528\u76ee\u7684\u5bc4\u5b58\u5668\u7684\u5185\u5bb9\u3001\u7a0b\u5e8f\u8ba1\u6570\u5668\u3001\u73af\u5883\u53d8\u91cf\u4ee5\u53ca\u6253\u5f00\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u96c6\u5408\u3002\n\n\n\u8fdb\u7a0b\u63d0\u4f9b\u4e86\u5e94\u7528\u7a0b\u5e8f\u4e24\u4e2a\u5173\u952e\u62bd\u8c61\uff1a\n\n\n\n\n\u4e00\u4e2a\n\u72ec\u7acb\n\u7684\u903b\u8f91\u63a7\u5236\u6d41\uff0c\u5b83\u63d0\u4f9b\u4e00\u4e2a\u5047\u8c61\uff0c\u597d\u50cf\u6211\u4eec\u7684\u7a0b\u5e8f\u72ec\u5360\u5730\u4f7f\u7528\u5904\u7406\u5668\u3002\n\n\n\u4e00\u4e2a\n\u79c1\u6709\n\u7684\u5730\u5740\u7a7a\u95f4\uff0c\u5b83\u63d0\u4f9b\u4e00\u4e2a\u5047\u8c61\uff0c\u597d\u50cf\u6211\u4eec\u7684\u7a0b\u5e8f\u72ec\u5360\u5730\u4f7f\u7528\u5185\u5b58\u7cfb\u7edf\u3002\n\n\n\n\n\u903b\u8f91\u63a7\u5236\u6d41\n\n\n\u903b\u8f91\u63a7\u5236\u6d41\n(Logical Control Flow\uff0c\u7b80\u79f0\u903b\u8f91\u6d41)\u662fPC\u503c\u7684\u5e8f\u5217\u3002\n\n\n\u5e76\u53d1\u6d41\n\n\n\u4e00\u4e2a\u903b\u8f91\u6d41\u7684\u6267\u884c\u5728\u65f6\u95f4\u4e0a\u4e0e\u53e6\u4e00\u4e2a\u6d41\u91cd\u53e0\uff0c\u79f0\u4e3a\n\u5e76\u53d1\u6d41\n(concurrent flow)\uff0c\u8fd9\u4e24\u4e2a\u6d41\u88ab\u79f0\u4e3a\n\u5e76\u53d1\u5730\u8fd0\u884c\n\u3002\n\n\n\u79c1\u6709\u5730\u5740\u7a7a\u95f4\n\n\n\u8fdb\u7a0b\u4e3a\u6bcf\u4e2a\u7a0b\u5e8f\u63d0\u4f9b\u5b83\u81ea\u5df1\u7684\n\u79c1\u6709\u5730\u5740\u7a7a\u95f4\n\u3002\u4e00\u822c\u800c\u8a00\uff0c\u548c\u8fd9\u4e2a\u7a7a\u95f4\u4e2d\u67d0\u4e2a\u5730\u5740\u76f8\u5173\u8054\u7684\u90a3\u4e2a\u5185\u5b58\u5b57\u8282\u662f\u4e0d\u80fd\u88ab\u5176\u4ed6\u8fdb\u7a0b\u8bfb\u6216\u8005\u5199\u7684\uff0c\u4ece\u8fd9\u4e2a\u610f\u4e49\u4e0a\u8bf4\uff0c\u8fd9\u4e2a\u5730\u5740\u7a7a\u95f4\u662f\u79c1\u6709\u7684\u3002\n\n\n\u7528\u6237\u6a21\u5f0f\u548c\u5185\u6838\u6a21\u5f0f\n\n\n\u5904\u7406\u5668\u901a\u5e38\u662f\u7528\u67d0\u4e2a\u63a7\u5236\u5bc4\u5b58\u5668\u4e2d\u7684\u4e00\u4e2a\n\u6a21\u5f0f\u4f4d\n(mode bit)\u6765\u63a7\u5236\u7528\u6237/\u5185\u6838\u6a21\u5f0f\u3002\u5f53\u8bbe\u7f6e\u4e86\u6a21\u5f0f\u4f4d\u65f6\uff0c\u8fdb\u7a0b\u5c31\u8fd0\u884c\u5728\n\u5185\u6838\u6a21\u5f0f\n\u4e2d\uff0c\u5426\u5219\u8fd0\u884c\u5728\n\u7528\u6237\u6a21\u5f0f\n\u4e2d\u3002\n\n\n\u8fd0\u884c\u5728\u5185\u6838\u6a21\u5f0f\u7684\u8fdb\u7a0b\u53ef\u4ee5\u6267\u884c\u6307\u4ee4\u96c6\u4e2d\u7684\u4efb\u4f55\u6307\u4ee4\uff0c\u53ef\u4ee5\u8bbf\u95ee\u4efb\u4f55\u5185\u5b58\u4f4d\u7f6e\u3002\u7528\u6237\u6a21\u5f0f\u4e2d\u7684\u8fdb\u7a0b\u4e0d\u5141\u8bb8\u6267\u884c\u7279\u6743\u6307\u4ee4\uff0c\u4e5f\u4e0d\u5141\u8bb8\u76f4\u63a5\u5f15\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u5185\u6838\u533a\u7684\u4ee3\u7801\u548c\u6570\u636e\u3002\n\n\n3 \u7cfb\u7edf\u8c03\u7528\u9519\u8bef\u5904\u7406\n\n\n4 \u8fdb\u7a0b\u63a7\u5236\n\n\n\u8fdb\u7a0b\u63a7\u5236\u5305\u62ec\u83b7\u53d6\u8fdb\u7a0bID\u3001\u521b\u5efa\u548c\u7ec8\u6b62\u8fdb\u7a0b\u3001\u56de\u6536\u5b50\u8fdb\u7a0b\u3001\u8ba9\u8fdb\u7a0b\u4f11\u7720\u3001\u52a0\u8f7d\u5e76\u8fd0\u884c\u7a0b\u5e8f\u7b49\u3002\u8fd9\u4e00\u8282\u5c06\u63cf\u8ff0Unix\u63d0\u4f9b\u4e86\u63a7\u5236\u8fdb\u7a0b\u7684\u7cfb\u7edf\u8c03\u7528\u3002\n\n\n\u83b7\u53d6\u8fdb\u7a0bID\n\n\n\u6bcf\u4e00\u4e2a\u8fdb\u7a0b\u90fd\u6709\u4e00\u4e2a\u552f\u4e00\u7684\u6574\u6570(\u975e\u96f6)\u8fdb\u7a0bID(PID)\u3002\ngetpid\n\u51fd\u6570\u8fd4\u56de\u8c03\u7528\u8fdb\u7a0b\u7684PID\u3002\ngetppid\n\u51fd\u6570\u8fd4\u56de\u5b83\u7684\u7236\u8fdb\u7a0b\u7684PID\u3002\n\n\n#include\n \nsys/types.h\n\n\n#include\n \nunistd.h\n\n\n\npid_t\n \ngetpid\n(\nvoid\n);\n\n\npit_t\n \ngetppid\n(\nvoid\n);\n\n\n\n\n\n\u521b\u5efa\u548c\u7ec8\u6b62\u8fdb\u7a0b\n\n\n\u7236\u8fdb\u7a0b\n\u901a\u8fc7\u8c03\u7528fork\u51fd\u6570\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u8fd0\u884c\u7684\n\u5b50\u8fdb\u7a0b\n\u3002\n\n\n#include\n \nsys/types.h\n\n\n#include\n \nunistd.h\n\n\n\npid_t\n \nfork\n(\nvoid\n);\n\n\n\n\u65b0\u521b\u5efa\u7684\u5b50\u8fdb\u7a0b\u51e0\u4e4e\u4f46\u4e0d\u5b8c\u5168\u4e0e\u7236\u8fdb\u7a0b\u76f8\u540c\uff1a\n\n\n\n\n\u76f8\u540c\u4f46\u662f\u72ec\u7acb\u7684\u5730\u5740\u7a7a\u95f4\n\uff1a\u5b50\u8fdb\u7a0b\u83b7\u5f97\u7236\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7684\u4e00\u4efd\u526f\u672c\n\n\n\u5171\u4eab\u6587\u4ef6\n\uff1a\u5b50\u8fdb\u7a0b\u83b7\u5f97\u7236\u8fdb\u7a0b\u6253\u5f00\u6587\u4ef6\u63cf\u8ff0\u7b26\u76f8\u540c\u7684\u526f\u672c\n\n\n\u5b50\u8fdb\u7a0b\u4e0e\u7236\u8fdb\u7a0bpid\u4e0d\u540c\n\n\n\n\n\u56de\u6536\u5b50\u8fdb\u7a0b\n\n\n\u8fdb\u7a0b\u5728\u7ec8\u6b62\u540e\uff0c\u5e76\u4e0d\u4f1a\u88ab\u5185\u6838\u4ece\u7cfb\u7edf\u4e2d\u6e05\u9664\uff0c\u800c\u662f\u4fdd\u6301\u8fd9\u79cd\u72b6\u6001\uff0c\u76f4\u5230\u88ab\u5b83\u7684\u7236\u8fdb\u7a0b\n\u56de\u6536\n(reaped)\u3002\n\n \u4e00\u4e2a\u7ec8\u6b62\u4e86\u4f46\u8fd8\u672a\u88ab\u56de\u6536\u7684\u8fdb\u7a0b\u79f0\u4e3a\n\u50f5\u6b7b\u8fdb\u7a0b\n(zombie)\u3002\n\n \u5373\u4f7f\u50f5\u6b7b\u8fdb\u7a0b\u6ca1\u6709\u8fd0\u884c\uff0c\u5b83\u4ecd\u7136\u6d88\u8017\u7cfb\u7edf\u7684\u5185\u5b58\u8d44\u6e90\u3002\n\n\n\u901a\u8fc7\u8c03\u7528\nwaitpid\n\u51fd\u6570\u6765\u7b49\u5f85\u5b50\u8fdb\u7a0b\u7ec8\u6b62\u6216\u8005\u505c\u6b62\u3002\n\n\n\u8fdb\u7a0b\u4f11\u7720\n\n\nsleep\n\u51fd\u6570\u5c06\u4e00\u4e2a\u8fdb\u7a0b\u6302\u8d77\u4e00\u6bb5\u5236\u5b9a\u7684\u65f6\u95f4\u3002\n\n\n#include\n \nunistd.n\n\n\nunsigned\n \nint\n \nsleep\n(\nunsigned\n \nint\n \nsecs\n);\n\n\n\n\n\n\u52a0\u8f7d\u5e76\u8fd0\u884c\u7a0b\u5e8f\n\n\nexecve\n\u51fd\u6570\u5728\u5f53\u524d\u8fdb\u7a0b\u7684\u4e0a\u4e0b\u6587\u4e2d\u52a0\u8f7d\u5e76\u8fd0\u884c\u4e00\u4e2a\u65b0\u7a0b\u5e8f\u3002\n* \nexecve\n\u8c03\u7528\u4e00\u6b21\u5e76\u4ece\u4e0d\u8fd4\u56de\u3002\n\n\n5 \u4fe1\u53f7\n\n\nLinux\n\u4fe1\u53f7\n\uff0c\u901a\u77e5\u8fdb\u7a0b\u7cfb\u7edf\u4e2d\u53d1\u751f\u4e00\u4e2a\u67d0\u79cd\u7c7b\u578b\u7684\u4e8b\u4ef6\u3002\u6bcf\u79cd\u4fe1\u53f7\u7c7b\u578b\u90fd\u5bf9\u5e94\u4e8e\u67d0\u79cd\u7cfb\u7edf\u4e8b\u4ef6\u3002\u4f4e\u5c42\u7684\u786c\u4ef6\u5f02\u5e38\u662f\u7531\u5185\u6838\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\u5904\u7406\u7684\uff0c\u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u5bf9\u7528\u6237\u8fdb\u7a0b\u800c\u8a00\u662f\u4e0d\u53ef\u89c1\u7684\u3002\u4e0b\u9762\u662fLinux\u7cfb\u7edf\u4e0a\u5e38\u89c1\u7684\u4fe1\u53f7\uff1a\n\n\n\u5e38\u89c1\u7684\u4fe1\u53f7\n\uff1a\n\n\n\n\n\n\n\n\n\u7f16\u53f7\n\n\n\u540d\u79f0\n\n\n\u9ed8\u8ba4\u52a8\u4f5c\n\n\n\u5bf9\u5e94\u4e8b\u4ef6\n\n\n\n\n\n\n\n\n\n\n2\n\n\nSIGINT\n\n\n\u7ec8\u6b62\n\n\n\u6765\u81ea\u952e\u76d8\u7684\u4e2d\u65adCTRL+C\n\n\n\n\n\n\n3\n\n\nSIGQUIT\n\n\n\u7ec8\u6b62\n\n\n\u6765\u81ea\u952e\u76d8\u7684\u9000\u51faCTRL+\\\n\n\n\n\n\n\n9\n\n\nSIGKILL\n\n\n\u7ec8\u6b62\n\n\n\u6740\u6b7b\u7a0b\u5e8f \n\\bin\\kill -9\n\n\n\n\n\n\n11\n\n\nSIGSEGV\n\n\n\u7ec8\u6b62\u5e76\u8f6c\u50a8\u5185\u5b58\n\n\n\u6bb5\u6545\u969c(\u65e0\u6548\u7684\u5185\u5b58\u5f15\u7528)\n\n\n\n\n\n\n15\n\n\nSIGTERM\n\n\n\u7ec8\u6b62\n\n\n\u8f6f\u4ef6\u7ec8\u6b62\u4fe1\u53f7\n\\bin\\kill\n\n\n\n\n\n\n17\n\n\nSIGCHLD\n\n\n\u5ffd\u7565\n\n\n\u5b50\u8fdb\u7a0b\u505c\u6b62\u6216\u7ec8\u6b62\n\n\n\n\n\n\n18\n\n\nSIGCONT\n\n\n\u5ffd\u7565\n\n\n\u7ee7\u7eed\u8fdb\u7a0b\u5982\u679c\u8be5\u8fdb\u7a0b\u505c\u6b62\n\n\n\n\n\n\n20\n\n\nSIGTSTP\n\n\n\u505c\u6b62\u76f4\u5230\u4e0b\u4e00\u4e2aSIGCONT\n\n\n\u7528\u6237\u8f93\u5165CTRL+Z\n\n\n\n\n\n\n\n\n\u8be6\u7ec6\u4fe1\u606f\u53ef\u4ee5\u901a\u8fc7\nman 7 signal\n\u67e5\u8be2\u3002\n\n\n\u53d1\u9001/\u63a5\u6536\u4fe1\u53f7\n\n\n\u4f20\u9001\u4e00\u4e2a\u4fe1\u53f7\u5230\u76ee\u7684\u8fdb\u7a0b\u7531\u53d1\u9001\u3001\u63a5\u6536\u4fe1\u53f7\u4e24\u4e2a\u6b65\u9aa4\u7ec4\u6210\uff1a\n\n\n\n\n\u53d1\u9001\u4fe1\u53f7\u3002\u5185\u6838\u901a\u8fc7\u66f4\u65b0\u76ee\u7684\u8fdb\u7a0b\u4e0a\u4e0b\u6587\u4e2d\u7684\u67d0\u4e2a\u72b6\u6001\uff0c\u53d1\u9001(\u9012\u9001)\u4e00\u4e2a\u4fe1\u53f7\u7ed9\u76ee\u7684\u8fdb\u7a0b\u3002\n\n\n\u63a5\u6536\u4fe1\u53f7\u3002\u5f53\u76ee\u7684\u8fdb\u7a0b\u88ab\u5185\u6838\u5f3a\u8feb\u5df2\u67d0\u79cd\u65b9\u5f0f\u5bf9\u4fe1\u53f7\u7684\u53d1\u9001\u505a\u51fa\u53cd\u5e94\u65f6\uff0c\u5b83\u5c31\u63a5\u6536\u4e86\u4fe1\u53f7\u3002\u8fdb\u7a0b\u53ef\u4ee5\u5ffd\u7565\u8fd9\u4e2a\u4fe1\u53f7\uff0c\u7ec8\u6b62\u6216\u8005\u901a\u8fc7\u6267\u884c\u4e00\u4e2a\u79f0\u4e3a\n\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f\n\u7684\u7528\u6237\u5c42\u51fd\u6570\u6355\u83b7\u8fd9\u4e2a\u4fe1\u53f7\u3002\n\n\n\n\n\u53d1\u9001\u4fe1\u53f7\n\n\n\u53d1\u9001\u4fe1\u53f7\u53ef\u4ee5\u7531\u4ee5\u4e0b\u539f\u56e0\u5f15\u8d77\uff1a\n\n\n\n\n\u7528\u6237\uff1a\u7528\u6237\u80fd\u591f\u901a\u8fc7\u8f93\u5165\nCTRL+c\n(\nSIGINT\n)\u3001\nCtrl+z\n(\nSIGTSTP\n)\uff0c\u6216\u8005\u662f\u7ec8\u7aef\u9a71\u52a8\u7a0b\u5e8f\u5206\u914d\u7ed9\u4fe1\u53f7\u63a7\u5236\u5b57\u7b26\u7684\u5176\u4ed6\u4efb\u4f55\u952e\u6765\u8bf7\u6c42\u5185\u6838\u4ea7\u751f\u4fe1\u53f7\uff1b\n\n\n\u5185\u6838\uff1a\u5f53\u8fdb\u7a0b\u6267\u884c\u51fa\u9519\u65f6\uff0c\u5185\u6838\u4f1a\u7ed9\u8fdb\u7a0b\u53d1\u9001\u4e00\u4e2a\u4fe1\u53f7\uff0c\u4f8b\u5982\u975e\u6cd5\u6bb5\u5b58\u53d6(\u5185\u5b58\u8bbf\u95ee\u8fdd\u89c4)\u3001\u6d6e\u70b9\u6570\u6ea2\u51fa\u7b49\uff1b\n\n\n\u8fdb\u7a0b\uff1a\u4e00\u4e2a\u8fdb\u7a0b\u53ef\u4ee5\u901a\u8fc7\u7cfb\u7edf\u8c03\u7528kill\u7ed9\u53e6\u4e00\u4e2a\u8fdb\u7a0b\u6216\u81ea\u5df1\u53d1\u9001\u4fe1\u53f7\u3002\n\n\n\n\n\u63a5\u6536\u4fe1\u53f7\n\n\n\u5f53\u5185\u6838\u628a\u8fdb\u7a0b\np\np\n\u4ece\u5185\u6838\u6a21\u5f0f\u5207\u6362\u5230\u7528\u6237\u6a21\u5f0f\u65f6\uff0c\u5b83\u4f1a\u68c0\u67e5\u8fdb\u7a0b\np\np\n\u7684\u672a\u88ab\u963b\u585e\u7684\u5f85\u5904\u7406\u4fe1\u53f7\u7684\u96c6\u5408(\npending\n~blocked\n,\u89c1\u4e0b\u6587)\uff0c\u5982\u679c\u96c6\u5408\u975e\u7a7a\uff0c\u90a3\u4e48\u5185\u6838\u5f3a\u5236\np\np\n\u63a5\u6536\u4fe1\u53f7\uff0c\u89e6\u53d1\u8fdb\u7a0b\u91c7\u53d6\u67d0\u79cd\u884c\u4e3a\u3002\n\n\n\u8fdb\u7a0b\u63a5\u6536\u5230\u4fe1\u53f7\u4ee5\u540e\uff0c\u53ef\u4ee5\u6709\u5982\u4e0b3\u79cd\u9009\u62e9\u8fdb\u884c\u5904\u7406\uff1a\n\n\n\n\n\u63a5\u6536\u9ed8\u8ba4\u5904\u7406\uff1a\u63a5\u6536\u9ed8\u8ba4\u5904\u7406\u7684\u8fdb\u7a0b\u901a\u5e38\u4f1a\u5bfc\u81f4\u8fdb\u7a0b\u672c\u8eab\u6d88\u4ea1\u3002\u4f8b\u5982\u8fde\u63a5\u5230\u7ec8\u7aef\u7684\u8fdb\u7a0b\uff0c\u7528\u6237\u6309\u4e0bCTRL+c\uff0c\u5c06\u5bfc\u81f4\u5185\u6838\u5411\u8fdb\u7a0b\u53d1\u9001\u4e00\u4e2aSIGINT\u7684\u4fe1\u53f7\uff0c\u8fdb\u7a0b\u5982\u679c\u4e0d\u5bf9\u8be5\u4fe1\u53f7\u505a\u7279\u6b8a\u7684\u5904\u7406\uff0c\u7cfb\u7edf\u5c06\u91c7\u7528\u9ed8\u8ba4\u7684\u65b9\u5f0f\u5904\u7406\u8be5\u4fe1\u53f7\uff0c\u5373\u7ec8\u6b62\u8fdb\u7a0b\u7684\u6267\u884c\uff1b\n\n\n\u5ffd\u7565\u4fe1\u53f7\uff1a\u8fdb\u7a0b\u53ef\u4ee5\u901a\u8fc7\u4ee3\u7801\uff0c\u663e\u793a\u5730\u5ffd\u7565\u67d0\u4e2a\u4fe1\u53f7\u7684\u5904\u7406\uff0c\u4f8b\u5982\uff1a\nsignal(SIGINT,SIGDEF)\n\uff1b\u4f46\u662f\u67d0\u4e9b\u4fe1\u53f7\u662f\u4e0d\u80fd\u88ab\u5ffd\u7565\u7684\uff0c\n\n\n\u6355\u83b7\u4fe1\u53f7\u5e76\u5904\u7406\uff1a\u5f53\u63a5\u6536\u5230\u4fe1\u53f7\u65f6\uff0c\u7531\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f\u81ea\u52a8\u6355\u83b7\u5e76\u4e14\u5904\u7406\u4fe1\u53f7\u3002\n\n\n\n\nsighandler_t\n \nsignal\n(\nint\n \nsignum\n,\n \nsighandler_t\n \nhandler\n);\n\n\n\n\n\n\u6709\u4e24\u4e2a\u4fe1\u53f7\u65e2\u4e0d\u80fd\u88ab\u5ffd\u7565\u4e5f\u4e0d\u80fd\u88ab\u6355\u83b7\uff0c\u5b83\u4eec\u662f\nSIGKILL\n\u548c\nSIGSTOP\n\u3002\u5373\u8fdb\u7a0b\u63a5\u6536\u5230\u8fd9\u4e24\u4e2a\u4fe1\u53f7\u540e\uff0c\u53ea\u80fd\u63a5\u53d7\u7cfb\u7edf\u7684\u9ed8\u8ba4\u5904\u7406\uff0c\u5373\u7ec8\u6b62\u7ebf\u7a0b\u3002\n\n\n\u963b\u585e\u4fe1\u53f7\u548c\u8fdb\u7a0b\u56de\u6536\n\n\n\u4e00\u4e2a\u53d1\u51fa\u800c\u6ca1\u6709\u88ab\u63a5\u53d7\u7684\u4fe1\u53f7\u53eb\u505a\n\u672a\u5904\u7406\u4fe1\u53f7\n\uff08Pending Signal\uff09\u3002\u8fdb\u7a0b\u53ef\u4ee5\u9009\u62e9\u963b\u585e\uff08Block\uff09\u67d0\u4e2a\u4fe1\u53f7\u3002\u88ab\u963b\u585e\u7684\u4fe1\u53f7\u4ea7\u751f\u65f6\u5c06\u4fdd\u6301\u5728\u672a\u5904\u7406\u72b6\u6001\uff0c\u76f4\u5230\u8fdb\u7a0b\u89e3\u9664\u5bf9\u6b64\u4fe1\u53f7\u7684\u963b\u585e\uff0c\u624d\u6267\u884c\u63a5\u6536\u7684\u52a8\u4f5c\u3002\u963b\u585e\u548c\u5ffd\u7565\u662f\u4e0d\u540c\u7684\uff0c\n\u53ea\u8981\u4fe1\u53f7\u88ab\u963b\u585e\u5c31\u4e0d\u4f1a\u63a5\u6536\n\uff0c\u800c\u5ffd\u7565\u662f\u5728\u63a5\u6536\u4e4b\u540e\u53ef\u9009\u7684\u4e00\u79cd\u5904\u7406\u52a8\u4f5c\u3002\n\n\nLinux\u63d0\u4f9b\u963b\u585e\u4fe1\u53f7\u7684\u9690\u5f0f\u548c\u663e\u5f0f\u673a\u5236:\n\n\n\n\n\u9690\u5f0f\u963b\u585e\u673a\u5236\n\uff1a\u5185\u6838\u9ed8\u8ba4\u963b\u585e\u4efb\u4f55\u5f53\u524d\u5904\u7406\u7a0b\u5e8f\u6b63\u5728\u5904\u7406\u4fe1\u53f7\u7c7b\u578b\u7684\u5f85\u5904\u7406\u7684\u4fe1\u53f7\u3002\u5982\u679c\u5728\u8fdb\u7a0b\u89e3\u9664\u5bf9\u67d0\u4fe1\u53f7\u7684\u963b\u585e\u4e4b\u524d\u8fd9\u79cd\u4fe1\u53f7\u4ea7\u751f\u8fc7\u591a\u6b21\uff0c\u53ea\u8ba1\u4e00\u6b21\u3002\u56e0\u4e3a\u6bcf\u4e2a\u4fe1\u53f7\u53ea\u6709\u4e00\u4e2abit\u7684\u672a\u5904\u7406\u6807\u5fd7(\u5982\u4e0b\u56fe)\uff0c\u975e0\u53731\uff0c\u4e0d\u8bb0\u5f55\u8be5\u4fe1\u53f7\u4ea7\u751f\u4e86\u591a\u5c11\u6b21\uff0c\u963b\u585e\u6807\u5fd7\u4e5f\u662f\u8fd9\u6837\u8868\u793a\u7684\u3002\n\n\n\u663e\u5f0f\u963b\u585e\u673a\u5236\n\uff1a\u5e94\u7528\nsigprocmask\n\u51fd\u6570\uff0c\u660e\u786e\u5730\u963b\u585e\u548c\u89e3\u9664\u963b\u585e\u9009\u5b9a\u7684\u4fe1\u53f7\u3002\n\n\n\n\n\u5185\u6838\u4e3a\u6bcf\u4e2a\u8fdb\u7a0b\u5728\npending\u4f4d\u5411\u91cf\n\u4e2d\u7ef4\u62a4\u7740\u5f85\u5904\u7406\u4fe1\u53f7\u7684\u96c6\u5408\uff0c\u800c\u5728\nblocked\u4f4d\u5411\u91cf\n\u4e2d\u7ef4\u62a4\u7740\u88ab\u963b\u585e\u7684\u4fe1\u53f7\u96c6\u5408\u3002\u4fe1\u53f7\u5728\u5185\u6838\u4e2d\u7684\u8868\u793a\u53ef\u4ee5\u770b\u4f5c\u662f\u8fd9\u6837\u7684\uff1a\n\n\n\n\n\u6bcf\u4e2a\u4fe1\u53f7\u90fd\u6709\u4e24\u4e2a\u6807\u5fd7\u4f4d\u5206\u522b\u8868\u793a\u963b\u585e\u548c\u672a\u5904\u7406\uff0c\u8fd8\u6709\u4e00\u4e2a\u51fd\u6570\u6307\u9488\u8868\u793a\u5904\u7406\u52a8\u4f5c\u3002\u4fe1\u53f7\u4ea7\u751f\u65f6\uff0c\u5185\u6838\u5728\u8fdb\u7a0b\u63a7\u5236\u5757\u4e2d\u8bbe\u7f6e\u8be5\u4fe1\u53f7\u7684\u672a\u5904\u7406\u6807\u5fd7\uff0c\u76f4\u5230\u4fe1\u53f7\u63a5\u6536\u624d\u6e05\u9664\u8be5\u6807\u5fd7\u3002\u5728\u4e0a\u56fe\u7684\u4f8b\u5b50\u4e2d\uff0c\n\n\n\n\nSIGHUP\u4fe1\u53f7\u672a\u963b\u585e\u4e5f\u672a\u4ea7\u751f\u8fc7\uff0c\u5f53\u5b83\u63a5\u6536\u65f6\u6267\u884c\u9ed8\u8ba4\u5904\u7406\u52a8\u4f5c\u3002\n\n\nSIGINT\u4fe1\u53f7\u4ea7\u751f\u8fc7\uff0c\u4f46\u6b63\u5728\u88ab\u963b\u585e\uff0c\u6240\u4ee5\u6682\u65f6\u4e0d\u80fd\u63a5\u6536\u3002\u867d\u7136\u5b83\u7684\u5904\u7406\u52a8\u4f5c\u662f\u5ffd\u7565\uff0c\u4f46\u5728\u6ca1\u6709\u89e3\u9664\u963b\u585e\u4e4b\u524d\u4e0d\u80fd\u5ffd\u7565\u8fd9\u4e2a\u4fe1\u53f7\uff0c\u56e0\u4e3a\u8fdb\u7a0b\u4ecd\u6709\u673a\u4f1a\u6539\u53d8\u5904\u7406\u52a8\u4f5c\u4e4b\u540e\u518d\u89e3\u9664\u963b\u585e\u3002\n\n\nSIGQUIT\u4fe1\u53f7\u672a\u4ea7\u751f\u8fc7\uff0c\u4e00\u65e6\u4ea7\u751fSIGQUIT\u4fe1\u53f7\u5c06\u88ab\u963b\u585e\uff0c\u5b83\u8c03\u7528\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f\nsighandler\n\u3002\n\n\n\n\n\u9690\u5f0f\u963b\u585e\u673a\u5236\n\n\n\u5f53\u591a\u4e2a\u672a\u5904\u7406\u4fe1\u53f7(\npending signal\n)\u5230\u8fbe\u65f6\uff0c\u7531\u4e8e\u4fe1\u53f7\u5e76\u4e0d\u4f1a\u4ea7\u751f\u6392\u961f\u7b49\u5f85\u8fd9\u6837\u7684\u60c5\u51b5\uff0c\u6240\u4ee5\u4ea7\u751f\u7684\u6548\u679c\u4ec5\u76f8\u5f53\u4e8e\u4e00\u4e2a\u672a\u5904\u7406\u4fe1\u53f7(\u4e5f\u5c31\u662f\u5bf9\u5e94\u7684\npending\n\u4f4d\u6807\u8bb0\u4e3a1\uff0c\u4f8b\u5982\u4e0a\u56fe\u4e2d\u7684\nSIGINT\n\u4fe1\u53f7)\u3002\n\n\n\u8fd9\u6837\u5e26\u6765\u51e0\u4e2a\u95ee\u9898\uff1a\n\n\n\n\n\u4e0d\u80fd\u7528\u4fe1\u53f7\u6765\u5bf9\u5176\u4ed6\u8fdb\u7a0b\u4e2d\u53d1\u751f\u7684\u4e8b\u4ef6\u8ba1\u6570\uff0c\u8fd9\u662f\u663e\u800c\u6613\u89c1\u7684\n\n\n\u5728\u56de\u6536\u5b50\u8fdb\u7a0b\u65f6\uff0c\u8981\u56de\u6536\u5c3d\u53ef\u80fd\u591a\u7684\u5b50\u8fdb\u7a0b\u3002\u4f8b\u5982\u4e0b\u9762\u8fd9\u4e2a\u4f8b\u5b50\u3002\n\n\n\n\nvoid\n \nhandler1\n(\nint\n \nsig\n)\n   \n\n{\n  \n    \npid_t\n \npid\n;\n  \n\n    \nif\n \n((\npid\n \n=\n \nwaitpid\n(\n-\n1\n,\n \nNULL\n,\n \n0\n))\n \n \n0\n)\n  \n        \nunix_error\n(\nwaitpid error\n);\n  \n    \nprintf\n(\nHandler reaped child %d\n\\n\n,\n \n(\nint\n)\npid\n);\n  \n    \nSleep\n(\n2\n);\n  \n    \nreturn\n;\n  \n\n}\n  \n\n\n/* $begin signal2 */\n\n\nvoid\n \nhandler2\n(\nint\n \nsig\n)\n \n\n{\n\n    \nint\n \nolderrno\n \n=\n \nerrno\n;\n\n\n    \nwhile\n \n(\nwaitpid\n(\n-\n1\n,\n \nNULL\n,\n \n0\n)\n \n \n0\n)\n \n{\n\n        \nSio_puts\n(\nHandler reaped child\n\\n\n);\n\n    \n}\n\n    \n// waitpid()\u51fd\u6570\u6709\u53ef\u80fd\u56e0\u4e3a\u627e\u4e0d\u5230\u5b50\u8fdb\u7a0b\u800c\u62a5ECHILD\u9519\u8bef\n\n    \nif\n \n(\nerrno\n \n!=\n \nECHILD\n)\n\n        \nSio_error\n(\nwaitpid error\n);\n\n    \nSleep\n(\n1\n);\n\n    \nerrno\n \n=\n \nolderrno\n;\n\n\n}\n\n\n/* $end signal2 */\n\n\n\nint\n \nmain\n()\n \n\n{\n\n    \nint\n \ni\n,\n \nn\n;\n\n    \nchar\n \nbuf\n[\nMAXBUF\n];\n\n\n    \nif\n \n(\nsignal\n(\nSIGCHLD\n,\n \nhandler2\n)\n \n==\n \nSIG_ERR\n)\n \n//handler2 \u6216\u8005 handler1\n\n        \nunix_error\n(\nsignal error\n);\n\n\n    \n/* Parent creates children */\n\n    \nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n \n3\n;\n \ni\n++\n)\n \n{\n\n        \nif\n \n(\nFork\n()\n \n==\n \n0\n)\n \n{\n\n            \nprintf\n(\nHello from child %d\n\\n\n,\n \n(\nint\n)\ngetpid\n());\n\n            \nexit\n(\n0\n);\n\n        \n}\n\n    \n}\n\n\n    \n/* Parent waits for terminal input and then processes it */\n\n    \nif\n \n((\nn\n \n=\n \nread\n(\nSTDIN_FILENO\n,\n \nbuf\n,\n \nsizeof\n(\nbuf\n)))\n \n \n0\n)\n\n        \nunix_error\n(\nread\n);\n\n\n    \nprintf\n(\nParent processing input\n\\n\n);\n\n    \nwhile\n \n(\n1\n)\n\n        \n;\n\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\u5728\u4e0a\u9762\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u7236\u8fdb\u7a0b\u521b\u5efa\u4e00\u4e9b\u5b50\u8fdb\u7a0b\uff0c\u8fd9\u4e9b\u5b50\u8fdb\u7a0b\u5404\u81ea\u72ec\u7acb\u8fd0\u884c\u4e00\u6bb5\u65f6\u95f4\uff0c\u7136\u540e\u7ec8\u6b62\u3002\u7528\nSIGCHLD\n\u5904\u7406\u7a0b\u5e8f\u6765\u56de\u6536\u5b50\u8fdb\u7a0b\uff0c\u5176\u4e2d\nhandler1\n\u662f\u9519\u8bef\u7684\uff0c\u4f1a\u4ea7\u751f\u50f5\u6b7b\u5b50\u8fdb\u7a0b\u3002\nhandler2\n\u662f\u5b89\u5168\u7684\u3002\u539f\u56e0\u662f\u5728\nhandler1\n\u4e2d\uff0c\u53ef\u80fd\u5b58\u5728\u5b50\u8fdb\u7a0b\u5148\u88ab\u6267\u884c\uff0c\u4ea7\u751f\nSIGCHLD\n\u4fe1\u53f7\uff1b\u4f46\u662f\u5728\u5b50\u8fdb\u7a0b\u8fd8\u672a\u88ab\u56de\u6536\u4e4b\u524d\uff0c\u53c8\u6709\u591a\u4e2a\u5b50\u8fdb\u7a0b\u88ab\u6267\u884c\uff0c\u4ea7\u751f\u591a\u4e2a\nSIGCHLD\n\u4fe1\u53f7\u3002\u4e8e\u662f\u591a\u4f59\u7684\u672a\u5904\u7406\nSIGCHLD\n\u4fe1\u53f7\u5c31\u88ab\u629b\u5f03\uff0c\u53ea\u76f8\u5f53\u4e8e\u4e00\u4e2a\nSIGCHLD\n\u4fe1\u53f7\u3002\u6700\u7ec8\u4f1a\u9020\u6210\u6709\u7684\u5b50\u8fdb\u7a0b\u672a\u88ab\u56de\u6536\uff0c\u4ea7\u751f\u50f5\u6b7b\u5b50\u8fdb\u7a0b\u3002\n\n\n\u6267\u884c\u7684\u53ef\u80fd\u7ed3\u679c\u5982\u4e0b\uff0c\u53ef\u4ee5\u770b\u5230\u7236\u8fdb\u7a0b\u53ea\u56de\u6536\u4e86\u4e24\u4e2a\u5b50\u8fdb\u7a0b\u3002\n\n\nHello from child 5617\nHello from child 5616\nHello from child 5618\nHandler reaped child\nHandler reaped child\n\nParent processing input\n\n\n\n\n\u663e\u5f0f\u963b\u585e\u673a\u5236\n\n\n\u6709\u65f6\u5019\u4e0d\u5e0c\u671b\u5728\u53d1\u9001\u4fe1\u53f7\u540e\u5c31\u7acb\u5373\u53bb\u63a5\u6536\u3001\u5904\u7406\u4fe1\u53f7\uff0c\u540c\u65f6\u4e5f\u4e0d\u5e0c\u671b\u5ffd\u7565\u8be5\u4fe1\u53f7\uff0c\u90a3\u4e48\u53ef\u4ee5\u901a\u8fc7\nsigprocmask\n\u663e\u5f0f\u5730\u963b\u585e\u4fe1\u53f7\u4ece\u800c\u5b9e\u73b0\u5ef6\u8fdf\u63a5\u6536\u4fe1\u53f7\u3002\n\n\n\u51fd\u6570\nsigprocmask\n\u53ef\u4ee5\u66f4\u6539\u5f53\u524d\u963b\u585e\u7684\u4fe1\u53f7\u96c6\u5408(\u5373blocked\u4f4d\u5411\u91cf):\n\n\nint\n \nsigprocmask\n(\nint\n \nhow\n,\n \nconst\n \nsigset_t\n \n*\nset\n,\n \nsigset_t\n \n*\noldset\n);\n\n\n\n\u5176\u5177\u4f53\u884c\u4e3a\u4f9d\u8d56\u4e8ehow\u503c\uff1a\n\n\nSIG_BLOCK, blocked = blocked | set //\u6dfb\u52a0set\u4fe1\u53f7\nSIG_UNBLOCK, blocked = blocked \n ~set //\u5220\u9664set\u4fe1\u53f7\nSIG_SETMASK, block = set //\u8bbe\u7f6eset\u4fe1\u53f7\u4e3a\u963b\u585e\u7684\u4fe1\u53f7\n\n\n\n\n\u963b\u585e\u7684\u4fe1\u53f7\u96c6\u5408\u5176\u5b9e\u5c31\u662f\u4e00\u4e2a\u65e0\u7b26\u53f7\u6574\u578b\u6570\u7ec4(\u5728x86-64\u4e0a\uff0c\u6570\u7ec4\u957f\u5ea6\u662f16)\u3002\n\n\n/* A `sigset_t\n has a bit for each signal.  */\n\n\n# define _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))\n\n\ntypedef\n \nstruct\n\n\n{\n\n    \nunsigned\n \nlong\n \nint\n \n__val\n[\n_SIGSET_NWORDS\n];\n\n\n}\n \nsigset_t\n;\n\n\n\n\n\n\u8fd8\u6709\u5176\u4ed6\u7684\u4e00\u4e9b\u51fd\u6570\u53ef\u4ee5\u5bf9\u4fe1\u53f7\u96c6\u8fdb\u884c\u64cd\u4f5c\uff1a\n\n\nint\n \nsigfillset\n(\nsigset_t\n \n*\nset\n);\n \n// \u4fe1\u53f7\u96c6\u521d\u59cb\u5316, \u7136\u540e\u628a\u6240\u6709\u7684\u4fe1\u53f7\u52a0\u5165\u5230\u6b64\u4fe1\u53f7\u96c6\u91cc\n\n\nint\n \nsigemptyset\n(\nsigset_t\n \n*\nset\n);\n \n//\u4fe1\u53f7\u96c6\u521d\u59cb\u5316\u4e3a\u7a7a\n\n\nint\n \nsigaddset\n(\nsigset_t\n \n*\nset\n,\n \nint\n \nsigno\n);\n \n//\u5c06\u4fe1\u53f7signo\u6dfb\u52a0\u5230\u4fe1\u53f7\u96c6\u4e2d  \n\n\n\n\n\n\u4e0b\u9762\u770b\u4e2a\u4f8b\u5b50, \u662f\u4e00\u4e2a\u5177\u6709\u7ec6\u5fae\u540c\u6b65\u9519\u8bef\u7684SHELL\u7a0b\u5e8f\u3002\u5982\u679c\u5b50\u8fdb\u7a0b\u5728\u7236\u8fdb\u7a0b\u80fd\u591f\u5f00\u59cb\u8fd0\u884c\u524d\u5c31\u7ed3\u675f\u4e86\uff0c\u90a3\u4e48\n\naddjob()\n \u548c \ndeletejob()\n \u4f1a\u4ee5\u9519\u8bef\u7684\u65b9\u5f0f\u88ab\u8c03\u7528\u3002\u8fd9\u4e2a\u7a0b\u5e8f\u5e0c\u671b\u7236\u8fdb\u7a0b\u5728\u4e00\u4e2a\u4f5c\u4e1a\u5217\u8868\u4e2d\u8bb0\u5f55\u7740\u5b83\u7684\u5f53\u524d\u5b50\u8fdb\u7a0b\uff0c\u6bcf\u4e2a\u4f5c\u4e1a\u6761\u76ee\u3002 \naddjob()\n \u548c \ndeletejob()\n \u5206\u522b\u60f3\u8fd9\u4e2a\u4f5c\u4e1a\u5217\u8868\u6dfb\u52a0\u548c\u4ece\u4e2d\u5220\u9664\u4f5c\u4e1a\u3002\u5f53\u7236\u8fdb\u7a0b\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5b50\u8fdb\u7a0b\u65f6\uff0c\u5b83\u5c31\u628a\u8fd9\u4e2a\u5b50\u8fdb\u7a0b\u6dfb\u52a0\u5230\u4f5c\u4e1a\u5217\u8868\u4e2d\u3002\u5f53\u7236\u8fdb\u7a0b\u5728\nSIGCHLD\n \u5904\u7406\u7a0b\u5e8f\u4e2d\u56de\u6536\u4e00\u4e2a\u7ec8\u6b62\u7684\uff08\u50f5\u6b7b\uff09\u5b50\u8fdb\u7a0b\u65f6\uff0c\u5b83\u5c31\u4ece\u4f5c\u4e1a\u5217\u8868\u4e2d\u5220\u9664\u8fd9\u4e2a\u5b50\u8fdb\u7a0b\u3002\u4e4d\u4e00\u770b\uff0c\u8fd9\u6bb5\u4ee3\u7801\u662f\u5bf9\u7684\u3002\u4e0d\u5e78\u7684\u662f\uff0c\u53ef\u80fd\u53d1\u751f\u4e0b\u9762\u7684\u60c5\u51b5\uff1a\n\n\n\n\n\n\n\n\n\u7236\u8fdb\u7a0b\u6267\u884c\nfork()\n\uff0c\u5185\u6838\u8c03\u5ea6\u65b0\u521b\u5efa\u7684\u5b50\u8fdb\u7a0b\u8fd0\u884c\uff0c\u800c\u4e0d\u662f\u7236\u8fdb\u7a0b\n\n\n\n\n\n\n\n\n\n\n\u5728\u7236\u8fdb\u7a0b\u80fd\u591f\u518d\u6b21\u8fd0\u884c\u4e4b\u524d\uff0c\u5b50\u8fdb\u7a0b\u5c31\u7ec8\u6b62\uff0c\u5e76\u4e14\u53d8\u6210\u4e00\u4e2a\u50f5\u6b7b\u8fdb\u7a0b\uff0c\u4f7f\u5f97\u5185\u6838\u4f20\u9012\u4e00\u4e2a\nSIGCHLD\n\u4fe1\u53f7\u7ed9\u7236\u8fdb\u7a0b\n\n\n\n\n\n\n\n\n\n\n\u540e\u6765\uff0c\u5f53\u7236\u8fdb\u7a0b\u518d\u6b21\u53d8\u6210\u53ef\u8fd0\u884c\u4f46\u53c8\u5728\u5b83\u6267\u884c\u4e4b\u524d\uff0c\u5185\u6838\u6ce8\u610f\u5230\u5f85\u5904\u7406\u7684\nSIGCHLD\n\u4fe1\u53f7\uff0c\u5e76\u901a\u8fc7\u5728\u7236\u8fdb\u7a0b\u4e2d\u8fd0\u884c\u5904\u7406\u7a0b\u5e8f\u63a5\u6536\u8fd9\u4e2a\u4fe1\u53f7\n\n\n\n\n\n\n\n\n\n\n\u5904\u7406\u7a0b\u5e8f\u56de\u6536\u7ec8\u6b62\u7684\u5b50\u8fdb\u7a0b\uff0c\u5e76\u8c03\u7528\ndeletejob()\n\uff0c\u8fd9\u4e2a\u51fd\u6570\u4ec0\u4e48\u90fd\u4e0d\u505a\uff0c\u56e0\u4e3a\u7236\u8fdb\u7a0b\u8fd8\u6ca1\u6709\u628a\u8be5\u5b50\u8fdb\u7a0b\u6dfb\u52a0\u5230\u5217\u8868\u4e2d\n\n\n\n\n\n\n\n\n\n\n\u5728\u5904\u7406\u7a0b\u5e8f\u8fd0\u884c\u7ed3\u675f\u540e\uff0c\u5185\u6838\u8fd0\u884c\u7236\u8fdb\u7a0b\uff0c\u7236\u8fdb\u7a0b\u4ece\nfork()\n\u8fd4\u56de\uff0c\u901a\u8fc7\u8c03\u7528\naddjob()\n \u9519\u8bef\u5730\u628a\uff08\u4e0d\u5b58\u5728\u7684\uff09\u5b50\u8fdb\u7a0b\u6dfb\u52a0\u5230\u4f5c\u4e1a\u5217\u8868\u4e2d\n\n\n\n\n\n\n\n\nvoid\n \nhandler\n(\nint\n \nsig\n)\n\n\n{\n\n        \npid_t\n \npid\n;\n\n        \nwhile\n \n((\npid\n \n=\n \nwaitpid\n(\n-\n1\n,\n \nNULL\n,\n \n0\n))\n \n \n0\n)\n \n/* Reap a zombie child */\n\n                \ndeletejob\n(\npid\n);\n \n/* Delete the child from the job list */\n\n        \nif\n \n(\nerrno\n \n!=\n \nECHILD\n)\n\n                \nunix_error\n(\nwaitpid error\n);\n\n\n}\n\n\n\nint\n \nmain\n(\nint\n \nargc\n,\n \nchar\n \n**\nargv\n)\n\n\n{\n\n        \nint\n \npid\n;\n\n\n        \nSignal\n(\nSIGCHLD\n,\n \nhandler\n);\n\n        \ninitjobs\n();\n             \n/* Initialize the job list */\n\n\n        \nwhile\n \n(\n1\n)\n \n{\n\n                \n/* Child process */\n\n                \nif\n \n((\npid\n \n=\n \nFork\n())\n \n==\n \n0\n)\n \n{\n\n                        \nExecve\n(\n/bin/date\n,\n \nargv\n,\n \nNULL\n);\n\n                \n}\n\n\n                \n/* Parent process */\n\n                \naddjob\n(\npid\n);\n    \n/* Add the child to the job list */\n\n        \n}\n\n\n        \nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\u6b63\u786e\u7684\u505a\u6cd5\u5e94\u8be5\u5982\u4e0b,  \u901a\u8fc7\u5728\u8c03\u7528 \nfork()\n \u4e4b\u524d\uff0c\u963b\u585e \nSIGCHLD\n \u4fe1\u53f7\uff0c\u7136\u540e\u5728\u6211\u4eec\u8c03\u7528\u4e86 \naddjob()\n \u4e4b\u540e\u5c31\u53d6\u6d88\u963b\u585e\u8fd9\u4e9b\u4fe1\u53f7\uff0c\u6211\u4eec\u4fdd\u8bc1\u4e86\u5728\u5b50\u8fdb\u7a0b\u88ab\u6dfb\u52a0\u5230\u4f5c\u4e1a\u5217\u8868\u4e4b\u540e\u56de\u6536\u8be5\u5b50\u8fdb\u7a0b\u3002\u6ce8\u610f\uff0c\u5b50\u8fdb\u7a0b\u7ee7\u627f\u4e86\u5b83\u4eec\u7236\u8fdb\u7a0b\u7684\u88ab\u963b\u585e\u96c6\u5408\uff0c\u6240\u4ee5\u6211\u4eec\u5fc5\u987b\u5728\u8c03\u7528 \nexecve()\n \u4e4b\u524d\uff0c\u5c0f\u5fc3\u5730\u89e3\u9664\u5b50\u8fdb\u7a0b\u4e2d\u963b\u585e\u7684 \nSIGCHLD\n \u4fe1\u53f7\u3002\u8fd9\u6837\uff0c\u7236\u8fdb\u7a0b\u4fdd\u8bc1\u5728\u76f8\u5e94\u7684 \ndeletejob()\n \u4e4b\u524d\u6267\u884c \naddjob()\n\u3002\n\n\nint\n \nmain\n(\nint\n \nargc\n,\n \nchar\n \n**\nargv\n)\n\n\n{\n\n    \nint\n \npid\n;\n\n    \nsigset_t\n \nmask_all\n,\n \nmask_one\n,\n \nprev_one\n;\n\n\n    \nSigfillset\n(\nmask_all\n);\n\n    \nSigemptyset\n(\nmask_one\n);\n\n    \nSigaddset\n(\nmask_one\n,\n \nSIGCHLD\n);\n\n    \nSignal\n(\nSIGCHLD\n,\n \nhandler\n);\n\n    \ninitjobs\n();\n \n/* Initialize the job list */\n\n\n    \nwhile\n \n(\n1\n)\n \n{\n\n        \nSigprocmask\n(\nSIG_BLOCK\n,\n \nmask_one\n,\n \nprev_one\n);\n \n/* Block SIGCHLD */\n\n        \nif\n \n((\npid\n \n=\n \nFork\n())\n \n==\n \n0\n)\n \n{\n \n/* Child process */\n\n            \nSigprocmask\n(\nSIG_SETMASK\n,\n \nprev_one\n,\n \nNULL\n);\n \n/* Unblock SIGCHLD */\n\n            \nExecve\n(\n/bin/date\n,\n \nargv\n,\n \nNULL\n);\n\n        \n}\n\n        \nSigprocmask\n(\nSIG_BLOCK\n,\n \nmask_all\n,\n \nNULL\n);\n \n/* Parent process */\n  \n        \naddjob\n(\npid\n);\n  \n/* Add the child to the job list */\n\n        \nSigprocmask\n(\nSIG_SETMASK\n,\n \nprev_one\n,\n \nNULL\n);\n  \n/* Unblock SIGCHLD */\n\n    \n}\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f\n\n\n\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f(signal handler)\u662f\u91cd\u8981\u4e14\u68d8\u624b\u7684\u4e00\u4e2a\u95ee\u9898\u3002\u5176\u96be\u70b9\u5728\uff1a\n\n\n\n\n\u5904\u7406\u7a0b\u5e8f\u4e0e\u4e3b\u7a0b\u5e8f\u5e76\u53d1\u8fd0\u884c\uff0c\u5171\u4eab\u540c\u6837\u7684\u5168\u5c40\u53d8\u91cf\uff0c\u56e0\u6b64\u53ef\u80fd\u4e0e\u4e3b\u7a0b\u5e8f\u548c\u5176\u4ed6\u5904\u7406\u7a0b\u5e8f\u76f8\u4e92\u5e72\u6270\uff1b\n\n\n\u5982\u4f55\u4ee5\u53ca\u4f55\u65f6\u63a5\u6536\u4fe1\u53f7\u7684\u89c4\u5219\u5e38\u5e38\u8fdd\u80cc\u4eba\u7684\u76f4\u89c9\u3002\n\n\n\n\n7 \u64cd\u4f5c\u8fdb\u7a0b\u7684\u5de5\u5177\n\n\nLinux\u7cfb\u7edf\u63d0\u4f9b\u4e86\u5927\u91cf\u7684\u76d1\u63a7\u548c\u64cd\u4f5c\u8fdb\u7a0b\u7684\u6709\u7528\u5de5\u5177\u3002\n\n\n\n\nSTRACE\uff1a \u6253\u5370\u4e00\u4e2a\u6b63\u5728\u8fd0\u884c\u7684\u7a0b\u5e8f\u548c\u5b83\u7684\u5b50\u8fdb\u7a0b\u8c03\u7528\u7684\u6bcf\u4e2a\u7cfb\u7edf\u8c03\u7528\u7684\u8f68\u8ff9\n\n\nPS\uff1a\u5217\u51fa\u5f53\u524d\u7cfb\u7edf\u4e2d\u7684\u8fdb\u7a0b(\u5305\u62ec\u50f5\u5c38\u8fdb\u7a0b)\n\n\nTOP: \u6253\u5370\u51fa\u5173\u4e8e\u5f53\u524d\u8fdb\u7a0b\u8d44\u6e90\u4f7f\u7528\u7684\u4fe1\u606f", 
            "title": "Chapter 8: \u5f02\u5e38\u63a7\u5236\u6d41"
        }, 
        {
            "location": "/csapp/ch8/#chapter-8", 
            "text": "\u4ece\u7ed9\u5904\u7406\u5668\u52a0\u7535\u5f00\u59cb\uff0c\u76f4\u5230\u4f60\u65ad\u7535\u4e3a\u6b62\uff0c\u7a0b\u5e8f\u8ba1\u6570\u5668\u5047\u8bbe\u6210\u4e00\u4e2a\u503c\u7684\u5e8f\u5217   a_0, a_1, ..., a_{n-1}  a_0, a_1, ..., a_{n-1}   \u5176\u4e2d\uff0c\u6bcf\u4e2a a_k a_k \u662f\u67d0\u4e2a\u76f8\u5e94\u7684\u6307\u4ee4 I_k I_k \u7684  \u5730\u5740  \u3002\u6bcf\u6b21\u4ece a_k a_k \u5230 a_{k+1} a_{k+1} \u7684\u8fc7\u6e21\u79f0\u4e3a \u63a7\u5236\u8f6c\u79fb (control transfer)\u3002\u8fd9\u6837\u7684\u63a7\u5236\u8f6c\u79fb\u5e8f\u5217\u53eb\u505a\u5904\u7406\u5668\u7684 \u63a7\u5236\u6d41 (control flow)\u3002  \u73b0\u5728\u7cfb\u7edf\u901a\u8fc7\u4f7f\u63a7\u5236\u6d41\u53d1\u751f\u7a81\u53d8\u6765\u5e94\u5bf9\u7cfb\u7edf\u72b6\u6001\u7684\u53d8\u5316(eg.\u7f3a\u9875\u5f02\u5e38\uff0c\u7f51\u7edc\u7b49\u5f85)\uff0c\u628a\u8fd9\u4e9b\u7a81\u53d8\u79f0\u4e3a \u5f02\u5e38\u63a7\u5236\u6d41 (Exceptional Control Flow, ECF)\u3002", 
            "title": "Chapter 8 \u5f02\u5e38\u63a7\u5236\u6d41"
        }, 
        {
            "location": "/csapp/ch8/#1", 
            "text": "", 
            "title": "1 \u5f02\u5e38"
        }, 
        {
            "location": "/csapp/ch8/#_1", 
            "text": "\u7cfb\u7edf\u4e3a\u6bcf \u7c7b \u53ef\u80fd\u7684\u5f02\u5e38\u90fd\u5206\u914d\u4e86\u4e00\u4e2a\u552f\u4e00\u7684\u975e\u8d1f\u6574\u6570\u7684 \u5f02\u5e38\u53f7 (exception number)\u3002\u5728\u7cfb\u7edf\u542f\u52a8\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5206\u914d\u548c\u521d\u59cb\u5316\u4e00\u5f20\u79f0\u4e3a \u5f02\u5e38\u8868 \u7684\u8df3\u8f6c\u8868\uff0c\u4f7f\u5f97\u8868\u76ee k k \u5305\u542b\u5f02\u5e38 k k \u7684\u5904\u7406\u7a0b\u5e8f\u7684\u5730\u5740\u3002   \u5f53\u68c0\u6d4b\u5230\u53d1\u751f\u4e86\u4e00\u4e2a\u4e8b\u4ef6\uff0c\u5e76\u4e14\u786e\u5b9a\u4e86\u76f8\u5e94\u7684\u5f02\u5e38\u53f7 k k \uff0c\u5904\u7406\u5668\u89e6\u53d1\u5f02\u5e38\uff0c\u6267\u884c\u95f4\u63a5\u8fc7\u7a0b\u8c03\u7528\uff0c\u901a\u8fc7\u5f02\u5e38\u8868\u7684\u8868\u76ee k k \uff0c\u8f6c\u5230\u76f8\u5e94\u7684\u5904\u7406\u7a0b\u5e8f\u3002", 
            "title": "\u5f02\u5e38\u7684\u5904\u7406"
        }, 
        {
            "location": "/csapp/ch8/#_2", 
            "text": "\u5f02\u5e38(exceptions)\u53ef\u4ee5\u5206\u4e3a\u56db\u7c7b\uff1a\u4e2d\u65ad(interrupt)\u3001\u9677\u9631(trap)\u3001\u6545\u969c(fault)\u548c\u7ec8\u6b62(abort)\u3002    \u4e2d\u65ad \u662f\u5f02\u6b65\u53d1\u751f\u7684\uff0c\u662f\u6765\u81ea\u5904\u7406\u5668\u5916\u90e8\u7684I/O\u8bbe\u5907\u7684\u4fe1\u53f7\u7684\u7ed3\u679c\u3002  \u9677\u9631 \u662f\u6709\u610f\u7684\u5f02\u5e38\uff0c\u662f\u6267\u884c\u4e00\u6761\u6307\u4ee4\u7684\u7ed3\u679c\u3002  \u5176\u7528\u9014\u662f\u5728\u7528\u6237\u7a0b\u5e8f\u548c\u5185\u6838\u4e4b\u95f4\u63d0\u4f9b\u4e00\u4e2a\u50cf\u8fc7\u7a0b\u4e00\u6837\u7684\u63a5\u53e3(\u7cfb\u7edf\u8c03\u7528)    \u6545\u969c \u662f\u7531\u9519\u8bef\u60c5\u51b5\u5f15\u8d77\u7684\uff0c\u53ef\u80fd\u80fd\u591f\u88ab\u6545\u969c\u5904\u7406\u7a0b\u5e8f\u4fee\u6b63\u3002  \u4f8b\u5982\u7f3a\u9875\u5f02\u5e38    \u7ec8\u6b62 \u662f\u4e0d\u53ef\u6062\u590d\u7684\u81f4\u547d\u9519\u8bef\u9020\u6210\u7684\u7ed3\u679c\uff0c\u901a\u5e38\u662f\u4e00\u4e9b\u786c\u4ef6\u9519\u8bef\u3002", 
            "title": "\u5f02\u5e38\u7684\u7c7b\u522b"
        }, 
        {
            "location": "/csapp/ch8/#2", 
            "text": "\u8fdb\u7a0b (Process)\u7684\u7ecf\u5178\u5b9a\u4e49\u5c31\u662f  \u4e00\u4e2a\u6267\u884c\u4e2d\u7a0b\u5e8f\u7684\u5b9e\u4f8b  (A process is a program in execuation) \u3002\u7cfb\u7edf\u4e2d\u7684\u6bcf\u4e2a\u7a0b\u5e8f\u90fd\u8fd0\u884c\u5728\u67d0\u4e2a\u8fdb\u7a0b\u7684\u4e0a\u4e0b\u6587(context)\u4e2d\u3002\u4e0a\u4e0b\u6587\u662f\u7531\u7a0b\u5e8f\u6b63\u786e\u8fd0\u884c\u6240\u9700\u7684\u72b6\u6001\u7ec4\u6210\u7684\u3002\u8fd9\u4e2a\u72b6\u6001\u5305\u62ec\u5b58\u653e\u5728\u5185\u5b58\u4e2d\u7684\u7a0b\u5e8f\u7684\u4ee3\u7801\u548c\u6570\u636e\uff0c\u5b83\u7684\u6808\u3001\u901a\u7528\u76ee\u7684\u5bc4\u5b58\u5668\u7684\u5185\u5bb9\u3001\u7a0b\u5e8f\u8ba1\u6570\u5668\u3001\u73af\u5883\u53d8\u91cf\u4ee5\u53ca\u6253\u5f00\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u96c6\u5408\u3002  \u8fdb\u7a0b\u63d0\u4f9b\u4e86\u5e94\u7528\u7a0b\u5e8f\u4e24\u4e2a\u5173\u952e\u62bd\u8c61\uff1a   \u4e00\u4e2a \u72ec\u7acb \u7684\u903b\u8f91\u63a7\u5236\u6d41\uff0c\u5b83\u63d0\u4f9b\u4e00\u4e2a\u5047\u8c61\uff0c\u597d\u50cf\u6211\u4eec\u7684\u7a0b\u5e8f\u72ec\u5360\u5730\u4f7f\u7528\u5904\u7406\u5668\u3002  \u4e00\u4e2a \u79c1\u6709 \u7684\u5730\u5740\u7a7a\u95f4\uff0c\u5b83\u63d0\u4f9b\u4e00\u4e2a\u5047\u8c61\uff0c\u597d\u50cf\u6211\u4eec\u7684\u7a0b\u5e8f\u72ec\u5360\u5730\u4f7f\u7528\u5185\u5b58\u7cfb\u7edf\u3002", 
            "title": "2 \u8fdb\u7a0b"
        }, 
        {
            "location": "/csapp/ch8/#_3", 
            "text": "\u903b\u8f91\u63a7\u5236\u6d41 (Logical Control Flow\uff0c\u7b80\u79f0\u903b\u8f91\u6d41)\u662fPC\u503c\u7684\u5e8f\u5217\u3002", 
            "title": "\u903b\u8f91\u63a7\u5236\u6d41"
        }, 
        {
            "location": "/csapp/ch8/#_4", 
            "text": "\u4e00\u4e2a\u903b\u8f91\u6d41\u7684\u6267\u884c\u5728\u65f6\u95f4\u4e0a\u4e0e\u53e6\u4e00\u4e2a\u6d41\u91cd\u53e0\uff0c\u79f0\u4e3a \u5e76\u53d1\u6d41 (concurrent flow)\uff0c\u8fd9\u4e24\u4e2a\u6d41\u88ab\u79f0\u4e3a \u5e76\u53d1\u5730\u8fd0\u884c \u3002", 
            "title": "\u5e76\u53d1\u6d41"
        }, 
        {
            "location": "/csapp/ch8/#_5", 
            "text": "\u8fdb\u7a0b\u4e3a\u6bcf\u4e2a\u7a0b\u5e8f\u63d0\u4f9b\u5b83\u81ea\u5df1\u7684 \u79c1\u6709\u5730\u5740\u7a7a\u95f4 \u3002\u4e00\u822c\u800c\u8a00\uff0c\u548c\u8fd9\u4e2a\u7a7a\u95f4\u4e2d\u67d0\u4e2a\u5730\u5740\u76f8\u5173\u8054\u7684\u90a3\u4e2a\u5185\u5b58\u5b57\u8282\u662f\u4e0d\u80fd\u88ab\u5176\u4ed6\u8fdb\u7a0b\u8bfb\u6216\u8005\u5199\u7684\uff0c\u4ece\u8fd9\u4e2a\u610f\u4e49\u4e0a\u8bf4\uff0c\u8fd9\u4e2a\u5730\u5740\u7a7a\u95f4\u662f\u79c1\u6709\u7684\u3002", 
            "title": "\u79c1\u6709\u5730\u5740\u7a7a\u95f4"
        }, 
        {
            "location": "/csapp/ch8/#_6", 
            "text": "\u5904\u7406\u5668\u901a\u5e38\u662f\u7528\u67d0\u4e2a\u63a7\u5236\u5bc4\u5b58\u5668\u4e2d\u7684\u4e00\u4e2a \u6a21\u5f0f\u4f4d (mode bit)\u6765\u63a7\u5236\u7528\u6237/\u5185\u6838\u6a21\u5f0f\u3002\u5f53\u8bbe\u7f6e\u4e86\u6a21\u5f0f\u4f4d\u65f6\uff0c\u8fdb\u7a0b\u5c31\u8fd0\u884c\u5728 \u5185\u6838\u6a21\u5f0f \u4e2d\uff0c\u5426\u5219\u8fd0\u884c\u5728 \u7528\u6237\u6a21\u5f0f \u4e2d\u3002  \u8fd0\u884c\u5728\u5185\u6838\u6a21\u5f0f\u7684\u8fdb\u7a0b\u53ef\u4ee5\u6267\u884c\u6307\u4ee4\u96c6\u4e2d\u7684\u4efb\u4f55\u6307\u4ee4\uff0c\u53ef\u4ee5\u8bbf\u95ee\u4efb\u4f55\u5185\u5b58\u4f4d\u7f6e\u3002\u7528\u6237\u6a21\u5f0f\u4e2d\u7684\u8fdb\u7a0b\u4e0d\u5141\u8bb8\u6267\u884c\u7279\u6743\u6307\u4ee4\uff0c\u4e5f\u4e0d\u5141\u8bb8\u76f4\u63a5\u5f15\u7528\u5730\u5740\u7a7a\u95f4\u4e2d\u5185\u6838\u533a\u7684\u4ee3\u7801\u548c\u6570\u636e\u3002", 
            "title": "\u7528\u6237\u6a21\u5f0f\u548c\u5185\u6838\u6a21\u5f0f"
        }, 
        {
            "location": "/csapp/ch8/#3", 
            "text": "", 
            "title": "3 \u7cfb\u7edf\u8c03\u7528\u9519\u8bef\u5904\u7406"
        }, 
        {
            "location": "/csapp/ch8/#4", 
            "text": "\u8fdb\u7a0b\u63a7\u5236\u5305\u62ec\u83b7\u53d6\u8fdb\u7a0bID\u3001\u521b\u5efa\u548c\u7ec8\u6b62\u8fdb\u7a0b\u3001\u56de\u6536\u5b50\u8fdb\u7a0b\u3001\u8ba9\u8fdb\u7a0b\u4f11\u7720\u3001\u52a0\u8f7d\u5e76\u8fd0\u884c\u7a0b\u5e8f\u7b49\u3002\u8fd9\u4e00\u8282\u5c06\u63cf\u8ff0Unix\u63d0\u4f9b\u4e86\u63a7\u5236\u8fdb\u7a0b\u7684\u7cfb\u7edf\u8c03\u7528\u3002", 
            "title": "4 \u8fdb\u7a0b\u63a7\u5236"
        }, 
        {
            "location": "/csapp/ch8/#id", 
            "text": "\u6bcf\u4e00\u4e2a\u8fdb\u7a0b\u90fd\u6709\u4e00\u4e2a\u552f\u4e00\u7684\u6574\u6570(\u975e\u96f6)\u8fdb\u7a0bID(PID)\u3002 getpid \u51fd\u6570\u8fd4\u56de\u8c03\u7528\u8fdb\u7a0b\u7684PID\u3002 getppid \u51fd\u6570\u8fd4\u56de\u5b83\u7684\u7236\u8fdb\u7a0b\u7684PID\u3002  #include   sys/types.h  #include   unistd.h  pid_t   getpid ( void );  pit_t   getppid ( void );", 
            "title": "\u83b7\u53d6\u8fdb\u7a0bID"
        }, 
        {
            "location": "/csapp/ch8/#_7", 
            "text": "\u7236\u8fdb\u7a0b \u901a\u8fc7\u8c03\u7528fork\u51fd\u6570\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u8fd0\u884c\u7684 \u5b50\u8fdb\u7a0b \u3002  #include   sys/types.h  #include   unistd.h  pid_t   fork ( void );  \n\u65b0\u521b\u5efa\u7684\u5b50\u8fdb\u7a0b\u51e0\u4e4e\u4f46\u4e0d\u5b8c\u5168\u4e0e\u7236\u8fdb\u7a0b\u76f8\u540c\uff1a   \u76f8\u540c\u4f46\u662f\u72ec\u7acb\u7684\u5730\u5740\u7a7a\u95f4 \uff1a\u5b50\u8fdb\u7a0b\u83b7\u5f97\u7236\u8fdb\u7a0b\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7684\u4e00\u4efd\u526f\u672c  \u5171\u4eab\u6587\u4ef6 \uff1a\u5b50\u8fdb\u7a0b\u83b7\u5f97\u7236\u8fdb\u7a0b\u6253\u5f00\u6587\u4ef6\u63cf\u8ff0\u7b26\u76f8\u540c\u7684\u526f\u672c  \u5b50\u8fdb\u7a0b\u4e0e\u7236\u8fdb\u7a0bpid\u4e0d\u540c", 
            "title": "\u521b\u5efa\u548c\u7ec8\u6b62\u8fdb\u7a0b"
        }, 
        {
            "location": "/csapp/ch8/#_8", 
            "text": "\u8fdb\u7a0b\u5728\u7ec8\u6b62\u540e\uff0c\u5e76\u4e0d\u4f1a\u88ab\u5185\u6838\u4ece\u7cfb\u7edf\u4e2d\u6e05\u9664\uff0c\u800c\u662f\u4fdd\u6301\u8fd9\u79cd\u72b6\u6001\uff0c\u76f4\u5230\u88ab\u5b83\u7684\u7236\u8fdb\u7a0b \u56de\u6536 (reaped)\u3002  \u4e00\u4e2a\u7ec8\u6b62\u4e86\u4f46\u8fd8\u672a\u88ab\u56de\u6536\u7684\u8fdb\u7a0b\u79f0\u4e3a \u50f5\u6b7b\u8fdb\u7a0b (zombie)\u3002  \u5373\u4f7f\u50f5\u6b7b\u8fdb\u7a0b\u6ca1\u6709\u8fd0\u884c\uff0c\u5b83\u4ecd\u7136\u6d88\u8017\u7cfb\u7edf\u7684\u5185\u5b58\u8d44\u6e90\u3002  \u901a\u8fc7\u8c03\u7528 waitpid \u51fd\u6570\u6765\u7b49\u5f85\u5b50\u8fdb\u7a0b\u7ec8\u6b62\u6216\u8005\u505c\u6b62\u3002", 
            "title": "\u56de\u6536\u5b50\u8fdb\u7a0b"
        }, 
        {
            "location": "/csapp/ch8/#_9", 
            "text": "sleep \u51fd\u6570\u5c06\u4e00\u4e2a\u8fdb\u7a0b\u6302\u8d77\u4e00\u6bb5\u5236\u5b9a\u7684\u65f6\u95f4\u3002  #include   unistd.n  unsigned   int   sleep ( unsigned   int   secs );", 
            "title": "\u8fdb\u7a0b\u4f11\u7720"
        }, 
        {
            "location": "/csapp/ch8/#_10", 
            "text": "execve \u51fd\u6570\u5728\u5f53\u524d\u8fdb\u7a0b\u7684\u4e0a\u4e0b\u6587\u4e2d\u52a0\u8f7d\u5e76\u8fd0\u884c\u4e00\u4e2a\u65b0\u7a0b\u5e8f\u3002\n*  execve \u8c03\u7528\u4e00\u6b21\u5e76\u4ece\u4e0d\u8fd4\u56de\u3002", 
            "title": "\u52a0\u8f7d\u5e76\u8fd0\u884c\u7a0b\u5e8f"
        }, 
        {
            "location": "/csapp/ch8/#5", 
            "text": "Linux \u4fe1\u53f7 \uff0c\u901a\u77e5\u8fdb\u7a0b\u7cfb\u7edf\u4e2d\u53d1\u751f\u4e00\u4e2a\u67d0\u79cd\u7c7b\u578b\u7684\u4e8b\u4ef6\u3002\u6bcf\u79cd\u4fe1\u53f7\u7c7b\u578b\u90fd\u5bf9\u5e94\u4e8e\u67d0\u79cd\u7cfb\u7edf\u4e8b\u4ef6\u3002\u4f4e\u5c42\u7684\u786c\u4ef6\u5f02\u5e38\u662f\u7531\u5185\u6838\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\u5904\u7406\u7684\uff0c\u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u5bf9\u7528\u6237\u8fdb\u7a0b\u800c\u8a00\u662f\u4e0d\u53ef\u89c1\u7684\u3002\u4e0b\u9762\u662fLinux\u7cfb\u7edf\u4e0a\u5e38\u89c1\u7684\u4fe1\u53f7\uff1a  \u5e38\u89c1\u7684\u4fe1\u53f7 \uff1a     \u7f16\u53f7  \u540d\u79f0  \u9ed8\u8ba4\u52a8\u4f5c  \u5bf9\u5e94\u4e8b\u4ef6      2  SIGINT  \u7ec8\u6b62  \u6765\u81ea\u952e\u76d8\u7684\u4e2d\u65adCTRL+C    3  SIGQUIT  \u7ec8\u6b62  \u6765\u81ea\u952e\u76d8\u7684\u9000\u51faCTRL+\\    9  SIGKILL  \u7ec8\u6b62  \u6740\u6b7b\u7a0b\u5e8f  \\bin\\kill -9    11  SIGSEGV  \u7ec8\u6b62\u5e76\u8f6c\u50a8\u5185\u5b58  \u6bb5\u6545\u969c(\u65e0\u6548\u7684\u5185\u5b58\u5f15\u7528)    15  SIGTERM  \u7ec8\u6b62  \u8f6f\u4ef6\u7ec8\u6b62\u4fe1\u53f7 \\bin\\kill    17  SIGCHLD  \u5ffd\u7565  \u5b50\u8fdb\u7a0b\u505c\u6b62\u6216\u7ec8\u6b62    18  SIGCONT  \u5ffd\u7565  \u7ee7\u7eed\u8fdb\u7a0b\u5982\u679c\u8be5\u8fdb\u7a0b\u505c\u6b62    20  SIGTSTP  \u505c\u6b62\u76f4\u5230\u4e0b\u4e00\u4e2aSIGCONT  \u7528\u6237\u8f93\u5165CTRL+Z     \u8be6\u7ec6\u4fe1\u606f\u53ef\u4ee5\u901a\u8fc7 man 7 signal \u67e5\u8be2\u3002", 
            "title": "5 \u4fe1\u53f7"
        }, 
        {
            "location": "/csapp/ch8/#_11", 
            "text": "\u4f20\u9001\u4e00\u4e2a\u4fe1\u53f7\u5230\u76ee\u7684\u8fdb\u7a0b\u7531\u53d1\u9001\u3001\u63a5\u6536\u4fe1\u53f7\u4e24\u4e2a\u6b65\u9aa4\u7ec4\u6210\uff1a   \u53d1\u9001\u4fe1\u53f7\u3002\u5185\u6838\u901a\u8fc7\u66f4\u65b0\u76ee\u7684\u8fdb\u7a0b\u4e0a\u4e0b\u6587\u4e2d\u7684\u67d0\u4e2a\u72b6\u6001\uff0c\u53d1\u9001(\u9012\u9001)\u4e00\u4e2a\u4fe1\u53f7\u7ed9\u76ee\u7684\u8fdb\u7a0b\u3002  \u63a5\u6536\u4fe1\u53f7\u3002\u5f53\u76ee\u7684\u8fdb\u7a0b\u88ab\u5185\u6838\u5f3a\u8feb\u5df2\u67d0\u79cd\u65b9\u5f0f\u5bf9\u4fe1\u53f7\u7684\u53d1\u9001\u505a\u51fa\u53cd\u5e94\u65f6\uff0c\u5b83\u5c31\u63a5\u6536\u4e86\u4fe1\u53f7\u3002\u8fdb\u7a0b\u53ef\u4ee5\u5ffd\u7565\u8fd9\u4e2a\u4fe1\u53f7\uff0c\u7ec8\u6b62\u6216\u8005\u901a\u8fc7\u6267\u884c\u4e00\u4e2a\u79f0\u4e3a \u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f \u7684\u7528\u6237\u5c42\u51fd\u6570\u6355\u83b7\u8fd9\u4e2a\u4fe1\u53f7\u3002", 
            "title": "\u53d1\u9001/\u63a5\u6536\u4fe1\u53f7"
        }, 
        {
            "location": "/csapp/ch8/#_12", 
            "text": "\u53d1\u9001\u4fe1\u53f7\u53ef\u4ee5\u7531\u4ee5\u4e0b\u539f\u56e0\u5f15\u8d77\uff1a   \u7528\u6237\uff1a\u7528\u6237\u80fd\u591f\u901a\u8fc7\u8f93\u5165 CTRL+c ( SIGINT )\u3001 Ctrl+z ( SIGTSTP )\uff0c\u6216\u8005\u662f\u7ec8\u7aef\u9a71\u52a8\u7a0b\u5e8f\u5206\u914d\u7ed9\u4fe1\u53f7\u63a7\u5236\u5b57\u7b26\u7684\u5176\u4ed6\u4efb\u4f55\u952e\u6765\u8bf7\u6c42\u5185\u6838\u4ea7\u751f\u4fe1\u53f7\uff1b  \u5185\u6838\uff1a\u5f53\u8fdb\u7a0b\u6267\u884c\u51fa\u9519\u65f6\uff0c\u5185\u6838\u4f1a\u7ed9\u8fdb\u7a0b\u53d1\u9001\u4e00\u4e2a\u4fe1\u53f7\uff0c\u4f8b\u5982\u975e\u6cd5\u6bb5\u5b58\u53d6(\u5185\u5b58\u8bbf\u95ee\u8fdd\u89c4)\u3001\u6d6e\u70b9\u6570\u6ea2\u51fa\u7b49\uff1b  \u8fdb\u7a0b\uff1a\u4e00\u4e2a\u8fdb\u7a0b\u53ef\u4ee5\u901a\u8fc7\u7cfb\u7edf\u8c03\u7528kill\u7ed9\u53e6\u4e00\u4e2a\u8fdb\u7a0b\u6216\u81ea\u5df1\u53d1\u9001\u4fe1\u53f7\u3002", 
            "title": "\u53d1\u9001\u4fe1\u53f7"
        }, 
        {
            "location": "/csapp/ch8/#_13", 
            "text": "\u5f53\u5185\u6838\u628a\u8fdb\u7a0b p p \u4ece\u5185\u6838\u6a21\u5f0f\u5207\u6362\u5230\u7528\u6237\u6a21\u5f0f\u65f6\uff0c\u5b83\u4f1a\u68c0\u67e5\u8fdb\u7a0b p p \u7684\u672a\u88ab\u963b\u585e\u7684\u5f85\u5904\u7406\u4fe1\u53f7\u7684\u96c6\u5408( pending ~blocked ,\u89c1\u4e0b\u6587)\uff0c\u5982\u679c\u96c6\u5408\u975e\u7a7a\uff0c\u90a3\u4e48\u5185\u6838\u5f3a\u5236 p p \u63a5\u6536\u4fe1\u53f7\uff0c\u89e6\u53d1\u8fdb\u7a0b\u91c7\u53d6\u67d0\u79cd\u884c\u4e3a\u3002  \u8fdb\u7a0b\u63a5\u6536\u5230\u4fe1\u53f7\u4ee5\u540e\uff0c\u53ef\u4ee5\u6709\u5982\u4e0b3\u79cd\u9009\u62e9\u8fdb\u884c\u5904\u7406\uff1a   \u63a5\u6536\u9ed8\u8ba4\u5904\u7406\uff1a\u63a5\u6536\u9ed8\u8ba4\u5904\u7406\u7684\u8fdb\u7a0b\u901a\u5e38\u4f1a\u5bfc\u81f4\u8fdb\u7a0b\u672c\u8eab\u6d88\u4ea1\u3002\u4f8b\u5982\u8fde\u63a5\u5230\u7ec8\u7aef\u7684\u8fdb\u7a0b\uff0c\u7528\u6237\u6309\u4e0bCTRL+c\uff0c\u5c06\u5bfc\u81f4\u5185\u6838\u5411\u8fdb\u7a0b\u53d1\u9001\u4e00\u4e2aSIGINT\u7684\u4fe1\u53f7\uff0c\u8fdb\u7a0b\u5982\u679c\u4e0d\u5bf9\u8be5\u4fe1\u53f7\u505a\u7279\u6b8a\u7684\u5904\u7406\uff0c\u7cfb\u7edf\u5c06\u91c7\u7528\u9ed8\u8ba4\u7684\u65b9\u5f0f\u5904\u7406\u8be5\u4fe1\u53f7\uff0c\u5373\u7ec8\u6b62\u8fdb\u7a0b\u7684\u6267\u884c\uff1b  \u5ffd\u7565\u4fe1\u53f7\uff1a\u8fdb\u7a0b\u53ef\u4ee5\u901a\u8fc7\u4ee3\u7801\uff0c\u663e\u793a\u5730\u5ffd\u7565\u67d0\u4e2a\u4fe1\u53f7\u7684\u5904\u7406\uff0c\u4f8b\u5982\uff1a signal(SIGINT,SIGDEF) \uff1b\u4f46\u662f\u67d0\u4e9b\u4fe1\u53f7\u662f\u4e0d\u80fd\u88ab\u5ffd\u7565\u7684\uff0c  \u6355\u83b7\u4fe1\u53f7\u5e76\u5904\u7406\uff1a\u5f53\u63a5\u6536\u5230\u4fe1\u53f7\u65f6\uff0c\u7531\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f\u81ea\u52a8\u6355\u83b7\u5e76\u4e14\u5904\u7406\u4fe1\u53f7\u3002   sighandler_t   signal ( int   signum ,   sighandler_t   handler );   \u6709\u4e24\u4e2a\u4fe1\u53f7\u65e2\u4e0d\u80fd\u88ab\u5ffd\u7565\u4e5f\u4e0d\u80fd\u88ab\u6355\u83b7\uff0c\u5b83\u4eec\u662f SIGKILL \u548c SIGSTOP \u3002\u5373\u8fdb\u7a0b\u63a5\u6536\u5230\u8fd9\u4e24\u4e2a\u4fe1\u53f7\u540e\uff0c\u53ea\u80fd\u63a5\u53d7\u7cfb\u7edf\u7684\u9ed8\u8ba4\u5904\u7406\uff0c\u5373\u7ec8\u6b62\u7ebf\u7a0b\u3002", 
            "title": "\u63a5\u6536\u4fe1\u53f7"
        }, 
        {
            "location": "/csapp/ch8/#_14", 
            "text": "\u4e00\u4e2a\u53d1\u51fa\u800c\u6ca1\u6709\u88ab\u63a5\u53d7\u7684\u4fe1\u53f7\u53eb\u505a \u672a\u5904\u7406\u4fe1\u53f7 \uff08Pending Signal\uff09\u3002\u8fdb\u7a0b\u53ef\u4ee5\u9009\u62e9\u963b\u585e\uff08Block\uff09\u67d0\u4e2a\u4fe1\u53f7\u3002\u88ab\u963b\u585e\u7684\u4fe1\u53f7\u4ea7\u751f\u65f6\u5c06\u4fdd\u6301\u5728\u672a\u5904\u7406\u72b6\u6001\uff0c\u76f4\u5230\u8fdb\u7a0b\u89e3\u9664\u5bf9\u6b64\u4fe1\u53f7\u7684\u963b\u585e\uff0c\u624d\u6267\u884c\u63a5\u6536\u7684\u52a8\u4f5c\u3002\u963b\u585e\u548c\u5ffd\u7565\u662f\u4e0d\u540c\u7684\uff0c \u53ea\u8981\u4fe1\u53f7\u88ab\u963b\u585e\u5c31\u4e0d\u4f1a\u63a5\u6536 \uff0c\u800c\u5ffd\u7565\u662f\u5728\u63a5\u6536\u4e4b\u540e\u53ef\u9009\u7684\u4e00\u79cd\u5904\u7406\u52a8\u4f5c\u3002  Linux\u63d0\u4f9b\u963b\u585e\u4fe1\u53f7\u7684\u9690\u5f0f\u548c\u663e\u5f0f\u673a\u5236:   \u9690\u5f0f\u963b\u585e\u673a\u5236 \uff1a\u5185\u6838\u9ed8\u8ba4\u963b\u585e\u4efb\u4f55\u5f53\u524d\u5904\u7406\u7a0b\u5e8f\u6b63\u5728\u5904\u7406\u4fe1\u53f7\u7c7b\u578b\u7684\u5f85\u5904\u7406\u7684\u4fe1\u53f7\u3002\u5982\u679c\u5728\u8fdb\u7a0b\u89e3\u9664\u5bf9\u67d0\u4fe1\u53f7\u7684\u963b\u585e\u4e4b\u524d\u8fd9\u79cd\u4fe1\u53f7\u4ea7\u751f\u8fc7\u591a\u6b21\uff0c\u53ea\u8ba1\u4e00\u6b21\u3002\u56e0\u4e3a\u6bcf\u4e2a\u4fe1\u53f7\u53ea\u6709\u4e00\u4e2abit\u7684\u672a\u5904\u7406\u6807\u5fd7(\u5982\u4e0b\u56fe)\uff0c\u975e0\u53731\uff0c\u4e0d\u8bb0\u5f55\u8be5\u4fe1\u53f7\u4ea7\u751f\u4e86\u591a\u5c11\u6b21\uff0c\u963b\u585e\u6807\u5fd7\u4e5f\u662f\u8fd9\u6837\u8868\u793a\u7684\u3002  \u663e\u5f0f\u963b\u585e\u673a\u5236 \uff1a\u5e94\u7528 sigprocmask \u51fd\u6570\uff0c\u660e\u786e\u5730\u963b\u585e\u548c\u89e3\u9664\u963b\u585e\u9009\u5b9a\u7684\u4fe1\u53f7\u3002   \u5185\u6838\u4e3a\u6bcf\u4e2a\u8fdb\u7a0b\u5728 pending\u4f4d\u5411\u91cf \u4e2d\u7ef4\u62a4\u7740\u5f85\u5904\u7406\u4fe1\u53f7\u7684\u96c6\u5408\uff0c\u800c\u5728 blocked\u4f4d\u5411\u91cf \u4e2d\u7ef4\u62a4\u7740\u88ab\u963b\u585e\u7684\u4fe1\u53f7\u96c6\u5408\u3002\u4fe1\u53f7\u5728\u5185\u6838\u4e2d\u7684\u8868\u793a\u53ef\u4ee5\u770b\u4f5c\u662f\u8fd9\u6837\u7684\uff1a   \u6bcf\u4e2a\u4fe1\u53f7\u90fd\u6709\u4e24\u4e2a\u6807\u5fd7\u4f4d\u5206\u522b\u8868\u793a\u963b\u585e\u548c\u672a\u5904\u7406\uff0c\u8fd8\u6709\u4e00\u4e2a\u51fd\u6570\u6307\u9488\u8868\u793a\u5904\u7406\u52a8\u4f5c\u3002\u4fe1\u53f7\u4ea7\u751f\u65f6\uff0c\u5185\u6838\u5728\u8fdb\u7a0b\u63a7\u5236\u5757\u4e2d\u8bbe\u7f6e\u8be5\u4fe1\u53f7\u7684\u672a\u5904\u7406\u6807\u5fd7\uff0c\u76f4\u5230\u4fe1\u53f7\u63a5\u6536\u624d\u6e05\u9664\u8be5\u6807\u5fd7\u3002\u5728\u4e0a\u56fe\u7684\u4f8b\u5b50\u4e2d\uff0c   SIGHUP\u4fe1\u53f7\u672a\u963b\u585e\u4e5f\u672a\u4ea7\u751f\u8fc7\uff0c\u5f53\u5b83\u63a5\u6536\u65f6\u6267\u884c\u9ed8\u8ba4\u5904\u7406\u52a8\u4f5c\u3002  SIGINT\u4fe1\u53f7\u4ea7\u751f\u8fc7\uff0c\u4f46\u6b63\u5728\u88ab\u963b\u585e\uff0c\u6240\u4ee5\u6682\u65f6\u4e0d\u80fd\u63a5\u6536\u3002\u867d\u7136\u5b83\u7684\u5904\u7406\u52a8\u4f5c\u662f\u5ffd\u7565\uff0c\u4f46\u5728\u6ca1\u6709\u89e3\u9664\u963b\u585e\u4e4b\u524d\u4e0d\u80fd\u5ffd\u7565\u8fd9\u4e2a\u4fe1\u53f7\uff0c\u56e0\u4e3a\u8fdb\u7a0b\u4ecd\u6709\u673a\u4f1a\u6539\u53d8\u5904\u7406\u52a8\u4f5c\u4e4b\u540e\u518d\u89e3\u9664\u963b\u585e\u3002  SIGQUIT\u4fe1\u53f7\u672a\u4ea7\u751f\u8fc7\uff0c\u4e00\u65e6\u4ea7\u751fSIGQUIT\u4fe1\u53f7\u5c06\u88ab\u963b\u585e\uff0c\u5b83\u8c03\u7528\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f sighandler \u3002", 
            "title": "\u963b\u585e\u4fe1\u53f7\u548c\u8fdb\u7a0b\u56de\u6536"
        }, 
        {
            "location": "/csapp/ch8/#_15", 
            "text": "\u5f53\u591a\u4e2a\u672a\u5904\u7406\u4fe1\u53f7( pending signal )\u5230\u8fbe\u65f6\uff0c\u7531\u4e8e\u4fe1\u53f7\u5e76\u4e0d\u4f1a\u4ea7\u751f\u6392\u961f\u7b49\u5f85\u8fd9\u6837\u7684\u60c5\u51b5\uff0c\u6240\u4ee5\u4ea7\u751f\u7684\u6548\u679c\u4ec5\u76f8\u5f53\u4e8e\u4e00\u4e2a\u672a\u5904\u7406\u4fe1\u53f7(\u4e5f\u5c31\u662f\u5bf9\u5e94\u7684 pending \u4f4d\u6807\u8bb0\u4e3a1\uff0c\u4f8b\u5982\u4e0a\u56fe\u4e2d\u7684 SIGINT \u4fe1\u53f7)\u3002  \u8fd9\u6837\u5e26\u6765\u51e0\u4e2a\u95ee\u9898\uff1a   \u4e0d\u80fd\u7528\u4fe1\u53f7\u6765\u5bf9\u5176\u4ed6\u8fdb\u7a0b\u4e2d\u53d1\u751f\u7684\u4e8b\u4ef6\u8ba1\u6570\uff0c\u8fd9\u662f\u663e\u800c\u6613\u89c1\u7684  \u5728\u56de\u6536\u5b50\u8fdb\u7a0b\u65f6\uff0c\u8981\u56de\u6536\u5c3d\u53ef\u80fd\u591a\u7684\u5b50\u8fdb\u7a0b\u3002\u4f8b\u5982\u4e0b\u9762\u8fd9\u4e2a\u4f8b\u5b50\u3002   void   handler1 ( int   sig )     {   \n     pid_t   pid ;   \n\n     if   (( pid   =   waitpid ( - 1 ,   NULL ,   0 ))     0 )   \n         unix_error ( waitpid error );   \n     printf ( Handler reaped child %d \\n ,   ( int ) pid );   \n     Sleep ( 2 );   \n     return ;    }    /* $begin signal2 */  void   handler2 ( int   sig )   { \n     int   olderrno   =   errno ; \n\n     while   ( waitpid ( - 1 ,   NULL ,   0 )     0 )   { \n         Sio_puts ( Handler reaped child \\n ); \n     } \n     // waitpid()\u51fd\u6570\u6709\u53ef\u80fd\u56e0\u4e3a\u627e\u4e0d\u5230\u5b50\u8fdb\u7a0b\u800c\u62a5ECHILD\u9519\u8bef \n     if   ( errno   !=   ECHILD ) \n         Sio_error ( waitpid error ); \n     Sleep ( 1 ); \n     errno   =   olderrno ;  }  /* $end signal2 */  int   main ()   { \n     int   i ,   n ; \n     char   buf [ MAXBUF ]; \n\n     if   ( signal ( SIGCHLD ,   handler2 )   ==   SIG_ERR )   //handler2 \u6216\u8005 handler1 \n         unix_error ( signal error ); \n\n     /* Parent creates children */ \n     for   ( i   =   0 ;   i     3 ;   i ++ )   { \n         if   ( Fork ()   ==   0 )   { \n             printf ( Hello from child %d \\n ,   ( int ) getpid ()); \n             exit ( 0 ); \n         } \n     } \n\n     /* Parent waits for terminal input and then processes it */ \n     if   (( n   =   read ( STDIN_FILENO ,   buf ,   sizeof ( buf )))     0 ) \n         unix_error ( read ); \n\n     printf ( Parent processing input \\n ); \n     while   ( 1 ) \n         ; \n\n     exit ( 0 );  }   \u5728\u4e0a\u9762\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u7236\u8fdb\u7a0b\u521b\u5efa\u4e00\u4e9b\u5b50\u8fdb\u7a0b\uff0c\u8fd9\u4e9b\u5b50\u8fdb\u7a0b\u5404\u81ea\u72ec\u7acb\u8fd0\u884c\u4e00\u6bb5\u65f6\u95f4\uff0c\u7136\u540e\u7ec8\u6b62\u3002\u7528 SIGCHLD \u5904\u7406\u7a0b\u5e8f\u6765\u56de\u6536\u5b50\u8fdb\u7a0b\uff0c\u5176\u4e2d handler1 \u662f\u9519\u8bef\u7684\uff0c\u4f1a\u4ea7\u751f\u50f5\u6b7b\u5b50\u8fdb\u7a0b\u3002 handler2 \u662f\u5b89\u5168\u7684\u3002\u539f\u56e0\u662f\u5728 handler1 \u4e2d\uff0c\u53ef\u80fd\u5b58\u5728\u5b50\u8fdb\u7a0b\u5148\u88ab\u6267\u884c\uff0c\u4ea7\u751f SIGCHLD \u4fe1\u53f7\uff1b\u4f46\u662f\u5728\u5b50\u8fdb\u7a0b\u8fd8\u672a\u88ab\u56de\u6536\u4e4b\u524d\uff0c\u53c8\u6709\u591a\u4e2a\u5b50\u8fdb\u7a0b\u88ab\u6267\u884c\uff0c\u4ea7\u751f\u591a\u4e2a SIGCHLD \u4fe1\u53f7\u3002\u4e8e\u662f\u591a\u4f59\u7684\u672a\u5904\u7406 SIGCHLD \u4fe1\u53f7\u5c31\u88ab\u629b\u5f03\uff0c\u53ea\u76f8\u5f53\u4e8e\u4e00\u4e2a SIGCHLD \u4fe1\u53f7\u3002\u6700\u7ec8\u4f1a\u9020\u6210\u6709\u7684\u5b50\u8fdb\u7a0b\u672a\u88ab\u56de\u6536\uff0c\u4ea7\u751f\u50f5\u6b7b\u5b50\u8fdb\u7a0b\u3002  \u6267\u884c\u7684\u53ef\u80fd\u7ed3\u679c\u5982\u4e0b\uff0c\u53ef\u4ee5\u770b\u5230\u7236\u8fdb\u7a0b\u53ea\u56de\u6536\u4e86\u4e24\u4e2a\u5b50\u8fdb\u7a0b\u3002  Hello from child 5617\nHello from child 5616\nHello from child 5618\nHandler reaped child\nHandler reaped child\n\nParent processing input", 
            "title": "\u9690\u5f0f\u963b\u585e\u673a\u5236"
        }, 
        {
            "location": "/csapp/ch8/#_16", 
            "text": "\u6709\u65f6\u5019\u4e0d\u5e0c\u671b\u5728\u53d1\u9001\u4fe1\u53f7\u540e\u5c31\u7acb\u5373\u53bb\u63a5\u6536\u3001\u5904\u7406\u4fe1\u53f7\uff0c\u540c\u65f6\u4e5f\u4e0d\u5e0c\u671b\u5ffd\u7565\u8be5\u4fe1\u53f7\uff0c\u90a3\u4e48\u53ef\u4ee5\u901a\u8fc7 sigprocmask \u663e\u5f0f\u5730\u963b\u585e\u4fe1\u53f7\u4ece\u800c\u5b9e\u73b0\u5ef6\u8fdf\u63a5\u6536\u4fe1\u53f7\u3002  \u51fd\u6570 sigprocmask \u53ef\u4ee5\u66f4\u6539\u5f53\u524d\u963b\u585e\u7684\u4fe1\u53f7\u96c6\u5408(\u5373blocked\u4f4d\u5411\u91cf):  int   sigprocmask ( int   how ,   const   sigset_t   * set ,   sigset_t   * oldset );  \n\u5176\u5177\u4f53\u884c\u4e3a\u4f9d\u8d56\u4e8ehow\u503c\uff1a  SIG_BLOCK, blocked = blocked | set //\u6dfb\u52a0set\u4fe1\u53f7\nSIG_UNBLOCK, blocked = blocked   ~set //\u5220\u9664set\u4fe1\u53f7\nSIG_SETMASK, block = set //\u8bbe\u7f6eset\u4fe1\u53f7\u4e3a\u963b\u585e\u7684\u4fe1\u53f7  \u963b\u585e\u7684\u4fe1\u53f7\u96c6\u5408\u5176\u5b9e\u5c31\u662f\u4e00\u4e2a\u65e0\u7b26\u53f7\u6574\u578b\u6570\u7ec4(\u5728x86-64\u4e0a\uff0c\u6570\u7ec4\u957f\u5ea6\u662f16)\u3002  /* A `sigset_t  has a bit for each signal.  */  # define _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))  typedef   struct  { \n     unsigned   long   int   __val [ _SIGSET_NWORDS ];  }   sigset_t ;   \u8fd8\u6709\u5176\u4ed6\u7684\u4e00\u4e9b\u51fd\u6570\u53ef\u4ee5\u5bf9\u4fe1\u53f7\u96c6\u8fdb\u884c\u64cd\u4f5c\uff1a  int   sigfillset ( sigset_t   * set );   // \u4fe1\u53f7\u96c6\u521d\u59cb\u5316, \u7136\u540e\u628a\u6240\u6709\u7684\u4fe1\u53f7\u52a0\u5165\u5230\u6b64\u4fe1\u53f7\u96c6\u91cc  int   sigemptyset ( sigset_t   * set );   //\u4fe1\u53f7\u96c6\u521d\u59cb\u5316\u4e3a\u7a7a  int   sigaddset ( sigset_t   * set ,   int   signo );   //\u5c06\u4fe1\u53f7signo\u6dfb\u52a0\u5230\u4fe1\u53f7\u96c6\u4e2d     \u4e0b\u9762\u770b\u4e2a\u4f8b\u5b50, \u662f\u4e00\u4e2a\u5177\u6709\u7ec6\u5fae\u540c\u6b65\u9519\u8bef\u7684SHELL\u7a0b\u5e8f\u3002\u5982\u679c\u5b50\u8fdb\u7a0b\u5728\u7236\u8fdb\u7a0b\u80fd\u591f\u5f00\u59cb\u8fd0\u884c\u524d\u5c31\u7ed3\u675f\u4e86\uff0c\u90a3\u4e48 addjob()  \u548c  deletejob()  \u4f1a\u4ee5\u9519\u8bef\u7684\u65b9\u5f0f\u88ab\u8c03\u7528\u3002\u8fd9\u4e2a\u7a0b\u5e8f\u5e0c\u671b\u7236\u8fdb\u7a0b\u5728\u4e00\u4e2a\u4f5c\u4e1a\u5217\u8868\u4e2d\u8bb0\u5f55\u7740\u5b83\u7684\u5f53\u524d\u5b50\u8fdb\u7a0b\uff0c\u6bcf\u4e2a\u4f5c\u4e1a\u6761\u76ee\u3002  addjob()  \u548c  deletejob()  \u5206\u522b\u60f3\u8fd9\u4e2a\u4f5c\u4e1a\u5217\u8868\u6dfb\u52a0\u548c\u4ece\u4e2d\u5220\u9664\u4f5c\u4e1a\u3002\u5f53\u7236\u8fdb\u7a0b\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5b50\u8fdb\u7a0b\u65f6\uff0c\u5b83\u5c31\u628a\u8fd9\u4e2a\u5b50\u8fdb\u7a0b\u6dfb\u52a0\u5230\u4f5c\u4e1a\u5217\u8868\u4e2d\u3002\u5f53\u7236\u8fdb\u7a0b\u5728 SIGCHLD  \u5904\u7406\u7a0b\u5e8f\u4e2d\u56de\u6536\u4e00\u4e2a\u7ec8\u6b62\u7684\uff08\u50f5\u6b7b\uff09\u5b50\u8fdb\u7a0b\u65f6\uff0c\u5b83\u5c31\u4ece\u4f5c\u4e1a\u5217\u8868\u4e2d\u5220\u9664\u8fd9\u4e2a\u5b50\u8fdb\u7a0b\u3002\u4e4d\u4e00\u770b\uff0c\u8fd9\u6bb5\u4ee3\u7801\u662f\u5bf9\u7684\u3002\u4e0d\u5e78\u7684\u662f\uff0c\u53ef\u80fd\u53d1\u751f\u4e0b\u9762\u7684\u60c5\u51b5\uff1a     \u7236\u8fdb\u7a0b\u6267\u884c fork() \uff0c\u5185\u6838\u8c03\u5ea6\u65b0\u521b\u5efa\u7684\u5b50\u8fdb\u7a0b\u8fd0\u884c\uff0c\u800c\u4e0d\u662f\u7236\u8fdb\u7a0b      \u5728\u7236\u8fdb\u7a0b\u80fd\u591f\u518d\u6b21\u8fd0\u884c\u4e4b\u524d\uff0c\u5b50\u8fdb\u7a0b\u5c31\u7ec8\u6b62\uff0c\u5e76\u4e14\u53d8\u6210\u4e00\u4e2a\u50f5\u6b7b\u8fdb\u7a0b\uff0c\u4f7f\u5f97\u5185\u6838\u4f20\u9012\u4e00\u4e2a SIGCHLD \u4fe1\u53f7\u7ed9\u7236\u8fdb\u7a0b      \u540e\u6765\uff0c\u5f53\u7236\u8fdb\u7a0b\u518d\u6b21\u53d8\u6210\u53ef\u8fd0\u884c\u4f46\u53c8\u5728\u5b83\u6267\u884c\u4e4b\u524d\uff0c\u5185\u6838\u6ce8\u610f\u5230\u5f85\u5904\u7406\u7684 SIGCHLD \u4fe1\u53f7\uff0c\u5e76\u901a\u8fc7\u5728\u7236\u8fdb\u7a0b\u4e2d\u8fd0\u884c\u5904\u7406\u7a0b\u5e8f\u63a5\u6536\u8fd9\u4e2a\u4fe1\u53f7      \u5904\u7406\u7a0b\u5e8f\u56de\u6536\u7ec8\u6b62\u7684\u5b50\u8fdb\u7a0b\uff0c\u5e76\u8c03\u7528 deletejob() \uff0c\u8fd9\u4e2a\u51fd\u6570\u4ec0\u4e48\u90fd\u4e0d\u505a\uff0c\u56e0\u4e3a\u7236\u8fdb\u7a0b\u8fd8\u6ca1\u6709\u628a\u8be5\u5b50\u8fdb\u7a0b\u6dfb\u52a0\u5230\u5217\u8868\u4e2d      \u5728\u5904\u7406\u7a0b\u5e8f\u8fd0\u884c\u7ed3\u675f\u540e\uff0c\u5185\u6838\u8fd0\u884c\u7236\u8fdb\u7a0b\uff0c\u7236\u8fdb\u7a0b\u4ece fork() \u8fd4\u56de\uff0c\u901a\u8fc7\u8c03\u7528 addjob()  \u9519\u8bef\u5730\u628a\uff08\u4e0d\u5b58\u5728\u7684\uff09\u5b50\u8fdb\u7a0b\u6dfb\u52a0\u5230\u4f5c\u4e1a\u5217\u8868\u4e2d     void   handler ( int   sig )  { \n         pid_t   pid ; \n         while   (( pid   =   waitpid ( - 1 ,   NULL ,   0 ))     0 )   /* Reap a zombie child */ \n                 deletejob ( pid );   /* Delete the child from the job list */ \n         if   ( errno   !=   ECHILD ) \n                 unix_error ( waitpid error );  }  int   main ( int   argc ,   char   ** argv )  { \n         int   pid ; \n\n         Signal ( SIGCHLD ,   handler ); \n         initjobs ();               /* Initialize the job list */ \n\n         while   ( 1 )   { \n                 /* Child process */ \n                 if   (( pid   =   Fork ())   ==   0 )   { \n                         Execve ( /bin/date ,   argv ,   NULL ); \n                 } \n\n                 /* Parent process */ \n                 addjob ( pid );      /* Add the child to the job list */ \n         } \n\n         exit ( 0 );  }   \u6b63\u786e\u7684\u505a\u6cd5\u5e94\u8be5\u5982\u4e0b,  \u901a\u8fc7\u5728\u8c03\u7528  fork()  \u4e4b\u524d\uff0c\u963b\u585e  SIGCHLD  \u4fe1\u53f7\uff0c\u7136\u540e\u5728\u6211\u4eec\u8c03\u7528\u4e86  addjob()  \u4e4b\u540e\u5c31\u53d6\u6d88\u963b\u585e\u8fd9\u4e9b\u4fe1\u53f7\uff0c\u6211\u4eec\u4fdd\u8bc1\u4e86\u5728\u5b50\u8fdb\u7a0b\u88ab\u6dfb\u52a0\u5230\u4f5c\u4e1a\u5217\u8868\u4e4b\u540e\u56de\u6536\u8be5\u5b50\u8fdb\u7a0b\u3002\u6ce8\u610f\uff0c\u5b50\u8fdb\u7a0b\u7ee7\u627f\u4e86\u5b83\u4eec\u7236\u8fdb\u7a0b\u7684\u88ab\u963b\u585e\u96c6\u5408\uff0c\u6240\u4ee5\u6211\u4eec\u5fc5\u987b\u5728\u8c03\u7528  execve()  \u4e4b\u524d\uff0c\u5c0f\u5fc3\u5730\u89e3\u9664\u5b50\u8fdb\u7a0b\u4e2d\u963b\u585e\u7684  SIGCHLD  \u4fe1\u53f7\u3002\u8fd9\u6837\uff0c\u7236\u8fdb\u7a0b\u4fdd\u8bc1\u5728\u76f8\u5e94\u7684  deletejob()  \u4e4b\u524d\u6267\u884c  addjob() \u3002  int   main ( int   argc ,   char   ** argv )  { \n     int   pid ; \n     sigset_t   mask_all ,   mask_one ,   prev_one ; \n\n     Sigfillset ( mask_all ); \n     Sigemptyset ( mask_one ); \n     Sigaddset ( mask_one ,   SIGCHLD ); \n     Signal ( SIGCHLD ,   handler ); \n     initjobs ();   /* Initialize the job list */ \n\n     while   ( 1 )   { \n         Sigprocmask ( SIG_BLOCK ,   mask_one ,   prev_one );   /* Block SIGCHLD */ \n         if   (( pid   =   Fork ())   ==   0 )   {   /* Child process */ \n             Sigprocmask ( SIG_SETMASK ,   prev_one ,   NULL );   /* Unblock SIGCHLD */ \n             Execve ( /bin/date ,   argv ,   NULL ); \n         } \n         Sigprocmask ( SIG_BLOCK ,   mask_all ,   NULL );   /* Parent process */   \n         addjob ( pid );    /* Add the child to the job list */ \n         Sigprocmask ( SIG_SETMASK ,   prev_one ,   NULL );    /* Unblock SIGCHLD */ \n     } \n     exit ( 0 );  }", 
            "title": "\u663e\u5f0f\u963b\u585e\u673a\u5236"
        }, 
        {
            "location": "/csapp/ch8/#_17", 
            "text": "\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f(signal handler)\u662f\u91cd\u8981\u4e14\u68d8\u624b\u7684\u4e00\u4e2a\u95ee\u9898\u3002\u5176\u96be\u70b9\u5728\uff1a   \u5904\u7406\u7a0b\u5e8f\u4e0e\u4e3b\u7a0b\u5e8f\u5e76\u53d1\u8fd0\u884c\uff0c\u5171\u4eab\u540c\u6837\u7684\u5168\u5c40\u53d8\u91cf\uff0c\u56e0\u6b64\u53ef\u80fd\u4e0e\u4e3b\u7a0b\u5e8f\u548c\u5176\u4ed6\u5904\u7406\u7a0b\u5e8f\u76f8\u4e92\u5e72\u6270\uff1b  \u5982\u4f55\u4ee5\u53ca\u4f55\u65f6\u63a5\u6536\u4fe1\u53f7\u7684\u89c4\u5219\u5e38\u5e38\u8fdd\u80cc\u4eba\u7684\u76f4\u89c9\u3002", 
            "title": "\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f"
        }, 
        {
            "location": "/csapp/ch8/#7", 
            "text": "Linux\u7cfb\u7edf\u63d0\u4f9b\u4e86\u5927\u91cf\u7684\u76d1\u63a7\u548c\u64cd\u4f5c\u8fdb\u7a0b\u7684\u6709\u7528\u5de5\u5177\u3002   STRACE\uff1a \u6253\u5370\u4e00\u4e2a\u6b63\u5728\u8fd0\u884c\u7684\u7a0b\u5e8f\u548c\u5b83\u7684\u5b50\u8fdb\u7a0b\u8c03\u7528\u7684\u6bcf\u4e2a\u7cfb\u7edf\u8c03\u7528\u7684\u8f68\u8ff9  PS\uff1a\u5217\u51fa\u5f53\u524d\u7cfb\u7edf\u4e2d\u7684\u8fdb\u7a0b(\u5305\u62ec\u50f5\u5c38\u8fdb\u7a0b)  TOP: \u6253\u5370\u51fa\u5173\u4e8e\u5f53\u524d\u8fdb\u7a0b\u8d44\u6e90\u4f7f\u7528\u7684\u4fe1\u606f", 
            "title": "7 \u64cd\u4f5c\u8fdb\u7a0b\u7684\u5de5\u5177"
        }, 
        {
            "location": "/csapp/ch9/", 
            "text": "Chapter 9 \u865a\u62df\u5185\u5b58\n\n\n1 \u7269\u7406/\u865a\u62df\u5bfb\u5740\n\n\n\u4e3b\u5b58\u662f\u7531\u8fde\u7eed\u7684\n\u5b57\u8282\u5927\u5c0f\n\u7684\u5355\u5143\u7ec4\u6210\u7684\u6570\u7ec4\uff0c\u6bcf\u5b57\u8282\u90fd\u6709\u4e00\u4e2a\u552f\u4e00\u7684\n\u7269\u7406\u5730\u5740\n(Physical Adress)\u3002CPU\u4f7f\u7528\u7269\u7406\u5730\u5740\u8bbf\u95ee\u5185\u5b58\u7684\u65b9\u5f0f\u79f0\u4e3a\n\u7269\u7406\u5bfb\u5740\n(Physical adressing)\u3002\n\n\n\u65e9\u671f\u7684PC\u4ee5\u53ca\u6570\u5b57\u4fe1\u53f7\u5904\u7406\u5668\u7b49\u4f7f\u7528\u7269\u7406\u5bfb\u5740\uff0c\u4e0b\u9762\u662f\u7269\u7406\u5bfb\u5740\u7684\u793a\u610f\u56fe\uff1a\n\n\n\n\n\u73b0\u4ee3\u5904\u7406\u5668\u901a\u8fc7\u751f\u6210\u4e00\u4e2a\n\u865a\u62df\u5730\u5740\n(Virtual Address)\u6765\u8bbf\u95ee\u4e3b\u5b58\uff0c\u865a\u62df\u5730\u5740\u7ecf\u8fc7\n\u5730\u5740\u7ffb\u8bd1\n(Address Translation)\u8f6c\u6362\u4e3a\u7269\u7406\u5730\u5740\u3002\u5730\u5740\u7ffb\u8bd1\u7531CPU\u5185\u7684\n\u5185\u5b58\u7ba1\u7406\u5355\u5143\n(Memory Management Unit, \nMMU\n)\u8d1f\u8d23.\n\n\n\n\n\u865a\u62df\u5185\u5b58\u5145\u5f53\u7740\u4e09\u4e2a\u89d2\u8272\uff1a\n\n\n\n\n\u4f5c\u4e3a\u7f13\u5b58\u7684\u5de5\u5177\uff0c\u53ef\u4ee5\u66f4\u6709\u6548\u7387\u7684\u4f7f\u7528\u5185\u5b58\uff1a\u4f7f\u7528DRAM\u5f53\u505a\u90e8\u5206\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7684\u7f13\u5b58\n\n\n\u4f5c\u4e3a\u5185\u5b58\u7ba1\u7406\u7684\u5de5\u5177\uff0c\u7b80\u5316\u5185\u5b58\u7ba1\u7406\uff1a\u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u6709\u7edf\u4e00\u7684\u7ebf\u6027\u5730\u5740\u7a7a\u95f4\n\n\n\u4f5c\u4e3a\u5185\u5b58\u4fdd\u62a4\u7684\u5de5\u5177\uff0c\u5206\u9694\u5730\u5740\u7a7a\u95f4\uff1a\u8fdb\u7a0b\u7684\u5185\u5b58\u4e0d\u4f1a\u76f8\u4e92\u5f71\u54cd\uff1b\u7528\u6237\u7a0b\u5e8f\u4e0d\u80fd\u8bbf\u95ee\u4fdd\u5bc6\u7684\u5185\u6838\u4fe1\u606f\u548c\u4ee3\u7801\n\n\n\n\n\u4e0b\u9762\u4e00\u8282\u5177\u4f53\u8bb2\u89e3\u865a\u62df\u5185\u5b58\u7684\u8fd9\u4e09\u4e2a\u89d2\u8272\u3002\n\n\n2 \u865a\u62df\u5185\u5b58\u7684\u4e09\u4e2a\u89d2\u8272\n\n\n2.1 \u4f5c\u4e3a\u7f13\u5b58\u7684\u5de5\u5177\n\n\n\u53ef\u4ee5\u628a\u4e3b\u5b58DRAM\u770b\u4f5c\u662f\u865a\u62df\u5185\u5b58\u7684\u7f13\u5b58\uff0c\u7c7b\u4f3c\u4e8eL1\u3001L2\u3001L3\u9ad8\u901f\u7f13\u5b58\u662fDRAM\u5185\u5b58\u7684\u7f13\u5b58\u3002\u4e5f\u5c31\u662f\u8bf4\u53ef\u4ee5\u628a\u865a\u62df\u5185\u5b58\u770b\u6210\u662f\u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784\u7684\u4e00\u90e8\u5206\u3002\n\n\n\u548c\u5176\u4ed6\u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784\u4e2d\u7684\u7f13\u5b58\u4e00\u6837\uff0c\u8f83\u4f4e\u5c42\u4e0a\u7684\u6570\u636e\u88ab\u5206\u5272\u6210\u5757\uff0c\u4f5c\u4e3a\u4e0e\u8f83\u9ad8\u5c42\u4e4b\u95f4\u7684\u4f20\u8f93\u5355\u5143\u3002\n\n\n\n\n\u8fd9\u91cc\u8f83\u4f4e\u5c42\u662f\u865a\u62df\u5185\u5b58\uff0c\u5206\u5272\u6210\n\u865a\u62df\u9875\n(Virtual Page, VP)\uff0c\u865a\u62df\u9875\u5927\u5c0f\u4e3a\nP=2^p \nP=2^p \n\u5b57\u8282\u3002\n\n\n\u7c7b\u4f3c\u7684\uff0c\u8fd9\u91cc\u7684\u8f83\u9ad8\u5c42\uff0c\u7269\u7406\u5185\u5b58DRAM\uff0c\u88ab\u5206\u5272\u4e3a\n\u7269\u7406\u9875\n(Physical Page, PP)\uff0c\u5927\u5c0f\u4e5f\u4e3a\nP\nP\n\uff0c\u4e5f\u53eb\u505a\u9875\u6862(page frame)\u3002\n\n\n\n\n\u865a\u62df\u9875\u7684\u72b6\u6001\u5206\u4e3a\u4e09\u79cd\uff1a\n\n\n\n\n\u672a\u5206\u914d\n(Unallocated): \u7cfb\u7edf\u8fd8\u672a\u5206\u914d(\u521b\u5efa)\u7684\u9875\uff0c\u4e0d\u5360\u7528\u78c1\u76d8\u7a7a\u95f4\u3002\n\n\n\u7f13\u5b58\u7684\n(Cached): \u5f53\u524d\u5df2\u7f13\u5b58\u5728\u7269\u7406\u5185\u5b58\u4e2d\u7684\u5df2\u5206\u914d\u9875\u3002\n\n\n\u672a\u7f13\u5b58\u7684\n(Uncached): \u672a\u7f13\u5b58\u5728\u7269\u7406\u5185\u5b58\u4e2d\u7684\u5df2\u5206\u914d\u9875\u3002\n\n\n\n\n\n\n\u90a3\u4e48\u5177\u4f53\u662f\u600e\u4e48\u5224\u65ad\u4e00\u4e2a\u865a\u62df\u9875\u7684\u72b6\u6001\u5462\uff1f\u600e\u4e48\u77e5\u9053\u865a\u62df\u9875\u653e\u5728\u54ea\u4e2a\u7269\u7406\u9875\u4e2d\u5462\uff1f\n\n\n\u7269\u7406\u5185\u5b58\u4e2d\u5b58\u5728\u4e00\u4e2a\u53eb\n\u9875\u8868\n(page table)\u7684\u6570\u636e\u7ed3\u6784\uff0c\u7531\u64cd\u4f5c\u7cfb\u7edf\u8d1f\u8d23\u3002\u9875\u8868\u5c06\u865a\u62df\u9875\u6620\u5c04\u5230\u7269\u7406\u9875\uff0c\u6bcf\u6b21\u5185\u5b58\u7ba1\u7406\u5355\u5143\u4e2d\u7684\n\u5730\u5740\u7ffb\u8bd1\u786c\u4ef6\n\u5c06\u865a\u62df\u5730\u5740\u8f6c\u6362\u4e3a\u7269\u7406\u5730\u5740\u65f6\u90fd\u4f1a\u8bfb\u53d6\u9875\u8868\u3002\n\n\n\u9875\u8868\u5176\u5b9e\u662f\u4e00\u4e2a\n\u9875\u8868\u6761\u76ee\n(Page Table Entry, PTE)\u7684\u6570\u7ec4\u3002\u9875\u8868\u6761\u76ee\u5305\u542b\u4e00\u4e2a\n\u6709\u6548\u4f4d(\nvalid bit)\u548c\u4e00\u4e2a\nn\nn\n\u4f4d\u5730\u5740\u5b57\u6bb5\u3002\n\n\n\n\n\u5728\u865a\u62df\u5185\u5b58\u7684\u4e60\u60ef\u8bf4\u6cd5\u4e2d\uff0cDRAM\u7f13\u5b58\u547d\u4e2d/\u4e0d\u547d\u4e2d\uff0c\u7279\u79f0\u4e3a\n\u9875\u547d\u4e2d\n/\n\u7f3a\u9875\n(Page Hit/ Fault)\u3002\n\n\n2.2 \u4f5c\u4e3a\u5185\u5b58\u7ba1\u7406\u7684\u5de5\u5177\n\n\n\u64cd\u4f5c\u7cfb\u7edf\u4e3a\u6bcf\u4e2a\u8fdb\u7a0b\u63d0\u4f9b\u4e86\u4e00\u4e2a\u72ec\u7acb\u7684\u9875\u8868\uff0c\u4e5f\u5c31\u662f\u63d0\u4f9b\u4e86\u4e00\u4e2a\u72ec\u7acb\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\u3002\u591a\u4e2a\u865a\u62df\u9875\u9762\u53ef\u4ee5\u6620\u5c04\u5230\u540c\u4e00\u4e2a\u5171\u4eab\u7269\u7406\u9875\u9762\u4e0a\u3002\u865a\u62df\u5185\u5b58\u7b80\u5316\u4e86\u94fe\u63a5\u548c\u52a0\u8f7d\u3001\u4ee3\u7801\u548c\u6570\u636e\u5171\u4eab\u3001\u4ee5\u53ca\u5e94\u7528\u7a0b\u5e8f\u7684\u5185\u5b58\u5206\u914d\u3002\n\n\n2.3 \u4f5c\u4e3a\u5185\u5b58\u4fdd\u62a4\u7684\u5de5\u5177\n\n\n\u4e00\u65b9\u9762\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u62e5\u6709\u72ec\u7acb\u7684\u5730\u5740\u7a7a\u95f4\u4f7f\u5f97\u533a\u5206\u4e0d\u540c\u8fdb\u7a0b\u7684\u79c1\u6709\u5185\u5b58\u53d8\u5f97\u5bb9\u6613\u3002\u53e6\u4e00\u65b9\u9762\u5728\u6bcf\u4e2a\u9875\u8868\u6761\u76eePTE\u4e2d\uff0c\u6dfb\u52a0\u4e86\u989d\u5916\u7684\n\u8bb8\u53ef\u4f4d\n(SUP, READ, WRITE, EXEC)\u6765\u63a7\u5236\u5bf9\u4e00\u4e2a\u865a\u62df\u9875\u9762\u5185\u5bb9\u7684\u8bbf\u95ee\uff1a\n\n\n\n\nSUP\u4f4d\u8868\u793a\u8fdb\u7a0b\u662f\u5426\u8fd0\u884c\u5728\u8d85\u7ea7\u7528\u6237\u6a21\u5f0f\u4e0b\u624d\u80fd\u8bbf\u95ee\n\n\nREAD/WRITE\u4f4d\u63a7\u5236\u8bfb\u548c\u5199\u7684\u8bbf\u95ee\n\n\nEXEC\u4f4d\u63a7\u5236\u6267\u884c\u7684\u8bbf\u95ee\n\n\n\n\n\n\n\u5982\u679c\u8fdd\u53cd\u8bb8\u53ef\u6761\u4ef6\uff0c\u90a3\u4e48\u5c31\u89e6\u53d1\u6bb5\u9519\u8bef(segmentation fault)\u3002\n\n\n3 \u5730\u5740\u7ffb\u8bd1\n\n\n\u5730\u5740\u7ffb\u8bd1\u662f\u865a\u62df\u5730\u5740\u7a7a\u95f4\u548c\u7269\u7406\u5730\u5740\u7a7a\u95f4\u4e4b\u95f4\u7684\u6620\u5c04\u3002CPU\u4e2d\u7684\n\u9875\u8868\u57fa\u5740\u5bc4\u5b58\u5668\n(Page Table Base Register, PTBR)\u6307\u5411\u5f53\u524d\u9875\u8868\u3002\n\n\n\n\nn\nn\n\u4f4d\u7684\u865a\u62df\u5730\u5740\u5305\u542b\u4e24\u4e2a\u90e8\u5206\uff1a\u4e00\u4e2a\np\np\n\u4f4d\u7684\n\u865a\u62df\u9875\u9762\u504f\u79fb\n(Virtual Page Offset, VPO)\u548c\u4e00\u4e2a\nn-p\nn-p\n\u4f4d\u7684\n\u865a\u62df\u9875\u53f7\n(Virtual Page Number, VPN)\u3002\n\n\nm\nm\n\u4f4d\u7684\u7269\u7406\u5730\u5740\u5305\u542b\u4e24\u4e2a\u90e8\u5206\uff1a\u4e00\u4e2a\np\np\n\u4f4d\u7684\n\u7269\u7406\u9875\u9762\u504f\u79fb\n(Physical Page Offset, PPO)\u548c\u4e00\u4e2a\nm-p\nm-p\n\u4f4d\u7684\n\u7269\u7406\u9875\u53f7\n(Physical Page Number, PPN)\u3002\n\n\n\u7269\u7406\u9875\u9762\u504f\u79fb\u548c\u865a\u62df\u9875\u9762\u504f\u79fb\u662f\u76f8\u901a\u7684\u3002\n\n\n\n\n\n\n\u5229\u7528TLB\u52a0\u901f\u5730\u5740\u7ffb\u8bd1\n\n\n\u6bcf\u6b21CPU\u4ea7\u751f\u4e00\u4e2a\u865a\u62df\u5730\u5740\uff0cMMU\u5c31\u5fc5\u987b\u67e5\u9605\u4e00\u4e2aPTE\u3002\u4e3a\u4e86\u8bd5\u56fe\u6d88\u9664\u8fd9\u79cd\u5f00\u9500\uff0c\u5728MMU\u4e2d\u5305\u542b\u4e86\u4e00\u4e2a\u5173\u4e8ePTE\u7684\u7f13\u5b58\uff0c\u79f0\u4e3a\n\u8f6c\u8bd1\u540e\u5907\u7f13\u51b2\u5668\n(Translation Lookaside Buffer, TLB)\n\n\n\n\n\u591a\u7ea7\u9875\u8868\n\n\n\u7528\u6765\u538b\u7f29\u9875\u8868\u7684\u5e38\u7528\u65b9\u6cd5\u662f\u4f7f\u7528\u5c42\u6b21\u7ed3\u6784\u7684\u9875\u8868\u3002\n\n\n\n\n\u865a\u62df\u5730\u5740\u88ab\u5212\u5206\u4e3a\nk\nk\n\u4e2aVPN\u548c1\u4e2aVPO\u3002\n\n\n\u6bcf\u4e2aVPN \ni\ni\n\u90fd\u662f\u4e00\u4e2a\u5230\u7b2c\ni\ni\n\u7ea7\u9875\u8868\u7684\u7d22\u5f15\uff0c\u5176\u4e2d\n\\le i \\le k\n\\le i \\le k\n\u3002\n\n\n\u7b2c\nj\nj\n\u7ea7\u9875\u8868\u4e2d\u7684\u6bcf\u4e2aPTE\u90fd\u6307\u5411\u7b2c\nj+1\nj+1\n\u7ea7\u7684\u67d0\u4e2a\u9875\u8868\u7684\u57fa\u5740\u3002\n\n\n\u7b2c\nk\nk\n\u7ea7\u9875\u8868\u4e2d\u7684\u6bcf\u4e2aPTE\u5305\u542b\u67d0\u4e2a\u7269\u7406\u9875\u9762\u7684PPN\u3002\n\n\n\n\n\n\n4 core i7\u5185\u5b58\u7cfb\u7edf\n\n\nCore i7\u7b80\u4ecb\n\n\nCore i7\u57282008\u5e74\u51ac\u5b63\u53d1\u5e03\uff0c\u57fa\u4e8e\u5168\u65b0Nehalem(/n\u0259\u02c8he\u026al\u0259m/)\u67b6\u6784\uff0c\u5b83\u7684\u82af\u7247\u7ed3\u6784\u5982\u4e0b\u6240\u793a\uff1a\n\n\n\n\n\u73b0\u5728\u7684Core i7\u652f\u630148\u4f4d(256TB)\u865a\u62df\u5730\u5740\u7a7a\u95f4\u548c52\u4f4d(4PB)\u7269\u7406\u5730\u5740\u7a7a\u95f4\u3002\n\n\n\u4e0b\u56fe\u7ed9\u51fa\u4e86Core i7\u5185\u5b58\u7cfb\u7edf\u7684\u91cd\u8981\u90e8\u5206\u3002\u5904\u7406\u5668\u5c01\u88c5(Processor package)\u5305\u62ec\u56db\u4e2a\u6838\u3001\u4e00\u4e2a\u5927\u7684\u6240\u6709\u6838\u5171\u4eab\u7684L3\u9ad8\u901f\u7f13\u5b58\uff0c\u4ee5\u53ca\u4e00\u4e2aDDR3\u5185\u5b58\u63a7\u5236\u5668\u3002 \u6bcf\u4e00\u4e2a\u6838\u5305\u542b\u4e00\u4e2a\u5c42\u6b21\u7ed3\u6784\u7684TLB\u3001\u4e00\u4e2a\u5c42\u6b21\u7ed3\u6784\u7684\u6570\u636e\u6838\u6307\u4ee4\u9ad8\u901f\u7f13\u5b58\uff0c\u4ee5\u53ca\u4e00\u7ec4\u5feb\u901f\u7684\u70b9\u5230\u70b9\u94fe\u8def(\u57fa\u4e8eQuickPath\u6280\u672f)\u3002\n\n\n\n\nTLB\u662f\u56db\u8def\u7ec4\u76f8\u8054\u7684\n\n\nL1\u3001L2\u3001L3\u9ad8\u901f\u7f13\u5b58\uff0c\u5757\u5927\u5c0f\u4e3a64\u5b57\u8282\u3002\n\n\nL1\u3001L2\u662f8\u8def\u7ec4\u76f8\u8054\u7684\uff0cL3\u662f16\u7ec4\u76f8\u8054\u7684\u3002\n\n\n\n\n\n\nCore i7\u5730\u5740\u7ffb\u8bd1\n\n\nCore i7\u91c7\u7528\u56db\u7ea7\u9875\u8868\u5c42\u6b21\u7ed3\u6784\u3002\u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u6709\u5b83\u81ea\u5df1\u79c1\u6709\u7684\u9875\u8868\u5c42\u6b21\u7ed3\u6784\u3002CR3\u63a7\u5236\u5bc4\u5b58\u5668\u6307\u5411\u7b2c\u4e00\u7ea7\u9875\u8868(L1)\u7684\u8d77\u59cb\u4f4d\u7f6e\u3002\n\n\n\n\nCore i7\u7b2c1-3\u7ea7\u9875\u8868\u6761\u76ee\u683c\u5f0f\uff1a\n\n\n\n\nEach entry references a 4K child page table. \nSignificant fields\n:\n\n\n\n\nP\n: Child page table present in physical memory (1) or not (0).\n\n\nR/W\n: Read-\u00ad\u2010only or read-\u00ad\u2010write access access permission for all reachable pages. \n\n\nU/S\n: user or supervisor (kernel) mode access permission for all reachable pages.\n\n\nWT\n: Write-\u00ad\u2010through or write-\u00ad\u2010back cache policy for the child page table.\n\n\nA\n: \nReference bit\n (\u5f15\u7528\u4f4d\uff0cset by MMU on reads and writes, cleared by software).\n\n\nPS\n: Page size either 4 KB or 4 MB (de\ufb01ned for Level 1 PTEs only).\n\n\nPage table physical base address\n: 40 \nmost significant bits\n(\u6700\u9ad8\n\u6709\u6548\u4f4d\n) of physical page table address (forces page tables to be 4KB aligned) \n\n\nXD\n: Disable or enable instruction fetches from all pages reachable from this PTE.\n\n\n\n\nCore i7\u7b2c4\u7ea7\u9875\u8868\u6761\u76ee\u683c\u5f0f\uff1a\n\n\n\n\n\n\nPage physical base address\n: 40 \nmost significant bits\n of physical page address (forces pages to be 4KB aligned)\n\n\nD\n: \nDirty bit\n (\u810f\u4f4d, or modify bit\uff0cset by MMU on \nwrites\n, cleared by software)\n\n\n\n\n\u4e0b\u56fe\u7ed9\u51fa\u4e86Core i7 MMU\u5982\u4f55\u4f7f\u7528\u56db\u7ea7\u9875\u8868\u5c06\u865a\u62df\u5730\u5740\u7ffb\u8bd1\u6210\u7269\u7406\u5730\u5740\u300236\u4f4dVPN\u88ab\u5212\u5206\u4e3a\u56db\u4e2a9\u4f4d\u7684\u7247\uff0c\u6bcf\u4e2a\u7247\u88ab\u7528\u4f5c\u4e00\u4e2a\u9875\u8868\u7684\u504f\u79fb\u91cf\u3002VPN1\u63d0\u4f9b\u5230\u4e00\u4e2aL1 PET\u7684\u504f\u79fb\u91cf\uff0c\u8fd9\u4e2aPTE\u5305\u542bL2\u9875\u8868\u7684\u57fa\u5730\u5740\u3002VPN2\u63d0\u4f9b\u5230\u4e00\u4e2aL2 PET\u7684\u504f\u79fb\u91cf\uff0c\u4ee5\u6b64\u7c7b\u63a8\u3002\n\n\n\n\n5 Linux\u865a\u62df\u5185\u5b58\u7cfb\u7edf\n\n\nLinux\u4e3a\u6bcf\u4e2a\u8fdb\u7a0b\u7ef4\u62a4\u4e86\u4e00\u4e2a\u5355\u72ec\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\u3002Linux\u5c06\u865a\u62df\u5185\u5b58\u7ec4\u7ec7\u6210\u4e00\u4e9b\n\u533a\u57df\n\u7684\u96c6\u5408\u3002\u4e00\u4e2a\u533a\u57df\u5c31\u662f\u5df2\u5206\u914d\u7684\u865a\u62df\u5185\u5b58\u7684\u8fde\u7eed\u7247\u3002\n\n\nLinux\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7531\u5982\u4e0b\u51e0\u4e2a\u533a\u57df\u7ec4\u6210\uff1a\n\n\n\n\n\u4ee3\u7801\uff08\n.text\n\uff09: \u8fd9\u91cc\u5b58\u653e\u7684\u662fCPU\u8981\u6267\u884c\u7684\u6307\u4ee4\u3002\u4ee3\u7801\u6bb5\u662f\u53ef\u5171\u4eab\u7684\uff0c\u76f8\u540c\u7684\u4ee3\u7801\u5728\u5185\u5b58\u4e2d\u53ea\u4f1a\u6709\u4e00\u4e2a\u62f7\u8d1d\uff0c\u540c\u65f6\u8fd9\u4e2a\u6bb5\u662f\u53ea\u8bfb\u7684\uff0c\u9632\u6b62\u7a0b\u5e8f\u7531\u4e8e\u9519\u8bef\u800c\u4fee\u6539\u81ea\u8eab\u7684\u6307\u4ee4\u3002\n\n\n\u521d\u59cb\u5316\u6570\u636e\u6bb5\uff08\n.data\n\uff09: \u8fd9\u91cc\u5b58\u653e\u7684\u662f\u7a0b\u5e8f\u4e2d\u9700\u8981\u660e\u786e\u8d4b\u521d\u59cb\u503c\u7684\u53d8\u91cf\uff0c\u4f8b\u5982\u4f4d\u4e8e\u6240\u6709\u51fd\u6570\u4e4b\u5916\u7684\u5168\u5c40\u53d8\u91cf\uff1a\nint val=\n100\n\u3002\u9700\u8981\u5f3a\u8c03\u7684\u662f\uff0c\u4ee5\u4e0a\u4e24\u6bb5\u90fd\u662f\u4f4d\u4e8e\u7a0b\u5e8f\u7684\u53ef\u6267\u884c\u6587\u4ef6\u4e2d\uff0c\u5185\u6838\u5728\u8c03\u7528\nexec\n\u51fd\u6570\u542f\u52a8\u8be5\u7a0b\u5e8f\u65f6\u4ece\u6e90\u7a0b\u5e8f\u6587\u4ef6\u4e2d\u8bfb\u5165\u3002\n\n\n\u672a\u521d\u59cb\u5316\u6570\u636e\u6bb5\uff08\n.bss\n\uff09: \u4f4d\u4e8e\u8fd9\u4e00\u6bb5\u4e2d\u7684\u6570\u636e\uff0c\u5185\u6838\u5728\u6267\u884c\u8be5\u7a0b\u5e8f\u524d\uff0c\u5c06\u5176\u521d\u59cb\u5316\u4e3a0\u6216\u8005\nnull\n\u3002\u4f8b\u5982\u51fa\u73b0\u5728\u4efb\u4f55\u51fd\u6570\u4e4b\u5916\u7684\u5168\u5c40\u53d8\u91cf\uff1aint sum;\n\n\n\u5806\uff08\nHeap\n\uff09: \u8fd9\u4e2a\u6bb5\u7528\u4e8e\u5728\u7a0b\u5e8f\u4e2d\u8fdb\u884c\u52a8\u6001\u5185\u5b58\u7533\u8bf7\uff0c\u4f8b\u5982\u7ecf\u5e38\u7528\u5230\u7684\nmalloc\n\uff0c\nnew\n\u7cfb\u5217\u51fd\u6570\u5c31\u662f\u4ece\u8fd9\u4e2a\u6bb5\u4e2d\u7533\u8bf7\u5185\u5b58\u3002\n\n\n\u5171\u4eab\u5e93(\nShared Library\n): \u7528\u6765\u5b58\u653e\u50cfC\u6807\u51c6\u5e93\u548c\u6570\u5b66\u54ed\u8fd9\u6837\u7684\u5171\u4eab\u5e93\u7684\u4ee3\u7801\u548c\u6570\u636e\u7684\u533a\u57df\u3002\n\n\n\u6808\uff08\nStack\n\uff09: \u51fd\u6570\u4e2d\u7684\u5c40\u90e8\u53d8\u91cf\u4ee5\u53ca\u5728\u51fd\u6570\u8c03\u7528\u8fc7\u7a0b\u4e2d\u4ea7\u751f\u7684\u4e34\u65f6\u53d8\u91cf\u90fd\u4fdd\u5b58\u5728\u6b64\u6bb5\u4e2d\uff0c\u5177\u4f53\u89c1\u4e0b\u9762\u4e00\u8282\u3002\n\n\n\u5185\u6838\u865a\u62df\u5185\u5b58\uff1a\u5305\u542b\u5185\u6838\u4e2d\u7684\u4ee3\u7801\u548c\u6570\u636e\u7ed3\u6784\u3002\n\n\n\n\n\n\n\u4e0b\u9762\u662f\u7a0b\u5e8f\u793a\u610f\uff1a\n\n\n \n#include\nstdio.h\n    \n\n \n#include\n \nmalloc.h\n    \n\n\n \nvoid\n \nprint\n(\nchar\n \n*\n,\nint\n);\n    \n \nint\n \nmain\n()\n    \n\n{\n    \n     \nchar\n \n*\ns1\n \n=\n \nabcde\n;\n  \n//\nabcde\n\u4f5c\u4e3a\u5b57\u7b26\u4e32\u5e38\u91cf\u5b58\u50a8\u5728\u5e38\u91cf\u533a s1\u3001s2\u3001s5\u62e5\u6709\u76f8\u540c\u7684\u5730\u5740  \n\n     \nchar\n \n*\ns2\n \n=\n \nabcde\n;\n    \n     \nchar\n \ns3\n[]\n \n=\n \nabcd\n;\n    \n     \nlong\n \nint\n \n*\ns4\n[\n100\n];\n    \n     \nchar\n \n*\ns5\n \n=\n \nabcde\n;\n    \n     \nint\n \na\n \n=\n \n5\n;\n    \n     \nint\n \nb\n \n=\n6\n;\n//a,b\u5728\u6808\u4e0a\uff0c\na\nb\u5730\u5740\u53cd\u5411\u589e\u957f    \n\n\n     \nprintf\n(\nvariables address in main function: \n\n     \ns1\n=%\np\n  \ns2\n=%\np\n \ns3\n=%\np\n \ns4\n=%\np\n \ns5\n=%\np\n \na\n=%\np\n \nb\n=%\np\n \n\\\nn\n, s1,s2,s3,s4,s5,\na,\nb);   \n\n     \nprintf\n(\nvariables address in processcall:n\n);\n    \n     \nprint\n(\nddddddddd\n,\n5\n);\n//\u53c2\u6570\u5165\u6808\u4ece\u53f3\u81f3\u5de6\u8fdb\u884c,p\u5148\u8fdb\u6808,str\u540e\u8fdb \np\nstr    \n\n     \nprintf\n(\nmain=%p print=%p \n\\n\n,\nmain\n,\nprint\n);\n    \n     \n//\u6253\u5370\u4ee3\u7801\u6bb5\u4e2d\u4e3b\u51fd\u6570\u548c\u5b50\u51fd\u6570\u7684\u5730\u5740\uff0c\u7f16\u8bd1\u65f6\u5148\u7f16\u8bd1\u7684\u5730\u5740\u4f4e\uff0c\u540e\u7f16\u8bd1\u7684\u5730\u5740\u9ad8main\nprint    \n\n \n}\n    \n\n \nvoid\n \nprint\n(\nchar\n \n*\nstr\n,\nint\n \np\n)\n    \n\n{\n    \n     \nchar\n \n*\ns1\n \n=\n \nabcde\n;\n  \n//abcde\u5728\u5e38\u91cf\u533a\uff0cs1\u5728\u6808\u4e0a    \n\n     \nchar\n \n*\ns2\n \n=\n \nabcde\n;\n  \n//abcde\u5728\u5e38\u91cf\u533a\uff0cs2\u5728\u6808\u4e0a s2-s1=6\u53ef\u80fd\u7b49\u4e8e0\uff0c\u7f16\u8bd1\u5668\u4f18\u5316\u4e86\u76f8\u540c\u7684\u5e38\u91cf\uff0c\u53ea\u5728\u5185\u5b58\u4fdd\u5b58\u4e00\u4efd    \n\n     \n//\u800c\ns1\ns2    \n\n     \nchar\n \ns3\n[]\n \n=\n \nabcdeee\n;\n//abcdeee\u5728\u5e38\u91cf\u533a\uff0cs3\u5728\u6808\u4e0a\uff0c\u6570\u7ec4\u4fdd\u5b58\u7684\u5185\u5bb9\u4e3aabcdeee\u7684\u4e00\u4efd\u62f7\u8d1d    \n\n     \nlong\n \nint\n \n*\ns4\n[\n100\n];\n    \n     \nchar\n \n*\ns5\n \n=\n \nabcde\n;\n    \n     \nint\n \na\n \n=\n \n5\n;\n    \n     \nint\n \nb\n \n=\n6\n;\n    \n     \nint\n \nc\n;\n    \n     \nint\n \nd\n;\n           \n//a,b,c,d\u5747\u5728\u6808\u4e0a\uff0c\na\nb\nc\nd\u5730\u5740\u53cd\u5411\u589e\u957f    \n\n     \nchar\n \n*\nq\n=\nstr\n;\n   \n     \nint\n \nm\n=\np\n;\n           \n     \nchar\n \n*\nr\n=\n(\nchar\n \n*\n)\nmalloc\n(\n1\n);\n    \n     \nchar\n \n*\nw\n=\n(\nchar\n \n*\n)\nmalloc\n(\n1\n)\n \n;\n  \n// r\nw \u5806\u6b63\u5411\u589e\u957f    \n\n\n     \nprintf\n(\ns1=%p s2=%p s3=%p s4=%p s5=%p a=%p b=%p c=%p d=%p str=%p q=%p p=%p m=%p r=%p w=%p \n\\n\n,\n \ns1\n,\ns2\n,\ns3\n,\ns4\n,\ns5\n,\na\n,\nb\n,\nc\n,\nd\n,\nstr\n,\nq\n,\np\n,\nm\n,\nr\n,\nw\n);\n   \n     \n/* \u6808\u548c\u5806\u662f\u5728\u7a0b\u5e8f\u8fd0\u884c\u65f6\u5019\u52a8\u6001\u5206\u914d\u7684\uff0c\u5c40\u90e8\u53d8\u91cf\u5747\u5728\u6808\u4e0a\u5206\u914d\u3002 \n\n\n        \u6808\u662f\u53cd\u5411\u589e\u957f\u7684\uff0c\u5730\u5740\u9012\u51cf\uff1bmalloc\u7b49\u5206\u914d\u7684\u5185\u5b58\u7a7a\u95f4\u5728\u5806\u7a7a\u95f4\u3002\u5806\u662f\u6b63\u5411\u589e\u957f\u7684\uff0c\u5730\u5740\u9012\u589e\u3002   \n\n\n        r,w\u53d8\u91cf\u5728\u6808\u4e0a(\u5219\nr\nw)\uff0cr,w\u6240\u6307\u5185\u5bb9\u5728\u5806\u4e2d(\u5373r\nw)\u3002*/\n   \n \n}\n    \n\n\n\n\nLinux\u662f\u5982\u4f55\u7ec4\u7ec7\u865a\u62df\u5185\u5b58\u7684\n\n\n\u90a3\u4e48Linux\u5177\u4f53\u662f\u600e\u4e48\u7ec4\u7ec7\u865a\u62df\u5185\u5b58\u7684\u5462\uff1fLinux\u5185\u6838\u4e3a\u7cfb\u7edf\u4e2d\u7684\u6bcf\u4e2a\u8fdb\u7a0b\u7ef4\u62a4\u4e00\u4e2a\u5355\u72ec\u7684\u4efb\u52a1\u7ed3\u6784\u4f53(\ntask_struct\n, \u5728\nsched.h\n\u5934\u6587\u4ef6\u4e2d)\u3002\ntask_struct\n\u4e2d\u7684\u5143\u7d20\u5305\u542b\u8fd0\u884c\u8be5\u8fdb\u7a0b\u6240\u9700\u8981\u7684\u6240\u6709\u4fe1\u606f(PID\u3001\u6307\u5411\u7528\u6237\u6808\u7684\u6307\u9488\u3001\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\u7684\u540d\u5b57\u3001\u4ee5\u53ca\u7a0b\u5e8f\u8ba1\u6570\u5668)\u3002\n\n\n\n\ntask_struct\n\u4e2d\u7684\u4e00\u4e2a\u5143\u7d20\u6307\u5411\nmm_struct\n\uff0c\u5b83\u63cf\u8ff0\u4e86\u865a\u62df\u5185\u5b58\u7684\u5f53\u524d\u72b6\u6001\u3002\npgd\n\u6307\u5411\u7b2c\u4e00\u7ea7\u9875\u8868\u7684\u57fa\u5740\uff0c\u800c\nmmap\n\u6307\u5411\u4e00\u4e2a\nvm_area_struct\n(\u533a\u57df\u7ed3\u6784, \u5b9a\u4e49\u5728\nmm_types.h\n)\u7684\u94fe\u8868\u3002\u6bcf\u4e2a\u533a\u57df\u7ed3\u6784\u94fe\u8868\u90fd\u63cf\u8ff0\u4e86\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7684\u4e00\u4e2a\u533a\u57df\uff0c\u5305\u542b\u4ee5\u4e0b\u5b57\u6bb5\uff1a\n\n\n\n\nvm_start\n: \u6307\u5411\u533a\u57df\u7684\u8d77\u59cb\u5904\n\n\nvm_end\n: \u6307\u5411\u533a\u57df\u7684\u7ed3\u675f\u5904\n\n\nvm_prot\n: \u63cf\u8ff0\u7740\u533a\u57df\u5185\u5305\u542b\u7684\u6240\u6709\u9875\u7684\u8bfb\u5199\u8bb8\u53ef\u6743\u9650\n\n\nvm_flags\n: \u63cf\u8ff0\u8fdb\u7a0b\u5171\u4eab/\u79c1\u6709\n\n\nvm_next\n: \u4e0b\u4e00\u4e2a\u533a\u57df\u7ed3\u6784\n\n\n\n\nLinux \u7f3a\u9875\u5f02\u5e38\u5904\u7406\n\n\n\u5185\u5b58\u7ba1\u7406\u5355\u5143MMU\u5728\u8bd5\u56fe\u7ffb\u8bd1\u67d0\u4e2a\u865a\u62df\u5730\u5740A\u65f6\uff0c\u89e6\u53d1\u4e86\u4e00\u4e2a\u7f3a\u9875\u5f02\u5e38\uff0c\u5f15\u8d77\u7f3a\u9875\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\uff1a\n\n\n\n\n\u865a\u62df\u5730\u5740A\u662f\u5408\u6cd5\u7684\u5417\uff1f-\n \u6bb5\u9519\u8bef(segment fault)\n\n\n\u8bd5\u56fe\u8fdb\u884c\u7684\u5185\u5b58\u8bbf\u95ee\u662f\u5408\u6cd5\u7684\u5417\uff1f -\n \u4fdd\u62a4\u5f02\u5e38(\u4e5f\u5f15\u53d1\u6bb5\u9519\u8bef)\n\n\n\n\n\n\n6 \u5185\u5b58\u6620\u5c04\n\n\nLinux \u901a\u8fc7\u5c06\u4e00\u4e2a\u865a\u62df\u5185\u533a\u57df\u4e0e\u4e00\u4e2a\u78c1\u76d8\u4e0a\u7684\n\u5bf9\u8c61\n(object)\u5173\u8054\u8d77\u6765\uff0c\u4ee5\u521d\u59cb\u5316\u8fd9\u4e2a\u865a\u62df\u5185\u5b58\u533a\u57df\u7684\u5185\u5bb9\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u79f0\u4e3a\n\u5185\u5b58\u6620\u5c04\n(memory mapping).\n\n\n\u4e00\u65e6\u4e00\u4e2a\u865a\u62df\u9875\u9762\u88ab\u521d\u59cb\u5316\u4e86\uff0c\u5b83\u5c31\u5728\u4e00\u4e2a\u7531\u5185\u6838\u7ef4\u62a4\u7684\u4e13\u95e8\u7684\n\u4ea4\u6362\u6587\u4ef6\n(swap file)\u4e4b\u95f4\u6362\u6765\u6362\u53bb\u3002\u4ea4\u6362\u6587\u4ef6\u4e5f\u53eb\u505a\n\u4ea4\u6362\u7a7a\u95f4\n(swap space)\u6216\u4ea4\u6362\u533a\u57df(swap area)\u3002\n\n\n\u518d\u770b\u5171\u4eab\u5bf9\u8c61\n\n\n\u4e00\u4e2a\u5bf9\u8c61\u53ef\u4ee5\u88ab\u6620\u5c04\u5230\u865a\u62df\u5185\u5b58\u7684\u4e00\u4e2a\u533a\u57df\uff0c\u8981\u4e48\u4f5c\u4e3a\n\u5171\u4eab\u5bf9\u8c61\n\uff0c\u8981\u4e48\u4f5c\u4e3a\n\u79c1\u6709\u5bf9\u8c61\n\u3002\n\n\n\n\n\u5982\u679c\u4e00\u4e2a\u8fdb\u7a0b\u5c06\u4e00\u4e2a\u5171\u4eab\u5bf9\u8c61\u6620\u5c04\u5230\u5b83\u7684\u865a\u62df\u7a7a\u95f4\u7684\u4e00\u4e2a\u533a\u57df\u5185\uff0c\u90a3\u4e48\u8fd9\u4e2a\u8fdb\u7a0b\u5bf9\u8fd9\u4e2a\u533a\u57df\u7684\u4efb\u4f55\u5199\u64cd\u4f5c\uff0c\u5bf9\u4e8e\u90a3\u4e9b\u4e5f\u628a\u8fd9\u4e2a\u5171\u4eab\u5bf9\u8c61\u6620\u5c04\u5230\u5b83\u4eec\u865a\u62df\u5185\u5b58\u7684\u5176\u4ed6\u8fdb\u7a0b\u800c\u8a00\uff0c\u4e5f\u662f\u53ef\u89c1\u7684\u3002\u800c\u4e14\uff0c\u8fd9\u4e9b\u53d8\u5316\u4e5f\u4f1a\u53cd\u6620\u5728\u78c1\u76d8\u4e0a\u7684\u539f\u59cb\u5bf9\u8c61\u4e2d\u3002\n\n\n\u5bf9\u4e8e\u4e00\u4e2a\u6620\u5c04\u5230\u79c1\u6709\u5bf9\u8c61\u7684\u533a\u57df\u505a\u7684\u6539\u53d8\uff0c\u5bf9\u4e8e\u5176\u4ed6\u8fdb\u7a0b\u6765\u8bf4\u662f\u4e0d\u53ef\u517c\u5f97\u3002\n\n\n\u5373\u4f7f\u5bf9\u8c61\u88ab\u6620\u5c04\u5230\u4e86\u591a\u4e2a\u5171\u4eab\u533a\u57df\uff0c\u7269\u7406\u5185\u5b58\u4e2d\u4e5f\u53ea\u9700\u8981\u5b58\u653e\u5171\u4eab\u5bf9\u8c61\u7684\u4e00\u4e2a\u526f\u672c\u3002\n\n\n\n\n\u79c1\u6709\u5bf9\u8c61\u4f7f\u7528\n\u5199\u65f6\u590d\u5236\n(copy-on-write)\u7684\u5de7\u5999\u6280\u672f\u88ab\u6620\u5c04\u5230\u865a\u62df\u5185\u5b58\u4e2d\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u6620\u5c04\u79c1\u6709\u5bf9\u8c61\u7684\u8fdb\u7a0b\uff0c\u76f8\u5e94\u79c1\u6709\u533a\u57df\u7684\u9875\u8868\u6761\u76ee\u90fd\u88ab\u6807\u8bb0\u4e3a\u53ea\u8bfb\uff0c\u5e76\u4e14\u533a\u57df\u7ed3\u6784\u88ab\u6807\u8bb0\u4e3a\n\u79c1\u6709\u7684\u5199\u65f6\u590d\u5236\n\u3002\n\n\n\n\n\u53ea\u8981\u6ca1\u6709\u8fdb\u7a0b\u65f6\u56fe\u5199\u5b83\u7684\u79c1\u6709\u533a\u57df\uff0c\u5b83\u4eec\u5c31\u53ef\u4ee5\u7ee7\u7eed\u5171\u4eab\u7269\u7406\u5185\u5b58\u4e2d\u5bf9\u8c61\u7684\u4e00\u4e2a\u5355\u72ec\u526f\u672c\u3002\n\n\n\u53ea\u8981\u6709\u4e00\u4e2a\u8fdb\u7a0b\u8bd5\u56fe\u5199\u79c1\u6709\u533a\u57df\u7684\u67d0\u4e2a\u9875\u9762\uff0c\u6545\u969c\u5904\u7406\u7a0b\u5e8f\u5c31\u4f1a\u5728\u7269\u7406\u5185\u5b58\u4e2d\u521b\u5efa\u8fd9\u4e2a\u9875\u9762\u7684\u4e00\u4e2a\u65b0\u526f\u672c\uff0c\u66f4\u65b0\u9875\u8868\u6761\u76ee\u6307\u5411\u8fd9\u4e2a\u65b0\u7684\u526f\u672c\uff0c\u7136\u540e\u6062\u590d\u8fd9\u4e2a\u9875\u9762\u7684\u53ef\u5199\u6743\u9650\u3002\n\n\n\n\n\n\n\n\n\n\n\u518d\u770bfork\u51fd\u6570\n\n\n\u5f53fork\u51fd\u6570\u88ab\u5f53\u524d\u8fdb\u7a0b\u8c03\u7528\u65f6\uff0c\u5185\u6838\u4e3a\u65b0\u8fdb\u7a0b\u521b\u5efa\u5404\u79cd\u6570\u636e\u7ed3\u6784\uff0c\u5e76\u5206\u914d\u7ed9\u5b83\u4e00\u4e2a\u552f\u4e00\u7684PID\u3002\n\n\n\n\n\u4e3a\u4e86\u7ed9\u8fd9\u4e2a\u65b0\u8fdb\u7a0b\u521b\u5efa\u865a\u62df\u5185\u5b58\uff0c\u5b83\u521b\u5efa\u4e86\u5f53\u524d\u8fdb\u7a0b\u7684\nmm_struct\n\u3001\u533a\u57df\u7ed3\u6784\nvm_area_struct\n\u548c\u9875\u8868\u7684\u539f\u6837\u526f\u672c\u3002\n\n\n\u5185\u6838\u5c06\u4e24\u4e2a\u8fdb\u7a0b\u4e2d\u7684\u6bcf\u4e2a\u9875\u9762\u90fd\u6807\u8bb0\u4e3a\u53ea\u8bfb\uff0c\u5e76\u5c06\u4e24\u4e2a\u8fdb\u7a0b\u4e2d\u7684\u6bcf\u4e2a\u533a\u57df\u7ed3\u6784\u90fd\u6807\u8bb0\u4e3a\u79c1\u6709\u7684\u5199\u65f6\u590d\u5236\u3002\n\n\n\u5f53\u8fd9\u4e24\u4e2a\u8fdb\u7a0b\u4e2d\u7684\u4efb\u4f55\u4e00\u4e2a\u8fdb\u884c\u5199\u64cd\u4f5c\u65f6\uff0c\u5199\u65f6\u590d\u5236\u673a\u5236\u5c31\u4f1a\u521b\u5efa\u65b0\u9875\u9762\u3002\n\n\n\n\n\u518d\u770bexecve\u51fd\u6570\n\n\nexecve\u51fd\u6570\u5728\u5f53\u524d\u8fdb\u7a0b\u4e2d\u52a0\u8f7d\u5e76\u8fd0\u884c\u65b0\u7a0b\u5e8f\uff1a\n\n\n\n\n\u5220\u9664\u5df2\u5b58\u5728\u7684\u7528\u6237\u533a\u57df\u3002\n\n\n\u6620\u5c04\u79c1\u6709\u533a\u57df\u3002\n\n\n\u6620\u5c04\u5171\u4eab\u533a\u57df\u3002\n\n\n\u8bbe\u7f6e\u7a0b\u5e8f\u8ba1\u6570\u5668\u3002\n\n\n\n\n\u7528\u6237\u7ea7\u5185\u5b58\u6620\u5c04\n\n\nLinux\u8fdb\u7a0b\u53ef\u4ee5\u4f7f\u7528mmap\u51fd\u6570\u6765\u521b\u5efa\u65b0\u7684\u865a\u62df\u5185\u5b58\u533a\u57df\uff0c\u5e76\u5c06\u5bf9\u8c61\u6620\u5c04\u5230\u8fd9\u4e9b\u533a\u57df\u4e2d\u3002\n\n\nvoid\n \n*\nmmap\n(\nvoid\n \n*\nstart\n,\n \nint\n \nlen\n,\n \nint\n \nprot\n,\n \nint\n \nflags\n,\n \nint\n \nfd\n,\n \nint\n \noffset\n)\n\n\n\n\n\nmmap\u51fd\u6570\u8981\u6c42\u5185\u6838\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u865a\u62df\u5185\u5b58\u533a\u57df\uff0c\u6700\u597d\u662f\u4ece\u5730\u5740start\u5f00\u59cb\u7684\u4e00\u4e2a\u533a\u57df\uff0c\u5e76\u5c06\u6587\u4ef6\u63cf\u8ff0\u7b26fd\u5236\u5b9a\u7684\u5bf9\u8c61\u7684\u4e00\u4e2a\u8fde\u7eed\u7684\u7247(chunk)\u6620\u5c04\u5230\u8fd9\u4e2a\u65b0\u7684\u533a\u57df\u3002\u8fde\u7eed\u7684\u5bf9\u8c61\u7247\u5927\u5c0f\u4e3alen\u5b57\u8282\uff0c\u4ece\u8ddd\u6587\u4ef6\u5f00\u59cb\u5904\u504f\u79fb\u91cf\u4e3aoffset\u5b57\u8282\u7684\u5730\u65b9\u5f00\u59cb\u3002\u5176\u53c2\u6570\uff1a\n\n\n\n\nstart\n: may be 0 for \u201cpick an address\u201d\n\n\nprot\n: PROT_READ, PROT_WRITE, ...\n\n\nflags\n: MAP_ANON, MAP_PRIVATE, MAP_SHARED, ...\n\n\nReturn a pointer to start of mapped area \n\n\n\n\n\n\n7 \u52a8\u6001\u5185\u5b58\u5206\u914d\n\n\n\u7a0b\u5e8f\u4f7f\u7528\u52a8\u6001\u5185\u5b58\u5206\u914d\u7684\u6700\u91cd\u8981\u7684\u539f\u56e0\u662f\u7ecf\u5e38\u76f4\u5230\u7a0b\u5e8f\u5b9e\u9645\u8fd0\u884c\u65f6\uff0c\u624d\u77e5\u9053\u67d0\u4e9b\u6570\u636e\u7ed3\u6784\u7684\u5927\u5c0f\u3002\u4e00\u822c\u4f7f\u7528\u52a8\u6001\u5185\u5b58\u5206\u914d\u5668(dynamic memeory allocator)\u6765\u5206\u914d\u52a8\u6001\u5185\u5b58\u3002\n\n\n\u5206\u914d\u5668\u6839\u636e\u54ea\u4e2a\u5b9e\u4f53\u6765\u8d1f\u8d23\u91ca\u653e\u5df2\u5206\u914d\u7684\u5757\uff0c\u5206\u4e3a\u4e24\u79cd\uff1a\n\n\n\n\n\u663e\u793a\u5206\u914d\u5668\n(explicit allocator)\uff1a\u8981\u6c42\u7a0b\u5e8f\u663e\u793a\u5730\u91ca\u653e\u4efb\u4f55\u5df2\u5206\u914d\u7684\u5757\u3002\u4f8b\u5982C\u4e2d\u7684malloc/free\uff0cC++\u4e2d\u7684new/delete\u3002\n\n\n\u9690\u5f0f\u5206\u914d\u5668\n(implicit allocator): \u9664\u6b64\u4e4b\u5916\uff0c\u81ea\u52a8\u91ca\u653e\u672a\u4f7f\u7528\u7684\u5df2\u5206\u914d\u5757(\u5783\u573e\u6536\u96c6\uff0cgarbage collection)\u3002\n\n\n\n\n7.2 \u663e\u5f0f\u5206\u914d\u5668\u7684\u8981\u6c42\u548c\u76ee\u6807\n\n\n7.2.1 \u5206\u914d\u5668\u7684\u8981\u6c42\n\n\n\u5206\u914d\u5668\u6709\u5982\u4e0b\u7684\u8981\u6c42\uff1a\n\n\n\n\n\u5904\u7406\u4efb\u610f\u8bf7\u6c42\u5e8f\u5217\n\n\n\u7acb\u5373\u76f8\u5e94\u8bf7\u6c42\n\n\n\u53ea\u4f7f\u7528\u5806\n\n\n\u5bf9\u9f50\u5757(\u5bf9\u9f50\u8981\u6c42)\n\n\n\u4e0d\u4fee\u6539\u5df2\u5206\u914d\u7684\u5757\n\n\n\n\n7.2.2 \u5206\u914d\u5668\u7684\u76ee\u6807\n\n\n\u5206\u914d\u5668\u8bd5\u56fe\u6700\u5927\u5316\u541e\u5410\u7387\u548c\u5185\u5b58\u5229\u7528\u7387\n\n\n\n\n\u6700\u5927\u5316\u541e\u5410\u7387(\u541e\u5410\u7387\uff1a\u6bcf\u4e2a\u5355\u4f4d\u65f6\u95f4\u91cc\u5b8c\u6210\u7684\u8bf7\u6c42\u6570)\n\n\n\u6700\u5927\u5316\u5185\u5b58\u5229\u7528\u7387\n\n\n\n\n\u6700\u5927\u5316\u541e\u5410\u7387\u548c\u6700\u5927\u5316\u5229\u7528\u7387\u4e4b\u95f4\u662f\u76f8\u4e92 \n\u7275\u5236\n \u7684\uff0c\u5206\u914d\u5668\u8bbe\u8ba1\u7684\u76ee\u6807\u662f\u5728\u8fd9\u4e24\u8005\u4e4b\u95f4\u627e\u5230\u4e00\u4e2a\u9002\u5f53\u7684\u5e73\u8861\u3002\n\n\n\u9020\u6210\u5229\u7528\u7387\u5f88\u4f4e\u7684\u4e3b\u8981\u539f\u56e0\u662f\n\u788e\u7247\n(fragmentation)\u73b0\u8c61\u3002\u5f53\u6709\u6548\u8f7d\u8377\u6bd4\u5757\u8981\u5c0f\u65f6\uff0c\u53d1\u751f\n\u5185\u90e8\u788e\u7247\n(Internal fragmentation)\uff0c\u5f15\u8d77\u7684\u539f\u56e0\u6709\uff1a\u5bf9\u9f50\u7b49\u3002\n\n\n\n\n\u5f53\u5373\u4f7f\u6709\u8db3\u591f\u7684\u7d2f\u79ef\u7684\u5757\u5185\u5b58\uff0c\u4f46\u662f\u6ca1\u6709\u5355\u4e00\u5757\u80fd\u591f\u6ee1\u8db3\u9700\u6c42\u65f6\uff0c\u53d1\u751f\n\u5916\u90e8\u788e\u7247\n(external fragmentation)\uff1a\n\n\n\n\n\u5916\u90e8\u788e\u7247\u8fd8\u53d6\u51b3\u4e8e\u5c06\u6765\u7684\u8bf7\u6c42\uff0c\u4f8b\u5982\u4e0a\u56fe\uff0c\u5982\u679c\u6700\u540e\u7684p4\u8bf7\u6c424\u4e2a\u5b57\u8282\u5462\uff1f\u4e5f\u5c31\u4e0d\u4f1a\u53d1\u751f\u788e\u7247\u3002\u6b63\u56e0\u4e3a\u5916\u90e8\u788e\u7247\u96be\u4ee5\u91cf\u5316\u4e14\u4e0d\u53ef\u80fd\u9884\u6d4b\uff0c\u6240\u4ee5\u5206\u914d\u5668\u901a\u5e38\u91c7\u7528\u542f\u53d1\u5f0f\u7b56\u7565\u6765\u8bd5\u56fe\u7ef4\u6301\u5c11\u91cf\u7684\u5927\u7a7a\u95f2\u5757\uff0c\u800c\u4e0d\u662f\u7ef4\u6301\u5927\u91cf\u7684\u5c0f\u7a7a\u95f2\u5757\u3002\n\n\n7.2.3 \u653e\u7f6e\u5df2\u5206\u914d\u7684\u5757\n\n\n\u5f53\u4e00\u4e2a\u5e94\u7528\u8bf7\u6c42\u4e00\u4e2a\nk\nk\n\u5b57\u8282\u7684\u5757\u65f6\uff0c\u5206\u914d\u5668\u641c\u7d22\u7a7a\u95f2\u94fe\u8868\uff0c\u67e5\u627e\u4e00\u4e2a\u8db3\u591f\u5927\u53ef\u4ee5\u653e\u7f6e\u6240\u8bf7\u6c42\u5757\u7684\u7a7a\u95f2\u5757\u3002\u5206\u914d\u5668\u7684\n\u653e\u7f6e\u7b56\u7565\n(placement policy)\u6709\n\u9996\u6b21\u9002\u914d\n(first fit)\u3001\n\u4e0b\u4e00\u6b21\u9002\u914d\n(next fit)\u548c\n\u6700\u4f73\u9002\u914d\n(best fit)\u3002\n\n\n\n\n\u9996\u6b21\u9002\u914d\n\u4ece\u5934\u5f00\u59cb\u641c\u7d22\u7a7a\u95f2\u94fe\u8868\uff0c\u9009\u62e9\u7b2c\u4e00\u4e2a\u9002\u5408\u7684\u7a7a\u95f2\u5757\u3002\n\n\n\u4e0b\u4e00\u6b21\u9002\u914d\n\u4ece\u4e0a\u4e00\u6b21\u67e5\u8be2\u7ed3\u675f\u7684\u5730\u65b9\u5f00\u59cb\u3002\n\n\n\u6700\u4f73\u9002\u914d\n\u68c0\u67e5\u6bcf\u4e2a\u7a7a\u95f2\u5757\uff0c\u9009\u62e9\u9002\u5408\u6240\u9700\u8bf7\u6c42\u5927\u5c0f\u7684\u6700\u5c0f\u7a7a\u95f2\u5757\u3002\n\n\n\n\n7.3 \u5b9e\u73b0\u65b9\u6cd5\n\n\n\n\n\u9690\u5f0f\u7a7a\u95f2\u5217\u8868 Implicit Free List\n\n\n\u663e\u5f0f\u7a7a\u95f2\u5217\u8868 Explicit Free List\n\n\n\u5206\u79bb\u5f0f\u7a7a\u95f2\u5217\u8868 Segregated Free List\n\n\n\n\n7.3.1 \u9690\u5f0f\u7a7a\u95f2\u5217\u8868\n\n\n\n\n\u9690\u5f0f\u7a7a\u95f2\u94fe\u8868\u4f18\u70b9\u662f\u7b80\u5355\uff0c\u7f3a\u70b9\u662f\u64cd\u4f5c\u5f00\u9500\u5927\u3002\u56e0\u4e3a\u65e0\u8bba\u662f\u5206\u914d\u8fd8\u662f\u91ca\u653e\u5757\uff0c\u90fd\u9700\u8981\u5bf9\u9690\u5f0f\u7a7a\u95f2\u5217\u8868\u8fdb\u884c\u641c\u7d22\uff0c\u590d\u6742\u5ea6\u662f\nO(n)\nO(n)\n\uff0c\nn\nn\n\u662f\u5df2\u5206\u914d\u5757\u548c\u7a7a\u95f2\u5757\u7684\u603b\u6570\u3002\n\n\n7.3.2 \u663e\u5f0f\u7a7a\u95f2\u5217\u8868\n\n\n\n\n7.3.3 \u5206\u79bb\u5f0f\u7a7a\u95f2\u5217\u8868\n\n\n8 \u5783\u573e\u6536\u96c6\n\n\n\u5783\u573e\u6536\u96c6\u5668\n(garbage collector)\u662f\u4e00\u79cd\u52a8\u6001\u5185\u5b58\u5206\u914d\u5668\uff0c\u5b83\u81ea\u52a8\u91ca\u653e\u7a0b\u5e8f\u4e0d\u518d\u9700\u8981\u7684\u5df2\u5206\u914d\u5757\u3002\u8fd9\u4e9b\u5757\u88ab\u79f0\u4f5c\n\u5783\u573e\n(garbage)\u3002\u81ea\u52a8\u56de\u6536\u5b58\u50a8\u7684\u8fc7\u7a0b\u53eb\u505a\n\u5783\u573e\u6536\u96c6\n(garbage collection)\u3002\n\n\nJava Garbage Collection\n\n\n\u5783\u573e\u6536\u96c6\u5668\u5c06\u5185\u5b58\u89c6\u4e3a\u4e00\u5f20\u6709\u5411\n\u53ef\u8fbe\u56fe\n(reachability graph)\u3002\n\n\n\n\n\u56fe\u7684\u8282\u70b9\u88ab\u5206\u6210\u4e00\u7ec4\n\u6839\u8282\u70b9\n(root node)\u548c\u4e00\u7ec4\n\u5806\u8282\u70b9\n(heap node). \n\n\n\u6709\u5411\u8fb9\np\\rightarrow q\np\\rightarrow q\n\u610f\u5473\u7740\u5757\np\np\n\u4e2d\u7684\u67d0\u4e2a\u4f4d\u7f6e\u6307\u5411\u5757\nq\nq\n\u4e2d\u7684\u67d0\u4e2a\u4f4d\u7f6e\u3002\n\n\n\u6839\u8282\u70b9\u4e0d\u5728\u5806\u4e2d\uff0c\u5305\u542b\u6307\u5411\u5806\u4e2d\u7684\u6307\u9488\u3002\n\n\n\u5f53\u5b58\u5728\u4e00\u6761\u4ece\u4efb\u610f\u6839\u8282\u70b9\u51fa\u53d1\u5e76\u5230\u8fbe\np\np\n\u7684\u6709\u5411\u8def\u5f84\u65f6\uff0c\u8282\u70b9\np\np\n\u662f\n\u53ef\u8fbe\n\u7684\u3002\n\n\n\u5783\u573e\u6536\u96c6\u5668\u7ef4\u62a4\u53ef\u8fbe\u56fe\u7684\u67d0\u79cd\u8868\u793a\uff0c\u5e76\u91ca\u653e\u4e0d\u53ef\u8fbe\u8282\u70b9\u3002\n\n\n\n\n\n\n9 C\u7a0b\u5e8f\u4e2d\u5e38\u89c1\u7684\u4e0e\u5185\u5b58\u6709\u5173\u7684\u9519\u8bef\n\n\n\u95f4\u63a5\u5f15\u7528\u574f\u6307\u9488\n\n\n\u8fd9\u662f\u975e\u5e38\u5e38\u89c1\u7684\u4f8b\u5b50\uff0c\u6ca1\u6709\u5f15\u7528\u5bf9\u5e94\u7684\u5730\u5740\uff0c\u5c11\u4e86 \n\n\nint\n \nval\n;\n\n\nscanf\n(\n%d\n,\n \nval\n);\n \n// \u6b63\u786e\u5e94\u8be5\u662fscanf(\n%d, \nval);\n\n\n\n\n\n\u8bfb\u672a\u521d\u59cb\u5316\u7684\u5185\u5b58\n\n\n\u5806\u5185\u5b58\u662f\u6ca1\u6709\u88ab\u521d\u59cb\u5316\u4e3a0\u7684\n\uff1a\n\n\n/* return y = Ax */\n\n\nint\n \n*\nmatvec\n(\nint\n \n**\nA\n,\n \nint\n \n*\nx\n)\n \n{\n\n    \nint\n \n*\ny\n \n=\n \nmalloc\n(\nN\n \n*\n \nsizeof\n(\nint\n));\n\n    \nint\n \ni\n,\n \nj\n;\n\n\n    \nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n \nN\n;\n \ni\n++\n)\n\n        \nfor\n \n(\nj\n \n=\n \n0\n;\n \nj\n \n \nN\n;\n \nj\n++\n)\n\n            \ny\n[\ni\n]\n \n+=\n \nA\n[\ni\n][\nj\n]\n \n*\n \nx\n[\nj\n];\n\n    \nreturn\n \ny\n;\n\n\n}\n\n\n\n\n\n\u6b63\u786e\u7684\u65b9\u6cd5\u662f\u663e\u5f0f\u5730\u5c06y[i]\u8bbe\u7f6e\u4e3a0\uff0c\u6216\u8005\u4f7f\u7528\ncalloc\n\u3002\n\n\n\u5141\u8bb8\u6808\u7f13\u51b2\u533a\u6ea2\u51fa\n\n\n\u6ca1\u6709\u68c0\u67e5\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\uff08\u7ecf\u5178\u7684\u7f13\u51b2\u533a\u6ea2\u51fa\u653b\u51fb\u4e5f\u662f\u5229\u7528\u76f8\u540c\u7684\u673a\u5236\uff09\n\n\nchar\n \ns\n[\n8\n];\n\n\nint\n \ni\n;\n\n\ngets\n(\ns\n);\n \n/* stack buffer overflow, reads \n123456789\n from stdin */\n\n\n\n\n\n\u5f15\u7528\u4e0d\u5b58\u5728\u7684\u53d8\u91cf\n\n\n\u5c3d\u7ba1\u6307\u9488\u4ecd\u7136\u6307\u5411\u4e00\u4e2a\u5408\u6cd5\u7684\u5185\u5b58\u5730\u5740\uff0c\u4f46\u662f\u5df2\u7ecf\u4e0d\u518d\u6307\u5411\u4e00\u4e2a\u5408\u6cd5\u7684\u53d8\u91cf\u4e86\u3002\u4ee5\u540e\u5728\u7a0b\u5e8f\u4e2d\u8c03\u7528\u5176\u4ed6\u51fd\u6570\u65f6\uff0c\u5185\u5b58\u5c06\u91cd\u7528\u5b83\u4eec\u7684\u6808\u9488\u3002\n\n\nint\n \n*\nfoo\n()\n \n{\n\n    \nint\n \nval\n;\n\n\n    \nreturn\n \nval\n;\n\n\n}\n\n\n\n\n\n\u591a\u6b21\u91ca\u653e\n\n\n\u8fd9\u4e2a\u4e0d\u7528\u591a\u8bf4\uff0c\u4e0d\u80fd\u91cd\u590d\u641e\u4e24\u6b21\n\n\nx\n \n=\n \nmalloc\n(\nN\n \n*\n \nsizeof\n(\nint\n));\n\n\n//  \nmanipulate x\n\n\nfree\n(\nx\n);\n\n\ny\n \n=\n \nmalloc\n(\nM\n \n*\n \nsizeof\n(\nint\n));\n\n\n//  \nmanipulate y\n\n\nfree\n(\nx\n);\n\n\n\n\n\n\u5f15\u7528\u5df2\u7ecf\u88ab\u91ca\u653e\u7684\u5806\u5757\u4e2d\u7684\u6570\u636e\n\n\n\u540c\u6837\u662f\u5f88\u660e\u663e\u7684\u9519\u8bef\uff0c\u4e0d\u8981\u72af\n\n\nx\n \n=\n \nmalloc\n(\nN\n \n*\n \nsizeof\n(\nint\n));\n\n\n//  \nmanipulate x\n\n\nfree\n(\nx\n);\n\n\n//  ....\n\n\ny\n \n=\n \nmalloc\n(\nM\n \n*\n \nsizeof\n(\nint\n));\n\n\nfor\n \n(\ni\n \n=\n \n0\n;\n \ni\n \n \nM\n;\n \ni\n++\n)\n\n    \ny\n[\ni\n]\n \n=\n \nx\n[\ni\n]\n++\n;\n\n\n\n\n\n\u5fd8\u8bb0\u91ca\u653e\u5df2\u5206\u914d\u5757\uff1a\n\n\nfoo\n()\n \n{\n\n    \nint\n \n*\nx\n \n=\n \nmalloc\n(\nN\n \n*\n \nsizeof\n(\nint\n));\n\n    \n// ...\n\n    \nreturn\n \n;\n\n\n}\n\n\n\n\n\n\u6216\u8005\u53ea\u91ca\u653e\u4e86\u6570\u636e\u7ed3\u6784\u7684\u4e00\u90e8\u5206\uff1a\n\n\nstruct\n \nlist\n \n{\n\n    \nint\n \nval\n;\n\n    \nstruct\n \nlist\n \n*\nnext\n;\n\n\n};\n\n\nfoo\n()\n \n{\n\n    \nstruct\n \nlist\n \n*\nhead\n \n=\n \nmalloc\n(\nsizeof\n(\nstruct\n \nlist\n));\n\n    \nhead\n-\nval\n \n=\n \n0\n;\n\n    \nhead\n-\nnext\n \n=\n \nNULL\n;\n\n    \n//...\n\n    \nfree\n(\nhead\n);\n\n    \nreturn\n;\n\n\n}", 
            "title": "Chapter 9: \u865a\u62df\u5185\u5b58"
        }, 
        {
            "location": "/csapp/ch9/#chapter-9", 
            "text": "", 
            "title": "Chapter 9 \u865a\u62df\u5185\u5b58"
        }, 
        {
            "location": "/csapp/ch9/#1", 
            "text": "\u4e3b\u5b58\u662f\u7531\u8fde\u7eed\u7684 \u5b57\u8282\u5927\u5c0f \u7684\u5355\u5143\u7ec4\u6210\u7684\u6570\u7ec4\uff0c\u6bcf\u5b57\u8282\u90fd\u6709\u4e00\u4e2a\u552f\u4e00\u7684 \u7269\u7406\u5730\u5740 (Physical Adress)\u3002CPU\u4f7f\u7528\u7269\u7406\u5730\u5740\u8bbf\u95ee\u5185\u5b58\u7684\u65b9\u5f0f\u79f0\u4e3a \u7269\u7406\u5bfb\u5740 (Physical adressing)\u3002  \u65e9\u671f\u7684PC\u4ee5\u53ca\u6570\u5b57\u4fe1\u53f7\u5904\u7406\u5668\u7b49\u4f7f\u7528\u7269\u7406\u5bfb\u5740\uff0c\u4e0b\u9762\u662f\u7269\u7406\u5bfb\u5740\u7684\u793a\u610f\u56fe\uff1a   \u73b0\u4ee3\u5904\u7406\u5668\u901a\u8fc7\u751f\u6210\u4e00\u4e2a \u865a\u62df\u5730\u5740 (Virtual Address)\u6765\u8bbf\u95ee\u4e3b\u5b58\uff0c\u865a\u62df\u5730\u5740\u7ecf\u8fc7 \u5730\u5740\u7ffb\u8bd1 (Address Translation)\u8f6c\u6362\u4e3a\u7269\u7406\u5730\u5740\u3002\u5730\u5740\u7ffb\u8bd1\u7531CPU\u5185\u7684 \u5185\u5b58\u7ba1\u7406\u5355\u5143 (Memory Management Unit,  MMU )\u8d1f\u8d23.   \u865a\u62df\u5185\u5b58\u5145\u5f53\u7740\u4e09\u4e2a\u89d2\u8272\uff1a   \u4f5c\u4e3a\u7f13\u5b58\u7684\u5de5\u5177\uff0c\u53ef\u4ee5\u66f4\u6709\u6548\u7387\u7684\u4f7f\u7528\u5185\u5b58\uff1a\u4f7f\u7528DRAM\u5f53\u505a\u90e8\u5206\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7684\u7f13\u5b58  \u4f5c\u4e3a\u5185\u5b58\u7ba1\u7406\u7684\u5de5\u5177\uff0c\u7b80\u5316\u5185\u5b58\u7ba1\u7406\uff1a\u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u6709\u7edf\u4e00\u7684\u7ebf\u6027\u5730\u5740\u7a7a\u95f4  \u4f5c\u4e3a\u5185\u5b58\u4fdd\u62a4\u7684\u5de5\u5177\uff0c\u5206\u9694\u5730\u5740\u7a7a\u95f4\uff1a\u8fdb\u7a0b\u7684\u5185\u5b58\u4e0d\u4f1a\u76f8\u4e92\u5f71\u54cd\uff1b\u7528\u6237\u7a0b\u5e8f\u4e0d\u80fd\u8bbf\u95ee\u4fdd\u5bc6\u7684\u5185\u6838\u4fe1\u606f\u548c\u4ee3\u7801   \u4e0b\u9762\u4e00\u8282\u5177\u4f53\u8bb2\u89e3\u865a\u62df\u5185\u5b58\u7684\u8fd9\u4e09\u4e2a\u89d2\u8272\u3002", 
            "title": "1 \u7269\u7406/\u865a\u62df\u5bfb\u5740"
        }, 
        {
            "location": "/csapp/ch9/#2", 
            "text": "", 
            "title": "2 \u865a\u62df\u5185\u5b58\u7684\u4e09\u4e2a\u89d2\u8272"
        }, 
        {
            "location": "/csapp/ch9/#21", 
            "text": "\u53ef\u4ee5\u628a\u4e3b\u5b58DRAM\u770b\u4f5c\u662f\u865a\u62df\u5185\u5b58\u7684\u7f13\u5b58\uff0c\u7c7b\u4f3c\u4e8eL1\u3001L2\u3001L3\u9ad8\u901f\u7f13\u5b58\u662fDRAM\u5185\u5b58\u7684\u7f13\u5b58\u3002\u4e5f\u5c31\u662f\u8bf4\u53ef\u4ee5\u628a\u865a\u62df\u5185\u5b58\u770b\u6210\u662f\u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784\u7684\u4e00\u90e8\u5206\u3002  \u548c\u5176\u4ed6\u5b58\u50a8\u5668\u5c42\u6b21\u7ed3\u6784\u4e2d\u7684\u7f13\u5b58\u4e00\u6837\uff0c\u8f83\u4f4e\u5c42\u4e0a\u7684\u6570\u636e\u88ab\u5206\u5272\u6210\u5757\uff0c\u4f5c\u4e3a\u4e0e\u8f83\u9ad8\u5c42\u4e4b\u95f4\u7684\u4f20\u8f93\u5355\u5143\u3002   \u8fd9\u91cc\u8f83\u4f4e\u5c42\u662f\u865a\u62df\u5185\u5b58\uff0c\u5206\u5272\u6210 \u865a\u62df\u9875 (Virtual Page, VP)\uff0c\u865a\u62df\u9875\u5927\u5c0f\u4e3a P=2^p  P=2^p  \u5b57\u8282\u3002  \u7c7b\u4f3c\u7684\uff0c\u8fd9\u91cc\u7684\u8f83\u9ad8\u5c42\uff0c\u7269\u7406\u5185\u5b58DRAM\uff0c\u88ab\u5206\u5272\u4e3a \u7269\u7406\u9875 (Physical Page, PP)\uff0c\u5927\u5c0f\u4e5f\u4e3a P P \uff0c\u4e5f\u53eb\u505a\u9875\u6862(page frame)\u3002   \u865a\u62df\u9875\u7684\u72b6\u6001\u5206\u4e3a\u4e09\u79cd\uff1a   \u672a\u5206\u914d (Unallocated): \u7cfb\u7edf\u8fd8\u672a\u5206\u914d(\u521b\u5efa)\u7684\u9875\uff0c\u4e0d\u5360\u7528\u78c1\u76d8\u7a7a\u95f4\u3002  \u7f13\u5b58\u7684 (Cached): \u5f53\u524d\u5df2\u7f13\u5b58\u5728\u7269\u7406\u5185\u5b58\u4e2d\u7684\u5df2\u5206\u914d\u9875\u3002  \u672a\u7f13\u5b58\u7684 (Uncached): \u672a\u7f13\u5b58\u5728\u7269\u7406\u5185\u5b58\u4e2d\u7684\u5df2\u5206\u914d\u9875\u3002    \u90a3\u4e48\u5177\u4f53\u662f\u600e\u4e48\u5224\u65ad\u4e00\u4e2a\u865a\u62df\u9875\u7684\u72b6\u6001\u5462\uff1f\u600e\u4e48\u77e5\u9053\u865a\u62df\u9875\u653e\u5728\u54ea\u4e2a\u7269\u7406\u9875\u4e2d\u5462\uff1f  \u7269\u7406\u5185\u5b58\u4e2d\u5b58\u5728\u4e00\u4e2a\u53eb \u9875\u8868 (page table)\u7684\u6570\u636e\u7ed3\u6784\uff0c\u7531\u64cd\u4f5c\u7cfb\u7edf\u8d1f\u8d23\u3002\u9875\u8868\u5c06\u865a\u62df\u9875\u6620\u5c04\u5230\u7269\u7406\u9875\uff0c\u6bcf\u6b21\u5185\u5b58\u7ba1\u7406\u5355\u5143\u4e2d\u7684 \u5730\u5740\u7ffb\u8bd1\u786c\u4ef6 \u5c06\u865a\u62df\u5730\u5740\u8f6c\u6362\u4e3a\u7269\u7406\u5730\u5740\u65f6\u90fd\u4f1a\u8bfb\u53d6\u9875\u8868\u3002  \u9875\u8868\u5176\u5b9e\u662f\u4e00\u4e2a \u9875\u8868\u6761\u76ee (Page Table Entry, PTE)\u7684\u6570\u7ec4\u3002\u9875\u8868\u6761\u76ee\u5305\u542b\u4e00\u4e2a \u6709\u6548\u4f4d( valid bit)\u548c\u4e00\u4e2a n n \u4f4d\u5730\u5740\u5b57\u6bb5\u3002   \u5728\u865a\u62df\u5185\u5b58\u7684\u4e60\u60ef\u8bf4\u6cd5\u4e2d\uff0cDRAM\u7f13\u5b58\u547d\u4e2d/\u4e0d\u547d\u4e2d\uff0c\u7279\u79f0\u4e3a \u9875\u547d\u4e2d / \u7f3a\u9875 (Page Hit/ Fault)\u3002", 
            "title": "2.1 \u4f5c\u4e3a\u7f13\u5b58\u7684\u5de5\u5177"
        }, 
        {
            "location": "/csapp/ch9/#22", 
            "text": "\u64cd\u4f5c\u7cfb\u7edf\u4e3a\u6bcf\u4e2a\u8fdb\u7a0b\u63d0\u4f9b\u4e86\u4e00\u4e2a\u72ec\u7acb\u7684\u9875\u8868\uff0c\u4e5f\u5c31\u662f\u63d0\u4f9b\u4e86\u4e00\u4e2a\u72ec\u7acb\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\u3002\u591a\u4e2a\u865a\u62df\u9875\u9762\u53ef\u4ee5\u6620\u5c04\u5230\u540c\u4e00\u4e2a\u5171\u4eab\u7269\u7406\u9875\u9762\u4e0a\u3002\u865a\u62df\u5185\u5b58\u7b80\u5316\u4e86\u94fe\u63a5\u548c\u52a0\u8f7d\u3001\u4ee3\u7801\u548c\u6570\u636e\u5171\u4eab\u3001\u4ee5\u53ca\u5e94\u7528\u7a0b\u5e8f\u7684\u5185\u5b58\u5206\u914d\u3002", 
            "title": "2.2 \u4f5c\u4e3a\u5185\u5b58\u7ba1\u7406\u7684\u5de5\u5177"
        }, 
        {
            "location": "/csapp/ch9/#23", 
            "text": "\u4e00\u65b9\u9762\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u62e5\u6709\u72ec\u7acb\u7684\u5730\u5740\u7a7a\u95f4\u4f7f\u5f97\u533a\u5206\u4e0d\u540c\u8fdb\u7a0b\u7684\u79c1\u6709\u5185\u5b58\u53d8\u5f97\u5bb9\u6613\u3002\u53e6\u4e00\u65b9\u9762\u5728\u6bcf\u4e2a\u9875\u8868\u6761\u76eePTE\u4e2d\uff0c\u6dfb\u52a0\u4e86\u989d\u5916\u7684 \u8bb8\u53ef\u4f4d (SUP, READ, WRITE, EXEC)\u6765\u63a7\u5236\u5bf9\u4e00\u4e2a\u865a\u62df\u9875\u9762\u5185\u5bb9\u7684\u8bbf\u95ee\uff1a   SUP\u4f4d\u8868\u793a\u8fdb\u7a0b\u662f\u5426\u8fd0\u884c\u5728\u8d85\u7ea7\u7528\u6237\u6a21\u5f0f\u4e0b\u624d\u80fd\u8bbf\u95ee  READ/WRITE\u4f4d\u63a7\u5236\u8bfb\u548c\u5199\u7684\u8bbf\u95ee  EXEC\u4f4d\u63a7\u5236\u6267\u884c\u7684\u8bbf\u95ee    \u5982\u679c\u8fdd\u53cd\u8bb8\u53ef\u6761\u4ef6\uff0c\u90a3\u4e48\u5c31\u89e6\u53d1\u6bb5\u9519\u8bef(segmentation fault)\u3002", 
            "title": "2.3 \u4f5c\u4e3a\u5185\u5b58\u4fdd\u62a4\u7684\u5de5\u5177"
        }, 
        {
            "location": "/csapp/ch9/#3", 
            "text": "\u5730\u5740\u7ffb\u8bd1\u662f\u865a\u62df\u5730\u5740\u7a7a\u95f4\u548c\u7269\u7406\u5730\u5740\u7a7a\u95f4\u4e4b\u95f4\u7684\u6620\u5c04\u3002CPU\u4e2d\u7684 \u9875\u8868\u57fa\u5740\u5bc4\u5b58\u5668 (Page Table Base Register, PTBR)\u6307\u5411\u5f53\u524d\u9875\u8868\u3002   n n \u4f4d\u7684\u865a\u62df\u5730\u5740\u5305\u542b\u4e24\u4e2a\u90e8\u5206\uff1a\u4e00\u4e2a p p \u4f4d\u7684 \u865a\u62df\u9875\u9762\u504f\u79fb (Virtual Page Offset, VPO)\u548c\u4e00\u4e2a n-p n-p \u4f4d\u7684 \u865a\u62df\u9875\u53f7 (Virtual Page Number, VPN)\u3002  m m \u4f4d\u7684\u7269\u7406\u5730\u5740\u5305\u542b\u4e24\u4e2a\u90e8\u5206\uff1a\u4e00\u4e2a p p \u4f4d\u7684 \u7269\u7406\u9875\u9762\u504f\u79fb (Physical Page Offset, PPO)\u548c\u4e00\u4e2a m-p m-p \u4f4d\u7684 \u7269\u7406\u9875\u53f7 (Physical Page Number, PPN)\u3002  \u7269\u7406\u9875\u9762\u504f\u79fb\u548c\u865a\u62df\u9875\u9762\u504f\u79fb\u662f\u76f8\u901a\u7684\u3002", 
            "title": "3 \u5730\u5740\u7ffb\u8bd1"
        }, 
        {
            "location": "/csapp/ch9/#tlb", 
            "text": "\u6bcf\u6b21CPU\u4ea7\u751f\u4e00\u4e2a\u865a\u62df\u5730\u5740\uff0cMMU\u5c31\u5fc5\u987b\u67e5\u9605\u4e00\u4e2aPTE\u3002\u4e3a\u4e86\u8bd5\u56fe\u6d88\u9664\u8fd9\u79cd\u5f00\u9500\uff0c\u5728MMU\u4e2d\u5305\u542b\u4e86\u4e00\u4e2a\u5173\u4e8ePTE\u7684\u7f13\u5b58\uff0c\u79f0\u4e3a \u8f6c\u8bd1\u540e\u5907\u7f13\u51b2\u5668 (Translation Lookaside Buffer, TLB)", 
            "title": "\u5229\u7528TLB\u52a0\u901f\u5730\u5740\u7ffb\u8bd1"
        }, 
        {
            "location": "/csapp/ch9/#_1", 
            "text": "\u7528\u6765\u538b\u7f29\u9875\u8868\u7684\u5e38\u7528\u65b9\u6cd5\u662f\u4f7f\u7528\u5c42\u6b21\u7ed3\u6784\u7684\u9875\u8868\u3002   \u865a\u62df\u5730\u5740\u88ab\u5212\u5206\u4e3a k k \u4e2aVPN\u548c1\u4e2aVPO\u3002  \u6bcf\u4e2aVPN  i i \u90fd\u662f\u4e00\u4e2a\u5230\u7b2c i i \u7ea7\u9875\u8868\u7684\u7d22\u5f15\uff0c\u5176\u4e2d \\le i \\le k \\le i \\le k \u3002  \u7b2c j j \u7ea7\u9875\u8868\u4e2d\u7684\u6bcf\u4e2aPTE\u90fd\u6307\u5411\u7b2c j+1 j+1 \u7ea7\u7684\u67d0\u4e2a\u9875\u8868\u7684\u57fa\u5740\u3002  \u7b2c k k \u7ea7\u9875\u8868\u4e2d\u7684\u6bcf\u4e2aPTE\u5305\u542b\u67d0\u4e2a\u7269\u7406\u9875\u9762\u7684PPN\u3002", 
            "title": "\u591a\u7ea7\u9875\u8868"
        }, 
        {
            "location": "/csapp/ch9/#4-core-i7", 
            "text": "", 
            "title": "4 core i7\u5185\u5b58\u7cfb\u7edf"
        }, 
        {
            "location": "/csapp/ch9/#core-i7", 
            "text": "Core i7\u57282008\u5e74\u51ac\u5b63\u53d1\u5e03\uff0c\u57fa\u4e8e\u5168\u65b0Nehalem(/n\u0259\u02c8he\u026al\u0259m/)\u67b6\u6784\uff0c\u5b83\u7684\u82af\u7247\u7ed3\u6784\u5982\u4e0b\u6240\u793a\uff1a   \u73b0\u5728\u7684Core i7\u652f\u630148\u4f4d(256TB)\u865a\u62df\u5730\u5740\u7a7a\u95f4\u548c52\u4f4d(4PB)\u7269\u7406\u5730\u5740\u7a7a\u95f4\u3002  \u4e0b\u56fe\u7ed9\u51fa\u4e86Core i7\u5185\u5b58\u7cfb\u7edf\u7684\u91cd\u8981\u90e8\u5206\u3002\u5904\u7406\u5668\u5c01\u88c5(Processor package)\u5305\u62ec\u56db\u4e2a\u6838\u3001\u4e00\u4e2a\u5927\u7684\u6240\u6709\u6838\u5171\u4eab\u7684L3\u9ad8\u901f\u7f13\u5b58\uff0c\u4ee5\u53ca\u4e00\u4e2aDDR3\u5185\u5b58\u63a7\u5236\u5668\u3002 \u6bcf\u4e00\u4e2a\u6838\u5305\u542b\u4e00\u4e2a\u5c42\u6b21\u7ed3\u6784\u7684TLB\u3001\u4e00\u4e2a\u5c42\u6b21\u7ed3\u6784\u7684\u6570\u636e\u6838\u6307\u4ee4\u9ad8\u901f\u7f13\u5b58\uff0c\u4ee5\u53ca\u4e00\u7ec4\u5feb\u901f\u7684\u70b9\u5230\u70b9\u94fe\u8def(\u57fa\u4e8eQuickPath\u6280\u672f)\u3002   TLB\u662f\u56db\u8def\u7ec4\u76f8\u8054\u7684  L1\u3001L2\u3001L3\u9ad8\u901f\u7f13\u5b58\uff0c\u5757\u5927\u5c0f\u4e3a64\u5b57\u8282\u3002  L1\u3001L2\u662f8\u8def\u7ec4\u76f8\u8054\u7684\uff0cL3\u662f16\u7ec4\u76f8\u8054\u7684\u3002", 
            "title": "Core i7\u7b80\u4ecb"
        }, 
        {
            "location": "/csapp/ch9/#core-i7_1", 
            "text": "Core i7\u91c7\u7528\u56db\u7ea7\u9875\u8868\u5c42\u6b21\u7ed3\u6784\u3002\u6bcf\u4e2a\u8fdb\u7a0b\u90fd\u6709\u5b83\u81ea\u5df1\u79c1\u6709\u7684\u9875\u8868\u5c42\u6b21\u7ed3\u6784\u3002CR3\u63a7\u5236\u5bc4\u5b58\u5668\u6307\u5411\u7b2c\u4e00\u7ea7\u9875\u8868(L1)\u7684\u8d77\u59cb\u4f4d\u7f6e\u3002   Core i7\u7b2c1-3\u7ea7\u9875\u8868\u6761\u76ee\u683c\u5f0f\uff1a   Each entry references a 4K child page table.  Significant fields :   P : Child page table present in physical memory (1) or not (0).  R/W : Read-\u00ad\u2010only or read-\u00ad\u2010write access access permission for all reachable pages.   U/S : user or supervisor (kernel) mode access permission for all reachable pages.  WT : Write-\u00ad\u2010through or write-\u00ad\u2010back cache policy for the child page table.  A :  Reference bit  (\u5f15\u7528\u4f4d\uff0cset by MMU on reads and writes, cleared by software).  PS : Page size either 4 KB or 4 MB (de\ufb01ned for Level 1 PTEs only).  Page table physical base address : 40  most significant bits (\u6700\u9ad8 \u6709\u6548\u4f4d ) of physical page table address (forces page tables to be 4KB aligned)   XD : Disable or enable instruction fetches from all pages reachable from this PTE.   Core i7\u7b2c4\u7ea7\u9875\u8868\u6761\u76ee\u683c\u5f0f\uff1a    Page physical base address : 40  most significant bits  of physical page address (forces pages to be 4KB aligned)  D :  Dirty bit  (\u810f\u4f4d, or modify bit\uff0cset by MMU on  writes , cleared by software)   \u4e0b\u56fe\u7ed9\u51fa\u4e86Core i7 MMU\u5982\u4f55\u4f7f\u7528\u56db\u7ea7\u9875\u8868\u5c06\u865a\u62df\u5730\u5740\u7ffb\u8bd1\u6210\u7269\u7406\u5730\u5740\u300236\u4f4dVPN\u88ab\u5212\u5206\u4e3a\u56db\u4e2a9\u4f4d\u7684\u7247\uff0c\u6bcf\u4e2a\u7247\u88ab\u7528\u4f5c\u4e00\u4e2a\u9875\u8868\u7684\u504f\u79fb\u91cf\u3002VPN1\u63d0\u4f9b\u5230\u4e00\u4e2aL1 PET\u7684\u504f\u79fb\u91cf\uff0c\u8fd9\u4e2aPTE\u5305\u542bL2\u9875\u8868\u7684\u57fa\u5730\u5740\u3002VPN2\u63d0\u4f9b\u5230\u4e00\u4e2aL2 PET\u7684\u504f\u79fb\u91cf\uff0c\u4ee5\u6b64\u7c7b\u63a8\u3002", 
            "title": "Core i7\u5730\u5740\u7ffb\u8bd1"
        }, 
        {
            "location": "/csapp/ch9/#5-linux", 
            "text": "Linux\u4e3a\u6bcf\u4e2a\u8fdb\u7a0b\u7ef4\u62a4\u4e86\u4e00\u4e2a\u5355\u72ec\u7684\u865a\u62df\u5730\u5740\u7a7a\u95f4\u3002Linux\u5c06\u865a\u62df\u5185\u5b58\u7ec4\u7ec7\u6210\u4e00\u4e9b \u533a\u57df \u7684\u96c6\u5408\u3002\u4e00\u4e2a\u533a\u57df\u5c31\u662f\u5df2\u5206\u914d\u7684\u865a\u62df\u5185\u5b58\u7684\u8fde\u7eed\u7247\u3002  Linux\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7531\u5982\u4e0b\u51e0\u4e2a\u533a\u57df\u7ec4\u6210\uff1a   \u4ee3\u7801\uff08 .text \uff09: \u8fd9\u91cc\u5b58\u653e\u7684\u662fCPU\u8981\u6267\u884c\u7684\u6307\u4ee4\u3002\u4ee3\u7801\u6bb5\u662f\u53ef\u5171\u4eab\u7684\uff0c\u76f8\u540c\u7684\u4ee3\u7801\u5728\u5185\u5b58\u4e2d\u53ea\u4f1a\u6709\u4e00\u4e2a\u62f7\u8d1d\uff0c\u540c\u65f6\u8fd9\u4e2a\u6bb5\u662f\u53ea\u8bfb\u7684\uff0c\u9632\u6b62\u7a0b\u5e8f\u7531\u4e8e\u9519\u8bef\u800c\u4fee\u6539\u81ea\u8eab\u7684\u6307\u4ee4\u3002  \u521d\u59cb\u5316\u6570\u636e\u6bb5\uff08 .data \uff09: \u8fd9\u91cc\u5b58\u653e\u7684\u662f\u7a0b\u5e8f\u4e2d\u9700\u8981\u660e\u786e\u8d4b\u521d\u59cb\u503c\u7684\u53d8\u91cf\uff0c\u4f8b\u5982\u4f4d\u4e8e\u6240\u6709\u51fd\u6570\u4e4b\u5916\u7684\u5168\u5c40\u53d8\u91cf\uff1a int val= 100 \u3002\u9700\u8981\u5f3a\u8c03\u7684\u662f\uff0c\u4ee5\u4e0a\u4e24\u6bb5\u90fd\u662f\u4f4d\u4e8e\u7a0b\u5e8f\u7684\u53ef\u6267\u884c\u6587\u4ef6\u4e2d\uff0c\u5185\u6838\u5728\u8c03\u7528 exec \u51fd\u6570\u542f\u52a8\u8be5\u7a0b\u5e8f\u65f6\u4ece\u6e90\u7a0b\u5e8f\u6587\u4ef6\u4e2d\u8bfb\u5165\u3002  \u672a\u521d\u59cb\u5316\u6570\u636e\u6bb5\uff08 .bss \uff09: \u4f4d\u4e8e\u8fd9\u4e00\u6bb5\u4e2d\u7684\u6570\u636e\uff0c\u5185\u6838\u5728\u6267\u884c\u8be5\u7a0b\u5e8f\u524d\uff0c\u5c06\u5176\u521d\u59cb\u5316\u4e3a0\u6216\u8005 null \u3002\u4f8b\u5982\u51fa\u73b0\u5728\u4efb\u4f55\u51fd\u6570\u4e4b\u5916\u7684\u5168\u5c40\u53d8\u91cf\uff1aint sum;  \u5806\uff08 Heap \uff09: \u8fd9\u4e2a\u6bb5\u7528\u4e8e\u5728\u7a0b\u5e8f\u4e2d\u8fdb\u884c\u52a8\u6001\u5185\u5b58\u7533\u8bf7\uff0c\u4f8b\u5982\u7ecf\u5e38\u7528\u5230\u7684 malloc \uff0c new \u7cfb\u5217\u51fd\u6570\u5c31\u662f\u4ece\u8fd9\u4e2a\u6bb5\u4e2d\u7533\u8bf7\u5185\u5b58\u3002  \u5171\u4eab\u5e93( Shared Library ): \u7528\u6765\u5b58\u653e\u50cfC\u6807\u51c6\u5e93\u548c\u6570\u5b66\u54ed\u8fd9\u6837\u7684\u5171\u4eab\u5e93\u7684\u4ee3\u7801\u548c\u6570\u636e\u7684\u533a\u57df\u3002  \u6808\uff08 Stack \uff09: \u51fd\u6570\u4e2d\u7684\u5c40\u90e8\u53d8\u91cf\u4ee5\u53ca\u5728\u51fd\u6570\u8c03\u7528\u8fc7\u7a0b\u4e2d\u4ea7\u751f\u7684\u4e34\u65f6\u53d8\u91cf\u90fd\u4fdd\u5b58\u5728\u6b64\u6bb5\u4e2d\uff0c\u5177\u4f53\u89c1\u4e0b\u9762\u4e00\u8282\u3002  \u5185\u6838\u865a\u62df\u5185\u5b58\uff1a\u5305\u542b\u5185\u6838\u4e2d\u7684\u4ee3\u7801\u548c\u6570\u636e\u7ed3\u6784\u3002    \u4e0b\u9762\u662f\u7a0b\u5e8f\u793a\u610f\uff1a    #include stdio.h      \n  #include   malloc.h      \n\n  void   print ( char   * , int );     \n  int   main ()      {     \n      char   * s1   =   abcde ;    // abcde \u4f5c\u4e3a\u5b57\u7b26\u4e32\u5e38\u91cf\u5b58\u50a8\u5728\u5e38\u91cf\u533a s1\u3001s2\u3001s5\u62e5\u6709\u76f8\u540c\u7684\u5730\u5740   \n      char   * s2   =   abcde ;     \n      char   s3 []   =   abcd ;     \n      long   int   * s4 [ 100 ];     \n      char   * s5   =   abcde ;     \n      int   a   =   5 ;     \n      int   b   = 6 ; //a,b\u5728\u6808\u4e0a\uff0c a b\u5730\u5740\u53cd\u5411\u589e\u957f     \n\n      printf ( variables address in main function:  \n      s1 =% p    s2 =% p   s3 =% p   s4 =% p   s5 =% p   a =% p   b =% p   \\ n , s1,s2,s3,s4,s5, a, b);    \n      printf ( variables address in processcall:n );     \n      print ( ddddddddd , 5 ); //\u53c2\u6570\u5165\u6808\u4ece\u53f3\u81f3\u5de6\u8fdb\u884c,p\u5148\u8fdb\u6808,str\u540e\u8fdb  p str     \n      printf ( main=%p print=%p  \\n , main , print );     \n      //\u6253\u5370\u4ee3\u7801\u6bb5\u4e2d\u4e3b\u51fd\u6570\u548c\u5b50\u51fd\u6570\u7684\u5730\u5740\uff0c\u7f16\u8bd1\u65f6\u5148\u7f16\u8bd1\u7684\u5730\u5740\u4f4e\uff0c\u540e\u7f16\u8bd1\u7684\u5730\u5740\u9ad8main print     \n  }     \n\n  void   print ( char   * str , int   p )      {     \n      char   * s1   =   abcde ;    //abcde\u5728\u5e38\u91cf\u533a\uff0cs1\u5728\u6808\u4e0a     \n      char   * s2   =   abcde ;    //abcde\u5728\u5e38\u91cf\u533a\uff0cs2\u5728\u6808\u4e0a s2-s1=6\u53ef\u80fd\u7b49\u4e8e0\uff0c\u7f16\u8bd1\u5668\u4f18\u5316\u4e86\u76f8\u540c\u7684\u5e38\u91cf\uff0c\u53ea\u5728\u5185\u5b58\u4fdd\u5b58\u4e00\u4efd     \n      //\u800c s1 s2     \n      char   s3 []   =   abcdeee ; //abcdeee\u5728\u5e38\u91cf\u533a\uff0cs3\u5728\u6808\u4e0a\uff0c\u6570\u7ec4\u4fdd\u5b58\u7684\u5185\u5bb9\u4e3aabcdeee\u7684\u4e00\u4efd\u62f7\u8d1d     \n      long   int   * s4 [ 100 ];     \n      char   * s5   =   abcde ;     \n      int   a   =   5 ;     \n      int   b   = 6 ;     \n      int   c ;     \n      int   d ;             //a,b,c,d\u5747\u5728\u6808\u4e0a\uff0c a b c d\u5730\u5740\u53cd\u5411\u589e\u957f     \n      char   * q = str ;    \n      int   m = p ;            \n      char   * r = ( char   * ) malloc ( 1 );     \n      char   * w = ( char   * ) malloc ( 1 )   ;    // r w \u5806\u6b63\u5411\u589e\u957f     \n\n      printf ( s1=%p s2=%p s3=%p s4=%p s5=%p a=%p b=%p c=%p d=%p str=%p q=%p p=%p m=%p r=%p w=%p  \\n ,   s1 , s2 , s3 , s4 , s5 , a , b , c , d , str , q , p , m , r , w );    \n      /* \u6808\u548c\u5806\u662f\u5728\u7a0b\u5e8f\u8fd0\u884c\u65f6\u5019\u52a8\u6001\u5206\u914d\u7684\uff0c\u5c40\u90e8\u53d8\u91cf\u5747\u5728\u6808\u4e0a\u5206\u914d\u3002           \u6808\u662f\u53cd\u5411\u589e\u957f\u7684\uff0c\u5730\u5740\u9012\u51cf\uff1bmalloc\u7b49\u5206\u914d\u7684\u5185\u5b58\u7a7a\u95f4\u5728\u5806\u7a7a\u95f4\u3002\u5806\u662f\u6b63\u5411\u589e\u957f\u7684\uff0c\u5730\u5740\u9012\u589e\u3002             r,w\u53d8\u91cf\u5728\u6808\u4e0a(\u5219 r w)\uff0cr,w\u6240\u6307\u5185\u5bb9\u5728\u5806\u4e2d(\u5373r w)\u3002*/    \n  }", 
            "title": "5 Linux\u865a\u62df\u5185\u5b58\u7cfb\u7edf"
        }, 
        {
            "location": "/csapp/ch9/#linux", 
            "text": "\u90a3\u4e48Linux\u5177\u4f53\u662f\u600e\u4e48\u7ec4\u7ec7\u865a\u62df\u5185\u5b58\u7684\u5462\uff1fLinux\u5185\u6838\u4e3a\u7cfb\u7edf\u4e2d\u7684\u6bcf\u4e2a\u8fdb\u7a0b\u7ef4\u62a4\u4e00\u4e2a\u5355\u72ec\u7684\u4efb\u52a1\u7ed3\u6784\u4f53( task_struct , \u5728 sched.h \u5934\u6587\u4ef6\u4e2d)\u3002 task_struct \u4e2d\u7684\u5143\u7d20\u5305\u542b\u8fd0\u884c\u8be5\u8fdb\u7a0b\u6240\u9700\u8981\u7684\u6240\u6709\u4fe1\u606f(PID\u3001\u6307\u5411\u7528\u6237\u6808\u7684\u6307\u9488\u3001\u53ef\u6267\u884c\u76ee\u6807\u6587\u4ef6\u7684\u540d\u5b57\u3001\u4ee5\u53ca\u7a0b\u5e8f\u8ba1\u6570\u5668)\u3002   task_struct \u4e2d\u7684\u4e00\u4e2a\u5143\u7d20\u6307\u5411 mm_struct \uff0c\u5b83\u63cf\u8ff0\u4e86\u865a\u62df\u5185\u5b58\u7684\u5f53\u524d\u72b6\u6001\u3002 pgd \u6307\u5411\u7b2c\u4e00\u7ea7\u9875\u8868\u7684\u57fa\u5740\uff0c\u800c mmap \u6307\u5411\u4e00\u4e2a vm_area_struct (\u533a\u57df\u7ed3\u6784, \u5b9a\u4e49\u5728 mm_types.h )\u7684\u94fe\u8868\u3002\u6bcf\u4e2a\u533a\u57df\u7ed3\u6784\u94fe\u8868\u90fd\u63cf\u8ff0\u4e86\u865a\u62df\u5730\u5740\u7a7a\u95f4\u7684\u4e00\u4e2a\u533a\u57df\uff0c\u5305\u542b\u4ee5\u4e0b\u5b57\u6bb5\uff1a   vm_start : \u6307\u5411\u533a\u57df\u7684\u8d77\u59cb\u5904  vm_end : \u6307\u5411\u533a\u57df\u7684\u7ed3\u675f\u5904  vm_prot : \u63cf\u8ff0\u7740\u533a\u57df\u5185\u5305\u542b\u7684\u6240\u6709\u9875\u7684\u8bfb\u5199\u8bb8\u53ef\u6743\u9650  vm_flags : \u63cf\u8ff0\u8fdb\u7a0b\u5171\u4eab/\u79c1\u6709  vm_next : \u4e0b\u4e00\u4e2a\u533a\u57df\u7ed3\u6784", 
            "title": "Linux\u662f\u5982\u4f55\u7ec4\u7ec7\u865a\u62df\u5185\u5b58\u7684"
        }, 
        {
            "location": "/csapp/ch9/#linux_1", 
            "text": "\u5185\u5b58\u7ba1\u7406\u5355\u5143MMU\u5728\u8bd5\u56fe\u7ffb\u8bd1\u67d0\u4e2a\u865a\u62df\u5730\u5740A\u65f6\uff0c\u89e6\u53d1\u4e86\u4e00\u4e2a\u7f3a\u9875\u5f02\u5e38\uff0c\u5f15\u8d77\u7f3a\u9875\u5f02\u5e38\u5904\u7406\u7a0b\u5e8f\uff1a   \u865a\u62df\u5730\u5740A\u662f\u5408\u6cd5\u7684\u5417\uff1f-  \u6bb5\u9519\u8bef(segment fault)  \u8bd5\u56fe\u8fdb\u884c\u7684\u5185\u5b58\u8bbf\u95ee\u662f\u5408\u6cd5\u7684\u5417\uff1f -  \u4fdd\u62a4\u5f02\u5e38(\u4e5f\u5f15\u53d1\u6bb5\u9519\u8bef)", 
            "title": "Linux \u7f3a\u9875\u5f02\u5e38\u5904\u7406"
        }, 
        {
            "location": "/csapp/ch9/#6", 
            "text": "Linux \u901a\u8fc7\u5c06\u4e00\u4e2a\u865a\u62df\u5185\u533a\u57df\u4e0e\u4e00\u4e2a\u78c1\u76d8\u4e0a\u7684 \u5bf9\u8c61 (object)\u5173\u8054\u8d77\u6765\uff0c\u4ee5\u521d\u59cb\u5316\u8fd9\u4e2a\u865a\u62df\u5185\u5b58\u533a\u57df\u7684\u5185\u5bb9\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u79f0\u4e3a \u5185\u5b58\u6620\u5c04 (memory mapping).  \u4e00\u65e6\u4e00\u4e2a\u865a\u62df\u9875\u9762\u88ab\u521d\u59cb\u5316\u4e86\uff0c\u5b83\u5c31\u5728\u4e00\u4e2a\u7531\u5185\u6838\u7ef4\u62a4\u7684\u4e13\u95e8\u7684 \u4ea4\u6362\u6587\u4ef6 (swap file)\u4e4b\u95f4\u6362\u6765\u6362\u53bb\u3002\u4ea4\u6362\u6587\u4ef6\u4e5f\u53eb\u505a \u4ea4\u6362\u7a7a\u95f4 (swap space)\u6216\u4ea4\u6362\u533a\u57df(swap area)\u3002", 
            "title": "6 \u5185\u5b58\u6620\u5c04"
        }, 
        {
            "location": "/csapp/ch9/#_2", 
            "text": "\u4e00\u4e2a\u5bf9\u8c61\u53ef\u4ee5\u88ab\u6620\u5c04\u5230\u865a\u62df\u5185\u5b58\u7684\u4e00\u4e2a\u533a\u57df\uff0c\u8981\u4e48\u4f5c\u4e3a \u5171\u4eab\u5bf9\u8c61 \uff0c\u8981\u4e48\u4f5c\u4e3a \u79c1\u6709\u5bf9\u8c61 \u3002   \u5982\u679c\u4e00\u4e2a\u8fdb\u7a0b\u5c06\u4e00\u4e2a\u5171\u4eab\u5bf9\u8c61\u6620\u5c04\u5230\u5b83\u7684\u865a\u62df\u7a7a\u95f4\u7684\u4e00\u4e2a\u533a\u57df\u5185\uff0c\u90a3\u4e48\u8fd9\u4e2a\u8fdb\u7a0b\u5bf9\u8fd9\u4e2a\u533a\u57df\u7684\u4efb\u4f55\u5199\u64cd\u4f5c\uff0c\u5bf9\u4e8e\u90a3\u4e9b\u4e5f\u628a\u8fd9\u4e2a\u5171\u4eab\u5bf9\u8c61\u6620\u5c04\u5230\u5b83\u4eec\u865a\u62df\u5185\u5b58\u7684\u5176\u4ed6\u8fdb\u7a0b\u800c\u8a00\uff0c\u4e5f\u662f\u53ef\u89c1\u7684\u3002\u800c\u4e14\uff0c\u8fd9\u4e9b\u53d8\u5316\u4e5f\u4f1a\u53cd\u6620\u5728\u78c1\u76d8\u4e0a\u7684\u539f\u59cb\u5bf9\u8c61\u4e2d\u3002  \u5bf9\u4e8e\u4e00\u4e2a\u6620\u5c04\u5230\u79c1\u6709\u5bf9\u8c61\u7684\u533a\u57df\u505a\u7684\u6539\u53d8\uff0c\u5bf9\u4e8e\u5176\u4ed6\u8fdb\u7a0b\u6765\u8bf4\u662f\u4e0d\u53ef\u517c\u5f97\u3002  \u5373\u4f7f\u5bf9\u8c61\u88ab\u6620\u5c04\u5230\u4e86\u591a\u4e2a\u5171\u4eab\u533a\u57df\uff0c\u7269\u7406\u5185\u5b58\u4e2d\u4e5f\u53ea\u9700\u8981\u5b58\u653e\u5171\u4eab\u5bf9\u8c61\u7684\u4e00\u4e2a\u526f\u672c\u3002   \u79c1\u6709\u5bf9\u8c61\u4f7f\u7528 \u5199\u65f6\u590d\u5236 (copy-on-write)\u7684\u5de7\u5999\u6280\u672f\u88ab\u6620\u5c04\u5230\u865a\u62df\u5185\u5b58\u4e2d\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u6620\u5c04\u79c1\u6709\u5bf9\u8c61\u7684\u8fdb\u7a0b\uff0c\u76f8\u5e94\u79c1\u6709\u533a\u57df\u7684\u9875\u8868\u6761\u76ee\u90fd\u88ab\u6807\u8bb0\u4e3a\u53ea\u8bfb\uff0c\u5e76\u4e14\u533a\u57df\u7ed3\u6784\u88ab\u6807\u8bb0\u4e3a \u79c1\u6709\u7684\u5199\u65f6\u590d\u5236 \u3002   \u53ea\u8981\u6ca1\u6709\u8fdb\u7a0b\u65f6\u56fe\u5199\u5b83\u7684\u79c1\u6709\u533a\u57df\uff0c\u5b83\u4eec\u5c31\u53ef\u4ee5\u7ee7\u7eed\u5171\u4eab\u7269\u7406\u5185\u5b58\u4e2d\u5bf9\u8c61\u7684\u4e00\u4e2a\u5355\u72ec\u526f\u672c\u3002  \u53ea\u8981\u6709\u4e00\u4e2a\u8fdb\u7a0b\u8bd5\u56fe\u5199\u79c1\u6709\u533a\u57df\u7684\u67d0\u4e2a\u9875\u9762\uff0c\u6545\u969c\u5904\u7406\u7a0b\u5e8f\u5c31\u4f1a\u5728\u7269\u7406\u5185\u5b58\u4e2d\u521b\u5efa\u8fd9\u4e2a\u9875\u9762\u7684\u4e00\u4e2a\u65b0\u526f\u672c\uff0c\u66f4\u65b0\u9875\u8868\u6761\u76ee\u6307\u5411\u8fd9\u4e2a\u65b0\u7684\u526f\u672c\uff0c\u7136\u540e\u6062\u590d\u8fd9\u4e2a\u9875\u9762\u7684\u53ef\u5199\u6743\u9650\u3002", 
            "title": "\u518d\u770b\u5171\u4eab\u5bf9\u8c61"
        }, 
        {
            "location": "/csapp/ch9/#fork", 
            "text": "\u5f53fork\u51fd\u6570\u88ab\u5f53\u524d\u8fdb\u7a0b\u8c03\u7528\u65f6\uff0c\u5185\u6838\u4e3a\u65b0\u8fdb\u7a0b\u521b\u5efa\u5404\u79cd\u6570\u636e\u7ed3\u6784\uff0c\u5e76\u5206\u914d\u7ed9\u5b83\u4e00\u4e2a\u552f\u4e00\u7684PID\u3002   \u4e3a\u4e86\u7ed9\u8fd9\u4e2a\u65b0\u8fdb\u7a0b\u521b\u5efa\u865a\u62df\u5185\u5b58\uff0c\u5b83\u521b\u5efa\u4e86\u5f53\u524d\u8fdb\u7a0b\u7684 mm_struct \u3001\u533a\u57df\u7ed3\u6784 vm_area_struct \u548c\u9875\u8868\u7684\u539f\u6837\u526f\u672c\u3002  \u5185\u6838\u5c06\u4e24\u4e2a\u8fdb\u7a0b\u4e2d\u7684\u6bcf\u4e2a\u9875\u9762\u90fd\u6807\u8bb0\u4e3a\u53ea\u8bfb\uff0c\u5e76\u5c06\u4e24\u4e2a\u8fdb\u7a0b\u4e2d\u7684\u6bcf\u4e2a\u533a\u57df\u7ed3\u6784\u90fd\u6807\u8bb0\u4e3a\u79c1\u6709\u7684\u5199\u65f6\u590d\u5236\u3002  \u5f53\u8fd9\u4e24\u4e2a\u8fdb\u7a0b\u4e2d\u7684\u4efb\u4f55\u4e00\u4e2a\u8fdb\u884c\u5199\u64cd\u4f5c\u65f6\uff0c\u5199\u65f6\u590d\u5236\u673a\u5236\u5c31\u4f1a\u521b\u5efa\u65b0\u9875\u9762\u3002", 
            "title": "\u518d\u770bfork\u51fd\u6570"
        }, 
        {
            "location": "/csapp/ch9/#execve", 
            "text": "execve\u51fd\u6570\u5728\u5f53\u524d\u8fdb\u7a0b\u4e2d\u52a0\u8f7d\u5e76\u8fd0\u884c\u65b0\u7a0b\u5e8f\uff1a   \u5220\u9664\u5df2\u5b58\u5728\u7684\u7528\u6237\u533a\u57df\u3002  \u6620\u5c04\u79c1\u6709\u533a\u57df\u3002  \u6620\u5c04\u5171\u4eab\u533a\u57df\u3002  \u8bbe\u7f6e\u7a0b\u5e8f\u8ba1\u6570\u5668\u3002", 
            "title": "\u518d\u770bexecve\u51fd\u6570"
        }, 
        {
            "location": "/csapp/ch9/#_3", 
            "text": "Linux\u8fdb\u7a0b\u53ef\u4ee5\u4f7f\u7528mmap\u51fd\u6570\u6765\u521b\u5efa\u65b0\u7684\u865a\u62df\u5185\u5b58\u533a\u57df\uff0c\u5e76\u5c06\u5bf9\u8c61\u6620\u5c04\u5230\u8fd9\u4e9b\u533a\u57df\u4e2d\u3002  void   * mmap ( void   * start ,   int   len ,   int   prot ,   int   flags ,   int   fd ,   int   offset )   mmap\u51fd\u6570\u8981\u6c42\u5185\u6838\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u865a\u62df\u5185\u5b58\u533a\u57df\uff0c\u6700\u597d\u662f\u4ece\u5730\u5740start\u5f00\u59cb\u7684\u4e00\u4e2a\u533a\u57df\uff0c\u5e76\u5c06\u6587\u4ef6\u63cf\u8ff0\u7b26fd\u5236\u5b9a\u7684\u5bf9\u8c61\u7684\u4e00\u4e2a\u8fde\u7eed\u7684\u7247(chunk)\u6620\u5c04\u5230\u8fd9\u4e2a\u65b0\u7684\u533a\u57df\u3002\u8fde\u7eed\u7684\u5bf9\u8c61\u7247\u5927\u5c0f\u4e3alen\u5b57\u8282\uff0c\u4ece\u8ddd\u6587\u4ef6\u5f00\u59cb\u5904\u504f\u79fb\u91cf\u4e3aoffset\u5b57\u8282\u7684\u5730\u65b9\u5f00\u59cb\u3002\u5176\u53c2\u6570\uff1a   start : may be 0 for \u201cpick an address\u201d  prot : PROT_READ, PROT_WRITE, ...  flags : MAP_ANON, MAP_PRIVATE, MAP_SHARED, ...  Return a pointer to start of mapped area", 
            "title": "\u7528\u6237\u7ea7\u5185\u5b58\u6620\u5c04"
        }, 
        {
            "location": "/csapp/ch9/#7", 
            "text": "\u7a0b\u5e8f\u4f7f\u7528\u52a8\u6001\u5185\u5b58\u5206\u914d\u7684\u6700\u91cd\u8981\u7684\u539f\u56e0\u662f\u7ecf\u5e38\u76f4\u5230\u7a0b\u5e8f\u5b9e\u9645\u8fd0\u884c\u65f6\uff0c\u624d\u77e5\u9053\u67d0\u4e9b\u6570\u636e\u7ed3\u6784\u7684\u5927\u5c0f\u3002\u4e00\u822c\u4f7f\u7528\u52a8\u6001\u5185\u5b58\u5206\u914d\u5668(dynamic memeory allocator)\u6765\u5206\u914d\u52a8\u6001\u5185\u5b58\u3002  \u5206\u914d\u5668\u6839\u636e\u54ea\u4e2a\u5b9e\u4f53\u6765\u8d1f\u8d23\u91ca\u653e\u5df2\u5206\u914d\u7684\u5757\uff0c\u5206\u4e3a\u4e24\u79cd\uff1a   \u663e\u793a\u5206\u914d\u5668 (explicit allocator)\uff1a\u8981\u6c42\u7a0b\u5e8f\u663e\u793a\u5730\u91ca\u653e\u4efb\u4f55\u5df2\u5206\u914d\u7684\u5757\u3002\u4f8b\u5982C\u4e2d\u7684malloc/free\uff0cC++\u4e2d\u7684new/delete\u3002  \u9690\u5f0f\u5206\u914d\u5668 (implicit allocator): \u9664\u6b64\u4e4b\u5916\uff0c\u81ea\u52a8\u91ca\u653e\u672a\u4f7f\u7528\u7684\u5df2\u5206\u914d\u5757(\u5783\u573e\u6536\u96c6\uff0cgarbage collection)\u3002", 
            "title": "7 \u52a8\u6001\u5185\u5b58\u5206\u914d"
        }, 
        {
            "location": "/csapp/ch9/#72", 
            "text": "", 
            "title": "7.2 \u663e\u5f0f\u5206\u914d\u5668\u7684\u8981\u6c42\u548c\u76ee\u6807"
        }, 
        {
            "location": "/csapp/ch9/#721", 
            "text": "\u5206\u914d\u5668\u6709\u5982\u4e0b\u7684\u8981\u6c42\uff1a   \u5904\u7406\u4efb\u610f\u8bf7\u6c42\u5e8f\u5217  \u7acb\u5373\u76f8\u5e94\u8bf7\u6c42  \u53ea\u4f7f\u7528\u5806  \u5bf9\u9f50\u5757(\u5bf9\u9f50\u8981\u6c42)  \u4e0d\u4fee\u6539\u5df2\u5206\u914d\u7684\u5757", 
            "title": "7.2.1 \u5206\u914d\u5668\u7684\u8981\u6c42"
        }, 
        {
            "location": "/csapp/ch9/#722", 
            "text": "\u5206\u914d\u5668\u8bd5\u56fe\u6700\u5927\u5316\u541e\u5410\u7387\u548c\u5185\u5b58\u5229\u7528\u7387   \u6700\u5927\u5316\u541e\u5410\u7387(\u541e\u5410\u7387\uff1a\u6bcf\u4e2a\u5355\u4f4d\u65f6\u95f4\u91cc\u5b8c\u6210\u7684\u8bf7\u6c42\u6570)  \u6700\u5927\u5316\u5185\u5b58\u5229\u7528\u7387   \u6700\u5927\u5316\u541e\u5410\u7387\u548c\u6700\u5927\u5316\u5229\u7528\u7387\u4e4b\u95f4\u662f\u76f8\u4e92  \u7275\u5236  \u7684\uff0c\u5206\u914d\u5668\u8bbe\u8ba1\u7684\u76ee\u6807\u662f\u5728\u8fd9\u4e24\u8005\u4e4b\u95f4\u627e\u5230\u4e00\u4e2a\u9002\u5f53\u7684\u5e73\u8861\u3002  \u9020\u6210\u5229\u7528\u7387\u5f88\u4f4e\u7684\u4e3b\u8981\u539f\u56e0\u662f \u788e\u7247 (fragmentation)\u73b0\u8c61\u3002\u5f53\u6709\u6548\u8f7d\u8377\u6bd4\u5757\u8981\u5c0f\u65f6\uff0c\u53d1\u751f \u5185\u90e8\u788e\u7247 (Internal fragmentation)\uff0c\u5f15\u8d77\u7684\u539f\u56e0\u6709\uff1a\u5bf9\u9f50\u7b49\u3002   \u5f53\u5373\u4f7f\u6709\u8db3\u591f\u7684\u7d2f\u79ef\u7684\u5757\u5185\u5b58\uff0c\u4f46\u662f\u6ca1\u6709\u5355\u4e00\u5757\u80fd\u591f\u6ee1\u8db3\u9700\u6c42\u65f6\uff0c\u53d1\u751f \u5916\u90e8\u788e\u7247 (external fragmentation)\uff1a   \u5916\u90e8\u788e\u7247\u8fd8\u53d6\u51b3\u4e8e\u5c06\u6765\u7684\u8bf7\u6c42\uff0c\u4f8b\u5982\u4e0a\u56fe\uff0c\u5982\u679c\u6700\u540e\u7684p4\u8bf7\u6c424\u4e2a\u5b57\u8282\u5462\uff1f\u4e5f\u5c31\u4e0d\u4f1a\u53d1\u751f\u788e\u7247\u3002\u6b63\u56e0\u4e3a\u5916\u90e8\u788e\u7247\u96be\u4ee5\u91cf\u5316\u4e14\u4e0d\u53ef\u80fd\u9884\u6d4b\uff0c\u6240\u4ee5\u5206\u914d\u5668\u901a\u5e38\u91c7\u7528\u542f\u53d1\u5f0f\u7b56\u7565\u6765\u8bd5\u56fe\u7ef4\u6301\u5c11\u91cf\u7684\u5927\u7a7a\u95f2\u5757\uff0c\u800c\u4e0d\u662f\u7ef4\u6301\u5927\u91cf\u7684\u5c0f\u7a7a\u95f2\u5757\u3002", 
            "title": "7.2.2 \u5206\u914d\u5668\u7684\u76ee\u6807"
        }, 
        {
            "location": "/csapp/ch9/#723", 
            "text": "\u5f53\u4e00\u4e2a\u5e94\u7528\u8bf7\u6c42\u4e00\u4e2a k k \u5b57\u8282\u7684\u5757\u65f6\uff0c\u5206\u914d\u5668\u641c\u7d22\u7a7a\u95f2\u94fe\u8868\uff0c\u67e5\u627e\u4e00\u4e2a\u8db3\u591f\u5927\u53ef\u4ee5\u653e\u7f6e\u6240\u8bf7\u6c42\u5757\u7684\u7a7a\u95f2\u5757\u3002\u5206\u914d\u5668\u7684 \u653e\u7f6e\u7b56\u7565 (placement policy)\u6709 \u9996\u6b21\u9002\u914d (first fit)\u3001 \u4e0b\u4e00\u6b21\u9002\u914d (next fit)\u548c \u6700\u4f73\u9002\u914d (best fit)\u3002   \u9996\u6b21\u9002\u914d \u4ece\u5934\u5f00\u59cb\u641c\u7d22\u7a7a\u95f2\u94fe\u8868\uff0c\u9009\u62e9\u7b2c\u4e00\u4e2a\u9002\u5408\u7684\u7a7a\u95f2\u5757\u3002  \u4e0b\u4e00\u6b21\u9002\u914d \u4ece\u4e0a\u4e00\u6b21\u67e5\u8be2\u7ed3\u675f\u7684\u5730\u65b9\u5f00\u59cb\u3002  \u6700\u4f73\u9002\u914d \u68c0\u67e5\u6bcf\u4e2a\u7a7a\u95f2\u5757\uff0c\u9009\u62e9\u9002\u5408\u6240\u9700\u8bf7\u6c42\u5927\u5c0f\u7684\u6700\u5c0f\u7a7a\u95f2\u5757\u3002", 
            "title": "7.2.3 \u653e\u7f6e\u5df2\u5206\u914d\u7684\u5757"
        }, 
        {
            "location": "/csapp/ch9/#73", 
            "text": "\u9690\u5f0f\u7a7a\u95f2\u5217\u8868 Implicit Free List  \u663e\u5f0f\u7a7a\u95f2\u5217\u8868 Explicit Free List  \u5206\u79bb\u5f0f\u7a7a\u95f2\u5217\u8868 Segregated Free List", 
            "title": "7.3 \u5b9e\u73b0\u65b9\u6cd5"
        }, 
        {
            "location": "/csapp/ch9/#731", 
            "text": "\u9690\u5f0f\u7a7a\u95f2\u94fe\u8868\u4f18\u70b9\u662f\u7b80\u5355\uff0c\u7f3a\u70b9\u662f\u64cd\u4f5c\u5f00\u9500\u5927\u3002\u56e0\u4e3a\u65e0\u8bba\u662f\u5206\u914d\u8fd8\u662f\u91ca\u653e\u5757\uff0c\u90fd\u9700\u8981\u5bf9\u9690\u5f0f\u7a7a\u95f2\u5217\u8868\u8fdb\u884c\u641c\u7d22\uff0c\u590d\u6742\u5ea6\u662f O(n) O(n) \uff0c n n \u662f\u5df2\u5206\u914d\u5757\u548c\u7a7a\u95f2\u5757\u7684\u603b\u6570\u3002", 
            "title": "7.3.1 \u9690\u5f0f\u7a7a\u95f2\u5217\u8868"
        }, 
        {
            "location": "/csapp/ch9/#732", 
            "text": "", 
            "title": "7.3.2 \u663e\u5f0f\u7a7a\u95f2\u5217\u8868"
        }, 
        {
            "location": "/csapp/ch9/#733", 
            "text": "", 
            "title": "7.3.3 \u5206\u79bb\u5f0f\u7a7a\u95f2\u5217\u8868"
        }, 
        {
            "location": "/csapp/ch9/#8", 
            "text": "\u5783\u573e\u6536\u96c6\u5668 (garbage collector)\u662f\u4e00\u79cd\u52a8\u6001\u5185\u5b58\u5206\u914d\u5668\uff0c\u5b83\u81ea\u52a8\u91ca\u653e\u7a0b\u5e8f\u4e0d\u518d\u9700\u8981\u7684\u5df2\u5206\u914d\u5757\u3002\u8fd9\u4e9b\u5757\u88ab\u79f0\u4f5c \u5783\u573e (garbage)\u3002\u81ea\u52a8\u56de\u6536\u5b58\u50a8\u7684\u8fc7\u7a0b\u53eb\u505a \u5783\u573e\u6536\u96c6 (garbage collection)\u3002  Java Garbage Collection  \u5783\u573e\u6536\u96c6\u5668\u5c06\u5185\u5b58\u89c6\u4e3a\u4e00\u5f20\u6709\u5411 \u53ef\u8fbe\u56fe (reachability graph)\u3002   \u56fe\u7684\u8282\u70b9\u88ab\u5206\u6210\u4e00\u7ec4 \u6839\u8282\u70b9 (root node)\u548c\u4e00\u7ec4 \u5806\u8282\u70b9 (heap node).   \u6709\u5411\u8fb9 p\\rightarrow q p\\rightarrow q \u610f\u5473\u7740\u5757 p p \u4e2d\u7684\u67d0\u4e2a\u4f4d\u7f6e\u6307\u5411\u5757 q q \u4e2d\u7684\u67d0\u4e2a\u4f4d\u7f6e\u3002  \u6839\u8282\u70b9\u4e0d\u5728\u5806\u4e2d\uff0c\u5305\u542b\u6307\u5411\u5806\u4e2d\u7684\u6307\u9488\u3002  \u5f53\u5b58\u5728\u4e00\u6761\u4ece\u4efb\u610f\u6839\u8282\u70b9\u51fa\u53d1\u5e76\u5230\u8fbe p p \u7684\u6709\u5411\u8def\u5f84\u65f6\uff0c\u8282\u70b9 p p \u662f \u53ef\u8fbe \u7684\u3002  \u5783\u573e\u6536\u96c6\u5668\u7ef4\u62a4\u53ef\u8fbe\u56fe\u7684\u67d0\u79cd\u8868\u793a\uff0c\u5e76\u91ca\u653e\u4e0d\u53ef\u8fbe\u8282\u70b9\u3002", 
            "title": "8 \u5783\u573e\u6536\u96c6"
        }, 
        {
            "location": "/csapp/ch9/#9-c", 
            "text": "", 
            "title": "9 C\u7a0b\u5e8f\u4e2d\u5e38\u89c1\u7684\u4e0e\u5185\u5b58\u6709\u5173\u7684\u9519\u8bef"
        }, 
        {
            "location": "/csapp/ch9/#_4", 
            "text": "\u8fd9\u662f\u975e\u5e38\u5e38\u89c1\u7684\u4f8b\u5b50\uff0c\u6ca1\u6709\u5f15\u7528\u5bf9\u5e94\u7684\u5730\u5740\uff0c\u5c11\u4e86   int   val ;  scanf ( %d ,   val );   // \u6b63\u786e\u5e94\u8be5\u662fscanf( %d,  val);", 
            "title": "\u95f4\u63a5\u5f15\u7528\u574f\u6307\u9488"
        }, 
        {
            "location": "/csapp/ch9/#_5", 
            "text": "\u5806\u5185\u5b58\u662f\u6ca1\u6709\u88ab\u521d\u59cb\u5316\u4e3a0\u7684 \uff1a  /* return y = Ax */  int   * matvec ( int   ** A ,   int   * x )   { \n     int   * y   =   malloc ( N   *   sizeof ( int )); \n     int   i ,   j ; \n\n     for   ( i   =   0 ;   i     N ;   i ++ ) \n         for   ( j   =   0 ;   j     N ;   j ++ ) \n             y [ i ]   +=   A [ i ][ j ]   *   x [ j ]; \n     return   y ;  }   \u6b63\u786e\u7684\u65b9\u6cd5\u662f\u663e\u5f0f\u5730\u5c06y[i]\u8bbe\u7f6e\u4e3a0\uff0c\u6216\u8005\u4f7f\u7528 calloc \u3002", 
            "title": "\u8bfb\u672a\u521d\u59cb\u5316\u7684\u5185\u5b58"
        }, 
        {
            "location": "/csapp/ch9/#_6", 
            "text": "\u6ca1\u6709\u68c0\u67e5\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\uff08\u7ecf\u5178\u7684\u7f13\u51b2\u533a\u6ea2\u51fa\u653b\u51fb\u4e5f\u662f\u5229\u7528\u76f8\u540c\u7684\u673a\u5236\uff09  char   s [ 8 ];  int   i ;  gets ( s );   /* stack buffer overflow, reads  123456789  from stdin */", 
            "title": "\u5141\u8bb8\u6808\u7f13\u51b2\u533a\u6ea2\u51fa"
        }, 
        {
            "location": "/csapp/ch9/#_7", 
            "text": "\u5c3d\u7ba1\u6307\u9488\u4ecd\u7136\u6307\u5411\u4e00\u4e2a\u5408\u6cd5\u7684\u5185\u5b58\u5730\u5740\uff0c\u4f46\u662f\u5df2\u7ecf\u4e0d\u518d\u6307\u5411\u4e00\u4e2a\u5408\u6cd5\u7684\u53d8\u91cf\u4e86\u3002\u4ee5\u540e\u5728\u7a0b\u5e8f\u4e2d\u8c03\u7528\u5176\u4ed6\u51fd\u6570\u65f6\uff0c\u5185\u5b58\u5c06\u91cd\u7528\u5b83\u4eec\u7684\u6808\u9488\u3002  int   * foo ()   { \n     int   val ; \n\n     return   val ;  }", 
            "title": "\u5f15\u7528\u4e0d\u5b58\u5728\u7684\u53d8\u91cf"
        }, 
        {
            "location": "/csapp/ch9/#_8", 
            "text": "\u8fd9\u4e2a\u4e0d\u7528\u591a\u8bf4\uff0c\u4e0d\u80fd\u91cd\u590d\u641e\u4e24\u6b21  x   =   malloc ( N   *   sizeof ( int ));  //   manipulate x  free ( x );  y   =   malloc ( M   *   sizeof ( int ));  //   manipulate y  free ( x );", 
            "title": "\u591a\u6b21\u91ca\u653e"
        }, 
        {
            "location": "/csapp/ch9/#_9", 
            "text": "\u540c\u6837\u662f\u5f88\u660e\u663e\u7684\u9519\u8bef\uff0c\u4e0d\u8981\u72af  x   =   malloc ( N   *   sizeof ( int ));  //   manipulate x  free ( x );  //  ....  y   =   malloc ( M   *   sizeof ( int ));  for   ( i   =   0 ;   i     M ;   i ++ ) \n     y [ i ]   =   x [ i ] ++ ;", 
            "title": "\u5f15\u7528\u5df2\u7ecf\u88ab\u91ca\u653e\u7684\u5806\u5757\u4e2d\u7684\u6570\u636e"
        }, 
        {
            "location": "/csapp/ch9/#_10", 
            "text": "foo ()   { \n     int   * x   =   malloc ( N   *   sizeof ( int )); \n     // ... \n     return   ;  }   \u6216\u8005\u53ea\u91ca\u653e\u4e86\u6570\u636e\u7ed3\u6784\u7684\u4e00\u90e8\u5206\uff1a  struct   list   { \n     int   val ; \n     struct   list   * next ;  };  foo ()   { \n     struct   list   * head   =   malloc ( sizeof ( struct   list )); \n     head - val   =   0 ; \n     head - next   =   NULL ; \n     //... \n     free ( head ); \n     return ;  }", 
            "title": "\u5fd8\u8bb0\u91ca\u653e\u5df2\u5206\u914d\u5757\uff1a"
        }, 
        {
            "location": "/csapp/ch10/", 
            "text": "Chapter 10 \u7cfb\u7edf\u7ea7I/O", 
            "title": "Chapter 10: \u7cfb\u7edf\u7ea7I/O"
        }, 
        {
            "location": "/csapp/ch10/#chapter-10-io", 
            "text": "", 
            "title": "Chapter 10 \u7cfb\u7edf\u7ea7I/O"
        }, 
        {
            "location": "/csapp/ch11/", 
            "text": "Chapter 11 \u7f51\u7edc\u7f16\u7a0b\n\n\n1 \u5ba2\u6237\u7aef-\u670d\u52a1\u5668\u7f16\u7a0b\u6a21\u578b\n\n\n\u6bcf\u4e2a\u7f51\u7edc\u5e94\u7528\u90fd\u662f\u57fa\u4e8e\n\u5ba2\u6237\u7aef-\u670d\u52a1\u5668\n\u6a21\u578b\u7684\u3002\n\n\n\u5ba2\u6237\u7aef-\u670d\u52a1\u5668\u6a21\u578b\u4e2d\u7684\u57fa\u672c\u64cd\u4f5c\u662f\n\u4e8b\u52a1\n(transaction)\u3002\u4e00\u4e2a\u5ba2\u6237\u7aef-\u670d\u52a1\u5668\u4e8b\u52a1\u7531\u4ee5\u4e0b\u56db\u6b65\u7ec4\u6210\uff1a\n\n\n\n\n\u5f53\u4e00\u4e2a\u5ba2\u6237\u7aef\u9700\u8981\u670d\u52a1\u65f6\uff0c\u5b83\u5411\u670d\u52a1\u5668\u53d1\u9001\u4e00\u4e2a\u8bf7\u6c42\uff0c\u53d1\u8d77\u4e00\u4e2a\u4e8b\u52a1\u3002\n\n\n\u670d\u52a1\u5668\u6536\u5230\u8bf7\u6c42\u540e\uff0c\u89e3\u91ca\u5b83\uff0c\u5e76\u4ee5\u9002\u5f53\u7684\u65b9\u5f0f\u64cd\u4f5c\u5b83\u7684\u8d44\u6e90\u3002\n\n\n\u670d\u52a1\u5668\u7ed9\u5ba2\u6237\u7aef\u53d1\u9001\u4e00\u4e2a\u54cd\u5e94\uff0c\u5e76\u7b49\u5f85\u4e0b\u4e00\u4e2a\u8bf7\u6c42\u3002\n\n\n\u5ba2\u6237\u7aef\u6536\u5230\u54cd\u5e94\u5e76\u5904\u7406\u5b83\u3002\n\n\n\n\n\n\n\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u662f\u8fdb\u7a0b\n\uff0c\u800c\u4e0d\u662f\u5e38\u63d0\u5230\u7684\u673a\u5668\u6216\u8005\u4e3b\u673a\u3002\n\n\n\n\n\u4e00\u53f0\u4e3b\u673a\u53ef\u4ee5\u540c\u65f6\u8fd0\u884c\u8bb8\u591a\u4e0d\u540c\u7684\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\n\n\n\u4e00\u4e2a\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u7684\u4e8b\u52a1\u53ef\u4ee5\u5728\u540c\u4e00\u53f0\u6216\u662f\u4e0d\u540c\u7684\u4e3b\u673a\u4e0a\u3002\n\n\n\n\n2 \u7f51\u7edc\n\n\n\u5bf9\u4e3b\u673a\u800c\u8a00\uff0c\u7f51\u7edc\u53ea\u662f\u53c8\u4e00\u79cdI/O\u8bbe\u5907\uff0c\u662f\u6570\u636e\u6e90\u548c\u6570\u636e\u63a5\u6536\u65b9\u3002\u7269\u7406\u4e0a\u800c\u8a00\uff0c\u7f51\u7edc\u662f\u4e00\u4e2a\u6309\u7167\u5730\u7406\u8fdc\u8fd1\u7ec4\u6210\u7684\u5c42\u6b21\u7cfb\u7edf\u3002\n\n\n\u7f51\u7edc\u5c42\u6b21\u7cfb\u7edf\n\n\n(1) \u6700\u5e95\u5c42\uff1a\u4ee5\u592a\u7f51\u6bb5\n\n\u5c40\u57df\u7f51\n(LAN, Local Area Network)\u7684\u8303\u56f4\u4e00\u822c\u9650\u5236\u5728\u4e00\u4e2a\u5efa\u7b51\u6216\u8005\u6821\u56ed\u5185\u3002\u6700\u6d41\u884c\u7684\u5c40\u57df\u7f51\u6280\u672f\u662f\n\u4ee5\u592a\u7f51\n(Ethernet)\uff0c\u7531\u7535\u7f06\u548c\u96c6\u7ebf\u5668(hub)\u7ec4\u6210\u4e00\u4e2a\u4ee5\u592a\u7f51\u6bb5\u3002\n\n\n\n\n(2) \u6865\u63a5\u4ee5\u592a\u7f51\n\n\u6865\u63a5\u4ee5\u592a\u7f51\n(bridged Ethernet)\u662f\u5c06\u4ee5\u592a\u7f51\u6bb5\u7528\u7535\u7f06\u548c\u7f51\u6865(bridge)\u8fde\u63a5\u6210\u7684\u8f83\u5927\u7684\u5c40\u57df\u7f51\u3002\n\n\n\n(3) \u4e92\u8054\u7f51\u7edc\n\u591a\u4e2a\u4e0d\u517c\u5bb9\u7684\u5c40\u57df\u7f51\u53ef\u4ee5\u901a\u8fc7\u8def\u7531\u5668(routers)\u8fde\u63a5\u6210\u4e92\u8054\u7f51\u7edc(internets)\u3002\n\n\n\n\n\u7f51\u7edc\u534f\u8bae\n\n\n\u4e92\u8054\u7f51\u7edc\u662f\u7531\u5404\u79cd\u5c40\u57df\u7f51\u548c\u5e7f\u57df\u7f51\u7ec4\u6210\uff0c\u5b83\u4eec\u91c7\u7528\u5b8c\u5168\u4e0d\u540c\u4e14\u4e0d\u517c\u5bb9\u7684\u6280\u672f\u3002\u90a3\u4e48\u5982\u4f55\u80fd\u8ba9\u67d0\u53f0\u4e3b\u673a\u8de8\u8fc7\u6240\u6709\u4e0d\u517c\u5bb9\u7684\u7f51\u7edc\u53d1\u9001\u6570\u636e\u4f4d\u5230\u53e6\u4e00\u53f0\u76ee\u7684\u4e3b\u673a\u5462\uff1f\n\n\n\u89e3\u51b3\u65b9\u6cd5\uff1a\u4e00\u5c42\u8fd0\u884c\u5728\u6bcf\u53f0\u4e3b\u673a\u548c\u8def\u7531\u5668\u4e0a\u7684\n\u534f\u8bae\n\u8f6f\u4ef6\uff0c\u5b83\u6d88\u9664\u4e86\u4e0d\u540c\u7f51\u7edc\u4e4b\u95f4\u7684\u5dee\u5f02\u3002\u534f\u8bae\u63d0\u4f9b\u4e86\u4e24\u79cd\u57fa\u672c\u80fd\u529b\uff1a\n\n \u63d0\u4f9b\u4e86\u547d\u540d\u673a\u5236\n    * \u5b9a\u4e49\u4e00\u81f4\u7684\n\u4e3b\u673a\u5730\u5740\n(host adress)\u683c\u5f0f\n    * \u6bcf\u53f0\u4e3b\u673a\u4f1a\u88ab\u5206\u914d\u81f3\u5c11\u4e00\u4e2a\n\u4e92\u8054\u7f51\u7edc\u5730\u5740\n(internet address)\uff0c\u5730\u5740\u552f\u4e00\u5730\u6807\u8bc6\u4e86\u4e3b\u673a\n\n \u63d0\u4f9b\u4e86\u4f20\u9001\u673a\u5236\n    * \u5b9a\u4e49\u4e86\u7edf\u4e00\u7684\u57fa\u672c\u4f20\u9001\u5355\u4f4d-\n\u5305\n(packet)\n    * \u5305\u7531\n\u5305\u5934\n(header)\u548c\n\u6709\u6548\u8f7d\u8377\n(payload)\u7ec4\u6210\n        * \u5305\u5934\u5305\u62ec\u5305\u7684\u5927\u5c0f\u4ee5\u53ca\u6e90\u4e3b\u673a\u548c\u76ee\u7684\u4e3b\u673a\u7684\u5730\u5740\n        * \u6709\u6548\u8f7d\u8377\u5305\u62ec\u4ece\u6e90\u4e3b\u673a\u53d1\u51fa\u7684\u6570\u636e\u4f4d\n\n\n![Transferring Internet Data Via Encapsulation](figure/Transferring%20Internet%20Data%20Via%20Encapsulation.png)\n\n\n\n\n\nPH: Internet packet header, \u4e92\u8054\u7f51\u7edc\u5305\u5934\nFH: LAN frame header, \u5c40\u57df\u7f51\u5e27\u5934\n\n\n3 \u5168\u7403IP\u56e0\u7279\u7f51\n\n\n\u5168\u7403IP\u56e0\u7279\u7f51(Global IP Internet)\u662f\u6700\u8457\u540d\u548c\u6700\u6210\u529f\u7684\u4e92\u8054\u7f51\u7edc(internet)\u5b9e\u73b0\u3002\u6bcf\u53f0\u56e0\u7279\u7f51\u4e3b\u673a\u90fd\u8fd0\u884c\u5b9e\u73b0TCP/IP\u534f\u8bae\u7684\u8f6f\u4ef6\uff0c\u4f7f\u7528\u5957\u63a5\u5b57\u63a5\u53e3(sockets interface)\u51fd\u6570\u548cUnix I/O\u51fd\u6570\u6765\u901a\u4fe1\u3002\n\n\n\n\n\u4ece\u7a0b\u5e8f\u5458\u7684\u89d2\u5ea6\uff1a\n\n \u4e3b\u673a\u88ab\u6620\u5c04\u4e3a\u4e00\u7ec432\u4f4d\u7684\nIP\u5730\u5740\n(IP addresses)\n    * 128.2.203.179\n\n IP\u5730\u5740\u88ab\u6620\u5c04\u4e3a\u4e00\u7ec4\u6807\u8bc6\u7b26\uff0c\u53eb\u505a\n\u57df\u540d\n(domain name)\n* \u56e0\u7279\u7f51\u4e3b\u673a\u4e0a\u7684\u8fdb\u7a0b\u80fd\u591f\u901a\u8fc7\n\u8fde\u63a5\n\u548c\u4efb\u4f55\u5176\u4ed6\u56e0\u7279\u7f51\u4e3b\u673a\u4e0a\u7684\u8fdb\u7a0b\u901a\u4fe1\u3002\n\n\nIP\u5730\u5740\n\n\n32\u4f4dIP\u5730\u5740\u5b58\u5728\u4e00\u4e2aIP\u5730\u5740\u7ed3\u6784(\nin_addr\n)\u4e2d\n* IP\u5730\u5740\u5728\u5185\u5b58\u4e2d\u662f\u4ee5\n\u7f51\u7edc\u5b57\u8282\u987a\u5e8f\n(network byte order, \u5927\u7aef\u6cd5)\u5b58\u653e\u7684\n\n\n/* Internet address structure */\n \n\nstruct\n \nin_addr\n \n{\n \n    \nuint32_t\n \ns_addr\n;\n \n/* network byte order (big-endian) */\n \n\n};\n\n\n\n\n\n\u57df\u540d\n\n\n\u57df\u540d\n(domain names)\u662f\u4e00\u4e32\u7528\u53e5\u70b9\u5206\u9694\u7684\u5355\u8bcd(\u5b57\u6bcd\u3001\u6570\u5b57\u548c\u7834\u6298\u53f7)\u3002\u57df\u540d\u96c6\u5408\u5f62\u6210\u4e86\u4e00\u4e2a\u5c42\u6b21\u7ed3\u6784\uff0c\u53ef\u4ee5\u8868\u793a\u4e3a\u4e00\u68f5\u6811\u3002\n\n\n\n\n\u57df\u540d\u7cfb\u7edf\n(Domain Naming System, DNS)\u662f\u6620\u5c04IP\u5730\u5740\u548c\u57df\u540d\u7684\u6570\u636e\u5e93\u3002\u53ef\u4ee5\u628aDNS\u6570\u636e\u5e93\u89c6\u4e3a\u4e0a\u767e\u4e07\u7684\n\u4e3b\u673a\u6761\u76ee\u7ed3\u6784\n(host entry structure)\u7684\u96c6\u5408\uff0c\u5176\u4e2d\u6bcf\u6761\u5b9a\u4e49\u4e86\u4e00\u7ec4\u57df\u540d\u548c\u4e00\u7ec4IP\u5730\u5740\u4e4b\u95f4\u7684\u6620\u5c04\u3002\n\n\n\n\nDNS\u6620\u5c04\uff0c\u53ef\u4ee5\u901a\u8fc7\nnsloopup\n\u67e5\u770b\n\n\n\u5728\u6700\u7b80\u5355\u7684\u60c5\u51b5\u4e2d\uff0c\u4e00\u4e2a\u57df\u540d\u548c\u4e00\u4e2aIP\u5730\u5740\u4e4b\u95f4\u662f\u4e00\u4e00\u6620\u5c04\n\n\nnslookup whaleshark.ics.cs.cmu.edu\n - \nAddress\n:\n \n128.2\n.\n210.175\n\n\n\n\n\n\n\u7136\u800c\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u591a\u4e2a\u57df\u540d\u53ef\u4ee5\u6620\u5c04\u4e3a\u540c\u4e00\u4e2aIP\u5730\u5740\n\n\nnslookup cs.mit.edu/ nslookup eecs.mit.edu\n - \nAddress\n:\n \n18.62\n.\n1.6\n\n\n\n\n\n\n\u5728\u6700\u901a\u5e38\u7684\u60c5\u51b5\u4e0b\uff0c\u591a\u4e2a\u57df\u540d\u53ef\u4ee5\u6620\u5c04\u5230\u540c\u4e00\u7ec4\u7684\u591a\u4e2aIP\u5730\u5740\n\n\nnslookup www.twitter.com\n - \nAddress\n:\n \n199.16\n.\n156.6\n, \nAddress\n:\n199.16\n.\n156.70\n\n\n\n\n\n\n\n\n\u56e0\u7279\u7f51\u8fde\u63a5\n\n\n\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u901a\u8fc7\n\u8fde\u63a5\n(connections)\u53d1\u9001\u5b57\u8282\u6d41\u6765\u901a\u4fe1\uff0c\u6bcf\u4e00\u4e2a\u8fde\u63a5\u90fd\u6709\u5982\u4e0b\u7279\u70b9\uff1a\n\n\n\n\n\u70b9\u5bf9\u70b9(point-to-point)\uff1a\u8fde\u63a5\u4e00\u5bf9\u8fdb\u7a0b\n\n\n\u5168\u53cc\u5de5(full-duplex)\uff1a\u6570\u636e\u53ef\u4ee5\u540c\u65f6\u5728\u4e24\u4e2a\u65b9\u5411\u4f20\u9001\n\n\n\u53ef\u9760\u6027(reliable)\uff1a\u53d1\u9001\u548c\u63a5\u6536\u7684\u5b57\u8282\u6d41\u987a\u5e8f\u76f8\u540c\n\n\n\n\n\u5957\u63a5\u5b57(sockets)\u662f\u8fde\u63a5\u7684\u7aef\u70b9\uff0c\u5957\u63a5\u5b57\u5730\u5740\u7528 \u201c\u5730\u5740\uff1a\u7aef\u53e3\u201d\u6765\u8868\u793a\u3002\n* \u7aef\u53e3(port)\u662f\u4e00\u4e2a16\u4f4d\u6574\u6570\uff0c\u6807\u8bc6\u4e86\u4e00\u4e2a\u8fdb\u7a0b\u3002\n    * \u4e34\u65f6\u7aef\u53e3\uff1a\u5f53\u53ef\u4f1a\u6de1\u53d1\u8d77\u8fde\u63a5\u8bf7\u6c42\u65f6\uff0c\u5185\u6838\u81ea\u52a8\u5206\u914d\u7684\u7aef\u53e3\n    * \u77e5\u540d\u7aef\u53e3\uff1a\u548c\u670d\u52a1\u5668\u63d0\u4f9b\u7684\u670d\u52a1\u6709\u77ed\u7684\u7aef\u53e3 (\n        * Web\u670d\u52a1\u5668\u4f7f\u7528\u7aef\u53e380\n        * ssh\u670d\u52a1\u5668\u4f7f\u7528\u7aef\u53e322\n        * email\u670d\u52a1\u5668\u4f7f\u7528\u7aef\u53e325\n\n\n\u4e00\u4e2a\u8fde\u63a5\u662f\u7531\u5b83\u4e24\u7aef\u7684\u5957\u63a5\u5b57\u5730\u5740\u552f\u4e00\u786e\u5b9a\u7684\uff08\u5957\u63a5\u5b57\u5bf9, socket pair\uff09\u3002\n\n\n\n\n\u4f7f\u7528\u7aef\u53e3\u6765\u8bc6\u522b\u670d\u52a1\n\n\n\n\n4 \u5957\u63a5\u5b57\u63a5\u53e3\n\n\n\u4ec0\u4e48\u662f\u5957\u63a5\u5b57\uff1f\n\n \u5bf9\u4e8e\u5185\u6838\u6765\u8bf4\uff0c\u5957\u63a5\u5b57\u662f\u901a\u4fe1\u7684\u7aef\u70b9\u3002 To the kernel, a socket is an endpoint of communication\n\n \u5bf9\u4e8e\u5e94\u7528\u6765\u8bf4\uff0c\u5957\u63a5\u5b57\u662f\u8ba9\u5e94\u7528\u4ece\u7f51\u7edc\u8bfb\u5199\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 To an application, a socket is a file descriptor that lets the application read/write from/to the network.\n\n\n\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u901a\u8fc7\u5bf9\u5957\u63a5\u5b57\u63cf\u8ff0\u7b26\u8bfb\u5199\u8fdb\u884c\u901a\u4fe1\uff1a\n\n\n\n\n(1) \u901a\u7528\u5957\u63a5\u5b57\u5730\u5740(generic socket address)\uff1a\n\n \u4ee5\u5957\u63a5\u5b57\u5730\u5740\u4f5c\u4e3a\nconnect()\n, \nbind()\n, \naccept\n\u7684\u5b9e\u53c2\n\n \u4ec5\u4ec5\u56e0\u4e3a\u90a3\u65f6\u7684C\u4e0d\u5b58\u5728\nvoid *\n\u6307\u9488\uff0c\u6240\u4ee5\u5957\u63a5\u5b57\u63a5\u53e3\u88ab\u8bbe\u8ba1\u6210\u8fd9\u6837\u3002\n\n\nstruct\n \nsockaddr\n \n{\n \n    \nuint16_t\n \nsa_family\n;\n \n/* Protocol family */\n\n    \nchar\n \nsa_data\n[\n14\n];\n \n};\n \n/* Address data. */\n\n\n\n(2) \u56e0\u7279\u7f51\u7684\u5957\u63a5\u5b57\u5730\u5740\n* \u5fc5\u987b\u5c06\nstruct sockaddr_in *\n \u8f6c\u6362\u4e3a \nstruct sockaddr *\n\u624d\u80fd\u4ee5\u5957\u63a5\u5b57\u5730\u5740\u4f5c\u4e3a\u51fd\u6570\u5b9e\u53c2\n\n\nstruct\n \nsockaddr_in\n \n{\n\n    \nuint16_t\n \nsin_family\n;\n\n    \nuint16_t\n \nsin_port\n;\n\n    \nstruct\n \nin_addr\n \nsin_addr\n;\n\n    \nunsigned\n \nchar\n \nsin_zero\n[\n8\n];\n\n    \n};\n\n\n\n\n\n\n\n\n\n\u5f00\u542f\u670d\u52a1\u5668(start server)\n\n\ngetaddrinfo\n: \u628a\u4e3b\u673a\u540d(hostname\uff09\u3001\u4e3b\u673a\u5730\u5740(host addresses)\u3001\u7aef\u53e3(ports)\u548c\u670d\u52a1\u540d(service names)\u8f6c\u6362\u4e3a\u5957\u63a5\u5b57\u5730\u5740\u7ed3\u6784\u3002\n\n\nsocket\n: \u521b\u5efa\u4e00\u4e2a\u5957\u63a5\u5b57\u63cf\u8ff0\u7b26(socket descriptor)\uff0c\u4e5f\u5c31\u662f\u4e4b\u540e\u7528\u6765\u8bfb\u5199\u7684 file descriptor\n\n\nbind\n: \u8bf7\u6c42\u5185\u6838\u628a\u5957\u63a5\u5b57\u5730\u5740\u548c\u5957\u63a5\u5b57\u63cf\u8ff0\u7b26\u7ed1\u5b9a\n\n\nlisten\n: \u5c06\u5957\u63a5\u5b57\u63cf\u8ff0\u7b26\u4ece\u4e00\u4e2a\u4e3b\u52a8\u5957\u63a5\u5b57\u8f6c\u6362\u4e3a\u76d1\u542c\u5957\u63a5\u5b57(listening socket)\uff0c\u8be5\u5957\u63a5\u5b57\u53ef\u4ee5\u63a5\u53d7\u6765\u81ea\u5ba2\u6237\u7aef\u7684\u8fde\u63a5\u8bf7\u6c42\n\n\naccept\n: \u7b49\u5f85\u6765\u81ea\u5ba2\u6237\u7aef\u7684\u8fde\u63a5\u8bf7\u6c42\n\n\n\n\n\n\n\u5f00\u542f\u5ba2\u6237\u7aef(start client)\n\n\ngetaddrinfo\n, \nsocket\n\u4e0e\u5f00\u542f\u670d\u52a1\u5668\u76f8\u540c\n\n\nconnect\n: \u8bd5\u56fe\u4e0e\u670d\u52a1\u5668\u5efa\u7acb\u8fde\u63a5\n\n\n\n\n\n\n\n\nEcho\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u793a\u4f8b\n\n\n\u5728\u548c\u670d\u52a1\u5668\u5efa\u7acb\u8fde\u63a5\u4e4b\u540e\uff0c\u5ba2\u6237\u7aef\u8fdb\u5165\u4e00\u4e2a\u5faa\u73af\uff0c\u53cd\u590d\u4ece\u6807\u51c6\u8f93\u5165\u8bfb\u53d6\u6587\u672c\u884c\uff0c\u53d1\u9001\u6587\u672c\u884c\u7ed9\u670d\u52a1\u5668\uff0c\u4ece\u670d\u52a1\u5668\u8bfb\u53d6\u56de\u9001\u7684\u884c\uff0c\u5e76\u8f93\u51fa\u7ed3\u679c\u5230\u63a5\u51c6\u8f93\u51fa\u3002\n\n\n#include\n \ncsapp.h\n\n\nint\n \nmain\n \n(\nint\n \nargc\n,\n \nchar\n \n**\nargv\n)\n \n{\n\n    \nint\n \nclientfd\n;\n\n    \nchar\n \n*\nhost\n,\n \n*\nport\n,\n \nbuf\n[\nMAXLINE\n];\n\n    \nrio_t\n \nrio\n;\n\n\n    \nhost\n \n=\n \nargv\n[\n1\n];\n\n    \nport\n \n=\n \nargv\n[\n2\n];\n\n\n    \n//\u548c\u670d\u52a1\u5668\u5efa\u7acb\u8fde\u63a5\n\n    \nclientfd\n \n=\n \nOpen_clientfd\n(\nhost\n,\n \nport\n);\n\n    \nRio_readinitb\n(\nrio\n,\n \nclientfd\n);\n\n\n    \nwhile\n \n(\nFgets\n(\nbuf\n,\n \nMAXLINE\n,\n \nstdin\n)\n \n!=\n \nNULL\n)\n \n{\n\n        \n// \u5199\u5165\uff0c\u4e5f\u5c31\u662f\u5411\u670d\u52a1\u5668\u53d1\u9001\u4fe1\u606f\n\n        \nRio_writen\n(\nclientfd\n,\n \nbuf\n,\n \nstrlen\n(\nbuf\n));\n\n        \n// \u8bfb\u53d6\uff0c\u4e5f\u5c31\u662f\u4ece\u670d\u52a1\u5668\u63a5\u6536\u4fe1\u606f\n\n        \nRio_readlineb\n(\nrio\n,\n \nbuf\n,\n \nMAXLINE\n);\n\n        \n// \u628a\u4ece\u670d\u52a1\u5668\u63a5\u6536\u7684\u4fe1\u606f\u663e\u793a\u5728\u8f93\u51fa\u4e2d\n\n        \nFputs\n(\nbuf\n,\n \nstdout\n);\n\n    \n}\n\n    \nClose\n(\nclientfd\n);\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\n\n\n\n\u670d\u52a1\u5668\u5728\u6253\u5f00\u76d1\u542c\u63cf\u8ff0\u7b26\u540e\uff0c\u8fdb\u5165\u4e00\u4e2a\u65e0\u9650\u5faa\u73af\u3002\u6bcf\u6b21\u5faa\u73af\u90fd\u7b49\u5f85\u4e00\u4e2a\u6765\u81ea\u5ba2\u6237\u7aef\u7684\u8fde\u63a5\u8bf7\u6c42\uff0c\u8f93\u51fa\u5df2\u8fde\u63a5\u5ba2\u6237\u7aef\u7684\u57df\u540d\u548cIP\u5730\u5740\uff0c\u5e76\u8c03\u7528\necho\n\u51fd\u6570\u4e3a\u8fd9\u4e9b\u5ba2\u6237\u7aef\u670d\u52a1\u3002\u5728\necho\n\u7a0b\u5e8f\u8fd4\u56de\u540e\uff0c\u4e3b\u7a0b\u5e8f\u5173\u95ed\u5df2\u8fde\u63a5\u63cf\u8ff0\u7b26\u3002\n\n\n#include\n \ncsapp.h\n\n\nvoid\n \necho\n(\nint\n \nconnfd\n);\n\n\nint\n \nmain\n(\nint\n \nargc\n,\n \nchar\n \n**\nargv\n){\n\n    \nint\n \nlistenfd\n,\n \nconnfd\n;\n\n    \nsocklen_t\n \nclientlen\n;\n\n    \nstruct\n \nsockaddr_storage\n \nclientaddr\n;\n \n// Enough room for any addr\n\n    \nchar\n \nclient_hostname\n[\nMAXLINE\n],\n \nclient_port\n[\nMAXLINE\n];\n\n\n    \n// \u5f00\u542f\u76d1\u542c\u7aef\u53e3\uff0c\u6ce8\u610f\u53ea\u5f00\u8fd9\u4e48\u4e00\u6b21\n\n    \nlistenfd\n \n=\n \nOpen_listenfd\n(\nargv\n[\n1\n]);\n\n    \nwhile\n \n(\n1\n)\n \n{\n\n        \n// \u9700\u8981\u5177\u4f53\u7684\u5927\u5c0f\n\n        \nclientlen\n \n=\n \nsizeof\n(\nstruct\n \nsockaddr_storage\n);\n \n// Important!\n\n        \n// \u7b49\u5f85\u8fde\u63a5\n\n        \nconnfd\n \n=\n \nAccept\n(\nlistenfd\n,\n \n(\nSA\n \n*\n)\nclientaddr\n,\n \nclientlen\n);\n\n        \n// \u83b7\u53d6\u5ba2\u6237\u7aef\u76f8\u5173\u4fe1\u606f\n\n        \nGetnameinfo\n((\nSA\n \n*\n)\n \nclientaddr\n,\n \nclientlen\n,\n \nclient_hostname\n,\n\n                     \nMAXLINE\n,\n \nclient_port\n,\n \nMAXLINE\n,\n \n0\n);\n\n        \nprintf\n(\nConnected to (%s, %s)\n\\n\n,\n \nclient_hostname\n,\n \nclient_port\n);\n\n        \n// \u670d\u52a1\u5668\u5177\u4f53\u5b8c\u6210\u7684\u5de5\u4f5c\n\n        \necho\n(\ncoonfd\n);\n\n        \nClose\n(\nconnfd\n);\n\n    \n}\n\n    \nexit\n(\n0\n);\n\n\n}\n\n\nvoid\n \necho\n(\nint\n \nconnfd\n)\n \n{\n\n    \nsize_t\n \nn\n;\n\n    \nchar\n \nbuf\n[\nMAXLINE\n];\n\n    \nrio_t\n \nrio\n;\n\n\n    \n// \u8bfb\u53d6\u4ece\u5ba2\u6237\u7aef\u4f20\u8f93\u8fc7\u6765\u7684\u6570\u636e\n\n    \nRio_readinitb\n(\nrio\n,\n \nconnfd\n);\n\n    \nwhile\n((\nn\n \n=\n \nRio_readlineb\n(\nrio\n,\n \nbuf\n,\n \nMAXLINE\n))\n \n!=\n \n0\n)\n \n{\n\n        \nprintf\n(\nserver received %d bytes\n\\n\n,\n \n(\nint\n)\nn\n);\n\n        \n// \u628a\u4ece client \u63a5\u6536\u5230\u7684\u4fe1\u606f\u518d\u5199\u56de\u53bb\n\n        \nRio_writen\n(\nconnfd\n,\n \nbuf\n,\n \nn\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n5 Web\u670d\u52a1\u5668\n\n\nWeb\u57fa\u7840\n\n\nWeb\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u4e4b\u95f4\u7684\u4ea4\u4e92\u7528\u7684\u662f\nHTTP\u534f\u8bae\n(\u8d85\u6587\u672c\u4f20\u8f93\u534f\u8bae)\uff0c\u4ea4\u4e92\u7684\u57fa\u672c\u8fc7\u7a0b\u4e3a\uff1a\n\n \u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\n\n \u5ba2\u6237\u7aef\u8bf7\u6c42\u5185\u5bb9\n\n \u670d\u52a1\u5668\u54cd\u5e94\u8bf7\u6c42\u7684\u5185\u5bb9\n\n \u670d\u52a1\u5668\u548c\u5ba2\u6237\u7aef\u6700\u7ec8\u5173\u95ed \u8fde\u63a5\n\n\n\n\nWeb\u5185\u5bb9\n\n\nWeb\u670d\u52a1\u5668\u8fd4\u56de\u5185\u5bb9\u7ed9\u5ba2\u6237\u7aef\uff0c\u5185\u5bb9\u662f\u4e0e\u4e00\u4e2a\nMIME\n\u7c7b\u578b\u76f8\u5173\u7684\u5b57\u8282\u5e8f\u5217\u3002(MIME -  Multipurpose Internet Mail Extensions)\n\n\nHTTP\u54cd\u5e94\u8fd4\u56de\u7684\u7c7b\u578b\u53ef\u4ee5\u662f\u9759\u6001\u7684\uff0c\u4e5f\u53ef\u4ee5\u662f\u52a8\u6001\u7684\uff1a\n\n \u9759\u6001\u5185\u5bb9\uff1a\u5185\u5bb9\u5b58\u50a8\u5728\u6587\u4ef6\u4e2d\uff0c\u54cd\u5e94HTTP\u8bf7\u6c42\u540e\u8fd4\u56de\u7ed9\u5ba2\u6237\u7aef\n    * \u4f8b\u5982HTML\u6587\u4ef6\uff0c\u56fe\u7247\uff0c\u58f0\u97f3\n\n \u52a8\u6001\u5185\u5bb9\uff1a\u8fd0\u884c\u4e00\u4e2a\u53ef\u6267\u884c\u6587\u4ef6\u4ea7\u751f\u8f93\u51fa\uff0c\u8fd4\u56de\u7ed9\u5ba2\u6237\u7aef\n\n\nHTTP\u4e8b\u52a1\n\n\n\u4e00\u4e2a\nHTTP\u8bf7\u6c42\n(request)\u662f\u4e00\u4e2a\n\u8bf7\u6c42\u884c\n(request line)\uff0c\u540e\u9762\u8ddf\u968f\u7740\u96f6\u4e2a\u6216\u591a\u4e2a\n\u8bf7\u6c42\u62a5\u5934\n(request header)\uff0c\u518d\u8ddf\u968f\u4e00\u4e2a\u7ec8\u6b62\u62a5\u5934\u7684\u7a7a\u884c\u3002\n\n\n\u8bf7\u6c42\u884c\n\u7684\u683c\u5f0f\u662f\nmethod\n \nuri\n \nversion\n\u3002\n\n \nmethod\n\u53ef\u4ee5\u662fGET, POST, OPTIONS, HEAD, PUT, DELETE, TRAXE\n\n \nuri\n\u662f\u54cd\u5e94\u7684URL\u7684\u540e\u7f00\uff0c\u5305\u62ec\u6587\u4ef6\u540d\u548c\u53ef\u9009\u7684\u53c2\u6570\n* \nversion\n\u662f\u8be5\u8bf7\u6c42\u9075\u5faa\u7684HTTP\u7684\u7248\u672c(HTTP/1.0\u6216\u8005HTTP/1.1)\n\n\n\u8bf7\u6c42\u62a5\u5934\n\u7684\u683c\u5f0f\u662f\nheader name\n:\nheader data\n\n* \u4e3a\u670d\u52a1\u5668\u63d0\u4f9b\u989d\u5916\u4fe1\u606f\uff0c\u4f8b\u5982\u6d4f\u89c8\u5668\u7684\u5546\u6807\u540d\n\n\nHTTP\u54cd\u5e94\n\u4e0eHTTP\u8bf7\u6c42\u7c7b\u4f3c\uff0c\u662f\u4e00\u4e2a\n\u54cd\u5e94\u884c\n(response line)\uff0c\u540e\u9762\u8ddf\u7740\u96f6\u4e2a\u6216\u8005\u591a\u4e2a\n\u54cd\u5e94\u62a5\u5934\n(response header)\uff0c\u518d\u8ddf\u968f\u4e00\u4e2a\u7ec8\u6b62\u62a5\u5934\u7684\u7a7a\u884c\uff0c\u518d\u8ddf\u968f\u4e00\u4e2a\u54cd\u5e94\u4e3b\u4f53(response body)\u3002\n\n\n\u54cd\u5e94\u884c\n\u7684\u683c\u5f0f\u662f\nversion\n \nstatus code\n \nstatus message\n\n\n \nversion\n\u662f\u54cd\u5e94\u6240\u9075\u5faa\u7684HTTP\u7248\u672c\n\n \nstatus-code\n\u662f\u4e00\u4e2a3\u4f4d\u7684\u6b63\u6574\u6570\uff0c\u6307\u660e\u5bf9\u8bf7\u6c42\u7684\u5904\u7406\n* \nstatus-message\n \u82f1\u6587\u63cf\u8ff0\n\n\n\u54cd\u5e94\u62a5\u5934\n\u7684\u683c\u5f0f\u662f\nheader name\n:\nheader data\n\n\n\u4e0b\u9762\u662fHTTP\u8bf7\u6c42\u7684\u4e00\u4e2a\u5b9e\u4f8b", 
            "title": "Chapter 11: \u7f51\u7edc\u7f16\u7a0b"
        }, 
        {
            "location": "/csapp/ch11/#chapter-11", 
            "text": "", 
            "title": "Chapter 11 \u7f51\u7edc\u7f16\u7a0b"
        }, 
        {
            "location": "/csapp/ch11/#1-", 
            "text": "\u6bcf\u4e2a\u7f51\u7edc\u5e94\u7528\u90fd\u662f\u57fa\u4e8e \u5ba2\u6237\u7aef-\u670d\u52a1\u5668 \u6a21\u578b\u7684\u3002  \u5ba2\u6237\u7aef-\u670d\u52a1\u5668\u6a21\u578b\u4e2d\u7684\u57fa\u672c\u64cd\u4f5c\u662f \u4e8b\u52a1 (transaction)\u3002\u4e00\u4e2a\u5ba2\u6237\u7aef-\u670d\u52a1\u5668\u4e8b\u52a1\u7531\u4ee5\u4e0b\u56db\u6b65\u7ec4\u6210\uff1a   \u5f53\u4e00\u4e2a\u5ba2\u6237\u7aef\u9700\u8981\u670d\u52a1\u65f6\uff0c\u5b83\u5411\u670d\u52a1\u5668\u53d1\u9001\u4e00\u4e2a\u8bf7\u6c42\uff0c\u53d1\u8d77\u4e00\u4e2a\u4e8b\u52a1\u3002  \u670d\u52a1\u5668\u6536\u5230\u8bf7\u6c42\u540e\uff0c\u89e3\u91ca\u5b83\uff0c\u5e76\u4ee5\u9002\u5f53\u7684\u65b9\u5f0f\u64cd\u4f5c\u5b83\u7684\u8d44\u6e90\u3002  \u670d\u52a1\u5668\u7ed9\u5ba2\u6237\u7aef\u53d1\u9001\u4e00\u4e2a\u54cd\u5e94\uff0c\u5e76\u7b49\u5f85\u4e0b\u4e00\u4e2a\u8bf7\u6c42\u3002  \u5ba2\u6237\u7aef\u6536\u5230\u54cd\u5e94\u5e76\u5904\u7406\u5b83\u3002    \u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u662f\u8fdb\u7a0b \uff0c\u800c\u4e0d\u662f\u5e38\u63d0\u5230\u7684\u673a\u5668\u6216\u8005\u4e3b\u673a\u3002   \u4e00\u53f0\u4e3b\u673a\u53ef\u4ee5\u540c\u65f6\u8fd0\u884c\u8bb8\u591a\u4e0d\u540c\u7684\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668  \u4e00\u4e2a\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u7684\u4e8b\u52a1\u53ef\u4ee5\u5728\u540c\u4e00\u53f0\u6216\u662f\u4e0d\u540c\u7684\u4e3b\u673a\u4e0a\u3002", 
            "title": "1 \u5ba2\u6237\u7aef-\u670d\u52a1\u5668\u7f16\u7a0b\u6a21\u578b"
        }, 
        {
            "location": "/csapp/ch11/#2", 
            "text": "\u5bf9\u4e3b\u673a\u800c\u8a00\uff0c\u7f51\u7edc\u53ea\u662f\u53c8\u4e00\u79cdI/O\u8bbe\u5907\uff0c\u662f\u6570\u636e\u6e90\u548c\u6570\u636e\u63a5\u6536\u65b9\u3002\u7269\u7406\u4e0a\u800c\u8a00\uff0c\u7f51\u7edc\u662f\u4e00\u4e2a\u6309\u7167\u5730\u7406\u8fdc\u8fd1\u7ec4\u6210\u7684\u5c42\u6b21\u7cfb\u7edf\u3002", 
            "title": "2 \u7f51\u7edc"
        }, 
        {
            "location": "/csapp/ch11/#_1", 
            "text": "(1) \u6700\u5e95\u5c42\uff1a\u4ee5\u592a\u7f51\u6bb5 \u5c40\u57df\u7f51 (LAN, Local Area Network)\u7684\u8303\u56f4\u4e00\u822c\u9650\u5236\u5728\u4e00\u4e2a\u5efa\u7b51\u6216\u8005\u6821\u56ed\u5185\u3002\u6700\u6d41\u884c\u7684\u5c40\u57df\u7f51\u6280\u672f\u662f \u4ee5\u592a\u7f51 (Ethernet)\uff0c\u7531\u7535\u7f06\u548c\u96c6\u7ebf\u5668(hub)\u7ec4\u6210\u4e00\u4e2a\u4ee5\u592a\u7f51\u6bb5\u3002   (2) \u6865\u63a5\u4ee5\u592a\u7f51 \u6865\u63a5\u4ee5\u592a\u7f51 (bridged Ethernet)\u662f\u5c06\u4ee5\u592a\u7f51\u6bb5\u7528\u7535\u7f06\u548c\u7f51\u6865(bridge)\u8fde\u63a5\u6210\u7684\u8f83\u5927\u7684\u5c40\u57df\u7f51\u3002  (3) \u4e92\u8054\u7f51\u7edc\n\u591a\u4e2a\u4e0d\u517c\u5bb9\u7684\u5c40\u57df\u7f51\u53ef\u4ee5\u901a\u8fc7\u8def\u7531\u5668(routers)\u8fde\u63a5\u6210\u4e92\u8054\u7f51\u7edc(internets)\u3002", 
            "title": "\u7f51\u7edc\u5c42\u6b21\u7cfb\u7edf"
        }, 
        {
            "location": "/csapp/ch11/#_2", 
            "text": "\u4e92\u8054\u7f51\u7edc\u662f\u7531\u5404\u79cd\u5c40\u57df\u7f51\u548c\u5e7f\u57df\u7f51\u7ec4\u6210\uff0c\u5b83\u4eec\u91c7\u7528\u5b8c\u5168\u4e0d\u540c\u4e14\u4e0d\u517c\u5bb9\u7684\u6280\u672f\u3002\u90a3\u4e48\u5982\u4f55\u80fd\u8ba9\u67d0\u53f0\u4e3b\u673a\u8de8\u8fc7\u6240\u6709\u4e0d\u517c\u5bb9\u7684\u7f51\u7edc\u53d1\u9001\u6570\u636e\u4f4d\u5230\u53e6\u4e00\u53f0\u76ee\u7684\u4e3b\u673a\u5462\uff1f  \u89e3\u51b3\u65b9\u6cd5\uff1a\u4e00\u5c42\u8fd0\u884c\u5728\u6bcf\u53f0\u4e3b\u673a\u548c\u8def\u7531\u5668\u4e0a\u7684 \u534f\u8bae \u8f6f\u4ef6\uff0c\u5b83\u6d88\u9664\u4e86\u4e0d\u540c\u7f51\u7edc\u4e4b\u95f4\u7684\u5dee\u5f02\u3002\u534f\u8bae\u63d0\u4f9b\u4e86\u4e24\u79cd\u57fa\u672c\u80fd\u529b\uff1a  \u63d0\u4f9b\u4e86\u547d\u540d\u673a\u5236\n    * \u5b9a\u4e49\u4e00\u81f4\u7684 \u4e3b\u673a\u5730\u5740 (host adress)\u683c\u5f0f\n    * \u6bcf\u53f0\u4e3b\u673a\u4f1a\u88ab\u5206\u914d\u81f3\u5c11\u4e00\u4e2a \u4e92\u8054\u7f51\u7edc\u5730\u5740 (internet address)\uff0c\u5730\u5740\u552f\u4e00\u5730\u6807\u8bc6\u4e86\u4e3b\u673a  \u63d0\u4f9b\u4e86\u4f20\u9001\u673a\u5236\n    * \u5b9a\u4e49\u4e86\u7edf\u4e00\u7684\u57fa\u672c\u4f20\u9001\u5355\u4f4d- \u5305 (packet)\n    * \u5305\u7531 \u5305\u5934 (header)\u548c \u6709\u6548\u8f7d\u8377 (payload)\u7ec4\u6210\n        * \u5305\u5934\u5305\u62ec\u5305\u7684\u5927\u5c0f\u4ee5\u53ca\u6e90\u4e3b\u673a\u548c\u76ee\u7684\u4e3b\u673a\u7684\u5730\u5740\n        * \u6709\u6548\u8f7d\u8377\u5305\u62ec\u4ece\u6e90\u4e3b\u673a\u53d1\u51fa\u7684\u6570\u636e\u4f4d  ![Transferring Internet Data Via Encapsulation](figure/Transferring%20Internet%20Data%20Via%20Encapsulation.png)  PH: Internet packet header, \u4e92\u8054\u7f51\u7edc\u5305\u5934\nFH: LAN frame header, \u5c40\u57df\u7f51\u5e27\u5934", 
            "title": "\u7f51\u7edc\u534f\u8bae"
        }, 
        {
            "location": "/csapp/ch11/#3-ip", 
            "text": "\u5168\u7403IP\u56e0\u7279\u7f51(Global IP Internet)\u662f\u6700\u8457\u540d\u548c\u6700\u6210\u529f\u7684\u4e92\u8054\u7f51\u7edc(internet)\u5b9e\u73b0\u3002\u6bcf\u53f0\u56e0\u7279\u7f51\u4e3b\u673a\u90fd\u8fd0\u884c\u5b9e\u73b0TCP/IP\u534f\u8bae\u7684\u8f6f\u4ef6\uff0c\u4f7f\u7528\u5957\u63a5\u5b57\u63a5\u53e3(sockets interface)\u51fd\u6570\u548cUnix I/O\u51fd\u6570\u6765\u901a\u4fe1\u3002   \u4ece\u7a0b\u5e8f\u5458\u7684\u89d2\u5ea6\uff1a  \u4e3b\u673a\u88ab\u6620\u5c04\u4e3a\u4e00\u7ec432\u4f4d\u7684 IP\u5730\u5740 (IP addresses)\n    * 128.2.203.179  IP\u5730\u5740\u88ab\u6620\u5c04\u4e3a\u4e00\u7ec4\u6807\u8bc6\u7b26\uff0c\u53eb\u505a \u57df\u540d (domain name)\n* \u56e0\u7279\u7f51\u4e3b\u673a\u4e0a\u7684\u8fdb\u7a0b\u80fd\u591f\u901a\u8fc7 \u8fde\u63a5 \u548c\u4efb\u4f55\u5176\u4ed6\u56e0\u7279\u7f51\u4e3b\u673a\u4e0a\u7684\u8fdb\u7a0b\u901a\u4fe1\u3002", 
            "title": "3 \u5168\u7403IP\u56e0\u7279\u7f51"
        }, 
        {
            "location": "/csapp/ch11/#ip", 
            "text": "32\u4f4dIP\u5730\u5740\u5b58\u5728\u4e00\u4e2aIP\u5730\u5740\u7ed3\u6784( in_addr )\u4e2d\n* IP\u5730\u5740\u5728\u5185\u5b58\u4e2d\u662f\u4ee5 \u7f51\u7edc\u5b57\u8282\u987a\u5e8f (network byte order, \u5927\u7aef\u6cd5)\u5b58\u653e\u7684  /* Internet address structure */   struct   in_addr   {  \n     uint32_t   s_addr ;   /* network byte order (big-endian) */   };", 
            "title": "IP\u5730\u5740"
        }, 
        {
            "location": "/csapp/ch11/#_3", 
            "text": "\u57df\u540d (domain names)\u662f\u4e00\u4e32\u7528\u53e5\u70b9\u5206\u9694\u7684\u5355\u8bcd(\u5b57\u6bcd\u3001\u6570\u5b57\u548c\u7834\u6298\u53f7)\u3002\u57df\u540d\u96c6\u5408\u5f62\u6210\u4e86\u4e00\u4e2a\u5c42\u6b21\u7ed3\u6784\uff0c\u53ef\u4ee5\u8868\u793a\u4e3a\u4e00\u68f5\u6811\u3002   \u57df\u540d\u7cfb\u7edf (Domain Naming System, DNS)\u662f\u6620\u5c04IP\u5730\u5740\u548c\u57df\u540d\u7684\u6570\u636e\u5e93\u3002\u53ef\u4ee5\u628aDNS\u6570\u636e\u5e93\u89c6\u4e3a\u4e0a\u767e\u4e07\u7684 \u4e3b\u673a\u6761\u76ee\u7ed3\u6784 (host entry structure)\u7684\u96c6\u5408\uff0c\u5176\u4e2d\u6bcf\u6761\u5b9a\u4e49\u4e86\u4e00\u7ec4\u57df\u540d\u548c\u4e00\u7ec4IP\u5730\u5740\u4e4b\u95f4\u7684\u6620\u5c04\u3002   DNS\u6620\u5c04\uff0c\u53ef\u4ee5\u901a\u8fc7 nsloopup \u67e5\u770b  \u5728\u6700\u7b80\u5355\u7684\u60c5\u51b5\u4e2d\uff0c\u4e00\u4e2a\u57df\u540d\u548c\u4e00\u4e2aIP\u5730\u5740\u4e4b\u95f4\u662f\u4e00\u4e00\u6620\u5c04  nslookup whaleshark.ics.cs.cmu.edu  -  Address :   128.2 . 210.175    \u7136\u800c\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u591a\u4e2a\u57df\u540d\u53ef\u4ee5\u6620\u5c04\u4e3a\u540c\u4e00\u4e2aIP\u5730\u5740  nslookup cs.mit.edu/ nslookup eecs.mit.edu  -  Address :   18.62 . 1.6    \u5728\u6700\u901a\u5e38\u7684\u60c5\u51b5\u4e0b\uff0c\u591a\u4e2a\u57df\u540d\u53ef\u4ee5\u6620\u5c04\u5230\u540c\u4e00\u7ec4\u7684\u591a\u4e2aIP\u5730\u5740  nslookup www.twitter.com  -  Address :   199.16 . 156.6 ,  Address : 199.16 . 156.70", 
            "title": "\u57df\u540d"
        }, 
        {
            "location": "/csapp/ch11/#_4", 
            "text": "\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u901a\u8fc7 \u8fde\u63a5 (connections)\u53d1\u9001\u5b57\u8282\u6d41\u6765\u901a\u4fe1\uff0c\u6bcf\u4e00\u4e2a\u8fde\u63a5\u90fd\u6709\u5982\u4e0b\u7279\u70b9\uff1a   \u70b9\u5bf9\u70b9(point-to-point)\uff1a\u8fde\u63a5\u4e00\u5bf9\u8fdb\u7a0b  \u5168\u53cc\u5de5(full-duplex)\uff1a\u6570\u636e\u53ef\u4ee5\u540c\u65f6\u5728\u4e24\u4e2a\u65b9\u5411\u4f20\u9001  \u53ef\u9760\u6027(reliable)\uff1a\u53d1\u9001\u548c\u63a5\u6536\u7684\u5b57\u8282\u6d41\u987a\u5e8f\u76f8\u540c   \u5957\u63a5\u5b57(sockets)\u662f\u8fde\u63a5\u7684\u7aef\u70b9\uff0c\u5957\u63a5\u5b57\u5730\u5740\u7528 \u201c\u5730\u5740\uff1a\u7aef\u53e3\u201d\u6765\u8868\u793a\u3002\n* \u7aef\u53e3(port)\u662f\u4e00\u4e2a16\u4f4d\u6574\u6570\uff0c\u6807\u8bc6\u4e86\u4e00\u4e2a\u8fdb\u7a0b\u3002\n    * \u4e34\u65f6\u7aef\u53e3\uff1a\u5f53\u53ef\u4f1a\u6de1\u53d1\u8d77\u8fde\u63a5\u8bf7\u6c42\u65f6\uff0c\u5185\u6838\u81ea\u52a8\u5206\u914d\u7684\u7aef\u53e3\n    * \u77e5\u540d\u7aef\u53e3\uff1a\u548c\u670d\u52a1\u5668\u63d0\u4f9b\u7684\u670d\u52a1\u6709\u77ed\u7684\u7aef\u53e3 (\n        * Web\u670d\u52a1\u5668\u4f7f\u7528\u7aef\u53e380\n        * ssh\u670d\u52a1\u5668\u4f7f\u7528\u7aef\u53e322\n        * email\u670d\u52a1\u5668\u4f7f\u7528\u7aef\u53e325  \u4e00\u4e2a\u8fde\u63a5\u662f\u7531\u5b83\u4e24\u7aef\u7684\u5957\u63a5\u5b57\u5730\u5740\u552f\u4e00\u786e\u5b9a\u7684\uff08\u5957\u63a5\u5b57\u5bf9, socket pair\uff09\u3002   \u4f7f\u7528\u7aef\u53e3\u6765\u8bc6\u522b\u670d\u52a1", 
            "title": "\u56e0\u7279\u7f51\u8fde\u63a5"
        }, 
        {
            "location": "/csapp/ch11/#4", 
            "text": "\u4ec0\u4e48\u662f\u5957\u63a5\u5b57\uff1f  \u5bf9\u4e8e\u5185\u6838\u6765\u8bf4\uff0c\u5957\u63a5\u5b57\u662f\u901a\u4fe1\u7684\u7aef\u70b9\u3002 To the kernel, a socket is an endpoint of communication  \u5bf9\u4e8e\u5e94\u7528\u6765\u8bf4\uff0c\u5957\u63a5\u5b57\u662f\u8ba9\u5e94\u7528\u4ece\u7f51\u7edc\u8bfb\u5199\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 To an application, a socket is a file descriptor that lets the application read/write from/to the network.  \u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u901a\u8fc7\u5bf9\u5957\u63a5\u5b57\u63cf\u8ff0\u7b26\u8bfb\u5199\u8fdb\u884c\u901a\u4fe1\uff1a   (1) \u901a\u7528\u5957\u63a5\u5b57\u5730\u5740(generic socket address)\uff1a  \u4ee5\u5957\u63a5\u5b57\u5730\u5740\u4f5c\u4e3a connect() ,  bind() ,  accept \u7684\u5b9e\u53c2  \u4ec5\u4ec5\u56e0\u4e3a\u90a3\u65f6\u7684C\u4e0d\u5b58\u5728 void * \u6307\u9488\uff0c\u6240\u4ee5\u5957\u63a5\u5b57\u63a5\u53e3\u88ab\u8bbe\u8ba1\u6210\u8fd9\u6837\u3002  struct   sockaddr   {  \n     uint16_t   sa_family ;   /* Protocol family */ \n     char   sa_data [ 14 ];   };   /* Address data. */  \n(2) \u56e0\u7279\u7f51\u7684\u5957\u63a5\u5b57\u5730\u5740\n* \u5fc5\u987b\u5c06 struct sockaddr_in *  \u8f6c\u6362\u4e3a  struct sockaddr * \u624d\u80fd\u4ee5\u5957\u63a5\u5b57\u5730\u5740\u4f5c\u4e3a\u51fd\u6570\u5b9e\u53c2  struct   sockaddr_in   { \n     uint16_t   sin_family ; \n     uint16_t   sin_port ; \n     struct   in_addr   sin_addr ; \n     unsigned   char   sin_zero [ 8 ]; \n     };     \u5f00\u542f\u670d\u52a1\u5668(start server)  getaddrinfo : \u628a\u4e3b\u673a\u540d(hostname\uff09\u3001\u4e3b\u673a\u5730\u5740(host addresses)\u3001\u7aef\u53e3(ports)\u548c\u670d\u52a1\u540d(service names)\u8f6c\u6362\u4e3a\u5957\u63a5\u5b57\u5730\u5740\u7ed3\u6784\u3002  socket : \u521b\u5efa\u4e00\u4e2a\u5957\u63a5\u5b57\u63cf\u8ff0\u7b26(socket descriptor)\uff0c\u4e5f\u5c31\u662f\u4e4b\u540e\u7528\u6765\u8bfb\u5199\u7684 file descriptor  bind : \u8bf7\u6c42\u5185\u6838\u628a\u5957\u63a5\u5b57\u5730\u5740\u548c\u5957\u63a5\u5b57\u63cf\u8ff0\u7b26\u7ed1\u5b9a  listen : \u5c06\u5957\u63a5\u5b57\u63cf\u8ff0\u7b26\u4ece\u4e00\u4e2a\u4e3b\u52a8\u5957\u63a5\u5b57\u8f6c\u6362\u4e3a\u76d1\u542c\u5957\u63a5\u5b57(listening socket)\uff0c\u8be5\u5957\u63a5\u5b57\u53ef\u4ee5\u63a5\u53d7\u6765\u81ea\u5ba2\u6237\u7aef\u7684\u8fde\u63a5\u8bf7\u6c42  accept : \u7b49\u5f85\u6765\u81ea\u5ba2\u6237\u7aef\u7684\u8fde\u63a5\u8bf7\u6c42    \u5f00\u542f\u5ba2\u6237\u7aef(start client)  getaddrinfo ,  socket \u4e0e\u5f00\u542f\u670d\u52a1\u5668\u76f8\u540c  connect : \u8bd5\u56fe\u4e0e\u670d\u52a1\u5668\u5efa\u7acb\u8fde\u63a5", 
            "title": "4 \u5957\u63a5\u5b57\u63a5\u53e3"
        }, 
        {
            "location": "/csapp/ch11/#echo", 
            "text": "\u5728\u548c\u670d\u52a1\u5668\u5efa\u7acb\u8fde\u63a5\u4e4b\u540e\uff0c\u5ba2\u6237\u7aef\u8fdb\u5165\u4e00\u4e2a\u5faa\u73af\uff0c\u53cd\u590d\u4ece\u6807\u51c6\u8f93\u5165\u8bfb\u53d6\u6587\u672c\u884c\uff0c\u53d1\u9001\u6587\u672c\u884c\u7ed9\u670d\u52a1\u5668\uff0c\u4ece\u670d\u52a1\u5668\u8bfb\u53d6\u56de\u9001\u7684\u884c\uff0c\u5e76\u8f93\u51fa\u7ed3\u679c\u5230\u63a5\u51c6\u8f93\u51fa\u3002  #include   csapp.h  int   main   ( int   argc ,   char   ** argv )   { \n     int   clientfd ; \n     char   * host ,   * port ,   buf [ MAXLINE ]; \n     rio_t   rio ; \n\n     host   =   argv [ 1 ]; \n     port   =   argv [ 2 ]; \n\n     //\u548c\u670d\u52a1\u5668\u5efa\u7acb\u8fde\u63a5 \n     clientfd   =   Open_clientfd ( host ,   port ); \n     Rio_readinitb ( rio ,   clientfd ); \n\n     while   ( Fgets ( buf ,   MAXLINE ,   stdin )   !=   NULL )   { \n         // \u5199\u5165\uff0c\u4e5f\u5c31\u662f\u5411\u670d\u52a1\u5668\u53d1\u9001\u4fe1\u606f \n         Rio_writen ( clientfd ,   buf ,   strlen ( buf )); \n         // \u8bfb\u53d6\uff0c\u4e5f\u5c31\u662f\u4ece\u670d\u52a1\u5668\u63a5\u6536\u4fe1\u606f \n         Rio_readlineb ( rio ,   buf ,   MAXLINE ); \n         // \u628a\u4ece\u670d\u52a1\u5668\u63a5\u6536\u7684\u4fe1\u606f\u663e\u793a\u5728\u8f93\u51fa\u4e2d \n         Fputs ( buf ,   stdout ); \n     } \n     Close ( clientfd ); \n     exit ( 0 );  }   \u670d\u52a1\u5668\u5728\u6253\u5f00\u76d1\u542c\u63cf\u8ff0\u7b26\u540e\uff0c\u8fdb\u5165\u4e00\u4e2a\u65e0\u9650\u5faa\u73af\u3002\u6bcf\u6b21\u5faa\u73af\u90fd\u7b49\u5f85\u4e00\u4e2a\u6765\u81ea\u5ba2\u6237\u7aef\u7684\u8fde\u63a5\u8bf7\u6c42\uff0c\u8f93\u51fa\u5df2\u8fde\u63a5\u5ba2\u6237\u7aef\u7684\u57df\u540d\u548cIP\u5730\u5740\uff0c\u5e76\u8c03\u7528 echo \u51fd\u6570\u4e3a\u8fd9\u4e9b\u5ba2\u6237\u7aef\u670d\u52a1\u3002\u5728 echo \u7a0b\u5e8f\u8fd4\u56de\u540e\uff0c\u4e3b\u7a0b\u5e8f\u5173\u95ed\u5df2\u8fde\u63a5\u63cf\u8ff0\u7b26\u3002  #include   csapp.h  void   echo ( int   connfd );  int   main ( int   argc ,   char   ** argv ){ \n     int   listenfd ,   connfd ; \n     socklen_t   clientlen ; \n     struct   sockaddr_storage   clientaddr ;   // Enough room for any addr \n     char   client_hostname [ MAXLINE ],   client_port [ MAXLINE ]; \n\n     // \u5f00\u542f\u76d1\u542c\u7aef\u53e3\uff0c\u6ce8\u610f\u53ea\u5f00\u8fd9\u4e48\u4e00\u6b21 \n     listenfd   =   Open_listenfd ( argv [ 1 ]); \n     while   ( 1 )   { \n         // \u9700\u8981\u5177\u4f53\u7684\u5927\u5c0f \n         clientlen   =   sizeof ( struct   sockaddr_storage );   // Important! \n         // \u7b49\u5f85\u8fde\u63a5 \n         connfd   =   Accept ( listenfd ,   ( SA   * ) clientaddr ,   clientlen ); \n         // \u83b7\u53d6\u5ba2\u6237\u7aef\u76f8\u5173\u4fe1\u606f \n         Getnameinfo (( SA   * )   clientaddr ,   clientlen ,   client_hostname , \n                      MAXLINE ,   client_port ,   MAXLINE ,   0 ); \n         printf ( Connected to (%s, %s) \\n ,   client_hostname ,   client_port ); \n         // \u670d\u52a1\u5668\u5177\u4f53\u5b8c\u6210\u7684\u5de5\u4f5c \n         echo ( coonfd ); \n         Close ( connfd ); \n     } \n     exit ( 0 );  }  void   echo ( int   connfd )   { \n     size_t   n ; \n     char   buf [ MAXLINE ]; \n     rio_t   rio ; \n\n     // \u8bfb\u53d6\u4ece\u5ba2\u6237\u7aef\u4f20\u8f93\u8fc7\u6765\u7684\u6570\u636e \n     Rio_readinitb ( rio ,   connfd ); \n     while (( n   =   Rio_readlineb ( rio ,   buf ,   MAXLINE ))   !=   0 )   { \n         printf ( server received %d bytes \\n ,   ( int ) n ); \n         // \u628a\u4ece client \u63a5\u6536\u5230\u7684\u4fe1\u606f\u518d\u5199\u56de\u53bb \n         Rio_writen ( connfd ,   buf ,   n ); \n     }  }", 
            "title": "Echo\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u793a\u4f8b"
        }, 
        {
            "location": "/csapp/ch11/#5-web", 
            "text": "", 
            "title": "5 Web\u670d\u52a1\u5668"
        }, 
        {
            "location": "/csapp/ch11/#web", 
            "text": "Web\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u4e4b\u95f4\u7684\u4ea4\u4e92\u7528\u7684\u662f HTTP\u534f\u8bae (\u8d85\u6587\u672c\u4f20\u8f93\u534f\u8bae)\uff0c\u4ea4\u4e92\u7684\u57fa\u672c\u8fc7\u7a0b\u4e3a\uff1a  \u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5  \u5ba2\u6237\u7aef\u8bf7\u6c42\u5185\u5bb9  \u670d\u52a1\u5668\u54cd\u5e94\u8bf7\u6c42\u7684\u5185\u5bb9  \u670d\u52a1\u5668\u548c\u5ba2\u6237\u7aef\u6700\u7ec8\u5173\u95ed \u8fde\u63a5", 
            "title": "Web\u57fa\u7840"
        }, 
        {
            "location": "/csapp/ch11/#web_1", 
            "text": "Web\u670d\u52a1\u5668\u8fd4\u56de\u5185\u5bb9\u7ed9\u5ba2\u6237\u7aef\uff0c\u5185\u5bb9\u662f\u4e0e\u4e00\u4e2a MIME \u7c7b\u578b\u76f8\u5173\u7684\u5b57\u8282\u5e8f\u5217\u3002(MIME -  Multipurpose Internet Mail Extensions)  HTTP\u54cd\u5e94\u8fd4\u56de\u7684\u7c7b\u578b\u53ef\u4ee5\u662f\u9759\u6001\u7684\uff0c\u4e5f\u53ef\u4ee5\u662f\u52a8\u6001\u7684\uff1a  \u9759\u6001\u5185\u5bb9\uff1a\u5185\u5bb9\u5b58\u50a8\u5728\u6587\u4ef6\u4e2d\uff0c\u54cd\u5e94HTTP\u8bf7\u6c42\u540e\u8fd4\u56de\u7ed9\u5ba2\u6237\u7aef\n    * \u4f8b\u5982HTML\u6587\u4ef6\uff0c\u56fe\u7247\uff0c\u58f0\u97f3  \u52a8\u6001\u5185\u5bb9\uff1a\u8fd0\u884c\u4e00\u4e2a\u53ef\u6267\u884c\u6587\u4ef6\u4ea7\u751f\u8f93\u51fa\uff0c\u8fd4\u56de\u7ed9\u5ba2\u6237\u7aef", 
            "title": "Web\u5185\u5bb9"
        }, 
        {
            "location": "/csapp/ch11/#http", 
            "text": "\u4e00\u4e2a HTTP\u8bf7\u6c42 (request)\u662f\u4e00\u4e2a \u8bf7\u6c42\u884c (request line)\uff0c\u540e\u9762\u8ddf\u968f\u7740\u96f6\u4e2a\u6216\u591a\u4e2a \u8bf7\u6c42\u62a5\u5934 (request header)\uff0c\u518d\u8ddf\u968f\u4e00\u4e2a\u7ec8\u6b62\u62a5\u5934\u7684\u7a7a\u884c\u3002  \u8bf7\u6c42\u884c \u7684\u683c\u5f0f\u662f method   uri   version \u3002   method \u53ef\u4ee5\u662fGET, POST, OPTIONS, HEAD, PUT, DELETE, TRAXE   uri \u662f\u54cd\u5e94\u7684URL\u7684\u540e\u7f00\uff0c\u5305\u62ec\u6587\u4ef6\u540d\u548c\u53ef\u9009\u7684\u53c2\u6570\n*  version \u662f\u8be5\u8bf7\u6c42\u9075\u5faa\u7684HTTP\u7684\u7248\u672c(HTTP/1.0\u6216\u8005HTTP/1.1)  \u8bf7\u6c42\u62a5\u5934 \u7684\u683c\u5f0f\u662f header name : header data \n* \u4e3a\u670d\u52a1\u5668\u63d0\u4f9b\u989d\u5916\u4fe1\u606f\uff0c\u4f8b\u5982\u6d4f\u89c8\u5668\u7684\u5546\u6807\u540d  HTTP\u54cd\u5e94 \u4e0eHTTP\u8bf7\u6c42\u7c7b\u4f3c\uff0c\u662f\u4e00\u4e2a \u54cd\u5e94\u884c (response line)\uff0c\u540e\u9762\u8ddf\u7740\u96f6\u4e2a\u6216\u8005\u591a\u4e2a \u54cd\u5e94\u62a5\u5934 (response header)\uff0c\u518d\u8ddf\u968f\u4e00\u4e2a\u7ec8\u6b62\u62a5\u5934\u7684\u7a7a\u884c\uff0c\u518d\u8ddf\u968f\u4e00\u4e2a\u54cd\u5e94\u4e3b\u4f53(response body)\u3002  \u54cd\u5e94\u884c \u7684\u683c\u5f0f\u662f version   status code   status message    version \u662f\u54cd\u5e94\u6240\u9075\u5faa\u7684HTTP\u7248\u672c   status-code \u662f\u4e00\u4e2a3\u4f4d\u7684\u6b63\u6574\u6570\uff0c\u6307\u660e\u5bf9\u8bf7\u6c42\u7684\u5904\u7406\n*  status-message  \u82f1\u6587\u63cf\u8ff0  \u54cd\u5e94\u62a5\u5934 \u7684\u683c\u5f0f\u662f header name : header data  \u4e0b\u9762\u662fHTTP\u8bf7\u6c42\u7684\u4e00\u4e2a\u5b9e\u4f8b", 
            "title": "HTTP\u4e8b\u52a1"
        }, 
        {
            "location": "/hfj/", 
            "text": "HFJ\n\n\n\n\nChapter 1: Dive in A Quick Dip\n\n\nChapter 2: Classes and Objects\n\n\nChapter 3: Primitives and References\n\n\nChapter 4: Methods use Instance Variables\n\n\nChapter 5: Writing a Program\n\n\nChapter 6: Get to Know the Java API\n\n\nChapter 7: Inheritance and Polymorphism\n\n\nChapter 8: Interfaces and Abstract Classes\n\n\nChapter 9: Constructors and Garbage Collection\n\n\nChapter 10: Numbers and Statics\n\n\nChapter 11: Exception Handling\n\n\nChapter 12: Getting GUI\n\n\nChapter 13: Using Swing\n\n\nChapter 14: Serialization and File I/O\n\n\nChapter 15: Networking and Threads\n\n\nChapter 16: Collections and Generics\n\n\nChapter 17: Packages, Jars and Deployment\n\n\nChapter 18: Remote deploy with RMI", 
            "title": "Contents"
        }, 
        {
            "location": "/hfj/#hfj", 
            "text": "Chapter 1: Dive in A Quick Dip  Chapter 2: Classes and Objects  Chapter 3: Primitives and References  Chapter 4: Methods use Instance Variables  Chapter 5: Writing a Program  Chapter 6: Get to Know the Java API  Chapter 7: Inheritance and Polymorphism  Chapter 8: Interfaces and Abstract Classes  Chapter 9: Constructors and Garbage Collection  Chapter 10: Numbers and Statics  Chapter 11: Exception Handling  Chapter 12: Getting GUI  Chapter 13: Using Swing  Chapter 14: Serialization and File I/O  Chapter 15: Networking and Threads  Chapter 16: Collections and Generics  Chapter 17: Packages, Jars and Deployment  Chapter 18: Remote deploy with RMI", 
            "title": "HFJ"
        }, 
        {
            "location": "/hfj/ch1/", 
            "text": "Chapter 1 Dive in A Quick Dip\n\n\nJava has friendly syntax, object-oriented features, memory management, and best of all - the \npromise of probability\n ( \nwrite-one/run-anywhere\n ).\n\n\nYou type a source code file(\n.java\n). compile it using the \njavac\n compiler, then run(\njava\n) the compiled bytecode(\n.class\n) on a java virtual machine.\n\n\n\n\nmain method\n\n\nEvery Java application has to have at least one class, and at least one \nmain\n method.\n\n\nThe \nmain\n method is where your program starts running.\n\n\npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n){\n\n    \n//your code goes here\n\n\n}\n\n\n\n\n\nLooping\n\n\nJava has three standard looping constructs: \nwhile\n, \ndo-while\n, and \nfor\n.\n\n\nwhile\n \n(\n \n)\n \n{\n\n\n\n}\n\n\n\n\n\nA boolean and an integer are not \ncompatible\n types in Java.\n\n\nint x=1;\nwhile (x) {} //wrong\n\n\n\n\nConditional branching\n\n\nif\n \n(\nconditional\n \ntest\n)\n \n{\n\n\n}\n \nelse\n \n{\n\n\n}\n\n\n\n\n\n\n\nNote\n\n\nSystem.out.println\n inserts a newline,  \nSystem.out.print\n keeps           printing to the same line.\n\n\n\n\nStrongly-typed language\n\n\nJava is a \nstrongly typed language\n(\u5f3a\u7c7b\u578b\u8bed\u8a00) and that means I can't allow variables to hold data of the wrong type.\n\n\nDynamic Binding\n\n\nHowever, There are some datatype exceptions that can emerge at runtime, but some of those have to be allowed to support one of Java's other important features -- \ndynamic binding\n(\u52a8\u6001\u7ed1\u5b9a).\n\n\nHere are a few important differences between \nstatic\n and \ndynamic\n binding in Java [\nref\n]:\n\n\n\n\nStatic binding in Java occurs during \ncompile\n time while dynamic binding occurs during \nruntime\n.\n\n\nprivate\n, \nfinal\n and \nstatic\n methods and variables use static binding and are bonded by compiler while virtual methods are bonded during runtime based upon runtime object.\n\n\nStatic binding uses Type (class in Java) information for binding while dynamic binding uses object to resolve binding.\n\n\nOverloaded methods are bonded using static binding while overridden methods are bonded using dynamic binding at runtime.\n\n\n\n\nStatic Binding Example in Java:\n\n\npublic\n \nclass\n \nStaticBindingTest\n \n{\n  \n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n \nargs\n[])\n \n{\n\n        \nCollection\n \nc\n \n=\n \nnew\n \nHashSet\n();\n\n        \nStaticBindingTest\n \net\n \n=\n \nnew\n \nStaticBindingTest\n();\n\n        \net\n.\nsort\n(\nc\n);\n\n    \n}\n\n    \n//overloaded method takes Collection argument\n\n    \npublic\n \nCollection\n \nsort\n(\nCollection\n \nc\n)\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nInside Collection sort method\n);\n\n        \nreturn\n \nc\n;\n\n    \n}\n\n    \n//another overloaded method which takes HashSet argument which is sub class\n\n    \npublic\n \nCollection\n \nsort\n(\nHashSet\n \nhs\n)\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nInside HashSet sort method\n);\n\n        \nreturn\n \nhs\n;\n\n    \n}\n\n\n}\n\n\n\n\n\nExample of Dynamic Binding in Java:\n\n\npublic\n \nclass\n \nDynamicBindingTest\n \n{\n   \n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n \nargs\n[])\n \n{\n\n        \nVehicle\n \nvehicle\n \n=\n \nnew\n \nCar\n();\n \n//here Type is vehicle but object will be Car\n\n        \nvehicle\n.\nstart\n();\n \n//Car\ns start called because start() is overridden method\n\n    \n}\n\n\n}\n\n\n\nclass\n \nVehicle\n \n{\n\n    \npublic\n \nvoid\n \nstart\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nInside start method of Vehicle\n);\n\n    \n}\n\n\n}\n\n\n\nclass\n \nCar\n \nextends\n \nVehicle\n \n{\n\n    \n@Override\n\n    \npublic\n \nvoid\n \nstart\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nInside start method of Car\n);\n\n    \n}\n\n\n}", 
            "title": "Chapter 1: Dive in A Quick Dip"
        }, 
        {
            "location": "/hfj/ch1/#chapter-1-dive-in-a-quick-dip", 
            "text": "Java has friendly syntax, object-oriented features, memory management, and best of all - the  promise of probability  (  write-one/run-anywhere  ).  You type a source code file( .java ). compile it using the  javac  compiler, then run( java ) the compiled bytecode( .class ) on a java virtual machine.", 
            "title": "Chapter 1 Dive in A Quick Dip"
        }, 
        {
            "location": "/hfj/ch1/#main-method", 
            "text": "Every Java application has to have at least one class, and at least one  main  method.  The  main  method is where your program starts running.  public   static   void   main ( String []   args ){ \n     //your code goes here  }", 
            "title": "main method"
        }, 
        {
            "location": "/hfj/ch1/#looping", 
            "text": "Java has three standard looping constructs:  while ,  do-while , and  for .  while   (   )   {  }   A boolean and an integer are not  compatible  types in Java.  int x=1;\nwhile (x) {} //wrong", 
            "title": "Looping"
        }, 
        {
            "location": "/hfj/ch1/#conditional-branching", 
            "text": "if   ( conditional   test )   {  }   else   {  }    Note  System.out.println  inserts a newline,   System.out.print  keeps           printing to the same line.", 
            "title": "Conditional branching"
        }, 
        {
            "location": "/hfj/ch1/#strongly-typed-language", 
            "text": "Java is a  strongly typed language (\u5f3a\u7c7b\u578b\u8bed\u8a00) and that means I can't allow variables to hold data of the wrong type.", 
            "title": "Strongly-typed language"
        }, 
        {
            "location": "/hfj/ch1/#dynamic-binding", 
            "text": "However, There are some datatype exceptions that can emerge at runtime, but some of those have to be allowed to support one of Java's other important features --  dynamic binding (\u52a8\u6001\u7ed1\u5b9a).  Here are a few important differences between  static  and  dynamic  binding in Java [ ref ]:   Static binding in Java occurs during  compile  time while dynamic binding occurs during  runtime .  private ,  final  and  static  methods and variables use static binding and are bonded by compiler while virtual methods are bonded during runtime based upon runtime object.  Static binding uses Type (class in Java) information for binding while dynamic binding uses object to resolve binding.  Overloaded methods are bonded using static binding while overridden methods are bonded using dynamic binding at runtime.   Static Binding Example in Java:  public   class   StaticBindingTest   {   \n     public   static   void   main ( String   args [])   { \n         Collection   c   =   new   HashSet (); \n         StaticBindingTest   et   =   new   StaticBindingTest (); \n         et . sort ( c ); \n     } \n     //overloaded method takes Collection argument \n     public   Collection   sort ( Collection   c )   { \n         System . out . println ( Inside Collection sort method ); \n         return   c ; \n     } \n     //another overloaded method which takes HashSet argument which is sub class \n     public   Collection   sort ( HashSet   hs )   { \n         System . out . println ( Inside HashSet sort method ); \n         return   hs ; \n     }  }   Example of Dynamic Binding in Java:  public   class   DynamicBindingTest   {    \n     public   static   void   main ( String   args [])   { \n         Vehicle   vehicle   =   new   Car ();   //here Type is vehicle but object will be Car \n         vehicle . start ();   //Car s start called because start() is overridden method \n     }  }  class   Vehicle   { \n     public   void   start ()   { \n         System . out . println ( Inside start method of Vehicle ); \n     }  }  class   Car   extends   Vehicle   { \n     @Override \n     public   void   start ()   { \n         System . out . println ( Inside start method of Car ); \n     }  }", 
            "title": "Dynamic Binding"
        }, 
        {
            "location": "/hfj/ch2/", 
            "text": "Chapter 2 Classes and Objects\n\n\nObject Oriented\n\n\nWhat do you like about OO? Some people say...\n\n\n\n\nIt helps me design in a more natural way. Things have a way of evolving.\n\n\nNot messing around with the code I've already tested, just to add a new feature.\n\n\nReusing code in other applications. When I write a new class, I can make it flexible enough to be used in something new, later\n\n\n\n\nClass\n\n\nA class describes what an object \nknows\n(instance variables, \u5b9e\u4f8b\u53d8\u91cf) and what an object \ndoes\n(methods).\n\n\n\n\nWhat's the \ndifference\n between a class and an object?\n\n\n\n\nA class is \nnot\n an object. \n\n\nA class is the \nblueprint\n for an object. \n\n\nA class tells the JVM \nhow\n to make an object of that particular type. \n\n\nEach object made from that class have its \nown\n values for the instance variables of that class.\n\n\n\n\n\n\nmain method\n\n\nThe two uses of \nmain\n method:\n\n\n\n\nto \ntest\n your real class\n\n\nto \nlaunch/start\n your Java application.", 
            "title": "Chapter 2: Classes and Objects"
        }, 
        {
            "location": "/hfj/ch2/#chapter-2-classes-and-objects", 
            "text": "", 
            "title": "Chapter 2 Classes and Objects"
        }, 
        {
            "location": "/hfj/ch2/#object-oriented", 
            "text": "What do you like about OO? Some people say...   It helps me design in a more natural way. Things have a way of evolving.  Not messing around with the code I've already tested, just to add a new feature.  Reusing code in other applications. When I write a new class, I can make it flexible enough to be used in something new, later", 
            "title": "Object Oriented"
        }, 
        {
            "location": "/hfj/ch2/#class", 
            "text": "A class describes what an object  knows (instance variables, \u5b9e\u4f8b\u53d8\u91cf) and what an object  does (methods).   What's the  difference  between a class and an object?   A class is  not  an object.   A class is the  blueprint  for an object.   A class tells the JVM  how  to make an object of that particular type.   Each object made from that class have its  own  values for the instance variables of that class.", 
            "title": "Class"
        }, 
        {
            "location": "/hfj/ch2/#main-method", 
            "text": "The two uses of  main  method:   to  test  your real class  to  launch/start  your Java application.", 
            "title": "main method"
        }, 
        {
            "location": "/hfj/ch3/", 
            "text": "Chapter 3 Primitives and references\n\n\nVariables must always be declared with a \nname\n and a \ntype\n. Variables come in two flavors: \nprimitive\n and \nreference\n.\n\n\nVariables can be used in many places:\n\n\n\n\nas object state: \ninstance variables\n\n\nvariables declared within a method: \nlocal variables\n\n\nvalues sent to a method by the calling code: \narguments\n\n\nvalues sent back to the caller of the method: \nreturn types\n\n\n\n\nNaming\n\n\nYou can name a class, method, or variable according the following rules (the real rules are sightly more flexible, but these will keep you safe:\n\n\n\n\nIt must start with a letter, underscore (_), or dollar sign ($). You can\u2019t start a name with a number.\n\n\nAfter the first character, you can use numbers as well. Just don\u2019t start it with a number.\n\n\nIt can be anything you like, subject to those two rules, just so long as it isn\u2019t one of Java\u2019s reserved words.\n\n\n\n\nPrimitive Variable\n\n\nA \nprimitive variable\n value is the bits representing the value.\n\n\n\n\nPrimitives hold fundamental values.\n\n\nEach primitive variable has a \nfixed\n number of bits.\n\n\n\n\nReference variable\n\n\n\n\nA \nreference variable\n value is the bits representing a way to \naccess\n an object on the heap.\n\n\nThe only way you can access an object is through a reference variable.\n\n\nIt doesn\u2019t hold the object itself, but it holds something like a pointer. Or an address.\n\n\nA reference variable is like a remote control. Using the dot operator(\n.\n) on a reference variable is like pressing a button on the remote control to access a method or instance variables.\n\n\nA reference variable has a value of \nnull\n when it is not referencing any object.\n\n\n\n\nThe three steps of \nobject declaration, creation and assignment\n.\n\n\n(e.g. \nDog myDog = new Dog()\n);\n\n\n\n\ndeclare\n a reference variable: tell the JVM to allocate space for a reference variable, and names that variable myDog\n\n\ncreate\n an object: tells the JCM to allocate space for a new Dog object on the heap.\n\n\nAssigns\n the object to the reference variable.\n\n\n\n\n\n\nThe size of reference variables: All references for a given JVM will be the same size regardless of the objects they reference, but each JVM might have a different way of representing reference, so references on one JVM may be smaller or larger than references on another JVM.\n\n\nArray\n\n\nAn array is like a tray of cups:\n\n\n\n\nDeclare an int array variable. An array variable is a remote control to an array object. \nint\n[]\n \nnums\n;\n\n\nCreate a new int array with a length of 7, and assign it to the previously-declared int[] variable nums. \nnums\n \n=\n \nnew\n \nint\n[\n7\n];\n\n\nGive each element in the array an int value. \nnums\n[\n0\n]\n \n=\n \n6\n;\n\n\n\n\n\n\n\n\nAn array is always an object, even if the array is declared to hold primitives. \n\n\nEvery element in an array is just a variable.", 
            "title": "Chapter 3: Primitives and References"
        }, 
        {
            "location": "/hfj/ch3/#chapter-3-primitives-and-references", 
            "text": "Variables must always be declared with a  name  and a  type . Variables come in two flavors:  primitive  and  reference .  Variables can be used in many places:   as object state:  instance variables  variables declared within a method:  local variables  values sent to a method by the calling code:  arguments  values sent back to the caller of the method:  return types", 
            "title": "Chapter 3 Primitives and references"
        }, 
        {
            "location": "/hfj/ch3/#naming", 
            "text": "You can name a class, method, or variable according the following rules (the real rules are sightly more flexible, but these will keep you safe:   It must start with a letter, underscore (_), or dollar sign ($). You can\u2019t start a name with a number.  After the first character, you can use numbers as well. Just don\u2019t start it with a number.  It can be anything you like, subject to those two rules, just so long as it isn\u2019t one of Java\u2019s reserved words.", 
            "title": "Naming"
        }, 
        {
            "location": "/hfj/ch3/#primitive-variable", 
            "text": "A  primitive variable  value is the bits representing the value.   Primitives hold fundamental values.  Each primitive variable has a  fixed  number of bits.", 
            "title": "Primitive Variable"
        }, 
        {
            "location": "/hfj/ch3/#reference-variable", 
            "text": "A  reference variable  value is the bits representing a way to  access  an object on the heap.  The only way you can access an object is through a reference variable.  It doesn\u2019t hold the object itself, but it holds something like a pointer. Or an address.  A reference variable is like a remote control. Using the dot operator( . ) on a reference variable is like pressing a button on the remote control to access a method or instance variables.  A reference variable has a value of  null  when it is not referencing any object.   The three steps of  object declaration, creation and assignment .  (e.g.  Dog myDog = new Dog() );   declare  a reference variable: tell the JVM to allocate space for a reference variable, and names that variable myDog  create  an object: tells the JCM to allocate space for a new Dog object on the heap.  Assigns  the object to the reference variable.    The size of reference variables: All references for a given JVM will be the same size regardless of the objects they reference, but each JVM might have a different way of representing reference, so references on one JVM may be smaller or larger than references on another JVM.", 
            "title": "Reference variable"
        }, 
        {
            "location": "/hfj/ch3/#array", 
            "text": "An array is like a tray of cups:   Declare an int array variable. An array variable is a remote control to an array object.  int []   nums ;  Create a new int array with a length of 7, and assign it to the previously-declared int[] variable nums.  nums   =   new   int [ 7 ];  Give each element in the array an int value.  nums [ 0 ]   =   6 ;     An array is always an object, even if the array is declared to hold primitives.   Every element in an array is just a variable.", 
            "title": "Array"
        }, 
        {
            "location": "/hfj/ch4/", 
            "text": "Chapter 4 Methods use instance variabels", 
            "title": "Chapter 4: Methods use Instance Variables"
        }, 
        {
            "location": "/hfj/ch4/#chapter-4-methods-use-instance-variabels", 
            "text": "", 
            "title": "Chapter 4 Methods use instance variabels"
        }, 
        {
            "location": "/hfj/ch5/", 
            "text": "Chapter 5 Writing a Program", 
            "title": "Chapter 5: Writing a Program"
        }, 
        {
            "location": "/hfj/ch5/#chapter-5-writing-a-program", 
            "text": "", 
            "title": "Chapter 5 Writing a Program"
        }, 
        {
            "location": "/hfj/ch6/", 
            "text": "Chapter 6 Get to know the Java API\n\n\nArrayList\n\n\nArrayList\n is a class in the core Java library (the API).\n\n\n\n\nboolean\n \nadd\n(\nObject\n \nelem\n)\n: Adds the objects parameter to the list(return \ntrue\n).\n\n\nboolean\n \nremove\n(\nint\n \nindex\n)\n: Removes the object at the index parameter. Returns \ntrue\n if the element was in the list.\n\n\nboolean\n \nremove\n(\nObject\n \nelem\n)\n: Removes this object(if it's in the ArrayList).\n\n\nboolean\n \ncontains\n(\nObject\n \nelem\n)\n: Returns \ntrue\n if there's a match for the object parameter.\n\n\nboolean\n \nisEmpty\n()\n: Returns \ntrue\n if the list has no elements\n\n\nint\n \nindexOf\n(\nObject\n \nelem\n)\n: Returns either the index of the object parameter, or -1\n\n\nsize\n()\n: Return the number of elements currently in the list.\n\n\nObject\n \nget\n(\nint\n \nindex\n)\n: Return the object currently at the index parameter.\n\n\n\n\nYou have to know the full name of the class you want to use in your code. You have two options:\n\n\n\n\nImport: put an import statement at the top of your source code file:\n\n\nimport\n \njava.util.ArrayList\n\n\n\n\n\n\nType: type the full name everywhere in your code. Each time you use it.\n\n\njava\n.\nutil\n.\nArrayList\nDog\n \nlist\n \n=\n \nnew\n \njava\n.\nutil\n.\nArrayList\nDog\n();\n\n\n\n\n\n\n\n\nImport\n\n\nAn \nimport\n is not the same as \ninclude\n in C. So the \nimport\n doesn't make a class bigger. \nAn \nimport\n statement saves you from typing\n. That's really it. It simply give Java the \nfull name of a class\n.\n\n\nYou must tell Java the full name of every class you use, unless that class is in the \njava.lang\n package.", 
            "title": "Chapter 6: Get to Know the Java API"
        }, 
        {
            "location": "/hfj/ch6/#chapter-6-get-to-know-the-java-api", 
            "text": "", 
            "title": "Chapter 6 Get to know the Java API"
        }, 
        {
            "location": "/hfj/ch6/#arraylist", 
            "text": "ArrayList  is a class in the core Java library (the API).   boolean   add ( Object   elem ) : Adds the objects parameter to the list(return  true ).  boolean   remove ( int   index ) : Removes the object at the index parameter. Returns  true  if the element was in the list.  boolean   remove ( Object   elem ) : Removes this object(if it's in the ArrayList).  boolean   contains ( Object   elem ) : Returns  true  if there's a match for the object parameter.  boolean   isEmpty () : Returns  true  if the list has no elements  int   indexOf ( Object   elem ) : Returns either the index of the object parameter, or -1  size () : Return the number of elements currently in the list.  Object   get ( int   index ) : Return the object currently at the index parameter.   You have to know the full name of the class you want to use in your code. You have two options:   Import: put an import statement at the top of your source code file:  import   java.util.ArrayList    Type: type the full name everywhere in your code. Each time you use it.  java . util . ArrayList Dog   list   =   new   java . util . ArrayList Dog ();", 
            "title": "ArrayList"
        }, 
        {
            "location": "/hfj/ch6/#import", 
            "text": "An  import  is not the same as  include  in C. So the  import  doesn't make a class bigger.  An  import  statement saves you from typing . That's really it. It simply give Java the  full name of a class .  You must tell Java the full name of every class you use, unless that class is in the  java.lang  package.", 
            "title": "Import"
        }, 
        {
            "location": "/hfj/ch7/", 
            "text": "Chapter 7 Inheritance and polymorphism\n\n\n1 Overriding\n\n\nOverriding\n(\u91cd\u5199) means that a subclass \nredefines\n one of its inherited methods when it needs to change or extend the behavior of that method.\n\n\nIn the example as follows, the Amoeba class overrides the methods of the Shape class. Then at runtime, the JVM knows exactly which \nrotate()\n method to run when someone tells the Amoeba to rotate.\n\n\n\n\nIf you want to protect a specific method from being overridden, mark the method with the \nfinal\n modifier. \u5982\u679c\u4f60\u60f3\u8981\u9632\u6b62\u7279\u5b9a\u7684\u65b9\u6cd5\u88ab\u8986\u76d6\uff0c\u53ef\u4ee5\u5c06\u8be5\u65b9\u6cd5\u6807\u8bc6\u6210final\u8868\u793a\u6ca1\u6709\u4efb\u4f55\u7684\u65b9\u6cd5\u53ef\u4ee5\u88ab\u8986\u76d6\u3002\n\n\nRules for overriding\n:\n\n\n\n\nArguments must be the \nsame\n, and return types must be \ncompatible\n. \u53c2\u6570\u5fc5\u987b\u8981\u4e00\u6837\uff0c\u4e14\u8fd4\u56de\u7c7b\u578b\u5fc5\u987b\u8981\u517c\u5bb9.\n\n\nThe method can't be less accessible(e.g change from public to private). \u4e0d\u80fd\u964d\u4f4e\u65b9\u6cd5\u7684\u8bbf\u95ee\u6743\u9650\n\n\n\n\n2 Inheritance\n\n\nWhen one class inherits from another, the subclass inherits from the superclass. In Java, we say that the \nsubclass extends the superclass\n(\u5b50\u7c7b\u7ee7\u627f\u81ea\u7236\u7c7b)\u3002\n\n\n\n\nThe subclass inherits the instance variables and methods of the superclass.\n\n\nThe subclass can add new methods and instance variables of its own, and it can override the methods it inherits from the superclass.\n\n\nInstance variables are not overridden because they don't need to be. They don't define any special behavior.\n\n\nInheritance avoids duplicating code in subclasses.\n\n\nInheritances lets you guarantee that all classes grouped under a certain supertype have all the methods that the supertype has. In other words, you define a \ncommon protocol\n for a set of classes related through inheritance. \u7ee7\u627f\u8ba9\u4f60\u53ef\u4ee5\u786e\u4fdd\u67d0\u4e2a\u7236\u7c7b\u578b\u4e4b\u4e0b\u7684\u6240\u6709\u7c7b\u90fd\u4f1a\u6709\u7236\u7c7b\u578b\u6240\u6301\u6709\u7684\u5168\u90e8\u65b9\u6cd5\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u4f60\u4f1a\u901a\u8fc7\u7ee7\u627f\u6765\u5b9a\u4e49\u76f8\u5173\u7c7b\u95f4\u7684\u5171\u540c\u534f\u8bae\u3002\n\n\n\n\nUsing IS-A\n\n\nWhen you want to know if one thing should extend another, apply the \nIS-A test\n.\u82e5\u4f60\u60f3\u8981\u77e5\u9053\u67d0\u7269\u662f\u5426\u5e94\u8be5\u8981\u7ee7\u627f\u53e6\u4e00\u7269\u65f6\uff0c\u5219\u53ef\u4ee5\u7528IS-A(\u662f\u4e00\u4e2a)\u6d4b\u8bd5\u6765\u68c0\u9a8c\u3002\n\n\nIf class B extends class A, class B IS-A class A.\n   \u5982\u679c\u7c7bB\u7ee7\u627f\u7c7bA\uff0c\u90a3\u4e48\u7c7bB\u662f\u4e00\u4e2a\u7c7bA\u3002\n\n\nsuper\n\n\nIn a subclass, what if I want to use BOTH the superclass version and my overriding subclass version of a method? In other words, I don't want to completely \nreplace\n the superclass version, I just want to add more stuff to it.\n\n\nSOLUTION: In your subclass overriding method, you can call the superclass version using the keyword \nsuper\n.\n\n\n// this calls the inherited version on roam(),\n\n\n// then comes back to do your own subclass-specific code\n\n\npublic\n \nvoid\n \nroam\n(){\n\n    \nsuper\n.\nroam\n();\n\n    \n//my own roam stuff\n\n\n}\n\n\n\n\n\nAccess Level\n\n\nAccess levels control \nwho sees what\n, and are crucial to having well-designed, robust Java code.\n\n\nThere are four access levels, moving from most restrictive to least, the four access levels are: \n\n\nprive, default, protected, public\n:\n\n\n\n\npublic members \nare\n inherited. \n\n\nprivate members \nare\n not inherited.\n\n\n\n\n3 Polymorphism\n\n\nWith polymorphism, the reference type can be a superclass of the actual object type\n. \u8fd0\u7528\u591a\u6001\u65f6\uff0c\u5f15\u7528\u7c7b\u578b\u53ef\u4ee5\u662f\u5b9e\u9645\u5bf9\u8c61\u7c7b\u578b\u7684\u7236\u7c7b\u3002\n\n\nAnimal\n[]\n \nanimals\n \n=\n \nnew\n \nAnimal\n[\n3\n];\n\n\n// You can put ANY subclass of Animal in the Animal array!\n\n\nanimals\n \n[\n0\n]\n \n=\n \nnew\n \nDog\n();\n \n// the reference and the object are different\n\n\nanimals\n \n[\n1\n]\n \n=\n \nnew\n \nCat\n();\n\n\nanimals\n \n[\n2\n]\n \n=\n \nnew\n \nLion\n();\n\n\n// You get to loop through the array and call one of the Animal-class methods, and every object does the right thing!\n\n\nfor\n \n(\nint\n \ni\n=\n0\n;\n \ni\n \nanimals\n.\nlength\n;\n \ni\n++)\n \n{\n\n    \nanimals\n[\ni\n].\neat\n();\n\n    \nanimals\n[\ni\n].\nroam\n();\n\n\n}\n\n\n\n\n\nYou can have polymorphic \narguments\n and \nreturn\n types. \u53c2\u6570\u548c\u8fd4\u56de\u7c7b\u578b\u4e5f\u53ef\u4ee5\u591a\u6001\u3002\n\n\nclass\n \nVet\n \n{\n\n    \n// The Animal parameter can take ANY Animal type as the argument.\n\n    \npublic\n \nvoid\n \ngiveShot\n(\nAnimal\n \na\n)\n \n{\n \n        \na\n.\nmakeNoise\n();\n \n    \n}\n\n\n}\n\n\n\nclass\n \nPetOwner\n \n{\n\n    \npublic\n \nvoid\n \nstart\n()\n \n{\n \n        \nVet\n \nv\n \n=\n \nnew\n \nVet\n();\n \n        \nDog\n \nd\n \n=\n \nnew\n \nDog\n();\n \n        \nHippo\n \nh\n \n=\n \nnew\n \nHippo\n();\n \n        \n// The vet\ns giveShot() method can take any Animal you give it.\n\n        \n// As long as the object you pass in as the argument is a subclass of Animal, \n\n        \n// it\nll work.\n\n        \nv\n.\ngiveShot\n(\nd\n);\n \n        \nv\n.\ngiveShot\n(\nh\n);\n\n\n}\n\n\n\n\n\nSO....\n\n\nIf I write my code using polymorphic arguments, where I declare the method parameter as a superclass type, I can pass in any subclass object at runtime.\n\n\nWith polymorphism, you can write code that doesn't have to change when you introduce new subclass types into the program. \u901a\u8fc7\u591a\u6001\uff0c\u4f60\u5c31\u53ef\u4ee5\u7f16\u5199\u51fa\u5f15\u8fdb\u65b0\u578b\u5b50\u7c7b\u65f6\u4e5f\u4e0d\u5fc5\u4fee\u6539\u7684\u7a0b\u5e8f\u3002 \n\n\nCAN'T INHERIT\n\n\nThere are three things that can prevent a class from being subclassed.\n\n\n\n\nA non-public class can be subclassed only by classes in the same package as the class.\n\n\nUsing keyword modifier \nfinal\n to stop a class from being subclassed. \u4f7f\u7528\nfinal\n\u4fee\u9970\u7b26\u963b\u6b62\u7c7b\u88ab\u7ee7\u627f\u3002\n\n\nIf a class has only \nprivate\n constructors, it can't be subclassed. \u5982\u679c\u7c7b\u53ea\u62e5\u6709\nprivate\n\u7684\u6784\u9020\u7a0b\u5e8f\uff0c\u5b83\u4e0d\u80fd\u88ab\u7ee7\u627f\u3002\n\n\n\n\n4 Overloading\n\n\nMethod overloading\n(\u65b9\u6cd5\u91cd\u8f7d) is nothing more than having two methods with the \nsame name\n but \ndifferent argument lists\n . \u65b9\u6cd5\u91cd\u8f7d\u5c31\u662f\u65b9\u6cd5\u540d\u79f0\u76f8\u540c\uff0c\u4f46\u53c2\u6570\u5217\u8868\u4e0d\u540c\u3002\n\n\n\n\nPurpose: overloading lets you make multiple versions of a method, with different argument lists, for convenience to the callers. \n\n\nThe return types can be different.\n\n\nYou can't change only the return type.\n\n\nYou can vary the access levels in any direction.", 
            "title": "Chapter 7: Inheritance and Polymorphism"
        }, 
        {
            "location": "/hfj/ch7/#chapter-7-inheritance-and-polymorphism", 
            "text": "", 
            "title": "Chapter 7 Inheritance and polymorphism"
        }, 
        {
            "location": "/hfj/ch7/#1-overriding", 
            "text": "Overriding (\u91cd\u5199) means that a subclass  redefines  one of its inherited methods when it needs to change or extend the behavior of that method.  In the example as follows, the Amoeba class overrides the methods of the Shape class. Then at runtime, the JVM knows exactly which  rotate()  method to run when someone tells the Amoeba to rotate.   If you want to protect a specific method from being overridden, mark the method with the  final  modifier. \u5982\u679c\u4f60\u60f3\u8981\u9632\u6b62\u7279\u5b9a\u7684\u65b9\u6cd5\u88ab\u8986\u76d6\uff0c\u53ef\u4ee5\u5c06\u8be5\u65b9\u6cd5\u6807\u8bc6\u6210final\u8868\u793a\u6ca1\u6709\u4efb\u4f55\u7684\u65b9\u6cd5\u53ef\u4ee5\u88ab\u8986\u76d6\u3002  Rules for overriding :   Arguments must be the  same , and return types must be  compatible . \u53c2\u6570\u5fc5\u987b\u8981\u4e00\u6837\uff0c\u4e14\u8fd4\u56de\u7c7b\u578b\u5fc5\u987b\u8981\u517c\u5bb9.  The method can't be less accessible(e.g change from public to private). \u4e0d\u80fd\u964d\u4f4e\u65b9\u6cd5\u7684\u8bbf\u95ee\u6743\u9650", 
            "title": "1 Overriding"
        }, 
        {
            "location": "/hfj/ch7/#2-inheritance", 
            "text": "When one class inherits from another, the subclass inherits from the superclass. In Java, we say that the  subclass extends the superclass (\u5b50\u7c7b\u7ee7\u627f\u81ea\u7236\u7c7b)\u3002   The subclass inherits the instance variables and methods of the superclass.  The subclass can add new methods and instance variables of its own, and it can override the methods it inherits from the superclass.  Instance variables are not overridden because they don't need to be. They don't define any special behavior.  Inheritance avoids duplicating code in subclasses.  Inheritances lets you guarantee that all classes grouped under a certain supertype have all the methods that the supertype has. In other words, you define a  common protocol  for a set of classes related through inheritance. \u7ee7\u627f\u8ba9\u4f60\u53ef\u4ee5\u786e\u4fdd\u67d0\u4e2a\u7236\u7c7b\u578b\u4e4b\u4e0b\u7684\u6240\u6709\u7c7b\u90fd\u4f1a\u6709\u7236\u7c7b\u578b\u6240\u6301\u6709\u7684\u5168\u90e8\u65b9\u6cd5\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u4f60\u4f1a\u901a\u8fc7\u7ee7\u627f\u6765\u5b9a\u4e49\u76f8\u5173\u7c7b\u95f4\u7684\u5171\u540c\u534f\u8bae\u3002", 
            "title": "2 Inheritance"
        }, 
        {
            "location": "/hfj/ch7/#using-is-a", 
            "text": "When you want to know if one thing should extend another, apply the  IS-A test .\u82e5\u4f60\u60f3\u8981\u77e5\u9053\u67d0\u7269\u662f\u5426\u5e94\u8be5\u8981\u7ee7\u627f\u53e6\u4e00\u7269\u65f6\uff0c\u5219\u53ef\u4ee5\u7528IS-A(\u662f\u4e00\u4e2a)\u6d4b\u8bd5\u6765\u68c0\u9a8c\u3002  If class B extends class A, class B IS-A class A.    \u5982\u679c\u7c7bB\u7ee7\u627f\u7c7bA\uff0c\u90a3\u4e48\u7c7bB\u662f\u4e00\u4e2a\u7c7bA\u3002", 
            "title": "Using IS-A"
        }, 
        {
            "location": "/hfj/ch7/#super", 
            "text": "In a subclass, what if I want to use BOTH the superclass version and my overriding subclass version of a method? In other words, I don't want to completely  replace  the superclass version, I just want to add more stuff to it.  SOLUTION: In your subclass overriding method, you can call the superclass version using the keyword  super .  // this calls the inherited version on roam(),  // then comes back to do your own subclass-specific code  public   void   roam (){ \n     super . roam (); \n     //my own roam stuff  }", 
            "title": "super"
        }, 
        {
            "location": "/hfj/ch7/#access-level", 
            "text": "Access levels control  who sees what , and are crucial to having well-designed, robust Java code.  There are four access levels, moving from most restrictive to least, the four access levels are:   prive, default, protected, public :   public members  are  inherited.   private members  are  not inherited.", 
            "title": "Access Level"
        }, 
        {
            "location": "/hfj/ch7/#3-polymorphism", 
            "text": "With polymorphism, the reference type can be a superclass of the actual object type . \u8fd0\u7528\u591a\u6001\u65f6\uff0c\u5f15\u7528\u7c7b\u578b\u53ef\u4ee5\u662f\u5b9e\u9645\u5bf9\u8c61\u7c7b\u578b\u7684\u7236\u7c7b\u3002  Animal []   animals   =   new   Animal [ 3 ];  // You can put ANY subclass of Animal in the Animal array!  animals   [ 0 ]   =   new   Dog ();   // the reference and the object are different  animals   [ 1 ]   =   new   Cat ();  animals   [ 2 ]   =   new   Lion ();  // You get to loop through the array and call one of the Animal-class methods, and every object does the right thing!  for   ( int   i = 0 ;   i   animals . length ;   i ++)   { \n     animals [ i ]. eat (); \n     animals [ i ]. roam ();  }   You can have polymorphic  arguments  and  return  types. \u53c2\u6570\u548c\u8fd4\u56de\u7c7b\u578b\u4e5f\u53ef\u4ee5\u591a\u6001\u3002  class   Vet   { \n     // The Animal parameter can take ANY Animal type as the argument. \n     public   void   giveShot ( Animal   a )   {  \n         a . makeNoise ();  \n     }  }  class   PetOwner   { \n     public   void   start ()   {  \n         Vet   v   =   new   Vet ();  \n         Dog   d   =   new   Dog ();  \n         Hippo   h   =   new   Hippo ();  \n         // The vet s giveShot() method can take any Animal you give it. \n         // As long as the object you pass in as the argument is a subclass of Animal,  \n         // it ll work. \n         v . giveShot ( d );  \n         v . giveShot ( h );  }   SO....  If I write my code using polymorphic arguments, where I declare the method parameter as a superclass type, I can pass in any subclass object at runtime.  With polymorphism, you can write code that doesn't have to change when you introduce new subclass types into the program. \u901a\u8fc7\u591a\u6001\uff0c\u4f60\u5c31\u53ef\u4ee5\u7f16\u5199\u51fa\u5f15\u8fdb\u65b0\u578b\u5b50\u7c7b\u65f6\u4e5f\u4e0d\u5fc5\u4fee\u6539\u7684\u7a0b\u5e8f\u3002", 
            "title": "3 Polymorphism"
        }, 
        {
            "location": "/hfj/ch7/#cant-inherit", 
            "text": "There are three things that can prevent a class from being subclassed.   A non-public class can be subclassed only by classes in the same package as the class.  Using keyword modifier  final  to stop a class from being subclassed. \u4f7f\u7528 final \u4fee\u9970\u7b26\u963b\u6b62\u7c7b\u88ab\u7ee7\u627f\u3002  If a class has only  private  constructors, it can't be subclassed. \u5982\u679c\u7c7b\u53ea\u62e5\u6709 private \u7684\u6784\u9020\u7a0b\u5e8f\uff0c\u5b83\u4e0d\u80fd\u88ab\u7ee7\u627f\u3002", 
            "title": "CAN'T INHERIT"
        }, 
        {
            "location": "/hfj/ch7/#4-overloading", 
            "text": "Method overloading (\u65b9\u6cd5\u91cd\u8f7d) is nothing more than having two methods with the  same name  but  different argument lists  . \u65b9\u6cd5\u91cd\u8f7d\u5c31\u662f\u65b9\u6cd5\u540d\u79f0\u76f8\u540c\uff0c\u4f46\u53c2\u6570\u5217\u8868\u4e0d\u540c\u3002   Purpose: overloading lets you make multiple versions of a method, with different argument lists, for convenience to the callers.   The return types can be different.  You can't change only the return type.  You can vary the access levels in any direction.", 
            "title": "4 Overloading"
        }, 
        {
            "location": "/hfj/ch8/", 
            "text": "Chapter 8 Interfaces and Abstract Classes\n\n\nWhat's an interface? it's a 100% abstract class. \nWhat's an abstract class? it's a class that can't be instantiated.\n\n\n1 Abstract classes\n\n\nHere's where it gets weird:\n\n\nAnimal\n \nanim\n \n=\n \nnew\n \nAnimal\n();\n \n\n\nThere two are the same type, but what the heck does an Animal object look like?\n\n\nSome classes just should not be instantiated!\n\nHow?  By marking the class as \nabstract\n, the compiler will stop any code, anywhere, from ever creating an instance of that type. i.e. prevent a class from ever being instantiated.\n\n\nMaking a class abstract before the class declaration:\n\n\nabstract\n \nclass\n \nCaine\n \nextends\n \nAnimal\n \n{\n\n    \npublic\n \nvoid\n \nroam\n()\n \n{}\n\n\n}\n\n\n\n\n\nWhen you're designing your class inheritance structure, you have to decide which classes are \nabstract\n and which are \nconcrete\n. \n\n\n\n\nConcrete\n classes are those that are specific enough to be instantiated. \n\n\nA \nconcrete\n class just means that it's OK to make objects of that type.\n\n\nAn \nabstract class\n has virtually no use, no value, no purpose in life, unless it is extended.\n\n\n\n\n2 Abstract methods\n\n\nAn \nabstract method\n means the method must be overriden, whereas an abstract class means the class must be extended.\n\n\n\n\nThere isn't any code that would make sense in the abstract method, you won't put in a method body. e.g. \npublic\n \nabstract\n \nvoid\n \neat\n()\n.\n\n\nIf you declare an abstract method, you must mark the class abstract as well. You can't have an abstract method in a non-abstract class.\n\n\nYou must implement all abstract methods.\n\n\n\n\n3 The ultimate superclass: \nObject\n\n\nEvery class in Java extends class \nObject\n. Class \nObject\n is the mother of all classes; it's the superclass of everything. \n\n\n\n\nAny class that doesn't \nexplicitly\n extend another class, \nimplicitly\n extends \nObject\n.\n\n\n\n\nMethods of \nObject\n class:\n\n\n\n\nequals\n()\n: tell you if two objects are considered equal.\n\n\ngetClass\n()\n: Gives you back the class that object was instantiated from.\n\n\nhashCode\n()\n: Prints out a hashcode for the object\n\n\ntoString\n()\n: Prints out a String message with the name of the class and some other number we rarely care about.\n\n\n\n\nObject\n is a \nnon-abstract\n class because it's got method implementation code that all classes can inherit and use out-of-box, without having to override the methods.\n\n\nThe \nObject\n class serves two main purpose:\n\n\n\n\nTo act as a polymorphic type for methods that need to work on any class that you or anyone else makes \u4f5c\u4e3a\u65b9\u6cd5\u7684\u591a\u6001\u7c7b\u578b\n\n\nTo provide real method code that all objects in Java need at runtime (and putting them in class Object means all other classes inherit them).\u63d0\u4f9bJava\u5728\u6267\u884c\u671f\u5806\u4efb\u4f55\u5bf9\u8c61\u90fd\u6709\u9700\u8981\u7684\u5b9e\u73b0\u65b9\u6cd5\u4ee3\u7801\u3002\n\n\n\n\n4 Using polymorphic references of type Object has a price\n\n\nWhen you put an object into an \nArrayList\nDog\n, it goes in as a Dog, and comes out as a Dog:\n\n\n// Make an ArrayList declared to hold Dog objects.\n\n\nArrayList\nDog\n \nmyDogArrayList\n \n=\n \nnew\n \nArrayList\nDog\n();\n\n\n// Make a Dog\n\n\nDog\n \naDog\n \n=\n \nnew\n \nDog\n();\n\n\n// Add the Dog to the list\n\n\nmyDogArrayList\n.\nadd\n(\naDog\n);\n\n\n//Assign the Dog from the list to a new Dog reference variable\n\n\nDog\n \nd\n \n=\n \nmyDogArrayList\n.\nget\n(\n0\n);\n\n\n\n\nEverything comes out of an \nArrayList\nObject\n as a reference of type Object, regardless of what the actual object is.\n \u4efb\u4f55\u4ece\nArrayList\nObject\n\u53d6\u51fa\u7684\u4e1c\u897f\u90fd\u4f1a\u88ab\u5f53\u4f5cObject\u7c7b\u578b\u7684\u5f15\u7528\uff0c\u800c\u4e0d\u7ba1\u5b83\u539f\u6765\u662f\u4ec0\u4e48\u3002\n\n\n// make an ArrayList declared to hold any type of Object\n\n\nArrayList\nObject\n \nmyDogArrayList\n \n=\n \nnew\n \nArrayList\nobject\n()\n\n\n// make a Dog\n\n\nDog\n \naDog\n \n=\n \nnew\n \nDog\n();\n\n\n// Add the Dog to the list\n\n\nmyDogArrayList\n.\nadd\n(\naDog\n);\n\n\n// No!! Won\nt compile!! the get() method returns type Object.\n\n\n// The compiler knows only that the object inherits from Object,\n\n\n// but it doesn\nt know it\ns a Dog!!\n\n\nDog\n \nd\n \n=\n \nmyDogArrayList\n.\nget\n(\n0\n)\n\n\n\n\n\nThe compiler decides whether you can call a method based on the \nreference type\n , not the actual object type.\n\n\nObject\n \no\n \n=\n \nal\n.\nget\n(\nindex\n);\n\n\n// Class Object has a hashCode() method\n\n\n// so you can call that method on any object in Java\n\n\nint\n \ni\n \n=\n \no\n.\nhashCode\n();\n\n\n// Can\nt do this!! the Object class  has no idea what it means to bark().\n\n\no\n.\nbark\n();\n\n\n\n\n\n\n\nIf you're sure the object is really a Dog, you can make a new Dog reference to it by copying the Object reference, and forcing that copy to go into a Dog reference variable, using a \ncast (Dog)\n.\n\n\nObject\n \no\n \n=\n \nal\n.\nget\n(\nindex\n);\n\n\n// cast the Object back to a Dog we know is there.\n\n\nDog\n \nd\n \n=\n \n(\nDog\n)\n \no\n;\n \n\nd\n.\nroam\n();\n\n\n\n\n\nIf you're not sure it's a Dog, you can use the \ninstanceof\n operator to check.\n\n\nif\n \n(\no\n \ninstanceof\n \nDog\n)\n \n{\n\n    \nDog\n \nd\n \n=\n \n(\nDog\n)\n \no\n;\n\n\n}\n\n\n\n\n\n\n\nNote\n\n\nJava\u4e2d\u7684instanceof \u7b97\u7b26\u662f\u7528\u6765\u5728\u8fd0\u884c\u65f6\u6307\u51fa\u5bf9\u8c61\u662f\u5426\u662f\u7279\u5b9a\u7c7b\u7684\u4e00\u4e2a\u5b9e\u4f8b\u3002instanceof\u901a\u8fc7\u8fd4\u56de\u4e00\u4e2a\u5e03\u5c14\u503c\u6765\u6307\u51fa\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u662f\u5426\u662f\u8fd9\u4e2a\u7279\u5b9a\u7c7b\u6216\u8005\u662f\u5b83\u7684\u5b50\u7c7b\u7684\u4e00\u4e2a\u5b9e\u4f8b\u3002\nresult\n \n=\n \nobject\n \ninstanceof\n \nclass\n\n\n\n\n5 Interface\n\n\nQuestions: What if you want to add Dog some Pet behaviors?\n\n\n\n\n\n\nOption one: We take the easy path, and put pet method in class Animal.\n\n\n\n\nPros: All the Animals will instantly inherit the pet behaviors. We won't have to touch the existing Animal subclasses at all.\n\n\nCons: Some animals like lion, wolf are not a pet. Non-pet Animals running around with pet methods.\n\n\n\n\n\n\n\n\nOption two: We start with option one, putting the pet methods in class Animal, but we make the methods abstract.\n\n\n\n\nPros: All classes must override the methods, but they can make the methods \"do-nothings\".\n\n\nCons: Waste a lot of time to implement every concrete Animal subclasses.\n\n\n\n\n\n\nOptions three: Put the pet methods Only in the classes where they belong.\n\n\nPros: The methods are where they belong, and only where they belong.\n\n\nCons: Firstly, you'd have to agree to a protocol, and all programmers of pet Animal classes now and in the future would have to know about the protocol. Secondly, you don't get to use polymorphism for the pet methods \n\n\n\n\n\n\n\n\nIt looks like we need two superclasses at the top.\n\n\n\n\nIt\u2019s called \"\nmultiple inheritance\n\"(\u591a\u91cd\u7ee7\u627f) and it can be a Really Bad Thing. Because multiple inheritance has a problem known as \nThe Deadly Diamond of Death\n(\u81f4\u547d\u7684\u6b7b\u4ea1\u7816\u77f3)\n\n\n\n\nJava\u7684\u65b9\u6848: Interface!!!\n\n\n\n\nA Java \ninterface\n(\u63a5\u53e3) solves multiple inheritance problem by giving you much of the polymorphic benefits of multiple inheritance without the pain and suffering from the Deadly Diamond of Death.\n\n\n\n\nHow?\n\n\n\n\nSurprisingly simple: \nmake all the methods abstract\n\n\nA Java interface is like a 100% pure abstract class.\n\n\n\n\nTo define an interface, use the keyword \ninterface\n instead of \nclass\n.\n\n\n//use the keyword \ninterface\n instead of \nclass\n\n\npublic\n \ninterface\n \nPet\n \n{}\n\n\n\n\n\nTo implement an interface, use the keyword \nimplements\n followed by the interface name:\n\n\n// Use the keyword \nimplements\n followed by the interface name.\n\n\npublic\n \nclass\n \nDog\n \nextends\n \nCanine\n \nimplements\n \nPet\n \n{}\n\n\n\n\n\nA class can implement \nmultiple\n interfaces!\n\n\npublic\n \nclass\n \nDog\n \nextends\n \nAnimal\n \nimplements\n \nPet\n,\n \nSaveable\n,\n \nPaintable\n \n{}\n\n\n\n\n\nClasses from \ndifferent\n inheritance trees can implement the \nsame\n interface.\n\n\n\n\nHow do you know whether to make a class, subclass, an abstract class, or an interface?\n\n\n\n\nMake a class that doesn\u2019t extend anything (other than Object) when your new class doesn\u2019t pass the IS-A test for any other type.\n\n\nMake a subclass (in other words, extend a class) only when you need to make a \nmore specific\n version of a class and need to override or add new behaviors.\n\n\nUse an abstract class when you want to define a \ntemplate\n for a group of subclasses, and you have at least some implementation code that all subclasses could use. Make the class abstract when you want to guarantee that nobody can make objects of that type.\n\n\nUse an interface when you want to define a \nrole\n that other classes can play, regardless of where those classes are in the inheritance tree.\n\n\n\n\n6 Using \nsuper\n\n\nWhat if you don't want to \nreplace\n the method with an override in a concrete subclass, but you just want to \nadd\n to it with some additional specific code?\n\n\nabstract\n \nclass\n \nReport\n \n{\n \n    \nvoid\n \nrunReport\n()\n \n{\n \n        \n// set-up report \n\n    \n}\n \n    \nvoid\n \nprintReport\n()\n \n{\n \n    \n// generic printing \n\n    \n}\n \n\n}\n\n\n\nclass\n \nBuzzwordsReport\n \nextends\n \nReport\n \n{\n\n    \nvoid\n \nrunReport\n()\n \n{\n\n        \n// call superclass version, then come back and do some      \n\n        \n// subclass-specific stuff\n\n        \nsuper\n.\nrunReport\n();\n\n        \nbuzzwordCompliance\n();\n \n        \nprintReport\n();\n\n    \n}\n\n    \nvoid\n \nbuzzwordCompliance\n()\n \n{...}\n\n\n}", 
            "title": "Chapter 8: Interfaces and Abstract Classes"
        }, 
        {
            "location": "/hfj/ch8/#chapter-8-interfaces-and-abstract-classes", 
            "text": "What's an interface? it's a 100% abstract class. \nWhat's an abstract class? it's a class that can't be instantiated.", 
            "title": "Chapter 8 Interfaces and Abstract Classes"
        }, 
        {
            "location": "/hfj/ch8/#1-abstract-classes", 
            "text": "Here's where it gets weird:  Animal   anim   =   new   Animal ();   \nThere two are the same type, but what the heck does an Animal object look like?  Some classes just should not be instantiated! \nHow?  By marking the class as  abstract , the compiler will stop any code, anywhere, from ever creating an instance of that type. i.e. prevent a class from ever being instantiated.  Making a class abstract before the class declaration:  abstract   class   Caine   extends   Animal   { \n     public   void   roam ()   {}  }   When you're designing your class inheritance structure, you have to decide which classes are  abstract  and which are  concrete .    Concrete  classes are those that are specific enough to be instantiated.   A  concrete  class just means that it's OK to make objects of that type.  An  abstract class  has virtually no use, no value, no purpose in life, unless it is extended.", 
            "title": "1 Abstract classes"
        }, 
        {
            "location": "/hfj/ch8/#2-abstract-methods", 
            "text": "An  abstract method  means the method must be overriden, whereas an abstract class means the class must be extended.   There isn't any code that would make sense in the abstract method, you won't put in a method body. e.g.  public   abstract   void   eat () .  If you declare an abstract method, you must mark the class abstract as well. You can't have an abstract method in a non-abstract class.  You must implement all abstract methods.", 
            "title": "2 Abstract methods"
        }, 
        {
            "location": "/hfj/ch8/#3-the-ultimate-superclass-object", 
            "text": "Every class in Java extends class  Object . Class  Object  is the mother of all classes; it's the superclass of everything.    Any class that doesn't  explicitly  extend another class,  implicitly  extends  Object .   Methods of  Object  class:   equals () : tell you if two objects are considered equal.  getClass () : Gives you back the class that object was instantiated from.  hashCode () : Prints out a hashcode for the object  toString () : Prints out a String message with the name of the class and some other number we rarely care about.   Object  is a  non-abstract  class because it's got method implementation code that all classes can inherit and use out-of-box, without having to override the methods.  The  Object  class serves two main purpose:   To act as a polymorphic type for methods that need to work on any class that you or anyone else makes \u4f5c\u4e3a\u65b9\u6cd5\u7684\u591a\u6001\u7c7b\u578b  To provide real method code that all objects in Java need at runtime (and putting them in class Object means all other classes inherit them).\u63d0\u4f9bJava\u5728\u6267\u884c\u671f\u5806\u4efb\u4f55\u5bf9\u8c61\u90fd\u6709\u9700\u8981\u7684\u5b9e\u73b0\u65b9\u6cd5\u4ee3\u7801\u3002", 
            "title": "3 The ultimate superclass: Object"
        }, 
        {
            "location": "/hfj/ch8/#4-using-polymorphic-references-of-type-object-has-a-price", 
            "text": "When you put an object into an  ArrayList Dog , it goes in as a Dog, and comes out as a Dog:  // Make an ArrayList declared to hold Dog objects.  ArrayList Dog   myDogArrayList   =   new   ArrayList Dog ();  // Make a Dog  Dog   aDog   =   new   Dog ();  // Add the Dog to the list  myDogArrayList . add ( aDog );  //Assign the Dog from the list to a new Dog reference variable  Dog   d   =   myDogArrayList . get ( 0 );   Everything comes out of an  ArrayList Object  as a reference of type Object, regardless of what the actual object is.  \u4efb\u4f55\u4ece ArrayList Object \u53d6\u51fa\u7684\u4e1c\u897f\u90fd\u4f1a\u88ab\u5f53\u4f5cObject\u7c7b\u578b\u7684\u5f15\u7528\uff0c\u800c\u4e0d\u7ba1\u5b83\u539f\u6765\u662f\u4ec0\u4e48\u3002  // make an ArrayList declared to hold any type of Object  ArrayList Object   myDogArrayList   =   new   ArrayList object ()  // make a Dog  Dog   aDog   =   new   Dog ();  // Add the Dog to the list  myDogArrayList . add ( aDog );  // No!! Won t compile!! the get() method returns type Object.  // The compiler knows only that the object inherits from Object,  // but it doesn t know it s a Dog!!  Dog   d   =   myDogArrayList . get ( 0 )   The compiler decides whether you can call a method based on the  reference type  , not the actual object type.  Object   o   =   al . get ( index );  // Class Object has a hashCode() method  // so you can call that method on any object in Java  int   i   =   o . hashCode ();  // Can t do this!! the Object class  has no idea what it means to bark().  o . bark ();    If you're sure the object is really a Dog, you can make a new Dog reference to it by copying the Object reference, and forcing that copy to go into a Dog reference variable, using a  cast (Dog) .  Object   o   =   al . get ( index );  // cast the Object back to a Dog we know is there.  Dog   d   =   ( Dog )   o ;   d . roam ();   If you're not sure it's a Dog, you can use the  instanceof  operator to check.  if   ( o   instanceof   Dog )   { \n     Dog   d   =   ( Dog )   o ;  }    Note  Java\u4e2d\u7684instanceof \u7b97\u7b26\u662f\u7528\u6765\u5728\u8fd0\u884c\u65f6\u6307\u51fa\u5bf9\u8c61\u662f\u5426\u662f\u7279\u5b9a\u7c7b\u7684\u4e00\u4e2a\u5b9e\u4f8b\u3002instanceof\u901a\u8fc7\u8fd4\u56de\u4e00\u4e2a\u5e03\u5c14\u503c\u6765\u6307\u51fa\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u662f\u5426\u662f\u8fd9\u4e2a\u7279\u5b9a\u7c7b\u6216\u8005\u662f\u5b83\u7684\u5b50\u7c7b\u7684\u4e00\u4e2a\u5b9e\u4f8b\u3002 result   =   object   instanceof   class", 
            "title": "4 Using polymorphic references of type Object has a price"
        }, 
        {
            "location": "/hfj/ch8/#5-interface", 
            "text": "Questions: What if you want to add Dog some Pet behaviors?    Option one: We take the easy path, and put pet method in class Animal.   Pros: All the Animals will instantly inherit the pet behaviors. We won't have to touch the existing Animal subclasses at all.  Cons: Some animals like lion, wolf are not a pet. Non-pet Animals running around with pet methods.     Option two: We start with option one, putting the pet methods in class Animal, but we make the methods abstract.   Pros: All classes must override the methods, but they can make the methods \"do-nothings\".  Cons: Waste a lot of time to implement every concrete Animal subclasses.    Options three: Put the pet methods Only in the classes where they belong.  Pros: The methods are where they belong, and only where they belong.  Cons: Firstly, you'd have to agree to a protocol, and all programmers of pet Animal classes now and in the future would have to know about the protocol. Secondly, you don't get to use polymorphism for the pet methods      It looks like we need two superclasses at the top.   It\u2019s called \" multiple inheritance \"(\u591a\u91cd\u7ee7\u627f) and it can be a Really Bad Thing. Because multiple inheritance has a problem known as  The Deadly Diamond of Death (\u81f4\u547d\u7684\u6b7b\u4ea1\u7816\u77f3)   Java\u7684\u65b9\u6848: Interface!!!   A Java  interface (\u63a5\u53e3) solves multiple inheritance problem by giving you much of the polymorphic benefits of multiple inheritance without the pain and suffering from the Deadly Diamond of Death.   How?   Surprisingly simple:  make all the methods abstract  A Java interface is like a 100% pure abstract class.   To define an interface, use the keyword  interface  instead of  class .  //use the keyword  interface  instead of  class  public   interface   Pet   {}   To implement an interface, use the keyword  implements  followed by the interface name:  // Use the keyword  implements  followed by the interface name.  public   class   Dog   extends   Canine   implements   Pet   {}   A class can implement  multiple  interfaces!  public   class   Dog   extends   Animal   implements   Pet ,   Saveable ,   Paintable   {}   Classes from  different  inheritance trees can implement the  same  interface.   How do you know whether to make a class, subclass, an abstract class, or an interface?   Make a class that doesn\u2019t extend anything (other than Object) when your new class doesn\u2019t pass the IS-A test for any other type.  Make a subclass (in other words, extend a class) only when you need to make a  more specific  version of a class and need to override or add new behaviors.  Use an abstract class when you want to define a  template  for a group of subclasses, and you have at least some implementation code that all subclasses could use. Make the class abstract when you want to guarantee that nobody can make objects of that type.  Use an interface when you want to define a  role  that other classes can play, regardless of where those classes are in the inheritance tree.", 
            "title": "5 Interface"
        }, 
        {
            "location": "/hfj/ch8/#6-using-super", 
            "text": "What if you don't want to  replace  the method with an override in a concrete subclass, but you just want to  add  to it with some additional specific code?  abstract   class   Report   {  \n     void   runReport ()   {  \n         // set-up report  \n     }  \n     void   printReport ()   {  \n     // generic printing  \n     }   }  class   BuzzwordsReport   extends   Report   { \n     void   runReport ()   { \n         // call superclass version, then come back and do some       \n         // subclass-specific stuff \n         super . runReport (); \n         buzzwordCompliance ();  \n         printReport (); \n     } \n     void   buzzwordCompliance ()   {...}  }", 
            "title": "6 Using super"
        }, 
        {
            "location": "/hfj/ch9/", 
            "text": "Chapter 9 Constructors and Garbage Collection\n\n\n1 Stack and Heap\n\n\nIn Java, programmers care about two areas of memory\n\n\n\n\nheap: where objects live\n\n\nstack: where method invocations and local variables live\n\n\n\n\n\n\nInstance variables\n are declared inside a \nclass\n but not inside a method. Instance variables live inside the object they belong to. So instance variable live on the Heap, inside the object.\n\n\n\n\nLocal variables\n are declared inside a \nmethod\n, including method parameters. They're temporary, and live only as long as the method is on the stack.\n\n\nWhat about local variables that are objects?\n\n\nIf the local variable is a reference to an object, only the variable (the reference/remote control) goes on the stack.\n\n\npublic\n \nclass\n \nStackRef\n \n{\n\n    \npublic\n \nvoid\n \nfoof\n()\n \n{\n\n     \nbarf\n();\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nbarf\n()\n \n{\n\n        \nDuck\n \nd\n \n=\n \nnew\n \nDuck\n(\n24\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n2 Constructor\n\n\nConstructor\n(\u6784\u9020\u51fd\u6570) is \nthe code that runs when you instantiate an object\n . They only way to invoke a constructor is with the keyword \nnew\n followed by the class name.\n\n\nYou can write a constructor for your class, but if you don't the \ncompiler writes one for you\n !\n\n\nHere is what the compiler default constructor looks like:\n\n\npublic\n \nDuck\n(){\n\n\n\n}\n\n\n\n\n\nA constructor does look and feel a lot like a method, but it's \nnot\n a method. How is it different from a method?\n\n\n\n\nA constructor's name is the same as the class name. That's mandatory.\n\n\nConstructors have no return type, while a method need a return type.\n\n\n\n\n\n\nNote\n\n\n\n\nJava lets you declare a method with the same name as your class. The thing that separates a method from a constructor is \nthe return type\n.\n\n\nConstructors are \nnot inherited\n.\n\n\n\n\n\n\nThe key feature of a constructor is that it runs \nbefore\n the object can be assigned to a reference.\n\n\nInitializing the state of an object\n\n\nMost people use constructors to initialize the state of an object. In other words, to make and assign values to the object's instance variables. \n\n\nAnd all you need to do is make a constructor with arguments:\n\n\npublic\n \nclass\n \nDuck\n \n{\n\n    \nint\n \nsize\n;\n\n    \n// Add an int parameter to the Duck constructor\n\n    \npublic\n \nDuck\n(\nint\n \nduckSize\n)\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nQuack\n);\n\n        \n// use the argument value to set the size instance variable.\n\n        \nsize\n \n=\n \nduckSize\n;\n\n        \nSystem\n.\nout\n.\nprintln\n(\nsize is \n \n+\n \nsize\n);\n\n    \n}\n\n\n    \npublic\n \nDuck\n()\n \n{\n\n        \n//supply default size\n\n        \nsize\n \n=\n \n27\n;\n\n    \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nUseADuck\n \n{\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n        \n// Pass a value to the constructor\n\n        \nDuck\n \nd\n \n=\n \nnew\n \nDuck\n(\n42\n);\n\n    \n}\n\n\n}\n\n\n\n\n\nIf you have more than one constructor in a class, it means you have \noverloaded\n constructors. \nThe constructors MUST have different arguments lists\n. Different arguments lists means different variable \ntype\n(int, Dog, etc.) and \norder\n.\n\n\nIf you write a constructor that takes arguments, and you still want a no-arg constructor, you'll have to build the no-arg constructor yourself! Because the compiler won't make a default constructor if you have any constructors.\n\n\nconstructor chaining\n\n\nWhen an object is created, the object gets space for \nall\n instance variables, from all the way up the inheritance tree.\n\n\nAll the constructors in an object's inheritance tree must run when you make a new object.\n When a constructor runs, it immediately calls its superclass constructor, all the way up the chain until you get to the class \nObject\n constructor (called \nconstructor chaining\n(\u6784\u9020\u51fd\u6570\u94fe)).\n\n\neg. A new Hippo object also IS-A Animal and IS-A Object. If you want to make a Hippo, you must also make the Animal and Object parts of the Hippo.\n\n\n\n\npublic\n \nclass\n \nAnimal\n \n{\n \n    \npublic\n \nAnimal\n()\n \n{\n \n        \nSystem\n.\nout\n.\nprintln\n(\n\u201c\nMaking\n \nan\n \nAnimal\n\u201d\n);\n \n    \n}\n \n\n}\n\n\n\npublic\n \nclass\n \nHippo\n \nextends\n \nAnimal\n \n{\n \n    \npublic\n \nHippo\n()\n \n{\n \n        \nSystem\n.\nout\n.\nprintln\n(\n\u201c\nMaking\n \na\n \nHippo\n\u201d\n);\n \n    \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nTestHippo\n \n{\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n \n(\nString\n[]\n \nargs\n \n{\n \n        \nSystem\n.\nout\n.\nprintln\n(\n\u201c\nStarting\n...\n\u201d\n);\n \n        \nHippo\n \nh\n \n=\n \nnew\n \nHippo\n();\n \n        \n}\n\n\n}\n\n\n\n\n\n\n\ninvoke a superclass constructor\n\n\nThe only way to call a superclass constructor is by calling \n**super()\n**.\n\n\npublic\n \nclass\n \nDuck\n \nextends\n \nAnimal\n \n{\n\n    \nint\n \nsize\n;\n\n\n    \npublic\n \nDuck\n(\nint\n \nnewSize\n)\n \n{\n\n        \nsuper\n();\n\n    \n}\n\n\n}\n\n\n\n\n\nA call to \nsuper()\n in your constructor puts the superclass constructor on the top of the Stack. And that superclass constructor calls its superclass constructor. And so it goes until the Object constructor is on the top of the Stack. Once \nObject()\n finishes, it's popped off the Stack and goes until the original constructor is on the top of the Stack.\n\n\n\n\nNote\n\n\nThe compiler will put a call to \nsuper()\n in \neach\n of your overloaded constructors, if you do \nnot\n have calls to \nsuper()\n.\n\n\n\n\nThe superclass parts of an object have to be fully-formed (completely built) before the subclass parts can be constructed.\n So the call to \nSuper()\n must be  the \nfirst\n statement in each constructor!\n\n\nthis\n\n\nthis\n is a \nreference\n to \nthe current object\n.  \n\n\n\n\nthis()\n calls the real constructor and let the real constructor finish the job of construction.\n\n\nThe call to \nthis()\n can be used only in a constructor, and must be the \nfirst\n statement in a constructor.\n\n\nA constructor can have a call to \nsuper()\n or \nthis()\n, but never both!\n\n\n\n\nclass\n \nMini\n \nextends\n \nCar\n \n{\n\n    \nColor\n \ncolor\n;\n\n    \npublic\n \nMini\n()\n \n{\n \n        \n// The no-arg constructor supplies a default Color\n\n        \n// and calls the overloaded Real Constructor (the one that calls super())\n\n        \nthis\n(\nColor\n.\nRed\n);\n\n    \n}\n\n\n    \npublic\n \nMini\n(\nColor\n \nc\n)\n \n{\n \n        \n// The is the Real Constructor that does the real work of initializing the object\n\n        \nsuper\n(\n\u201c\nMini\n\u201d\n);\n   \n        \ncolor\n \n=\n \nc\n;\n \n        \n// more initialization \n\n    \n}\n\n\n    \npublic\n \nMini\n(\nint\n \nsize\n)\n \n{\n \n        \n// Won\nt work!! Can\nt have super() and this() in the same constructor\n\n        \n// because they each must be the first statement!\n\n        \nthis\n(\nColor\n.\nRed\n);\n \n        \nsuper\n(\nsize\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n3 Object lifespan\n\n\nAn Object's life depends entirely on the life of references referring to it.\n\n\n\n\nIf the reference is considered \"alive\", the object is still alive on the Heap.\n\n\nIf the reference dies, the object will die.\n\n\n\n\nSo if an object's life depends on the reference variable's life, how long does a variable live?\n\n\n\n\nA \nlocal\n variable lives only within the method that declared the variable.\n\n\nAn \ninstance\n variable lives as long as the object does. If the object is still alive, so are its instance variables.\n\n\n\n\nThe difference between \nlife\n and \nscope\n for local variables:\n\n\n\n\nLife\n: a local variable is alive as long as its Stack frame is  on the Stack.\n\n\nScope\n: a local variable is in \nscope\n only within the method in which the variable was declared. You can use a variable only when it is in scope.\n\n\n\n\nObject lifecycle\n\n\nAn object's life has no value, no meaning, no point, unless somebody has a reference to it. Because if you can't get to it, you can't ask it to do anything and it's just a big fat waste of bits.\n\n\nAn object becomes eligible for Garbage Collector(\u5783\u573e\u6536\u96c6\u5668) when its last live reference disappear.\n\n\nObject-killer\n\n\n\n\nReference goes out of scope, permanently.\n\n\nAssign the reference to another object.\n\n\nExplicitly set the reference to null.", 
            "title": "Chapter 9: Constructors and Garbage Collection"
        }, 
        {
            "location": "/hfj/ch9/#chapter-9-constructors-and-garbage-collection", 
            "text": "", 
            "title": "Chapter 9 Constructors and Garbage Collection"
        }, 
        {
            "location": "/hfj/ch9/#1-stack-and-heap", 
            "text": "In Java, programmers care about two areas of memory   heap: where objects live  stack: where method invocations and local variables live    Instance variables  are declared inside a  class  but not inside a method. Instance variables live inside the object they belong to. So instance variable live on the Heap, inside the object.   Local variables  are declared inside a  method , including method parameters. They're temporary, and live only as long as the method is on the stack.  What about local variables that are objects?  If the local variable is a reference to an object, only the variable (the reference/remote control) goes on the stack.  public   class   StackRef   { \n     public   void   foof ()   { \n      barf (); \n     } \n\n     public   void   barf ()   { \n         Duck   d   =   new   Duck ( 24 ); \n     }  }", 
            "title": "1 Stack and Heap"
        }, 
        {
            "location": "/hfj/ch9/#2-constructor", 
            "text": "Constructor (\u6784\u9020\u51fd\u6570) is  the code that runs when you instantiate an object  . They only way to invoke a constructor is with the keyword  new  followed by the class name.  You can write a constructor for your class, but if you don't the  compiler writes one for you  !  Here is what the compiler default constructor looks like:  public   Duck (){  }   A constructor does look and feel a lot like a method, but it's  not  a method. How is it different from a method?   A constructor's name is the same as the class name. That's mandatory.  Constructors have no return type, while a method need a return type.    Note   Java lets you declare a method with the same name as your class. The thing that separates a method from a constructor is  the return type .  Constructors are  not inherited .    The key feature of a constructor is that it runs  before  the object can be assigned to a reference.", 
            "title": "2 Constructor"
        }, 
        {
            "location": "/hfj/ch9/#initializing-the-state-of-an-object", 
            "text": "Most people use constructors to initialize the state of an object. In other words, to make and assign values to the object's instance variables.   And all you need to do is make a constructor with arguments:  public   class   Duck   { \n     int   size ; \n     // Add an int parameter to the Duck constructor \n     public   Duck ( int   duckSize )   { \n         System . out . println ( Quack ); \n         // use the argument value to set the size instance variable. \n         size   =   duckSize ; \n         System . out . println ( size is    +   size ); \n     } \n\n     public   Duck ()   { \n         //supply default size \n         size   =   27 ; \n     }  }  public   class   UseADuck   { \n     public   static   void   main ( String []   args )   { \n         // Pass a value to the constructor \n         Duck   d   =   new   Duck ( 42 ); \n     }  }   If you have more than one constructor in a class, it means you have  overloaded  constructors.  The constructors MUST have different arguments lists . Different arguments lists means different variable  type (int, Dog, etc.) and  order .  If you write a constructor that takes arguments, and you still want a no-arg constructor, you'll have to build the no-arg constructor yourself! Because the compiler won't make a default constructor if you have any constructors.", 
            "title": "Initializing the state of an object"
        }, 
        {
            "location": "/hfj/ch9/#constructor-chaining", 
            "text": "When an object is created, the object gets space for  all  instance variables, from all the way up the inheritance tree.  All the constructors in an object's inheritance tree must run when you make a new object.  When a constructor runs, it immediately calls its superclass constructor, all the way up the chain until you get to the class  Object  constructor (called  constructor chaining (\u6784\u9020\u51fd\u6570\u94fe)).  eg. A new Hippo object also IS-A Animal and IS-A Object. If you want to make a Hippo, you must also make the Animal and Object parts of the Hippo.   public   class   Animal   {  \n     public   Animal ()   {  \n         System . out . println ( \u201c Making   an   Animal \u201d );  \n     }   }  public   class   Hippo   extends   Animal   {  \n     public   Hippo ()   {  \n         System . out . println ( \u201c Making   a   Hippo \u201d );  \n     }  }  public   class   TestHippo   { \n     public   static   void   main   ( String []   args   {  \n         System . out . println ( \u201c Starting ... \u201d );  \n         Hippo   h   =   new   Hippo ();  \n         }  }", 
            "title": "constructor chaining"
        }, 
        {
            "location": "/hfj/ch9/#invoke-a-superclass-constructor", 
            "text": "The only way to call a superclass constructor is by calling  **super() **.  public   class   Duck   extends   Animal   { \n     int   size ; \n\n     public   Duck ( int   newSize )   { \n         super (); \n     }  }   A call to  super()  in your constructor puts the superclass constructor on the top of the Stack. And that superclass constructor calls its superclass constructor. And so it goes until the Object constructor is on the top of the Stack. Once  Object()  finishes, it's popped off the Stack and goes until the original constructor is on the top of the Stack.   Note  The compiler will put a call to  super()  in  each  of your overloaded constructors, if you do  not  have calls to  super() .   The superclass parts of an object have to be fully-formed (completely built) before the subclass parts can be constructed.  So the call to  Super()  must be  the  first  statement in each constructor!", 
            "title": "invoke a superclass constructor"
        }, 
        {
            "location": "/hfj/ch9/#this", 
            "text": "this  is a  reference  to  the current object .     this()  calls the real constructor and let the real constructor finish the job of construction.  The call to  this()  can be used only in a constructor, and must be the  first  statement in a constructor.  A constructor can have a call to  super()  or  this() , but never both!   class   Mini   extends   Car   { \n     Color   color ; \n     public   Mini ()   {  \n         // The no-arg constructor supplies a default Color \n         // and calls the overloaded Real Constructor (the one that calls super()) \n         this ( Color . Red ); \n     } \n\n     public   Mini ( Color   c )   {  \n         // The is the Real Constructor that does the real work of initializing the object \n         super ( \u201c Mini \u201d );    \n         color   =   c ;  \n         // more initialization  \n     } \n\n     public   Mini ( int   size )   {  \n         // Won t work!! Can t have super() and this() in the same constructor \n         // because they each must be the first statement! \n         this ( Color . Red );  \n         super ( size ); \n     }  }", 
            "title": "this"
        }, 
        {
            "location": "/hfj/ch9/#3-object-lifespan", 
            "text": "An Object's life depends entirely on the life of references referring to it.   If the reference is considered \"alive\", the object is still alive on the Heap.  If the reference dies, the object will die.   So if an object's life depends on the reference variable's life, how long does a variable live?   A  local  variable lives only within the method that declared the variable.  An  instance  variable lives as long as the object does. If the object is still alive, so are its instance variables.   The difference between  life  and  scope  for local variables:   Life : a local variable is alive as long as its Stack frame is  on the Stack.  Scope : a local variable is in  scope  only within the method in which the variable was declared. You can use a variable only when it is in scope.", 
            "title": "3 Object lifespan"
        }, 
        {
            "location": "/hfj/ch9/#object-lifecycle", 
            "text": "An object's life has no value, no meaning, no point, unless somebody has a reference to it. Because if you can't get to it, you can't ask it to do anything and it's just a big fat waste of bits.  An object becomes eligible for Garbage Collector(\u5783\u573e\u6536\u96c6\u5668) when its last live reference disappear.  Object-killer   Reference goes out of scope, permanently.  Assign the reference to another object.  Explicitly set the reference to null.", 
            "title": "Object lifecycle"
        }, 
        {
            "location": "/hfj/ch10/", 
            "text": "Chapter 10 Numbers and Statics\n\n\n1 Static methods\n\n\nMethods in the Math class don't use any instance variable values. Because the methods of Math are 'static', you don't need to have an instance of Math. All you need is the Math class.\n\n\nint\n \nx\n \n=\n \nMath\n.\nround\n(\n42.2\n);\n\n\nint\n \ny\n \n=\n \nMath\n.\nmin\n(\n56\n,\n \n12\n);\n\n\nint\n \nz\n \n=\n \nMath\n.\nabs\n(-\n343\n);\n\n\n\n\n\nIf you try to make an instance of class Math:\n\n\nMath\n \nmathObject\n \n=\n \nnew\n \nMath\n()\n\n\n\n\n\nYou'll get an error:\n\n\nMath() has private access in java.lang.Math\n\n\n\n\nThis error shows that the Math constructor is marked private! That means you can NEVER say \nnew\n on the Math class to make a new Math object.\n\n\nThe keyword \nstatic\n lets a method run \nwithout any instance of the class\n.\n\n\npublic\n \nstatic\n \nint\n \nmin\n(\nint\n \na\n,\n \nint\n \nb\n)\n \n{\n\n    \n//return the lesser of a  and b\n\n\n}\n\n\n\n\n\nstatic method v.s. non-static method:\n\n\n\n\nCall a static method using a class name (e.g.\nMath.min(88, 12)\n)\n\n\nCall a non-static method using a reference variable name (e.g. \nt2.play()\n)\n\n\n\n\nComparison between abstract class and private constructor\n\n\nOften (although not always), a class with static method is not to be instantiated. But this does not mean that a class with one or more static methods should never be instantiated. In fact, every class you put a \nmain()\n method in is a class with a static method in it.\n\n\nAn abstract class is impossible to be instantiated. And a non-abstract class with private constructor means only code from within the class can invoke the constructor.\n\n\nUsage\n\n\nStatic methods can't use non-static methods/variables\n, because static methods run without knowing about any particular instance of the static method's class.\n\n\npublic\n \nclass\n \nDuck\n \n{\n\n    \nprivate\n \nint\n \nsize\n;\n\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n \n(\nString\n[]\n \nargs\n)\n \n{\n\n        \n// which Duck? Whose size?\n\n        \nSystem\n.\nout\n.\nprintln\n(\nSize of duck is \n \n+\n \nsize\n);\n\n        \n// Calling getSize() just postpones \n\n        \n// the inevitable-getSize() use the size instance varible.\n\n        \nSystem\n.\nout\n.\nprintln\n(\nsize is \n \n+\n \ngetSize\n());\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nsetSize\n(\nint\n \ns\n)\n \n{\n\n        \nsize\n \n=\n \ns\n;\n\n    \n}\n\n\n    \npublic\n \nint\n \ngetSize\n()\n \n{\n\n        \nreturn\n \nsize\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n2 Static variable\n\n\nStatic variable: value is the same for All instances of the class.\n\n\n\n\nStatic variables are shared by all instances of a class. \n\n\nIn other words, one value per \nclass\n, instead of one value per \ninstance\n.\n\n\n\n\npublic\n \nclass\n \nDuck\n \n{\n\n    \nprivate\n \nint\n \nsize\n;\n\n    \n// The static duckCount variable is initialized\n\n    \n// ONLY when the class is first loaded,\n\n    \n// NOT each time a new instance is made\n\n    \nprivate\n \nstatic\n \nint\n \nduckCount\n \n=\n \n0\n;\n\n\n    \npublic\n \nDuck\n()\n \n{\n\n        \n// Now it will keep incrementing each time the Duck constructor runs\n\n        \n// because duck Count is static and won\nt reset to 0.\n\n        \nduckCount\n++;\n\n    \n}\n\n\n    \npublic\n \nvoid\n \nsetSize\n(\nint\n \ns\n)\n \n{\n\n        \nsize\n \n=\n \ns\n;\n\n    \n}\n\n\n    \npublic\n \nint\n \ngetSize\n()\n \n{\n\n        \nreturn\n \nsize\n;\n\n    \n}\n\n\n}\n\n\n\n\n\nInitializing a static variable\n\n\nThere are two guarantees about static initialization:\n\n\n\n\nStatic variables in a class are initialized before any \nobject\n of that class can be created.\n\n\nStatic variables in a class are initialized before any \nstatic method\n of the class runs.\n\n\nIf you don't explicitly initialize a static variable, it gets a default value when declared. ( in exactly the same way that instance variables are given default values)\n\n\n\n\nStatic final\n\n\n Static final variables are constants.\n\n\nA variable marked \nfinal\n means that -- once initialized -- it can never change. In other words, the value of the \nstatic final\n variable will stay the same as long as the class is loaded. \n\n\nFor example, \nMath.PI\n is declared as\n\n\npublic\n \nstatic\n \nfinal\n \ndouble\n \nPI\n \n=\n \n3.141592653589793\n;\n\n\n\n\n\nName convection: \nConstant variables names should be in all caps!\n\n\nfinal\n variables in Java must be initialized.\n\n\nfinal\n \nclass\n \ninitialize_final\n\n\n{\n\n    \nprivate\n \nint\n \nx\n;\n \n// x will have a default value without initialization.\n\n    \nprivate\n \nfinal\n \nint\n \ny\n \n=\n \n0\n;\n \n//y must be initialized.\n\n    \nprivate\n \nfinal\n \nint\n \nz\n;\n \n//ERROR! y must be initialized.\n\n    \nprivate\n \nstatic\n \nfinal\n \nint\n \nh\n;\n  \n//h must be initialized.\n\n\n    \nstatic\n\n    \n{\n\n        \nh\n \n=\n \n10\n;\n  \n//static final variable can be initialized here. See details in next section.\n\n    \n}\n\n\n}\n\n\n//output: Error: variable z not initialized in the default constructor.\n\n\n\n\n\nStatic block\n\n\nA \nstatic block\n(\u9759\u6001\u5757) or \nstatic initializer\n(\u9759\u6001\u521d\u59cb\u5316\u7a0b\u5e8f) is a block of code that runs when a class is loaded, \nbefore any other code can use the class\n , so it's a great place to initialize a static final variable.\n\n\npublic\n \nclass\n \nBar\n \n{\n\n    \npublic\n \nstatic\n \nfinal\n \ndouble\n \nBAR_SIGN\n;\n\n\n    \nstatic\n \n{\n\n        \n// this code runs as soon as the class is loaded,\n\n        \n// before any static method is called,\n\n        \n// and even before any static variable can be used.\n\n        \nBAR_SIGN\n \n=\n \n(\ndouble\n)\n \nMath\n.\nrandom\n();\n\n    \n}\n\n\n}\n\n\n\n\n\nImportant Notes:\n\n\n\n\nStatic blocks will be executed only once as soon the class is \nloaded in memory\n.\n\n\nThey are executed in \nthe order which they appear\n in the class.\n\n\nYou cannot refer to any instance variables from within the static blocks.\n\n\nYou can have as many static blocks as many you want in a class.\n\n\n\n\nclass\n \nStaticSuper\n{\n\n    \nstatic\n \n{\n \n        \nSystem\n.\nout\n.\nprintln\n(\nsuper static block\n);\n \n    \n}\n\n\n    \nStaticSuper\n(){\n\n        \nSystem\n.\nout\n.\nprintln\n(\nsuper constructor\n);\n \n    \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nStaticTests\n \nextends\n \nStaticSuper\n \n{\n\n    \nstatic\n \nint\n \nrand\n;\n\n\n    \nstatic\n \n{\n\n        \nrand\n \n=\n \n(\nint\n)\n \n(\nMath\n.\nrandom\n()*\n6\n);\n\n        \nSystem\n.\nout\n.\nprintln\n(\nstatic block\n \n+\n \nrand\n);\n\n    \n}\n\n\n    \nStaticTests\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nconstructor\n);\n\n    \n}\n\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n \n[]\n \nargs\n)\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nint main\n);\n\n        \nStaticTests\n \nst\n \n=\n \nnew\n \nStaticTests\n();\n\n    \n}\n\n\n}\n\n\n\n\n\noutput: \n\n\nsuper static block\nstatic block2\nint main\nsuper constructor\nconstructor\n\n\n\n\nFinal\n\n\nThe keyword \nfinal\n can modify non-static variables, including instance variables, local variables, and even method parameters. In each case, it means the same thing: \nthe value can't be changed\n .\n\n\n\n\nA final \nvariable\n means you can't \nchange\n its value.\n\n\nA final \nmethod\n means you can't \noverride\n the method.\n\n\nA final \nclass\n means you can't \nextend\n the class.\n\n\n\n\n\n\nNote\n\n\nIf the class is final, you don't need to mark the method final.\n\n\n\n\n3 Wrapping a primitive\n\n\nSometimes you want to treat a primitive like an object. For example, in all versions of Java prior to 5.0, you can't put a primitive directly into a collection like ArrayList or HashMap:\n\n\nint\n \nx\n \n=\n \n32\n;\n\n\nArrayList\n \nlist\n \n=\n \nnew\n \nArrayList\n();\n\n\n// ArrayList only has add() methods that\n\n\n// take object references,  not primitives.\n\n\nlist\n.\nadd\n(\nx\n);\n\n\n\n\n\nWhen you need to treat a primitive like an object, wrap it. Java provide wrapper classes for every primitive type. Each one is named after the primitive type it wraps, but with the first letter capitalized.\n\n\n\n\nBoolean\n\n\nCharacter // different: char\n\n\nByte\n\n\nShort\n\n\nInteger // different: int\n\n\nLong\n\n\nFloat\n\n\nDouble\n\n\n\n\n\n\nAutoboxing\n\n\nThe \nautoboxing/unboxing\n(\u81ea\u52a8\u88c5\u7bb1/\u62c6\u7bb1) feature added to Java 5.0 does the conversion from primitive to wrap/unwrap object \nautomatically\n!\n\n\npublic\n \nvoid\n \ndoNumsNewWay\n()\n \n{\n\n    \n// Make an ArrayList of type Integer\n\n    \nArrayList\nInteger\n \nlistOfNumbers\n \n=\n \nnew\n \nArrayList\nInteger\n();\n\n    \n// Just add it!\n\n    \nlistOfNumbers\n.\nadd\n(\n3\n);\n \n    \n// And the compiler automatically unwraps (unboxes) the Integer object\n\n    \n// so you can assign the int value directly to a primitive without\n\n    \n// having to call the intValue() method on the Integer object.\n\n    \nint\n \nnum\n \n=\n \nlistOfNumbers\n.\nget\n(\n0\n);\n\n\n}\n\n\n\n\n\nAutoboxing works almost everywhere:\n\n\n\n\nMethod arguments: \nvoid takeNumber(Integer i){}\n\n\nReturn values: \nint giveNumber(){ Integer x = new Integer(42); return x; }\n\n\nBoolean expressions: \nif (bool) {System.out.println(\ntrue\n);}\n\n\nOption on numbers: \nInteger i = new Integer(42); i++\n\n\nAssignments: \ndouble x = 10.0; Double d = x;\n\n\n\n\nWrapper method\n\n\nWrappers have a bunch of really useful static methods.\n\n\nString\n \ns\n \n=\n \n2\n;\n\n\nint\n \nx\n \n=\n \nInteger\n.\nparseInt\n(\ns\n);\n\n\ndouble\n \nd\n \n=\n \nInteger\n.\nparseDobule\n(\n420.24\n);\n\n\n\ndouble\n \nd\n \n=\n \n42.5\n;\n\n\nString\n \ndoubleString\n \n=\n \nDouble\n.\ntoString\n(\nd\n);\n\n\n\n\n\n4 Number formatting\n\n\nJava has a powerful and flexible formatting through a Formatter class in \njava.util\n. You don't need to create and call methods on the Formatter class yourself, just calling a static \nString.format()\n method and passing it the thing you want formatted along with formatting instructions.\n\n\nString\n \ns\n \n=\n \nString\n.\nformat\n(\n%, d\n,\n \n1000000000\n);\n\n\nSystem\n.\nout\n.\nprintln\n(\ns\n);\n \n// output: 1,000,000,000\n\n\n\n\n\nThe format specifier\n\n\nThe \nformat specifier\n(\u683c\u5f0f\u8bf4\u660e\u7b26) is the things that go after the percentage (%) sign.\n\n\nA format specifier can have up to five different parts (not including the \u201c%\u201d). Everything in brackets \n[ ]\n below is \noptional\n, so only the percent (%) and the type are required. But the \norder\n is also \nmandatory\n, so any parts you DO use must go in this order.\n\n\n\n%[argument number][\ufb02ags][width][.precision]type\n\n\n\n\n\nflags\n: It is for special formatting options like inserting commas, or putting negative numbers in parentheses, or to make the numbers left justified.\n\n\nwidth\n: It defines the MINIMUM number of characters that will be used. If the number is longer than the width, it'll still be used in full, but if it's less than the width, it'll be padded with zeros.\n\n\nprecision\n: It defines the precision. It sets the number of decimal places.\n\n\ntype\n: It is mandatory and will usually be \"d\" for a decimal integer or \"f\" for a floating point number.\n\n\n\n\nA few examples:\n\n\n\n\n%,d: insert commas and format the number as a decimal integer.\n\n\n%,.2f: insert commas and format the number as a floating point with a precision of two decimal places.\n\n\n\n\nDate Formatting\n\n\nDate formats use a two-character type that starts with \"t\".\n\n\nimport\n \njava.util.Date\n\n\n//The complete data and time: %tc\n\n\nString\n.\nformat\n(\n%tc\n,\n \nnew\n \nDate\n());\n \n//output: Mon Jul 30 16:33:29 CST 2017\n\n\n// Just the time %tr\n\n\nString\n.\nformat\n(\n%tr\n,\n \nnew\n \nDate\n());\n \n// output: 04:35:11 PM\n\n\n// Day of the week, month and day %tA %tB %td\n\n\nDate\n \ntoday\n \n=\n \nnew\n \nDate\n();\n \n\nString\n.\nformat\n(\n\u201c\n%\ntA\n,\n \n%\ntB\n \n%\ntd\n\u201d\n,\ntoday\n,\ntoday\n,\ntoday\n)\n \n// output: Sunday, November 28\n\n\nString\n.\nformat\n(\n\u201c\n%\ntA\n,\n \n%\ntB\n \n%\n \ntd\n\u201d\n,\ntoday\n);\n \n// output: Sunday, November 28\n\n\n\n\n\nCalendar\n\n\nFor a time-stamp of \"now\" use Date. But for everything else, use \nCalendar\n (in \njava\n.\nutil\n.\nCalendar\n).\n\n\nCalendar is actually an abstract class, so you can't use \nnew\n. Instead, use the static \ngetInstance()\n method, which gives you an \ninstance of a concrete Calendar subclass\n.\n\n\nExamples of working with a Calendar object:\n\n\nCalendar\n \nc\n \n=\n \nCalendar\n.\ngetInstance\n();\n \n\nc\n.\nset\n(\n2004\n,\n0\n,\n7\n,\n15\n,\n40\n);\n \n// set time to Jan 7, 2004 at 15:40 (Notice the month is zero-based)\n\n\nlong\n \nday1\n \n=\n \nc\n.\ngetTimeInMillis\n();\n\n\nday1\n \n+=\n \n1000\n \n*\n \n60\n \n*\n \n60\n;\n \n\nc\n.\nsetTimeInMillis\n(\nday1\n);\n \n\nSystem\n.\nout\n.\nprintln\n(\nnew hour \n \n+\n \nc\n.\nget\n(\nc\n.\nHOUR_OF_DAY\n));\n  \n//new hour 16\n\n\nc\n.\nadd\n(\nc\n.\nDATE\n,\n \n35\n);\n \n\nSystem\n.\nout\n.\nprintln\n(\nadd 35 days \n \n+\n \nc\n.\ngetTime\n());\n  \n// add 35 days Wed Feb 11 16:40:03 CST 2004\n\n\nc\n.\nroll\n(\nc\n.\nDATE\n,\n \n35\n);\n\n\nSystem\n.\nout\n.\nprintln\n(\nroll 35 days \n \n+\n \nc\n.\ngetTime\n());\n \n// roll 35 days Tue Feb 17 16:40:03 CST 2004\n\n\nc\n.\nset\n(\nc\n.\nDATE\n,\n \n1\n);\n \n\nSystem\n.\nout\n.\nprintln\n(\nset to 1 \n \n+\n \nc\n.\ngetTime\n());\n \n//set to 1 Sun Feb 01 16:40:03 CST 2004", 
            "title": "Chapter 10: Numbers and Statics"
        }, 
        {
            "location": "/hfj/ch10/#chapter-10-numbers-and-statics", 
            "text": "", 
            "title": "Chapter 10 Numbers and Statics"
        }, 
        {
            "location": "/hfj/ch10/#1-static-methods", 
            "text": "Methods in the Math class don't use any instance variable values. Because the methods of Math are 'static', you don't need to have an instance of Math. All you need is the Math class.  int   x   =   Math . round ( 42.2 );  int   y   =   Math . min ( 56 ,   12 );  int   z   =   Math . abs (- 343 );   If you try to make an instance of class Math:  Math   mathObject   =   new   Math ()   You'll get an error:  Math() has private access in java.lang.Math  This error shows that the Math constructor is marked private! That means you can NEVER say  new  on the Math class to make a new Math object.  The keyword  static  lets a method run  without any instance of the class .  public   static   int   min ( int   a ,   int   b )   { \n     //return the lesser of a  and b  }   static method v.s. non-static method:   Call a static method using a class name (e.g. Math.min(88, 12) )  Call a non-static method using a reference variable name (e.g.  t2.play() )", 
            "title": "1 Static methods"
        }, 
        {
            "location": "/hfj/ch10/#comparison-between-abstract-class-and-private-constructor", 
            "text": "Often (although not always), a class with static method is not to be instantiated. But this does not mean that a class with one or more static methods should never be instantiated. In fact, every class you put a  main()  method in is a class with a static method in it.  An abstract class is impossible to be instantiated. And a non-abstract class with private constructor means only code from within the class can invoke the constructor.", 
            "title": "Comparison between abstract class and private constructor"
        }, 
        {
            "location": "/hfj/ch10/#usage", 
            "text": "Static methods can't use non-static methods/variables , because static methods run without knowing about any particular instance of the static method's class.  public   class   Duck   { \n     private   int   size ; \n\n     public   static   void   main   ( String []   args )   { \n         // which Duck? Whose size? \n         System . out . println ( Size of duck is    +   size ); \n         // Calling getSize() just postpones  \n         // the inevitable-getSize() use the size instance varible. \n         System . out . println ( size is    +   getSize ()); \n     } \n\n     public   void   setSize ( int   s )   { \n         size   =   s ; \n     } \n\n     public   int   getSize ()   { \n         return   size ; \n     }  }", 
            "title": "Usage"
        }, 
        {
            "location": "/hfj/ch10/#2-static-variable", 
            "text": "Static variable: value is the same for All instances of the class.   Static variables are shared by all instances of a class.   In other words, one value per  class , instead of one value per  instance .   public   class   Duck   { \n     private   int   size ; \n     // The static duckCount variable is initialized \n     // ONLY when the class is first loaded, \n     // NOT each time a new instance is made \n     private   static   int   duckCount   =   0 ; \n\n     public   Duck ()   { \n         // Now it will keep incrementing each time the Duck constructor runs \n         // because duck Count is static and won t reset to 0. \n         duckCount ++; \n     } \n\n     public   void   setSize ( int   s )   { \n         size   =   s ; \n     } \n\n     public   int   getSize ()   { \n         return   size ; \n     }  }", 
            "title": "2 Static variable"
        }, 
        {
            "location": "/hfj/ch10/#initializing-a-static-variable", 
            "text": "There are two guarantees about static initialization:   Static variables in a class are initialized before any  object  of that class can be created.  Static variables in a class are initialized before any  static method  of the class runs.  If you don't explicitly initialize a static variable, it gets a default value when declared. ( in exactly the same way that instance variables are given default values)", 
            "title": "Initializing a static variable"
        }, 
        {
            "location": "/hfj/ch10/#static-final", 
            "text": "Static final variables are constants.  A variable marked  final  means that -- once initialized -- it can never change. In other words, the value of the  static final  variable will stay the same as long as the class is loaded.   For example,  Math.PI  is declared as  public   static   final   double   PI   =   3.141592653589793 ;   Name convection:  Constant variables names should be in all caps!  final  variables in Java must be initialized.  final   class   initialize_final  { \n     private   int   x ;   // x will have a default value without initialization. \n     private   final   int   y   =   0 ;   //y must be initialized. \n     private   final   int   z ;   //ERROR! y must be initialized. \n     private   static   final   int   h ;    //h must be initialized. \n\n     static \n     { \n         h   =   10 ;    //static final variable can be initialized here. See details in next section. \n     }  }  //output: Error: variable z not initialized in the default constructor.", 
            "title": "Static final"
        }, 
        {
            "location": "/hfj/ch10/#static-block", 
            "text": "A  static block (\u9759\u6001\u5757) or  static initializer (\u9759\u6001\u521d\u59cb\u5316\u7a0b\u5e8f) is a block of code that runs when a class is loaded,  before any other code can use the class  , so it's a great place to initialize a static final variable.  public   class   Bar   { \n     public   static   final   double   BAR_SIGN ; \n\n     static   { \n         // this code runs as soon as the class is loaded, \n         // before any static method is called, \n         // and even before any static variable can be used. \n         BAR_SIGN   =   ( double )   Math . random (); \n     }  }   Important Notes:   Static blocks will be executed only once as soon the class is  loaded in memory .  They are executed in  the order which they appear  in the class.  You cannot refer to any instance variables from within the static blocks.  You can have as many static blocks as many you want in a class.   class   StaticSuper { \n     static   {  \n         System . out . println ( super static block );  \n     } \n\n     StaticSuper (){ \n         System . out . println ( super constructor );  \n     }  }  public   class   StaticTests   extends   StaticSuper   { \n     static   int   rand ; \n\n     static   { \n         rand   =   ( int )   ( Math . random ()* 6 ); \n         System . out . println ( static block   +   rand ); \n     } \n\n     StaticTests ()   { \n         System . out . println ( constructor ); \n     } \n\n     public   static   void   main ( String   []   args )   { \n         System . out . println ( int main ); \n         StaticTests   st   =   new   StaticTests (); \n     }  }   output:   super static block\nstatic block2\nint main\nsuper constructor\nconstructor", 
            "title": "Static block"
        }, 
        {
            "location": "/hfj/ch10/#final", 
            "text": "The keyword  final  can modify non-static variables, including instance variables, local variables, and even method parameters. In each case, it means the same thing:  the value can't be changed  .   A final  variable  means you can't  change  its value.  A final  method  means you can't  override  the method.  A final  class  means you can't  extend  the class.    Note  If the class is final, you don't need to mark the method final.", 
            "title": "Final"
        }, 
        {
            "location": "/hfj/ch10/#3-wrapping-a-primitive", 
            "text": "Sometimes you want to treat a primitive like an object. For example, in all versions of Java prior to 5.0, you can't put a primitive directly into a collection like ArrayList or HashMap:  int   x   =   32 ;  ArrayList   list   =   new   ArrayList ();  // ArrayList only has add() methods that  // take object references,  not primitives.  list . add ( x );   When you need to treat a primitive like an object, wrap it. Java provide wrapper classes for every primitive type. Each one is named after the primitive type it wraps, but with the first letter capitalized.   Boolean  Character // different: char  Byte  Short  Integer // different: int  Long  Float  Double", 
            "title": "3 Wrapping a primitive"
        }, 
        {
            "location": "/hfj/ch10/#autoboxing", 
            "text": "The  autoboxing/unboxing (\u81ea\u52a8\u88c5\u7bb1/\u62c6\u7bb1) feature added to Java 5.0 does the conversion from primitive to wrap/unwrap object  automatically !  public   void   doNumsNewWay ()   { \n     // Make an ArrayList of type Integer \n     ArrayList Integer   listOfNumbers   =   new   ArrayList Integer (); \n     // Just add it! \n     listOfNumbers . add ( 3 );  \n     // And the compiler automatically unwraps (unboxes) the Integer object \n     // so you can assign the int value directly to a primitive without \n     // having to call the intValue() method on the Integer object. \n     int   num   =   listOfNumbers . get ( 0 );  }   Autoboxing works almost everywhere:   Method arguments:  void takeNumber(Integer i){}  Return values:  int giveNumber(){ Integer x = new Integer(42); return x; }  Boolean expressions:  if (bool) {System.out.println( true );}  Option on numbers:  Integer i = new Integer(42); i++  Assignments:  double x = 10.0; Double d = x;", 
            "title": "Autoboxing"
        }, 
        {
            "location": "/hfj/ch10/#wrapper-method", 
            "text": "Wrappers have a bunch of really useful static methods.  String   s   =   2 ;  int   x   =   Integer . parseInt ( s );  double   d   =   Integer . parseDobule ( 420.24 );  double   d   =   42.5 ;  String   doubleString   =   Double . toString ( d );", 
            "title": "Wrapper method"
        }, 
        {
            "location": "/hfj/ch10/#4-number-formatting", 
            "text": "Java has a powerful and flexible formatting through a Formatter class in  java.util . You don't need to create and call methods on the Formatter class yourself, just calling a static  String.format()  method and passing it the thing you want formatted along with formatting instructions.  String   s   =   String . format ( %, d ,   1000000000 );  System . out . println ( s );   // output: 1,000,000,000", 
            "title": "4 Number formatting"
        }, 
        {
            "location": "/hfj/ch10/#the-format-specifier", 
            "text": "The  format specifier (\u683c\u5f0f\u8bf4\u660e\u7b26) is the things that go after the percentage (%) sign.  A format specifier can have up to five different parts (not including the \u201c%\u201d). Everything in brackets  [ ]  below is  optional , so only the percent (%) and the type are required. But the  order  is also  mandatory , so any parts you DO use must go in this order.  \n%[argument number][\ufb02ags][width][.precision]type   flags : It is for special formatting options like inserting commas, or putting negative numbers in parentheses, or to make the numbers left justified.  width : It defines the MINIMUM number of characters that will be used. If the number is longer than the width, it'll still be used in full, but if it's less than the width, it'll be padded with zeros.  precision : It defines the precision. It sets the number of decimal places.  type : It is mandatory and will usually be \"d\" for a decimal integer or \"f\" for a floating point number.   A few examples:   %,d: insert commas and format the number as a decimal integer.  %,.2f: insert commas and format the number as a floating point with a precision of two decimal places.", 
            "title": "The format specifier"
        }, 
        {
            "location": "/hfj/ch10/#date-formatting", 
            "text": "Date formats use a two-character type that starts with \"t\".  import   java.util.Date  //The complete data and time: %tc  String . format ( %tc ,   new   Date ());   //output: Mon Jul 30 16:33:29 CST 2017  // Just the time %tr  String . format ( %tr ,   new   Date ());   // output: 04:35:11 PM  // Day of the week, month and day %tA %tB %td  Date   today   =   new   Date ();   String . format ( \u201c % tA ,   % tB   % td \u201d , today , today , today )   // output: Sunday, November 28  String . format ( \u201c % tA ,   % tB   %   td \u201d , today );   // output: Sunday, November 28", 
            "title": "Date Formatting"
        }, 
        {
            "location": "/hfj/ch10/#calendar", 
            "text": "For a time-stamp of \"now\" use Date. But for everything else, use  Calendar  (in  java . util . Calendar ).  Calendar is actually an abstract class, so you can't use  new . Instead, use the static  getInstance()  method, which gives you an  instance of a concrete Calendar subclass .  Examples of working with a Calendar object:  Calendar   c   =   Calendar . getInstance ();   c . set ( 2004 , 0 , 7 , 15 , 40 );   // set time to Jan 7, 2004 at 15:40 (Notice the month is zero-based)  long   day1   =   c . getTimeInMillis ();  day1   +=   1000   *   60   *   60 ;   c . setTimeInMillis ( day1 );   System . out . println ( new hour    +   c . get ( c . HOUR_OF_DAY ));    //new hour 16  c . add ( c . DATE ,   35 );   System . out . println ( add 35 days    +   c . getTime ());    // add 35 days Wed Feb 11 16:40:03 CST 2004  c . roll ( c . DATE ,   35 );  System . out . println ( roll 35 days    +   c . getTime ());   // roll 35 days Tue Feb 17 16:40:03 CST 2004  c . set ( c . DATE ,   1 );   System . out . println ( set to 1    +   c . getTime ());   //set to 1 Sun Feb 01 16:40:03 CST 2004", 
            "title": "Calendar"
        }, 
        {
            "location": "/hfj/ch11/", 
            "text": "Chapter 11 Exception Handling\n\n\n1 Exception\n\n\nMethods in Java use exceptions to tell the calling code, \"Something Bad Happened. I failed.\"\n\n\n\n\nIf a method can fail at runtime, a method has to declare the exceptions it might throw. \n\n\nYou may find a \nthrows\n clause in the risky(exception-throwing) method'sdeclaration. \n\n\nIt's the risky method that \nthrows\n the exception to \nyou\n.\n\n\n\n\npublic\n \nstatic\n \nSequencer\n \ngetSequencer\n()\n \nthrows\n \nMidiUnavailableException\n\n\n\n\n\ntry/catch\n\n\nIf you wrap the risky code in something called a \ntry/catch\n, the compiler will relax.\n\n\nA \ntry/catch\n block tells the compiler that you \nknow\n an exceptional thing could happen in the method you're calling, and that you're prepared to handle it.\n\n\nAn exception is an object of type \nException\n.\n\n\ntry\n \n{\n\n    \n// do risky thing\n\n\n}\n \ncatch\n(\nException\n \nex\n)\n \n{\n \n// its just like declaring a method argument\n\n    \n// try to recover\n\n    \n// This code only runs if an Exception is throw\n\n\n}\n\n\n\n\n\nchecked and unchecked exceptions\n\n\nThe compiler checks for everything except \nRuntimeExceptions\n.\n\n\n\n\n\n\nThe compiler cares about all subclasses of Exception, unless they are a special type, RuntimeException.\n\n\nAny exception class that extends RuntimeException gets a free pass.\n\n\nRuntimeExceptions can be thrown anywhere, with or without throws declarations or try/catch blocks.\n\n\nMost RuntimeExceptions come from a problem in your \ncode logic\n, rather than a condition that fails at runtime in ways that you cannot predict or prevent.\n\n\ne.g. You \ncannot\n guarantee the server is up. You \ncannot\n guarantee the file is there. But you \ncan\n make sure your code doesn't index of the end of an array.\n\n\n\n\n\n\n\n\nFlow control in try/catch blocks\n\n\n\n\nIf the try \nsucceeds\n, the code below the catch runs.\n\n\nIf the try \nfails\n, it throws an exception and the rest of the try block doesn't run. And the catch block runs.\n\n\n\n\nFinally block\n\n\nA finally block is where you put code that must run regardless of an exception.\n\n\n\n\nIf the try block fails (an exception), flow control immediately moves to the catch block. When the catch block completes, the finally block runs.\n\n\nIf the try block succeeds (no exception), flow control skips over the catch block and moves to the finally block.\n\n\nIf the try or catch block has a return statement, finally block will still run! Flow jumps to the finally, then back to the return.\n\n\n\n\n// You have to turn off the oven no matter what!\n\n\ntry\n \n{\n\n    \nturnOvenOn\n();\n \n    \nx\n.\nbake\n();\n\n\n}\n \ncatch\n \n(\nBakingException\n \nex\n)\n \n{\n\n    \nex\n.\nprintStackTrace\n();\n \n\n}\n \nfinally\n \n{\n\n    \nturnOvenOff\n();\n \n\n}\n\n\n\n\n\nMultiple exceptions\n\n\nA method can throw \nmultiple exceptions\n if it needs to. But a method's declaration must declare \nall\n the checked exceptions it can throw.\n\n\nStack the \ncatch\n blocks under the \ntry\n, one after the other.\n\n\npublic\n \nclass\n \nLaundry\n \n{\n\n    \npublic\n \nvoid\n \ndoLaundry\n()\n \nthrows\n \nPantsException\n,\n \nLingerieException\n{\n \n        \n// code that could throw either exception \n\n    \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nFoo\n \n{\n\n    \npublic\n \nvoid\n \ngo\n()\n \n{\n \n        \nLaundry\n \nlaundry\n \n=\n \nnew\n \nLaundry\n();\n\n        \ntry\n \n{\n\n            \nlaundry\n.\ndoLaundry\n();\n\n        \n}\n \ncatch\n(\nPantsException\n \npex\n)\n \n{\n\n            \n// recovery code\n\n        \n}\n \ncatch\n(\nLingerieException\n \nlex\n)\n \n{\n\n            \n// recovery code\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\nMultiple catch blocks must be ordered from smallest to biggest.\n\n\n\n\nThe higher up the inheritance tree, the bigger the catch \"basket\". (e.g. ClothingExceptions will catch TeeShirtException and ShirtException)\n\n\nWith catch blocks, the JVM simply starts at the first one and works its way down until it finds a catch that's \nbroad enough \nto handle the exception.\n\n\nIf your first catch block is `catch(Exception ex), the compiler knows there's no point in adding any others -- they'll never be reached.  \n\n\n\n\n\n\n\n\nPolymorphic Exception\n\n\nExceptions are objects. The benefit for it is that a method doesn't have to explicitly declare \nevery\n possible exception it might throw; it can declare a \nsuperclass\n of the exceptions.\n\n\nYou can DECLARE exceptions using a supertype of the exceptions you throw.\n\n\npublic\n \nvoid\n \ndoLaundry\n()\n \nthrows\n \nClothingException\n \n{\n  \n}\n\n\n\n\n\nSame thing with catch blocks. You don't have to write a catch for each possible exception as long as the catch (or catches) you have can handle any exception throw.\n\n\nYou can CATCH exceptions using a supertype of the exception thrown.\n\n\ntry\n \n{\n\n    \nlaundry\n.\ndoLaundry\n();\n\n\n}\n \ncatch\n(\nClothingException\n \ncex\n)\n \n{\n \n// can catch any clothingException subclass.\n\n    \n// recovery code\n\n\n}\n\n\n\n\n\nThe mother of all catch arguments is type \nException\n; it will catch \nany\n exception, including runtime (unchecked) exceptions, so you probably won't use it outside of testing.\n\n\nDuck exception\n\n\nIf you don't want to handle an exception, you can \nduck\n it by \ndeclaring\n it.\n\n\n// You don\nt REALLY throw it, but since you don\nt have a try/catch\n\n\n// for the risky method you call, you are now the risky method.\n\n\n\npublic\n \nvoid\n \nfoo\n()\n \nthrows\n \nReallyBadException\n \n{\n \n    \n// call risky method without a try/catch    \n\n    \nlaundry\n.\ndoLaundry\n();\n \n    \n}\n\n\n\nDucking (by declaring) only delays the inevitable. Sooner or later, somebody has to deal with it.\n\n\nBut what if \nmain()\n ducks the exception? \n\n\n\n\nThe exception is thrown back to JVM and the JVM shuts down.\n\n\n\n\nimport\n \njava.io.FileReader\n;\n\n\nimport\n \njava.io.IOException\n;\n\n\n\npublic\n \nclass\n \ntest\n \n{\n\n    \npublic\n \nvoid\n \ngo\n()\n \nthrows\n \nIOException\n \n{\n\n        \ntry\n \n{\n\n            \nString\n \nfileName\n \n=\n \nimdonotexist.file\n;\n\n            \nFileReader\n \nwriter\n \n=\n \nnew\n \nFileReader\n(\nfileName\n);\n\n\n        \n}\n \ncatch\n \n(\nIOException\n \nioexcept\n)\n \n{\n\n            \nioexcept\n.\nprintStackTrace\n();\n\n        \n}\n\n        \nfinally\n \n{\n\n            \nSystem\n.\nout\n.\nprintln\n(\nFinally....\n);\n\n\n        \n}\n\n    \n}\n\n\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \nthrows\n \nIOException\n \n{\n\n        \ntest\n \ntest1\n \n=\n \nnew\n \ntest\n();\n\n        \ntest1\n.\ngo\n();\n\n        \nSystem\n.\nout\n.\nprintln\n(\nI\nm in main.\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n2 MIDI Music Player\n\n\nJavaSound\n is a collection of classes and interfaces added to Java starting with version 1.3. JavaSound is split into two parts: MIDI and Sampled. \nMIDI\n stands for \nMusical Instrument Digital Interface\n, and is a standard protocol for getting different kinds of electronic sound equipment to communicate.\n\n\nMIDI data doesn't actually include any \nsound\n, but it does include the \ninstructions\n that a MIDI-reading instrument can play back.\n\n\nMaking actual sound\n\n\nHow it works in JavaSound:\n\n\n\n\n\n\nSequencer\n: It takes all the MIDI data and sends it to the right instruments. It's the thing that \nplays\n the music. Think of it like a \nmusic CD player\n.\n\n\nSequence\n: It is the Song, the musical piece that the Sequencer will play.\n\n\nTrack\n: The part of the Sequence that holds the actual information.\n\n\nMIDI Event\n: It is a message that the Sequence can understand.\n\n\n\n\nAnd you need FOUR steps:\n\n\n\n\nGet a \nSequencer\n and open it: \nSequencer\n \nplayer\n \n=\n \nMidiSystem\n.\ngetSequencer\n();\n \nplayer\n.\nopen\n();\n\n\nMake a new \nSequence\n: \nSequence\n \nseq\n \n=\n \nnew\n \nSequence\n(\ntiming\n,\n \n4\n);\n\n\nGet a new \nTrack\n from the Sequence: \nTrack\n \nt\n=\n \nseq\n.\ncreateTrack\n();\n\n\nFill the Track with \nMidiEvents\n and give the Sequence to the Sequencer: \nt\n.\nadd\n(\nmyMidiEvent1\n);\n \nplayer\n.\nsetSequence\n(\nseq\n);\n\n\n\n\n\n\nimport\n \njavax.sound.midi.*\n;\n\n\n\npublic\n \nclass\n \nMiniMiniMusicApp\n \n{\n   \n// this is the first one\n\n\n     \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n        \nMiniMiniMusicApp\n \nmini\n \n=\n \nnew\n \nMiniMiniMusicApp\n();\n\n        \nmini\n.\nplay\n();\n\n     \n}\n\n\n    \npublic\n \nvoid\n \nplay\n()\n \n{\n\n      \ntry\n \n{\n\n         \n// make (and open) a sequencer, make a sequence and track\n\n\n         \nSequencer\n \nsequencer\n \n=\n \nMidiSystem\n.\ngetSequencer\n();\n         \n         \nsequencer\n.\nopen\n();\n\n\n         \nSequence\n \nseq\n \n=\n \nnew\n \nSequence\n(\nSequence\n.\nPPQ\n,\n \n4\n);\n\n         \nTrack\n \ntrack\n \n=\n \nseq\n.\ncreateTrack\n();\n     \n\n         \n// now make two midi events (containing a midi message)\n\n         \nMidiEvent\n \nevent\n \n=\n \nnull\n;\n\n\n         \n// first make the message\n\n         \n// then stick the message into a midi event \n\n         \n// and add the event to the track\n\n          \nShortMessage\n \na\n \n=\n \nnew\n \nShortMessage\n();\n\n          \na\n.\nsetMessage\n(\n144\n,\n \n1\n,\n \n44\n,\n \n100\n);\n\n          \nMidiEvent\n \nnoteOn\n \n=\n \nnew\n \nMidiEvent\n(\na\n,\n \n1\n);\n//means at tick one, the above event happens\n\n          \ntrack\n.\nadd\n(\nnoteOn\n);\n\n\n          \nShortMessage\n \nb\n \n=\n \nnew\n \nShortMessage\n();\n\n          \nb\n.\nsetMessage\n(\n128\n,\n \n1\n,\n \n44\n,\n \n100\n);\n\n          \nMidiEvent\n \nnoteOff\n \n=\n \nnew\n \nMidiEvent\n(\nb\n,\n \n16\n);\n//means at tick one, the above event happens\n\n          \ntrack\n.\nadd\n(\nnoteOff\n);\n\n\n         \n// add the events to the track\n\n\n          \n// add the sequence to the sequencer, set timing, and start\n\n          \nsequencer\n.\nsetSequence\n(\nseq\n);\n\n\n          \nsequencer\n.\nstart\n();\n\n          \n// new\n\n          \nThread\n.\nsleep\n(\n1000\n);\n\n          \nsequencer\n.\nclose\n();\n\n          \nSystem\n.\nexit\n(\n0\n);\n\n      \n}\n \ncatch\n \n(\nException\n \nex\n)\n \n{\nex\n.\nprintStackTrace\n();}\n\n  \n}\n \n// close play\n\n\n\n}\n \n// close class\n\n\n\n\n\n\nMidiEvent\n\n\nA MidiEvent says what to do and when to do it.\n\n\nShortMessage\n \na\n \n=\n \nnew\n \nShortMessage\n();\n\n\na\n.\nsetMessage\n(\n144\n,\n \n1\n,\n \n44\n,\n \n100\n);\n\n\nMidiEvent\n \nnoteOn\n \n=\n \nnew\n \nMidiEvent\n(\na\n,\n \n1\n);\n\n\ntrack\n.\nadd\n(\nnoteon\n);\n\n\n\n\n\nExplanation for the code above:\n\n\nThe instructions are in the message, but the MidiEvent adds the moment in time when the instruction should be triggered. This MidiEvent says to trigger message \"a\" at the first beat (beat 1).", 
            "title": "Chapter 11: Exception Handling"
        }, 
        {
            "location": "/hfj/ch11/#chapter-11-exception-handling", 
            "text": "", 
            "title": "Chapter 11 Exception Handling"
        }, 
        {
            "location": "/hfj/ch11/#1-exception", 
            "text": "Methods in Java use exceptions to tell the calling code, \"Something Bad Happened. I failed.\"   If a method can fail at runtime, a method has to declare the exceptions it might throw.   You may find a  throws  clause in the risky(exception-throwing) method'sdeclaration.   It's the risky method that  throws  the exception to  you .   public   static   Sequencer   getSequencer ()   throws   MidiUnavailableException", 
            "title": "1 Exception"
        }, 
        {
            "location": "/hfj/ch11/#trycatch", 
            "text": "If you wrap the risky code in something called a  try/catch , the compiler will relax.  A  try/catch  block tells the compiler that you  know  an exceptional thing could happen in the method you're calling, and that you're prepared to handle it.  An exception is an object of type  Exception .  try   { \n     // do risky thing  }   catch ( Exception   ex )   {   // its just like declaring a method argument \n     // try to recover \n     // This code only runs if an Exception is throw  }", 
            "title": "try/catch"
        }, 
        {
            "location": "/hfj/ch11/#checked-and-unchecked-exceptions", 
            "text": "The compiler checks for everything except  RuntimeExceptions .    The compiler cares about all subclasses of Exception, unless they are a special type, RuntimeException.  Any exception class that extends RuntimeException gets a free pass.  RuntimeExceptions can be thrown anywhere, with or without throws declarations or try/catch blocks.  Most RuntimeExceptions come from a problem in your  code logic , rather than a condition that fails at runtime in ways that you cannot predict or prevent.  e.g. You  cannot  guarantee the server is up. You  cannot  guarantee the file is there. But you  can  make sure your code doesn't index of the end of an array.", 
            "title": "checked and unchecked exceptions"
        }, 
        {
            "location": "/hfj/ch11/#flow-control-in-trycatch-blocks", 
            "text": "If the try  succeeds , the code below the catch runs.  If the try  fails , it throws an exception and the rest of the try block doesn't run. And the catch block runs.", 
            "title": "Flow control in try/catch blocks"
        }, 
        {
            "location": "/hfj/ch11/#finally-block", 
            "text": "A finally block is where you put code that must run regardless of an exception.   If the try block fails (an exception), flow control immediately moves to the catch block. When the catch block completes, the finally block runs.  If the try block succeeds (no exception), flow control skips over the catch block and moves to the finally block.  If the try or catch block has a return statement, finally block will still run! Flow jumps to the finally, then back to the return.   // You have to turn off the oven no matter what!  try   { \n     turnOvenOn ();  \n     x . bake ();  }   catch   ( BakingException   ex )   { \n     ex . printStackTrace ();   }   finally   { \n     turnOvenOff ();   }", 
            "title": "Finally block"
        }, 
        {
            "location": "/hfj/ch11/#multiple-exceptions", 
            "text": "A method can throw  multiple exceptions  if it needs to. But a method's declaration must declare  all  the checked exceptions it can throw.  Stack the  catch  blocks under the  try , one after the other.  public   class   Laundry   { \n     public   void   doLaundry ()   throws   PantsException ,   LingerieException {  \n         // code that could throw either exception  \n     }  }  public   class   Foo   { \n     public   void   go ()   {  \n         Laundry   laundry   =   new   Laundry (); \n         try   { \n             laundry . doLaundry (); \n         }   catch ( PantsException   pex )   { \n             // recovery code \n         }   catch ( LingerieException   lex )   { \n             // recovery code \n         } \n     }  }    Multiple catch blocks must be ordered from smallest to biggest.   The higher up the inheritance tree, the bigger the catch \"basket\". (e.g. ClothingExceptions will catch TeeShirtException and ShirtException)  With catch blocks, the JVM simply starts at the first one and works its way down until it finds a catch that's  broad enough  to handle the exception.  If your first catch block is `catch(Exception ex), the compiler knows there's no point in adding any others -- they'll never be reached.", 
            "title": "Multiple exceptions"
        }, 
        {
            "location": "/hfj/ch11/#polymorphic-exception", 
            "text": "Exceptions are objects. The benefit for it is that a method doesn't have to explicitly declare  every  possible exception it might throw; it can declare a  superclass  of the exceptions.  You can DECLARE exceptions using a supertype of the exceptions you throw.  public   void   doLaundry ()   throws   ClothingException   {    }   Same thing with catch blocks. You don't have to write a catch for each possible exception as long as the catch (or catches) you have can handle any exception throw.  You can CATCH exceptions using a supertype of the exception thrown.  try   { \n     laundry . doLaundry ();  }   catch ( ClothingException   cex )   {   // can catch any clothingException subclass. \n     // recovery code  }   The mother of all catch arguments is type  Exception ; it will catch  any  exception, including runtime (unchecked) exceptions, so you probably won't use it outside of testing.", 
            "title": "Polymorphic Exception"
        }, 
        {
            "location": "/hfj/ch11/#duck-exception", 
            "text": "If you don't want to handle an exception, you can  duck  it by  declaring  it.  // You don t REALLY throw it, but since you don t have a try/catch  // for the risky method you call, you are now the risky method.  public   void   foo ()   throws   ReallyBadException   {  \n     // call risky method without a try/catch     \n     laundry . doLaundry ();  \n     }  \nDucking (by declaring) only delays the inevitable. Sooner or later, somebody has to deal with it.  But what if  main()  ducks the exception?    The exception is thrown back to JVM and the JVM shuts down.   import   java.io.FileReader ;  import   java.io.IOException ;  public   class   test   { \n     public   void   go ()   throws   IOException   { \n         try   { \n             String   fileName   =   imdonotexist.file ; \n             FileReader   writer   =   new   FileReader ( fileName ); \n\n         }   catch   ( IOException   ioexcept )   { \n             ioexcept . printStackTrace (); \n         } \n         finally   { \n             System . out . println ( Finally.... ); \n\n         } \n     } \n\n\n     public   static   void   main ( String []   args )   throws   IOException   { \n         test   test1   =   new   test (); \n         test1 . go (); \n         System . out . println ( I m in main. ); \n     }  }", 
            "title": "Duck exception"
        }, 
        {
            "location": "/hfj/ch11/#2-midi-music-player", 
            "text": "JavaSound  is a collection of classes and interfaces added to Java starting with version 1.3. JavaSound is split into two parts: MIDI and Sampled.  MIDI  stands for  Musical Instrument Digital Interface , and is a standard protocol for getting different kinds of electronic sound equipment to communicate.  MIDI data doesn't actually include any  sound , but it does include the  instructions  that a MIDI-reading instrument can play back.", 
            "title": "2 MIDI Music Player"
        }, 
        {
            "location": "/hfj/ch11/#making-actual-sound", 
            "text": "How it works in JavaSound:    Sequencer : It takes all the MIDI data and sends it to the right instruments. It's the thing that  plays  the music. Think of it like a  music CD player .  Sequence : It is the Song, the musical piece that the Sequencer will play.  Track : The part of the Sequence that holds the actual information.  MIDI Event : It is a message that the Sequence can understand.   And you need FOUR steps:   Get a  Sequencer  and open it:  Sequencer   player   =   MidiSystem . getSequencer ();   player . open ();  Make a new  Sequence :  Sequence   seq   =   new   Sequence ( timing ,   4 );  Get a new  Track  from the Sequence:  Track   t =   seq . createTrack ();  Fill the Track with  MidiEvents  and give the Sequence to the Sequencer:  t . add ( myMidiEvent1 );   player . setSequence ( seq );    import   javax.sound.midi.* ;  public   class   MiniMiniMusicApp   {     // this is the first one \n\n      public   static   void   main ( String []   args )   { \n         MiniMiniMusicApp   mini   =   new   MiniMiniMusicApp (); \n         mini . play (); \n      } \n\n     public   void   play ()   { \n       try   { \n          // make (and open) a sequencer, make a sequence and track \n\n          Sequencer   sequencer   =   MidiSystem . getSequencer ();          \n          sequencer . open (); \n\n          Sequence   seq   =   new   Sequence ( Sequence . PPQ ,   4 ); \n          Track   track   =   seq . createTrack ();      \n\n          // now make two midi events (containing a midi message) \n          MidiEvent   event   =   null ; \n\n          // first make the message \n          // then stick the message into a midi event  \n          // and add the event to the track \n           ShortMessage   a   =   new   ShortMessage (); \n           a . setMessage ( 144 ,   1 ,   44 ,   100 ); \n           MidiEvent   noteOn   =   new   MidiEvent ( a ,   1 ); //means at tick one, the above event happens \n           track . add ( noteOn ); \n\n           ShortMessage   b   =   new   ShortMessage (); \n           b . setMessage ( 128 ,   1 ,   44 ,   100 ); \n           MidiEvent   noteOff   =   new   MidiEvent ( b ,   16 ); //means at tick one, the above event happens \n           track . add ( noteOff ); \n\n          // add the events to the track \n\n           // add the sequence to the sequencer, set timing, and start \n           sequencer . setSequence ( seq ); \n\n           sequencer . start (); \n           // new \n           Thread . sleep ( 1000 ); \n           sequencer . close (); \n           System . exit ( 0 ); \n       }   catch   ( Exception   ex )   { ex . printStackTrace ();} \n   }   // close play  }   // close class", 
            "title": "Making actual sound"
        }, 
        {
            "location": "/hfj/ch11/#midievent", 
            "text": "A MidiEvent says what to do and when to do it.  ShortMessage   a   =   new   ShortMessage ();  a . setMessage ( 144 ,   1 ,   44 ,   100 );  MidiEvent   noteOn   =   new   MidiEvent ( a ,   1 );  track . add ( noteon );   Explanation for the code above:  The instructions are in the message, but the MidiEvent adds the moment in time when the instruction should be triggered. This MidiEvent says to trigger message \"a\" at the first beat (beat 1).", 
            "title": "MidiEvent"
        }, 
        {
            "location": "/hfj/ch12/", 
            "text": "Chapter 12 Getting GUI", 
            "title": "Chapter 12: Getting GUI"
        }, 
        {
            "location": "/hfj/ch12/#chapter-12-getting-gui", 
            "text": "", 
            "title": "Chapter 12 Getting GUI"
        }, 
        {
            "location": "/hfj/ch13/", 
            "text": "Chapter 13 Using Swing", 
            "title": "Chapter 13: Using Swing"
        }, 
        {
            "location": "/hfj/ch13/#chapter-13-using-swing", 
            "text": "", 
            "title": "Chapter 13 Using Swing"
        }, 
        {
            "location": "/hfj/ch14/", 
            "text": "Chapter 14 Serialization and File I/O", 
            "title": "Chapter 14: Serialization and File I/O"
        }, 
        {
            "location": "/hfj/ch14/#chapter-14-serialization-and-file-io", 
            "text": "", 
            "title": "Chapter 14 Serialization and File I/O"
        }, 
        {
            "location": "/hfj/ch15/", 
            "text": "Chapter 15 Networking and Threads", 
            "title": "Chapter 15: Networking and Threads"
        }, 
        {
            "location": "/hfj/ch15/#chapter-15-networking-and-threads", 
            "text": "", 
            "title": "Chapter 15 Networking and Threads"
        }, 
        {
            "location": "/hfj/ch16/", 
            "text": "Chapter 16 Collections and Generics", 
            "title": "Chapter 16: Collections and Generics"
        }, 
        {
            "location": "/hfj/ch16/#chapter-16-collections-and-generics", 
            "text": "", 
            "title": "Chapter 16 Collections and Generics"
        }, 
        {
            "location": "/hfj/ch17/", 
            "text": "Chapter 17 Packages, Jars and Deployment", 
            "title": "Chapter 17: Packages, Jars and Deployment"
        }, 
        {
            "location": "/hfj/ch17/#chapter-17-packages-jars-and-deployment", 
            "text": "", 
            "title": "Chapter 17 Packages, Jars and Deployment"
        }, 
        {
            "location": "/hfj/ch18/", 
            "text": "Chapter 18 Remote deploy with RMI", 
            "title": "Chapter 18: Remote deploy with RMI"
        }, 
        {
            "location": "/hfj/ch18/#chapter-18-remote-deploy-with-rmi", 
            "text": "", 
            "title": "Chapter 18 Remote deploy with RMI"
        }, 
        {
            "location": "/lkd/", 
            "text": "LKD\n\n\n\n\nChapter 1 : Introduction to Linux Kernel\n\n\nChapter 2\n\n\nChapter 3\n\n\nChapter 4\n\n\nChapter 5\n\n\nChapter 6\n\n\nChapter 7\n\n\nChapter 8\n\n\nChapter 9\n\n\nChapter 10\n\n\nChapter 11\n\n\nChapter 12: Memory management\n\n\nChapter 13\n\n\nChapter 14\n\n\nChapter 15\n\n\nChapter 16\n\n\nChapter 17\n\n\nChapter 18\n\n\nChapter 19\n\n\nChapter 20", 
            "title": "Contents"
        }, 
        {
            "location": "/lkd/#lkd", 
            "text": "Chapter 1 : Introduction to Linux Kernel  Chapter 2  Chapter 3  Chapter 4  Chapter 5  Chapter 6  Chapter 7  Chapter 8  Chapter 9  Chapter 10  Chapter 11  Chapter 12: Memory management  Chapter 13  Chapter 14  Chapter 15  Chapter 16  Chapter 17  Chapter 18  Chapter 19  Chapter 20", 
            "title": "LKD"
        }, 
        {
            "location": "/lkd/ch1/", 
            "text": "Linux Kernel Development 1 - Introduction to the Linux Kernel", 
            "title": "Chapter 1 : Introduction to Linux Kernel"
        }, 
        {
            "location": "/lkd/ch1/#linux-kernel-development-1-introduction-to-the-linux-kernel", 
            "text": "", 
            "title": "Linux Kernel Development 1 - Introduction to the Linux Kernel"
        }, 
        {
            "location": "/lkd/ch2/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 2"
        }, 
        {
            "location": "/lkd/ch2/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/lkd/ch3/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 3"
        }, 
        {
            "location": "/lkd/ch3/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/lkd/ch4/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 4"
        }, 
        {
            "location": "/lkd/ch4/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/lkd/ch5/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 5"
        }, 
        {
            "location": "/lkd/ch5/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/lkd/ch6/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 6"
        }, 
        {
            "location": "/lkd/ch6/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/lkd/ch7/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 7"
        }, 
        {
            "location": "/lkd/ch7/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/lkd/ch8/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 8"
        }, 
        {
            "location": "/lkd/ch8/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/lkd/ch9/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 9"
        }, 
        {
            "location": "/lkd/ch9/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/lkd/ch10/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 10"
        }, 
        {
            "location": "/lkd/ch10/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/lkd/ch11/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 11"
        }, 
        {
            "location": "/lkd/ch11/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/lkd/ch12/", 
            "text": "Linux Kernel Development 2 - Memory management", 
            "title": "Chapter 12: Memory management"
        }, 
        {
            "location": "/lkd/ch12/#linux-kernel-development-2-memory-management", 
            "text": "", 
            "title": "Linux Kernel Development 2 - Memory management"
        }, 
        {
            "location": "/lkd/ch13/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 13"
        }, 
        {
            "location": "/lkd/ch13/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/lkd/ch14/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 14"
        }, 
        {
            "location": "/lkd/ch14/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/lkd/ch15/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 15"
        }, 
        {
            "location": "/lkd/ch15/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/lkd/ch16/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 16"
        }, 
        {
            "location": "/lkd/ch16/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/lkd/ch17/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 17"
        }, 
        {
            "location": "/lkd/ch17/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/lkd/ch18/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 18"
        }, 
        {
            "location": "/lkd/ch18/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/lkd/ch19/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 19"
        }, 
        {
            "location": "/lkd/ch19/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/lkd/ch20/", 
            "text": "Linux Kernel Development 2 -", 
            "title": "Chapter 20"
        }, 
        {
            "location": "/lkd/ch20/#linux-kernel-development-2-", 
            "text": "", 
            "title": "Linux Kernel Development 2 -"
        }, 
        {
            "location": "/books/", 
            "text": "Books and Materials\n\n\nBooks\n\n\nThe following is the primary reading list of books. Each chapter is organized as a single page; the included sections are noted with major concepts, and summary.\n\n\nCSAPP\n\n\n\n\nComputer System: A Programmer's Perspective, 3rd Edition\n\n\nby Randal E. Bryant and David A. O'Hallaron\n\n\nOSC\n\n\n\n\nOperating System Concepts (10th Edition)\n\n\nby Silberschatz Abraham, Galvin, Peter B., Gagne, Greg\n\n\nHFJ\n\n\n\n\nHead first java, 2nd Edition\n\n\nby Kathy Sierra and Bert Bates\n\n\nLKD\n\n\n\n\nLinux Kernel Development, 3rd Edition\n\n\nby Robert Love", 
            "title": "Books"
        }, 
        {
            "location": "/books/#books-and-materials", 
            "text": "", 
            "title": "Books and Materials"
        }, 
        {
            "location": "/books/#books", 
            "text": "The following is the primary reading list of books. Each chapter is organized as a single page; the included sections are noted with major concepts, and summary.", 
            "title": "Books"
        }, 
        {
            "location": "/books/#csapp", 
            "text": "Computer System: A Programmer's Perspective, 3rd Edition  by Randal E. Bryant and David A. O'Hallaron", 
            "title": "CSAPP"
        }, 
        {
            "location": "/books/#osc", 
            "text": "Operating System Concepts (10th Edition)  by Silberschatz Abraham, Galvin, Peter B., Gagne, Greg", 
            "title": "OSC"
        }, 
        {
            "location": "/books/#hfj", 
            "text": "Head first java, 2nd Edition  by Kathy Sierra and Bert Bates", 
            "title": "HFJ"
        }, 
        {
            "location": "/books/#lkd", 
            "text": "Linux Kernel Development, 3rd Edition  by Robert Love", 
            "title": "LKD"
        }
    ]
}