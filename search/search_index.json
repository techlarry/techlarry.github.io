{
    "docs": [
        {
            "location": "/hfj/ch8/", 
            "text": "Chapter 8 Interfaces and Abstract Classes\n\n\n\n\n\n\nWhat's an interface? it's a 100% abstract class. \n\n\nWhat's an abstract class? it's a class that can't be instantiated.\n\n\n\n\n\n\n1 Abstract classes\n\n\nHere's where it gets weird:\n\n\n \nAnimal\n \nanim\n \n=\n \nnew\n \nAnimal\n();\n \n\n\n\nThere two are the same type, but what the heck does an Animal object look like?\n\n\nSome classes just should not be instantiated!\n\nHow?  By marking the class as \nabstract\n, the compiler will stop any code, anywhere, from ever creating an instance of that type. i.e. prevent a class from ever being instantiated.\n\n\nMaking a class abstract before the class declaration:\n\n\n \nabstract\n \nclass\n \nCaine\n \nextends\n \nAnimal\n \n{\n\n    \npublic\n \nvoid\n \nroam\n()\n \n{}\n\n\n}\n\n\n\n\nWhen you're designing your class inheritance structure, you have to decide which classes are \nabstract\n and which are \nconcrete\n. \n\n\n\n\nConcrete\n classes are those that are specific enough to be instantiated. \n\n\nA \nconcrete\n class just means that it's OK to make objects of that type.\n\n\nAn \nabstract class\n has virtually no use, no value, no purpose in life, unless it is extended.\n\n\n\n\n2 Abstract methods\n\n\nAn \nabstract method\n means the method must be \noverriden\n, whereas an abstract class means the class must be extended.\n\n\n\n\nThere isn't any code that would make sense in the abstract method, you won't put in a method body. e.g. \npublic\n \nabstract\n \nvoid\n \neat\n()\n.\n\n\nIf you declare an abstract method, you must mark the class abstract as well. You can't have an abstract method in a non-abstract class.\n\n\nYou must implement all abstract methods.\n\n\n\n\n3 The ultimate superclass: \nObject\n\n\nEvery class in Java extends class \nObject\n. Class \nObject\n is the mother of all classes; it's the superclass of everything. \n\n\n\n\nAny class that doesn't \nexplicitly\n extend another class, \nimplicitly\n extends \nObject\n.\n\n\n\n\nMethods of \nObject\n class:\n\n\n\n\nequals\n()\n: tell you if two objects are considered equal.\n\n\ngetClass\n()\n: Gives you back the class that object was instantiated from.\n\n\nhashCode\n()\n: Prints out a hashcode for the object\n\n\ntoString\n()\n: Prints out a String message with the name of the class and some other number we rarely care about.\n\n\n\n\nObject\n is a \nnon-abstract\n class because it's got method implementation code that all classes can inherit and use out-of-box, without having to override the methods.\n\n\nThe \nObject\n class serves two main purpose:\n\n\n\n\nTo act as a polymorphic type for methods that need to work on any class that you or anyone else makes \u4f5c\u4e3a\u65b9\u6cd5\u7684\u591a\u6001\u7c7b\u578b\n\n\nTo provide real method code that all objects in Java need at runtime (and putting them in class Object means all other classes inherit them).\u63d0\u4f9bJava\u5728\u6267\u884c\u671f\u5806\u4efb\u4f55\u5bf9\u8c61\u90fd\u6709\u9700\u8981\u7684\u5b9e\u73b0\u65b9\u6cd5\u4ee3\u7801\u3002\n\n\n\n\n4 Using polymorphic references of type Object has a price\n\n\nWhen you put an object into an \nArrayList\nDog\n, it goes in as a Dog, and comes out as a Dog:\n\n\n \n// Make an ArrayList declared to hold Dog objects.\n\n\nArrayList\nDog\n \nmyDogArrayList\n \n=\n \nnew\n \nArrayList\nDog\n();\n\n\n// Make a Dog\n\n\nDog\n \naDog\n \n=\n \nnew\n \nDog\n();\n\n\n// Add the Dog to the list\n\n\nmyDogArrayList\n.\nadd\n(\naDog\n);\n\n\n//Assign the Dog from the list to a new Dog reference variable\n\n\nDog\n \nd\n \n=\n \nmyDogArrayList\n.\nget\n(\n0\n);\n\n\n\n\nEverything comes out of an \nArrayList\nObject\n as a reference of type Object, regardless of what the actual object is.\n \u4efb\u4f55\u4ece\nArrayList\nObject\n\u53d6\u51fa\u7684\u4e1c\u897f\u90fd\u4f1a\u88ab\u5f53\u4f5cObject\u7c7b\u578b\u7684\u5f15\u7528\uff0c\u800c\u4e0d\u7ba1\u5b83\u539f\u6765\u662f\u4ec0\u4e48\u3002\n\n\n \n// make an ArrayList declared to hold any type of Object\n\n\nArrayList\nObject\n \nmyDogArrayList\n \n=\n \nnew\n \nArrayList\nobject\n()\n\n\n// make a Dog\n\n\nDog\n \naDog\n \n=\n \nnew\n \nDog\n();\n\n\n// Add the Dog to the list\n\n\nmyDogArrayList\n.\nadd\n(\naDog\n);\n\n\n// No!! Won\nt compile!! the get() method returns type Object.\n\n\n// The compiler knows only that the object inherits from Object,\n\n\n// but it doesn\nt know it\ns a Dog!!\n\n\nDog\n \nd\n \n=\n \nmyDogArrayList\n.\nget\n(\n0\n)\n\n\n\n\nThe compiler decides whether you can call a method based on the \nreference type\n , not the actual object type.\n\n\n \nObject\n \no\n \n=\n \nal\n.\nget\n(\nindex\n);\n\n\n// Class Object has a hashCode() method\n\n\n// so you can call that method on any object in Java\n\n\nint\n \ni\n \n=\n \no\n.\nhashCode\n();\n\n\n// Can\nt do this!! the Object class  has no idea what it means to bark().\n\n\no\n.\nbark\n();\n\n\n\n\n\n\nIf you're sure the object is really a Dog, you can make a new Dog reference to it by copying the Object reference, and forcing that copy to go into a Dog reference variable, using a \ncast (Dog)\n.\n\n\n \nObject\n \no\n \n=\n \nal\n.\nget\n(\nindex\n);\n\n\n// cast the Object back to a Dog we know is there.\n\n\nDog\n \nd\n \n=\n \n(\nDog\n)\n \no\n;\n \n\nd\n.\nroam\n();\n\n\n\n\nIf you're not sure it's a Dog, you can use the \ninstanceof\n operator to check.\n\n\n \nif\n \n(\no\n \ninstanceof\n \nDog\n)\n \n{\n\n    \nDog\n \nd\n \n=\n \n(\nDog\n)\n \no\n;\n\n\n}\n\n\n\n\n\n\nNote\n\n\nJava\u4e2d\u7684instanceof \u7b97\u7b26\u662f\u7528\u6765\u5728\u8fd0\u884c\u65f6\u6307\u51fa\u5bf9\u8c61\u662f\u5426\u662f\u7279\u5b9a\u7c7b\u7684\u4e00\u4e2a\u5b9e\u4f8b\u3002instanceof\u901a\u8fc7\u8fd4\u56de\u4e00\u4e2a\u5e03\u5c14\u503c\u6765\u6307\u51fa\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u662f\u5426\u662f\u8fd9\u4e2a\u7279\u5b9a\u7c7b\u6216\u8005\u662f\u5b83\u7684\u5b50\u7c7b\u7684\u4e00\u4e2a\u5b9e\u4f8b\u3002\nresult\n \n=\n \nobject\n \ninstanceof\n \nclass\n\n\n\n\n5 Interface\n\n\nQuestions: What if you want to add Dog some Pet behaviors?\n\n\n\n\n\n\nOption one: We take the easy path, and put pet method in class Animal.\n\n\n\n\nPros: All the Animals will instantly inherit the pet behaviors. We won't have to touch the existing Animal subclasses at all.\n\n\nCons: Some animals like lion, wolf are not a pet. Non-pet Animals running around with pet methods.\n\n\n\n\n\n\n\n\nOption two: We start with option one, putting the pet methods in class Animal, but we make the methods abstract.\n\n\n\n\nPros: All classes must override the methods, but they can make the methods \"do-nothings\".\n\n\nCons: Waste a lot of time to implement every concrete Animal subclasses.\n\n\n\n\n\n\nOptions three: Put the pet methods Only in the classes where they belong.\n\n\nPros: The methods are where they belong, and only where they belong.\n\n\nCons: Firstly, you'd have to agree to a protocol, and all programmers of pet Animal classes now and in the future would have to know about the protocol. Secondly, you don't get to use polymorphism for the pet methods \n\n\n\n\n\n\n\n\nIt looks like we need two superclasses at the top.\n\n\n\n\nIt\u2019s called \"\nmultiple inheritance\n\"(\u591a\u91cd\u7ee7\u627f) and it can be a Really Bad Thing. Because multiple inheritance has a problem known as \nThe Deadly Diamond of Death\n(\u81f4\u547d\u7684\u6b7b\u4ea1\u7816\u77f3)\n\n\n\n\nJava\u7684\u65b9\u6848: Interface!!!\n\n\n\n\nA Java \ninterface\n(\u63a5\u53e3) solves multiple inheritance problem by giving you much of the polymorphic benefits of multiple inheritance without the pain and suffering from the Deadly Diamond of Death.\n\n\n\n\nHow?\n\n\n\n\nSurprisingly simple: \nmake all the methods abstract\n\n\nA Java interface is like a 100% pure abstract class.\n\n\n\n\nTo define an interface, use the keyword \ninterface\n instead of \nclass\n.\n\n\n \n//use the keyword \ninterface\n instead of \nclass\n\n\npublic\n \ninterface\n \nPet\n \n{}\n\n\n\n\nTo implement an interface, use the keyword \nimplements\n followed by the interface name:\n\n\n \n// Use the keyword \nimplements\n followed by the interface name.\n\n\npublic\n \nclass\n \nDog\n \nextends\n \nCanine\n \nimplements\n \nPet\n \n{}\n\n\n\n\nA class can implement \nmultiple\n interfaces!\n\n\n \npublic\n \nclass\n \nDog\n \nextends\n \nAnimal\n \nimplements\n \nPet\n,\n \nSaveable\n,\n \nPaintable\n \n{}\n\n\n\n\nClasses from \ndifferent\n inheritance trees can implement the \nsame\n interface.\n\n\n\n\nHow do you know whether to make a class, subclass, an abstract class, or an interface?\n\n\n\n\nMake a class that doesn\u2019t extend anything (other than Object) when your new class doesn\u2019t pass the IS-A test for any other type.\n\n\nMake a subclass (in other words, extend a class) only when you need to make a \nmore specific\n version of a class and need to override or add new behaviors.\n\n\nUse an abstract class when you want to define a \ntemplate\n for a group of subclasses, and you have at least some implementation code that all subclasses could use. Make the class abstract when you want to guarantee that nobody can make objects of that type.\n\n\nUse an interface when you want to define a \nrole\n that other classes can play, regardless of where those classes are in the inheritance tree.\n\n\n\n\n\n\nNote\n\n\nAbstract class vs Interface\n\n\n\n\nType of methods\n: Interface can have only abstract methods. Abstract class can have abstract and non-abstract methods. \n\n\nFinal Variables\n: Variables declared in a Java interface are by default final. An abstract class may contain non-final variables.\n\n\nType of variables\n: Abstract class can have final, non-final, static and non-static variables. Interface has only static and final variables.\n\n\nImplementation\n: Abstract class can provide the implementation of interface.   Interface can\u2019t provide the implementation of abstract class.\n\n\nInheritance vs Abstraction\n: A Java interface can be implemented using keyword \nimplements\n and abstract class can be extended using keyword \nextends\n.\n\n\nMultiple implementation\n: An interface can extend another Java interface only, an abstract class can extend another Java class and implement multiple Java interfaces.\n\n\nAccessibility of Data Members\n: Members of a Java interface are public by default. A Java abstract class can have class members like private, protected, etc.\n\n\n\n\n\n\n\n\nNote\n\n\nYou can never instantiate an interface in java. However, you can refer to an object that implements an interface by the type of the interface.\n\n\npublic\n \ninterface\n \nA\n \n{};\nclass\n \nB\n \nimplements\n \nA\n \n{};\npublic\n \nvoid\n \nfunctionC\n \n{\nA\n \ntest\n \n=\n \nnew\n \nB\n();\n}\n\n\nAnother example, commonly used as an anonymous implementation class, is as follows:\n\n\nRunnable\n \nr\n \n=\n \nnew\n \nRunnable\n()\n \n{\npublic\n \nvoid\n \nrun\n(){\n \n}\n};\n\n\n\n\n\n\nNote\n\n\nTo have a wider picture, an array of interface:\n\n\nJavaAnimal [] Zoo = new Animal[10] ; // is also correct\n\n\nYou would need to fill the array with instances of a class(es) that implement that interface.\n\n\n\n\n6 Using \nsuper\n\n\nWhat if you don't want to \nreplace\n the method with an override in a concrete subclass, but you just want to \nadd\n to it with some additional specific code?\n\n\n \nabstract\n \nclass\n \nReport\n \n{\n \n    \nvoid\n \nrunReport\n()\n \n{\n \n        \n// set-up report \n\n    \n}\n \n    \nvoid\n \nprintReport\n()\n \n{\n \n    \n// generic printing \n\n    \n}\n \n\n}\n\n\n\nclass\n \nBuzzwordsReport\n \nextends\n \nReport\n \n{\n\n    \nvoid\n \nrunReport\n()\n \n{\n\n        \n// call superclass version, then come back and do some      \n\n        \n// subclass-specific stuff\n\n        \nsuper\n.\nrunReport\n();\n\n        \nbuzzwordCompliance\n();\n \n        \nprintReport\n();\n\n    \n}\n\n    \nvoid\n \nbuzzwordCompliance\n()\n \n{...}\n\n\n}", 
            "title": "Chapter 8: Interfaces and Abstract Classes"
        }, 
        {
            "location": "/hfj/ch8/#chapter-8-interfaces-and-abstract-classes", 
            "text": "What's an interface? it's a 100% abstract class.   What's an abstract class? it's a class that can't be instantiated.", 
            "title": "Chapter 8 Interfaces and Abstract Classes"
        }, 
        {
            "location": "/hfj/ch8/#1-abstract-classes", 
            "text": "Here's where it gets weird:    Animal   anim   =   new   Animal ();    There two are the same type, but what the heck does an Animal object look like?  Some classes just should not be instantiated! \nHow?  By marking the class as  abstract , the compiler will stop any code, anywhere, from ever creating an instance of that type. i.e. prevent a class from ever being instantiated.  Making a class abstract before the class declaration:    abstract   class   Caine   extends   Animal   { \n     public   void   roam ()   {}  }   When you're designing your class inheritance structure, you have to decide which classes are  abstract  and which are  concrete .    Concrete  classes are those that are specific enough to be instantiated.   A  concrete  class just means that it's OK to make objects of that type.  An  abstract class  has virtually no use, no value, no purpose in life, unless it is extended.", 
            "title": "1 Abstract classes"
        }, 
        {
            "location": "/hfj/ch8/#2-abstract-methods", 
            "text": "An  abstract method  means the method must be  overriden , whereas an abstract class means the class must be extended.   There isn't any code that would make sense in the abstract method, you won't put in a method body. e.g.  public   abstract   void   eat () .  If you declare an abstract method, you must mark the class abstract as well. You can't have an abstract method in a non-abstract class.  You must implement all abstract methods.", 
            "title": "2 Abstract methods"
        }, 
        {
            "location": "/hfj/ch8/#3-the-ultimate-superclass-object", 
            "text": "Every class in Java extends class  Object . Class  Object  is the mother of all classes; it's the superclass of everything.    Any class that doesn't  explicitly  extend another class,  implicitly  extends  Object .   Methods of  Object  class:   equals () : tell you if two objects are considered equal.  getClass () : Gives you back the class that object was instantiated from.  hashCode () : Prints out a hashcode for the object  toString () : Prints out a String message with the name of the class and some other number we rarely care about.   Object  is a  non-abstract  class because it's got method implementation code that all classes can inherit and use out-of-box, without having to override the methods.  The  Object  class serves two main purpose:   To act as a polymorphic type for methods that need to work on any class that you or anyone else makes \u4f5c\u4e3a\u65b9\u6cd5\u7684\u591a\u6001\u7c7b\u578b  To provide real method code that all objects in Java need at runtime (and putting them in class Object means all other classes inherit them).\u63d0\u4f9bJava\u5728\u6267\u884c\u671f\u5806\u4efb\u4f55\u5bf9\u8c61\u90fd\u6709\u9700\u8981\u7684\u5b9e\u73b0\u65b9\u6cd5\u4ee3\u7801\u3002", 
            "title": "3 The ultimate superclass: Object"
        }, 
        {
            "location": "/hfj/ch8/#4-using-polymorphic-references-of-type-object-has-a-price", 
            "text": "When you put an object into an  ArrayList Dog , it goes in as a Dog, and comes out as a Dog:    // Make an ArrayList declared to hold Dog objects.  ArrayList Dog   myDogArrayList   =   new   ArrayList Dog ();  // Make a Dog  Dog   aDog   =   new   Dog ();  // Add the Dog to the list  myDogArrayList . add ( aDog );  //Assign the Dog from the list to a new Dog reference variable  Dog   d   =   myDogArrayList . get ( 0 );   Everything comes out of an  ArrayList Object  as a reference of type Object, regardless of what the actual object is.  \u4efb\u4f55\u4ece ArrayList Object \u53d6\u51fa\u7684\u4e1c\u897f\u90fd\u4f1a\u88ab\u5f53\u4f5cObject\u7c7b\u578b\u7684\u5f15\u7528\uff0c\u800c\u4e0d\u7ba1\u5b83\u539f\u6765\u662f\u4ec0\u4e48\u3002    // make an ArrayList declared to hold any type of Object  ArrayList Object   myDogArrayList   =   new   ArrayList object ()  // make a Dog  Dog   aDog   =   new   Dog ();  // Add the Dog to the list  myDogArrayList . add ( aDog );  // No!! Won t compile!! the get() method returns type Object.  // The compiler knows only that the object inherits from Object,  // but it doesn t know it s a Dog!!  Dog   d   =   myDogArrayList . get ( 0 )   The compiler decides whether you can call a method based on the  reference type  , not the actual object type.    Object   o   =   al . get ( index );  // Class Object has a hashCode() method  // so you can call that method on any object in Java  int   i   =   o . hashCode ();  // Can t do this!! the Object class  has no idea what it means to bark().  o . bark ();    If you're sure the object is really a Dog, you can make a new Dog reference to it by copying the Object reference, and forcing that copy to go into a Dog reference variable, using a  cast (Dog) .    Object   o   =   al . get ( index );  // cast the Object back to a Dog we know is there.  Dog   d   =   ( Dog )   o ;   d . roam ();   If you're not sure it's a Dog, you can use the  instanceof  operator to check.    if   ( o   instanceof   Dog )   { \n     Dog   d   =   ( Dog )   o ;  }    Note  Java\u4e2d\u7684instanceof \u7b97\u7b26\u662f\u7528\u6765\u5728\u8fd0\u884c\u65f6\u6307\u51fa\u5bf9\u8c61\u662f\u5426\u662f\u7279\u5b9a\u7c7b\u7684\u4e00\u4e2a\u5b9e\u4f8b\u3002instanceof\u901a\u8fc7\u8fd4\u56de\u4e00\u4e2a\u5e03\u5c14\u503c\u6765\u6307\u51fa\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u662f\u5426\u662f\u8fd9\u4e2a\u7279\u5b9a\u7c7b\u6216\u8005\u662f\u5b83\u7684\u5b50\u7c7b\u7684\u4e00\u4e2a\u5b9e\u4f8b\u3002 result   =   object   instanceof   class", 
            "title": "4 Using polymorphic references of type Object has a price"
        }, 
        {
            "location": "/hfj/ch8/#5-interface", 
            "text": "Questions: What if you want to add Dog some Pet behaviors?    Option one: We take the easy path, and put pet method in class Animal.   Pros: All the Animals will instantly inherit the pet behaviors. We won't have to touch the existing Animal subclasses at all.  Cons: Some animals like lion, wolf are not a pet. Non-pet Animals running around with pet methods.     Option two: We start with option one, putting the pet methods in class Animal, but we make the methods abstract.   Pros: All classes must override the methods, but they can make the methods \"do-nothings\".  Cons: Waste a lot of time to implement every concrete Animal subclasses.    Options three: Put the pet methods Only in the classes where they belong.  Pros: The methods are where they belong, and only where they belong.  Cons: Firstly, you'd have to agree to a protocol, and all programmers of pet Animal classes now and in the future would have to know about the protocol. Secondly, you don't get to use polymorphism for the pet methods      It looks like we need two superclasses at the top.   It\u2019s called \" multiple inheritance \"(\u591a\u91cd\u7ee7\u627f) and it can be a Really Bad Thing. Because multiple inheritance has a problem known as  The Deadly Diamond of Death (\u81f4\u547d\u7684\u6b7b\u4ea1\u7816\u77f3)   Java\u7684\u65b9\u6848: Interface!!!   A Java  interface (\u63a5\u53e3) solves multiple inheritance problem by giving you much of the polymorphic benefits of multiple inheritance without the pain and suffering from the Deadly Diamond of Death.   How?   Surprisingly simple:  make all the methods abstract  A Java interface is like a 100% pure abstract class.   To define an interface, use the keyword  interface  instead of  class .    //use the keyword  interface  instead of  class  public   interface   Pet   {}   To implement an interface, use the keyword  implements  followed by the interface name:    // Use the keyword  implements  followed by the interface name.  public   class   Dog   extends   Canine   implements   Pet   {}   A class can implement  multiple  interfaces!    public   class   Dog   extends   Animal   implements   Pet ,   Saveable ,   Paintable   {}   Classes from  different  inheritance trees can implement the  same  interface.   How do you know whether to make a class, subclass, an abstract class, or an interface?   Make a class that doesn\u2019t extend anything (other than Object) when your new class doesn\u2019t pass the IS-A test for any other type.  Make a subclass (in other words, extend a class) only when you need to make a  more specific  version of a class and need to override or add new behaviors.  Use an abstract class when you want to define a  template  for a group of subclasses, and you have at least some implementation code that all subclasses could use. Make the class abstract when you want to guarantee that nobody can make objects of that type.  Use an interface when you want to define a  role  that other classes can play, regardless of where those classes are in the inheritance tree.    Note  Abstract class vs Interface   Type of methods : Interface can have only abstract methods. Abstract class can have abstract and non-abstract methods.   Final Variables : Variables declared in a Java interface are by default final. An abstract class may contain non-final variables.  Type of variables : Abstract class can have final, non-final, static and non-static variables. Interface has only static and final variables.  Implementation : Abstract class can provide the implementation of interface.   Interface can\u2019t provide the implementation of abstract class.  Inheritance vs Abstraction : A Java interface can be implemented using keyword  implements  and abstract class can be extended using keyword  extends .  Multiple implementation : An interface can extend another Java interface only, an abstract class can extend another Java class and implement multiple Java interfaces.  Accessibility of Data Members : Members of a Java interface are public by default. A Java abstract class can have class members like private, protected, etc.     Note  You can never instantiate an interface in java. However, you can refer to an object that implements an interface by the type of the interface.  public   interface   A   {}; class   B   implements   A   {}; public   void   functionC   { A   test   =   new   B (); }  Another example, commonly used as an anonymous implementation class, is as follows:  Runnable   r   =   new   Runnable ()   { public   void   run (){   } };    Note  To have a wider picture, an array of interface:  JavaAnimal [] Zoo = new Animal[10] ; // is also correct  You would need to fill the array with instances of a class(es) that implement that interface.", 
            "title": "5 Interface"
        }, 
        {
            "location": "/hfj/ch8/#6-using-super", 
            "text": "What if you don't want to  replace  the method with an override in a concrete subclass, but you just want to  add  to it with some additional specific code?    abstract   class   Report   {  \n     void   runReport ()   {  \n         // set-up report  \n     }  \n     void   printReport ()   {  \n     // generic printing  \n     }   }  class   BuzzwordsReport   extends   Report   { \n     void   runReport ()   { \n         // call superclass version, then come back and do some       \n         // subclass-specific stuff \n         super . runReport (); \n         buzzwordCompliance ();  \n         printReport (); \n     } \n     void   buzzwordCompliance ()   {...}  }", 
            "title": "6 Using super"
        }, 
        {
            "location": "/hfdp/ch6/", 
            "text": "Head First Design Patterns 6 - Command Pattern\n\n\n1 Command pattern de\ufb01ned\n\n\n\n\nThe Command Pattern encapsulates a request as an object, thereby letting you parameterize other objects with different requests, queue or log requests, and support undoable operations.\n\n\n\n\nThe class diagram:\n\n\n\n\n\n\nThe \nClient\n is responsible for creating a \nConcreateCommand\n and setting its \nRecevier\n.\n\n\nThe \nReceiver\n knows how to perform the work needed to carry out the request. Any class can act as a \nReceiver\n.\n\n\nCommand\n declares an interface for all commands. A command is invoked through its \nexecute()\n method, which asks a receiver to perform an action.\n\n\nThe \nInvoker\n holds a command and at some point asks the command to carry out a request by calling its \nexecute\n method.\n\n\n\n\n2 Example - Remote control\n\n\nThe remote control is our \nInvoker\n. When a button is pressed, the \nexecute()\n method is going to be called on the corresponding command, which results in actions being invoked on the receiver (like lights, celling fans).\n\n\n\n\nExample - the Remote Control\n\n\nExample - queuing requests", 
            "title": "Chapter 6: Command Pattern"
        }, 
        {
            "location": "/hfdp/ch6/#head-first-design-patterns-6-command-pattern", 
            "text": "", 
            "title": "Head First Design Patterns 6 - Command Pattern"
        }, 
        {
            "location": "/hfdp/ch6/#1-command-pattern-defined", 
            "text": "The Command Pattern encapsulates a request as an object, thereby letting you parameterize other objects with different requests, queue or log requests, and support undoable operations.   The class diagram:    The  Client  is responsible for creating a  ConcreateCommand  and setting its  Recevier .  The  Receiver  knows how to perform the work needed to carry out the request. Any class can act as a  Receiver .  Command  declares an interface for all commands. A command is invoked through its  execute()  method, which asks a receiver to perform an action.  The  Invoker  holds a command and at some point asks the command to carry out a request by calling its  execute  method.", 
            "title": "1 Command pattern de\ufb01ned"
        }, 
        {
            "location": "/hfdp/ch6/#2-example-remote-control", 
            "text": "The remote control is our  Invoker . When a button is pressed, the  execute()  method is going to be called on the corresponding command, which results in actions being invoked on the receiver (like lights, celling fans).", 
            "title": "2 Example - Remote control"
        }, 
        {
            "location": "/hfdp/ch6/#example-the-remote-control", 
            "text": "", 
            "title": "Example - the Remote Control"
        }, 
        {
            "location": "/hfdp/ch6/#example-queuing-requests", 
            "text": "", 
            "title": "Example - queuing requests"
        }
    ]
}