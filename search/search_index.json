{
    "docs": [
        {
            "location": "/hfdp/ch4/", 
            "text": "Head First Design Patterns 4 - Factory Pattern\n\n\n1 Simple Factory\n\n\nLet\ns say you have a pizza shop, and as a cutting-edge pizza store owner in Objectville you might end up writing some code like this:\n\n\n \nPizza\n \norderPizza\n()\n \n{\n \n    \n// For flexibility, we really want this to be an  abstract class or interface,\n\n    \n// but we can\nt directly instantiate either of those.\n\n    \nPizza\n \npizza\n \n=\n \nnew\n \nPizza\n();\n\n    \npizza\n.\nprepare\n();\n \n    \npizza\n.\nbake\n();\n \n    \npizza\n.\ncut\n();\n \n    \npizza\n.\nbox\n();\n \n    \nreturn\n \npizza\n;\n\n\n}\n\n\n\n\nBut you need more than one type of pizza...\n\n\n \nPizza\n \norderPizza\n(\nString\n \ntype\n)\n \n{\n \n    \nPizza\n \npizza\n;\n\n\n    \nif\n \n(\ntype\n.\nequals\n(\nldquo\n;\ncheese\nrdquo\n;))\n \n{\n \n        \npizza\n \n=\n \nnew\n \nCheesePizza\n();\n \n}\n \n    \nelse\n \nif\n \n(\ntype\n.\nequals\n(\nldquo\n;\ngreek\nrdquo\n;)\n \n{\n\n        \npizza\n \n=\n \nnew\n \nGreekPizza\n();\n \n    \n}\n \nelse\n \nif\n \n(\ntype\n.\nequals\n(\nldquo\n;\npepperoni\nrdquo\n;)\n \n{\n\n        \npizza\n \n=\n \nnew\n \nPepperoniPizza\n();\n \n    \n}\n\n    \n// Once we have a Pizza, we prepare it \n\n    \n// (you know, roll the dough, put on the sauce and add the toppings \n cheese), \n\n    \n// then we bake it, cut it and box it!\n\n    \npizza\n.\nprepare\n();\n \n    \npizza\n.\nbake\n();\n \n    \npizza\n.\ncut\n();\n \n    \npizza\n.\nbox\n();\n \n    \nreturn\n \npizza\n;\n\n\n}\n\n\n\n\nBut the pressure is on to add more pizza types...\n\n\nEncapsulating object creation\n\n\nFactories handle the details of object creation. Once we have a \nSimplePizzaFactory\n, our \norderPizza()\n method just becomes a client of that object.\n\n\nSimplepizzafactory\npublic\n \nclass\n \nSimplePizzaFactory\n \n{\n\n    \npublic\n \nPizza\n \ncreatePizza\n(\nString\n \ntype\n)\n\n    \n{\n\n        \nPizza\n \npizza\n \n=\n \nnull\n;\n\n        \nif\n \n(\ntype\n.\nequals\n(\nldquo\n;\ncheese\nrdquo\n;))\n \n{\n \n            \npizza\n \n=\n \nnew\n \nCheesePizza\n();\n \n}\n \n        \nelse\n \nif\n \n(\ntype\n.\nequals\n(\nldquo\n;\npepperoni\nrdquo\n;))\n \n{\n \n            \npizza\n \n=\n \nnew\n \nPepperoniPizza\n();\n \n        \n}\n \nelse\n \nif\n \n(\ntype\n.\nequals\n(\nldquo\n;\nclam\nrdquo\n;))\n \n{\n\n            \npizza\n \n=\n \nnew\n \nClamPizza\n();\n \n        \n}\n \nelse\n \nif\n \n(\ntype\n.\nequals\n(\nldquo\n;\nveggie\nrdquo\n;))\n \n{\n\n            \npizza\n \n=\n \nnew\n \nVeggiePizza\n();\n \n        \n}\n  \n// end if\n\n        \nreturn\n \npizza\n;\n   \n    \n}\n \n// end createPizza\n\n\n}\n\n\nPizzastore\npublic\n \nclass\n \nPizzaStore\n \n{\n\n  \n// Now we give PizzaStore a reference to a SimplePizzaFactory.\n\n    \nSimplePizzaFactory\n \nfactory\n;\n\n    \n// PizzaStore gets the factory passes to it in the constructor.\n\n    \npublic\n \nPizzaStore\n(\nSimplePizzaFactory\n \nfactory\n)\n \n{\n\n        \nthis\n.\nfactory\n \n=\n \nfactory\n;\n\n    \n}\n\n\n    \npublic\n \nPizza\n \norderPizza\n(\nString\n \ntype\n)\n \n{\n\n        \nPizza\n \npizza\n;\n\n        \npizza\n \n=\n \nfactory\n.\ncreatePizza\n(\ntype\n);\n\n        \npizza\n.\nprepare\n();\n\n        \npizza\n.\nbake\n();\n\n        \npizza\n.\ncut\n();\n\n        \npizza\n.\nbox\n();\n\n        \nreturn\n \npizza\n;\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n\nThe Simple Factory is NOT actually a Design Pattern; it\ns more of a programming IDIOM. But it is commonly used.\n\n\n\n\n2 Factory Method Pattern\n\n\nYour Objectville PizzaStore has done so well that you\nve trounced the competition and now everyone wants a PizzaStore in their own neighborhood.\n\n\nAnd now each franchise might want to offer different styles of pizzas (New York, Chicago, and California, etc), depending on where the franchise store is located and the tastes of the local pizza connoisseurs.\n\n\n\n\nPizzastore\npublic\n \nabstract\n \nclass\n \nPizzaStore\n \n{\n\n\n    \nabstract\n \nPizza\n \ncreatePizza\n(\nString\n \nitem\n);\n\n\n    \npublic\n \nPizza\n \norderPizza\n(\nString\n \ntype\n)\n \n{\n\n        \nPizza\n \npizza\n \n=\n \ncreatePizza\n(\ntype\n);\n\n        \nSystem\n.\nout\n.\nprintln\n(\n--- Making a \n \n+\n \npizza\n.\ngetName\n()\n \n+\n \n ---\n);\n\n        \npizza\n.\nprepare\n();\n\n        \npizza\n.\nbake\n();\n\n        \npizza\n.\ncut\n();\n\n        \npizza\n.\nbox\n();\n\n        \nreturn\n \npizza\n;\n\n    \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nNYPizzaStore\n \nextends\n \nPizzaStore\n \n{\n\n\n    \nPizza\n \ncreatePizza\n(\nString\n \nitem\n)\n \n{\n\n        \nif\n \n(\nitem\n.\nequals\n(\ncheese\n))\n \n{\n\n            \nreturn\n \nnew\n \nNYStyleCheesePizza\n();\n\n        \n}\n \nelse\n \nif\n \n(\nitem\n.\nequals\n(\nveggie\n))\n \n{\n\n            \nreturn\n \nnew\n \nNYStyleVeggiePizza\n();\n\n        \n}\n \nelse\n \nif\n \n(\nitem\n.\nequals\n(\nclam\n))\n \n{\n\n            \nreturn\n \nnew\n \nNYStyleClamPizza\n();\n\n        \n}\n \nelse\n \nif\n \n(\nitem\n.\nequals\n(\npepperoni\n))\n \n{\n\n            \nreturn\n \nnew\n \nNYStylePepperoniPizza\n();\n\n        \n}\n \nelse\n \nreturn\n \nnull\n;\n\n    \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nNYPizzaStore\n \nextends\n \nPizzaStore\n \n{\n\n\n    \nPizza\n \ncreatePizza\n(\nString\n \nitem\n)\n \n{\n\n        \nif\n \n(\nitem\n.\nequals\n(\ncheese\n))\n \n{\n\n            \nreturn\n \nnew\n \nNYStyleCheesePizza\n();\n\n        \n}\n \nelse\n \nif\n \n(\nitem\n.\nequals\n(\nveggie\n))\n \n{\n\n            \nreturn\n \nnew\n \nNYStyleVeggiePizza\n();\n\n        \n}\n \nelse\n \nif\n \n(\nitem\n.\nequals\n(\nclam\n))\n \n{\n\n            \nreturn\n \nnew\n \nNYStyleClamPizza\n();\n\n        \n}\n \nelse\n \nif\n \n(\nitem\n.\nequals\n(\npepperoni\n))\n \n{\n\n            \nreturn\n \nnew\n \nNYStylePepperoniPizza\n();\n\n        \n}\n \nelse\n \nreturn\n \nnull\n;\n\n    \n}\n\n\n}\n\n\nPizza\npublic\n \nabstract\n \nclass\n \nPizza\n \n{\n\n    \nString\n \nname\n;\n\n    \nString\n \ndough\n;\n\n    \nString\n \nsauce\n;\n\n    \nArrayList\nString\n \ntoppings\n \n=\n \nnew\n \nArrayList\nString\n();\n\n\n    \nvoid\n \nprepare\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nPrepare \n \n+\n \nname\n);\n\n        \nSystem\n.\nout\n.\nprintln\n(\nTossing dough...\n);\n\n        \nSystem\n.\nout\n.\nprintln\n(\nAdding sauce...\n);\n\n        \nSystem\n.\nout\n.\nprintln\n(\nAdding toppings: \n);\n\n        \nfor\n \n(\nString\n \ntopping\n \n:\n \ntoppings\n)\n \n{\n\n            \nSystem\n.\nout\n.\nprintln\n(\n   \n \n+\n \ntopping\n);\n\n        \n}\n\n    \n}\n\n\n    \nvoid\n \nbake\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nBake for 25 minutes at 350\n);\n\n    \n}\n\n\n    \nvoid\n \ncut\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nCut the pizza into diagonal slices\n);\n\n    \n}\n\n\n    \nvoid\n \nbox\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nPlace pizza in official PizzaStore box\n);\n\n    \n}\n\n\n    \npublic\n \nString\n \ngetName\n()\n \n{\n\n        \nreturn\n \nname\n;\n\n    \n}\n\n\n    \npublic\n \nString\n \ntoString\n()\n \n{\n\n        \nStringBuffer\n \ndisplay\n \n=\n \nnew\n \nStringBuffer\n();\n\n        \ndisplay\n.\nappend\n(\n---- \n \n+\n \nname\n \n+\n \n ----\\n\n);\n\n        \ndisplay\n.\nappend\n(\ndough\n \n+\n \n\\n\n);\n\n        \ndisplay\n.\nappend\n(\nsauce\n \n+\n \n\\n\n);\n\n        \nfor\n \n(\nString\n \ntopping\n \n:\n \ntoppings\n)\n \n{\n\n            \ndisplay\n.\nappend\n(\ntopping\n \n+\n \n\\n\n);\n\n        \n}\n\n        \nreturn\n \ndisplay\n.\ntoString\n();\n\n    \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nNYStyleCheesePizza\n \nextends\n \nPizza\n \n{\n\n\n    \npublic\n \nNYStyleCheesePizza\n()\n \n{\n \n        \nname\n \n=\n \nNY Style Sauce and Cheese Pizza\n;\n\n        \ndough\n \n=\n \nThin Crust Dough\n;\n\n        \nsauce\n \n=\n \nMarinara Sauce\n;\n\n\n        \ntoppings\n.\nadd\n(\nGrated Reggiano Cheese\n);\n\n    \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nChicagoStyleClamPizza\n \nextends\n \nPizza\n \n{\n\n    \npublic\n \nChicagoStyleClamPizza\n()\n \n{\n\n        \nname\n \n=\n \nChicago Style Clam Pizza\n;\n\n        \ndough\n \n=\n \nExtra Thick Crust Dough\n;\n\n        \nsauce\n \n=\n \nPlum Tomato Sauce\n;\n\n\n        \ntoppings\n.\nadd\n(\nShredded Mozzarella Cheese\n);\n\n        \ntoppings\n.\nadd\n(\nFrozen Clams from Chesapeake Bay\n);\n\n    \n}\n\n\n    \nvoid\n \ncut\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nCutting the pizza into square slices\n);\n\n    \n}\n\n\n}\n\n\nPizzatestdrive\npublic\n \nclass\n \nPizzaTestDrive\n \n{\n\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n        \nPizzaStore\n \nnyStore\n \n=\n \nnew\n \nNYPizzaStore\n();\n\n        \nPizzaStore\n \nchicagoStore\n \n=\n \nnew\n \nChicagoPizzaStore\n();\n\n\n        \nPizza\n \npizza\n \n=\n \nnyStore\n.\norderPizza\n(\ncheese\n);\n\n        \nSystem\n.\nout\n.\nprintln\n(\nEthan ordered a \n \n+\n \npizza\n.\ngetName\n()\n \n+\n \n\\n\n);\n\n\n        \npizza\n \n=\n \nchicagoStore\n.\norderPizza\n(\ncheese\n);\n\n        \nSystem\n.\nout\n.\nprintln\n(\nJoel ordered a \n \n+\n \npizza\n.\ngetName\n()\n \n+\n \n\\n\n);\n\n\n        \npizza\n \n=\n \nnyStore\n.\norderPizza\n(\nclam\n);\n\n        \nSystem\n.\nout\n.\nprintln\n(\nEthan ordered a \n \n+\n \npizza\n.\ngetName\n()\n \n+\n \n\\n\n);\n\n\n        \npizza\n \n=\n \nchicagoStore\n.\norderPizza\n(\nclam\n);\n\n        \nSystem\n.\nout\n.\nprintln\n(\nJoel ordered a \n \n+\n \npizza\n.\ngetName\n()\n \n+\n \n\\n\n);\n\n\n        \npizza\n \n=\n \nnyStore\n.\norderPizza\n(\npepperoni\n);\n\n        \nSystem\n.\nout\n.\nprintln\n(\nEthan ordered a \n \n+\n \npizza\n.\ngetName\n()\n \n+\n \n\\n\n);\n\n\n        \npizza\n \n=\n \nchicagoStore\n.\norderPizza\n(\npepperoni\n);\n\n        \nSystem\n.\nout\n.\nprintln\n(\nJoel ordered a \n \n+\n \npizza\n.\ngetName\n()\n \n+\n \n\\n\n);\n\n\n        \npizza\n \n=\n \nnyStore\n.\norderPizza\n(\nveggie\n);\n\n        \nSystem\n.\nout\n.\nprintln\n(\nEthan ordered a \n \n+\n \npizza\n.\ngetName\n()\n \n+\n \n\\n\n);\n\n\n        \npizza\n \n=\n \nchicagoStore\n.\norderPizza\n(\nveggie\n);\n\n        \nSystem\n.\nout\n.\nprintln\n(\nJoel ordered a \n \n+\n \npizza\n.\ngetName\n()\n \n+\n \n\\n\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n\nThe \nFactory Method\n Pattern defines an interface for creating an object, but lets subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.\n\n\n\n\n\n\nDependency inversion principle\n\n\n\n\nThe Dependency Inversion Principle: Depend upon abstractions. Do not depend upon concrete classes.\n\n\n\n\nA few guidelines to help you follow the Principle:\n\n\n\n\nNo variable should hold a reference to a concrete class.\n\n\nNo class should derive from a concrete class.\n\n\nNo method should override an implemented method of any of its base classes.\n\n\n\n\n3 Abstract Factory Pattern\n\n\n\n\nThe \nAbstract Factory Pattern\n provides an interface for creating families of related or dependent objects without specifying their concrete classes.\n\n\n\n\n\n\nFactory Method and Abstract Factory compared", 
            "title": "Chapter 4: Factory Pattern"
        }, 
        {
            "location": "/hfdp/ch4/#head-first-design-patterns-4-factory-pattern", 
            "text": "", 
            "title": "Head First Design Patterns 4 - Factory Pattern"
        }, 
        {
            "location": "/hfdp/ch4/#1-simple-factory", 
            "text": "Let s say you have a pizza shop, and as a cutting-edge pizza store owner in Objectville you might end up writing some code like this:    Pizza   orderPizza ()   {  \n     // For flexibility, we really want this to be an  abstract class or interface, \n     // but we can t directly instantiate either of those. \n     Pizza   pizza   =   new   Pizza (); \n     pizza . prepare ();  \n     pizza . bake ();  \n     pizza . cut ();  \n     pizza . box ();  \n     return   pizza ;  }   But you need more than one type of pizza...    Pizza   orderPizza ( String   type )   {  \n     Pizza   pizza ; \n\n     if   ( type . equals ( ldquo ; cheese rdquo ;))   {  \n         pizza   =   new   CheesePizza ();   }  \n     else   if   ( type . equals ( ldquo ; greek rdquo ;)   { \n         pizza   =   new   GreekPizza ();  \n     }   else   if   ( type . equals ( ldquo ; pepperoni rdquo ;)   { \n         pizza   =   new   PepperoniPizza ();  \n     } \n     // Once we have a Pizza, we prepare it  \n     // (you know, roll the dough, put on the sauce and add the toppings   cheese),  \n     // then we bake it, cut it and box it! \n     pizza . prepare ();  \n     pizza . bake ();  \n     pizza . cut ();  \n     pizza . box ();  \n     return   pizza ;  }   But the pressure is on to add more pizza types...", 
            "title": "1 Simple Factory"
        }, 
        {
            "location": "/hfdp/ch4/#encapsulating-object-creation", 
            "text": "Factories handle the details of object creation. Once we have a  SimplePizzaFactory , our  orderPizza()  method just becomes a client of that object.  Simplepizzafactory public   class   SimplePizzaFactory   { \n     public   Pizza   createPizza ( String   type ) \n     { \n         Pizza   pizza   =   null ; \n         if   ( type . equals ( ldquo ; cheese rdquo ;))   {  \n             pizza   =   new   CheesePizza ();   }  \n         else   if   ( type . equals ( ldquo ; pepperoni rdquo ;))   {  \n             pizza   =   new   PepperoniPizza ();  \n         }   else   if   ( type . equals ( ldquo ; clam rdquo ;))   { \n             pizza   =   new   ClamPizza ();  \n         }   else   if   ( type . equals ( ldquo ; veggie rdquo ;))   { \n             pizza   =   new   VeggiePizza ();  \n         }    // end if \n         return   pizza ;    \n     }   // end createPizza  }  Pizzastore public   class   PizzaStore   { \n   // Now we give PizzaStore a reference to a SimplePizzaFactory. \n     SimplePizzaFactory   factory ; \n     // PizzaStore gets the factory passes to it in the constructor. \n     public   PizzaStore ( SimplePizzaFactory   factory )   { \n         this . factory   =   factory ; \n     } \n\n     public   Pizza   orderPizza ( String   type )   { \n         Pizza   pizza ; \n         pizza   =   factory . createPizza ( type ); \n         pizza . prepare (); \n         pizza . bake (); \n         pizza . cut (); \n         pizza . box (); \n         return   pizza ; \n     }  }     The Simple Factory is NOT actually a Design Pattern; it s more of a programming IDIOM. But it is commonly used.", 
            "title": "Encapsulating object creation"
        }, 
        {
            "location": "/hfdp/ch4/#2-factory-method-pattern", 
            "text": "Your Objectville PizzaStore has done so well that you ve trounced the competition and now everyone wants a PizzaStore in their own neighborhood.  And now each franchise might want to offer different styles of pizzas (New York, Chicago, and California, etc), depending on where the franchise store is located and the tastes of the local pizza connoisseurs.   Pizzastore public   abstract   class   PizzaStore   { \n\n     abstract   Pizza   createPizza ( String   item ); \n\n     public   Pizza   orderPizza ( String   type )   { \n         Pizza   pizza   =   createPizza ( type ); \n         System . out . println ( --- Making a    +   pizza . getName ()   +    --- ); \n         pizza . prepare (); \n         pizza . bake (); \n         pizza . cut (); \n         pizza . box (); \n         return   pizza ; \n     }  }  public   class   NYPizzaStore   extends   PizzaStore   { \n\n     Pizza   createPizza ( String   item )   { \n         if   ( item . equals ( cheese ))   { \n             return   new   NYStyleCheesePizza (); \n         }   else   if   ( item . equals ( veggie ))   { \n             return   new   NYStyleVeggiePizza (); \n         }   else   if   ( item . equals ( clam ))   { \n             return   new   NYStyleClamPizza (); \n         }   else   if   ( item . equals ( pepperoni ))   { \n             return   new   NYStylePepperoniPizza (); \n         }   else   return   null ; \n     }  }  public   class   NYPizzaStore   extends   PizzaStore   { \n\n     Pizza   createPizza ( String   item )   { \n         if   ( item . equals ( cheese ))   { \n             return   new   NYStyleCheesePizza (); \n         }   else   if   ( item . equals ( veggie ))   { \n             return   new   NYStyleVeggiePizza (); \n         }   else   if   ( item . equals ( clam ))   { \n             return   new   NYStyleClamPizza (); \n         }   else   if   ( item . equals ( pepperoni ))   { \n             return   new   NYStylePepperoniPizza (); \n         }   else   return   null ; \n     }  }  Pizza public   abstract   class   Pizza   { \n     String   name ; \n     String   dough ; \n     String   sauce ; \n     ArrayList String   toppings   =   new   ArrayList String (); \n\n     void   prepare ()   { \n         System . out . println ( Prepare    +   name ); \n         System . out . println ( Tossing dough... ); \n         System . out . println ( Adding sauce... ); \n         System . out . println ( Adding toppings:  ); \n         for   ( String   topping   :   toppings )   { \n             System . out . println (       +   topping ); \n         } \n     } \n\n     void   bake ()   { \n         System . out . println ( Bake for 25 minutes at 350 ); \n     } \n\n     void   cut ()   { \n         System . out . println ( Cut the pizza into diagonal slices ); \n     } \n\n     void   box ()   { \n         System . out . println ( Place pizza in official PizzaStore box ); \n     } \n\n     public   String   getName ()   { \n         return   name ; \n     } \n\n     public   String   toString ()   { \n         StringBuffer   display   =   new   StringBuffer (); \n         display . append ( ----    +   name   +    ----\\n ); \n         display . append ( dough   +   \\n ); \n         display . append ( sauce   +   \\n ); \n         for   ( String   topping   :   toppings )   { \n             display . append ( topping   +   \\n ); \n         } \n         return   display . toString (); \n     }  }  public   class   NYStyleCheesePizza   extends   Pizza   { \n\n     public   NYStyleCheesePizza ()   {  \n         name   =   NY Style Sauce and Cheese Pizza ; \n         dough   =   Thin Crust Dough ; \n         sauce   =   Marinara Sauce ; \n\n         toppings . add ( Grated Reggiano Cheese ); \n     }  }  public   class   ChicagoStyleClamPizza   extends   Pizza   { \n     public   ChicagoStyleClamPizza ()   { \n         name   =   Chicago Style Clam Pizza ; \n         dough   =   Extra Thick Crust Dough ; \n         sauce   =   Plum Tomato Sauce ; \n\n         toppings . add ( Shredded Mozzarella Cheese ); \n         toppings . add ( Frozen Clams from Chesapeake Bay ); \n     } \n\n     void   cut ()   { \n         System . out . println ( Cutting the pizza into square slices ); \n     }  }  Pizzatestdrive public   class   PizzaTestDrive   { \n\n     public   static   void   main ( String []   args )   { \n         PizzaStore   nyStore   =   new   NYPizzaStore (); \n         PizzaStore   chicagoStore   =   new   ChicagoPizzaStore (); \n\n         Pizza   pizza   =   nyStore . orderPizza ( cheese ); \n         System . out . println ( Ethan ordered a    +   pizza . getName ()   +   \\n ); \n\n         pizza   =   chicagoStore . orderPizza ( cheese ); \n         System . out . println ( Joel ordered a    +   pizza . getName ()   +   \\n ); \n\n         pizza   =   nyStore . orderPizza ( clam ); \n         System . out . println ( Ethan ordered a    +   pizza . getName ()   +   \\n ); \n\n         pizza   =   chicagoStore . orderPizza ( clam ); \n         System . out . println ( Joel ordered a    +   pizza . getName ()   +   \\n ); \n\n         pizza   =   nyStore . orderPizza ( pepperoni ); \n         System . out . println ( Ethan ordered a    +   pizza . getName ()   +   \\n ); \n\n         pizza   =   chicagoStore . orderPizza ( pepperoni ); \n         System . out . println ( Joel ordered a    +   pizza . getName ()   +   \\n ); \n\n         pizza   =   nyStore . orderPizza ( veggie ); \n         System . out . println ( Ethan ordered a    +   pizza . getName ()   +   \\n ); \n\n         pizza   =   chicagoStore . orderPizza ( veggie ); \n         System . out . println ( Joel ordered a    +   pizza . getName ()   +   \\n ); \n     }  }     The  Factory Method  Pattern defines an interface for creating an object, but lets subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.", 
            "title": "2 Factory Method Pattern"
        }, 
        {
            "location": "/hfdp/ch4/#dependency-inversion-principle", 
            "text": "The Dependency Inversion Principle: Depend upon abstractions. Do not depend upon concrete classes.   A few guidelines to help you follow the Principle:   No variable should hold a reference to a concrete class.  No class should derive from a concrete class.  No method should override an implemented method of any of its base classes.", 
            "title": "Dependency inversion principle"
        }, 
        {
            "location": "/hfdp/ch4/#3-abstract-factory-pattern", 
            "text": "The  Abstract Factory Pattern  provides an interface for creating families of related or dependent objects without specifying their concrete classes.", 
            "title": "3 Abstract Factory Pattern"
        }, 
        {
            "location": "/hfdp/ch4/#factory-method-and-abstract-factory-compared", 
            "text": "", 
            "title": "Factory Method and Abstract Factory compared"
        }
    ]
}