{
    "docs": [
        {
            "location": "/tij/ch21/", 
            "text": "Thinking in Java 21 - Annotations\n\n\nAnnotations (also known as \nmetadata\n) provide a formalized way to add information to your code so that you can easily use that data at some later point. \n\n\nThe syntax of annotations is reasonably simple and consists mainly of the addition of the @symbol to the language. Java SE5 contains three general purpose built-in annotations, defined in \njava.lang\n\n\n\n\n@\nOverride\n, to indicate that a method definition is intended to override a method in the base class. This generates a compiler error if you accidentally misspell the method name or give an improper signature.\n\n\n@\nDeprecated\n, to produce a compiler warning if this element is used.\n\n\n@\nSuppressWarnings\n, to turn off inappropriate compiler warnings.\n\n\n\n\nDefining annotations\n\n\nAnnotation definitions look a lot like interface definitions. In fact, they compile to class files like any other Java interface:\n\n\n \n@Target\n(\nElementType\n.\nMETHOD\n)\n \n\n@Retention\n(\nRetentionPolicy\n.\nRUNTIME\n)\n \n\npublic\n \n@interface\n \nTest\n \n{}\n\n\n\n\nAn annotation definition also requires the meta-annotations \n@Target\n and \n@Retention\n. \n@Target\n defines where you can apply this annotation (a method or a field, for example). \n@Retention\n defines whether the annotations are available in the source code, in the class files, or at run time.\n\n\nAnnotations will usually contain elements to specify values in your annotations. An annotation without any elements, such as \n@Test\n above, is called a \nmarker annotation\n.\n\n\nHere is a simple annotation that tracks use cases in a project. \nid\n and \ndescription\n are elements, which resemble method declarations.\n\n\n \n@Target\n(\nElementType\n.\nMETHOD\n)\n \n\n@Retention\n(\nRetentionPolicy\n.\nRUNTIME\n)\n \n\npublic\n \n@interface\n \nUseCase\n \n{\n\n    \npublic\n \nint\n \nid\n();\n\n    \npublic\n \nString\n \ndescription\n()\n \ndefault\n \nno description\n;\n \n\n}\n\n\n\n\nHere is a class with three methods annotated as use cases:\n\n\n \npublic\n \nclass\n \nPasswordUtils\n \n{\n\n  \n@UseCase\n(\nid\n \n=\n \n47\n,\n \ndescription\n \n=\n\n  \nPasswords must contain at least one numeric\n)\n\n  \npublic\n \nboolean\n \nvalidatePassword\n(\nString\n \npassword\n)\n \n{\n\n    \nreturn\n \n(\npassword\n.\nmatches\n(\n\\\\w*\\\\d\\\\w*\n));\n\n  \n}\n\n  \n@UseCase\n(\nid\n \n=\n \n48\n)\n\n  \npublic\n \nString\n \nencryptPassword\n(\nString\n \npassword\n)\n \n{\n\n   \nreturn\n \nnew\n \nStringBuilder\n(\npassword\n).\nreverse\n().\ntoString\n();\n\n  \n}\n\n  \n@UseCase\n(\nid\n \n=\n \n49\n,\n \ndescription\n \n=\n\n  \nNew passwords can\nt equal previously used ones\n)\n\n  \npublic\n \nboolean\n \ncheckForNewPassword\n(\n\n    \nList\nString\n \nprevPasswords\n,\n \nString\n \npassword\n)\n \n{\n\n    \nreturn\n \n!\nprevPasswords\n.\ncontains\n(\npassword\n);\n\n  \n}\n\n\n}\n\n\n\n\nNote that values of the annotation elements are expressed as name-value pairs in parentheses.\n\n\nMeta-annotations\n\n\nThere are currently only three standard annotations (described earlier) and four meta-annotations defined in the Java language. The meta-annotations are for annotating annotations:\n\n\n\n\n@Target\n: Where this annotation can be applied. The possible \nElementType\n arguments are:\n\n\nCONSTRUCTOR\n: Constructor declaration\n\n\nFIELD\n: Field declaration (includes \nenum\n constants) \n\n\nLOCAL_VARIABLE\n: Local variable declaration \n\n\nMETHOD\n: Method declaration\n\n\nPACKAGE\n: Package declaration \n\n\nPARAMETER\n: Parameter declaration \n\n\nTYPE\n: Class, interface (including annotation type), or enum declaration\n\n\n\n\n\n\n@Retention\n: How long the annotation information is kept. The possible \nRetentionPolicy\n arguments are: \n\n\nSOURCE\n: Annotations are discarded by the compiler.\n\n\nCLASS\n: Annotations are available in the class file by the compiler but can be discarded by the VM. \n\n\nRUNTIME\n: Annotations are retained by the VM at run time, so they may be read reflectively.\n\n\n\n\n\n\n@Documented\n: Include this annotation in the Javadocs.\n\n\n@Inherited\n: Allow subclasses to inherit parent annotations.\n\n\n\n\nWriting annotation processors\n\n\nHere is a very simple annotation processor that reads the annotated \nPasswordUtils\n class and uses reflection to look for \n@UseCase\n tags. Given a list of id values, it lists the use cases it finds and reports any that are missing:\n\n\n \npublic\n \nclass\n \nUseCaseTracker\n \n{\n\n  \npublic\n \nstatic\n \nvoid\n \ntrackUseCases\n(\nList\nInteger\n \nuseCases\n,\n \nClass\n?\n \ncl\n)\n \n{\n\n    \nfor\n(\nMethod\n \nm\n \n:\n \ncl\n.\ngetDeclaredMethods\n())\n \n{\n\n      \nUseCase\n \nuc\n \n=\n \nm\n.\ngetAnnotation\n(\nUseCase\n.\nclass\n);\n\n      \nif\n(\nuc\n \n!=\n \nnull\n)\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nFound Use Case:\n \n+\n \nuc\n.\nid\n()\n \n+\n\n          \n \n \n+\n \nuc\n.\ndescription\n());\n\n        \nuseCases\n.\nremove\n(\nnew\n \nInteger\n(\nuc\n.\nid\n()));\n\n      \n}\n\n    \n}\n\n    \nfor\n(\nint\n \ni\n \n:\n \nuseCases\n)\n \n{\n\n      \nSystem\n.\nout\n.\nprintln\n(\nWarning: Missing use case-\n \n+\n \ni\n);\n\n    \n}\n\n  \n}\n\n  \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n    \nList\nInteger\n \nuseCases\n \n=\n \nnew\n \nArrayList\nInteger\n();\n\n    \nCollections\n.\naddAll\n(\nuseCases\n,\n \n47\n,\n \n48\n,\n \n49\n,\n \n50\n);\n\n    \ntrackUseCases\n(\nuseCases\n,\n \nPasswordUtils\n.\nclass\n);\n\n  \n}\n\n\n}", 
            "title": "Chapter 21: Annotations"
        }, 
        {
            "location": "/tij/ch21/#thinking-in-java-21-annotations", 
            "text": "Annotations (also known as  metadata ) provide a formalized way to add information to your code so that you can easily use that data at some later point.   The syntax of annotations is reasonably simple and consists mainly of the addition of the @symbol to the language. Java SE5 contains three general purpose built-in annotations, defined in  java.lang   @ Override , to indicate that a method definition is intended to override a method in the base class. This generates a compiler error if you accidentally misspell the method name or give an improper signature.  @ Deprecated , to produce a compiler warning if this element is used.  @ SuppressWarnings , to turn off inappropriate compiler warnings.", 
            "title": "Thinking in Java 21 - Annotations"
        }, 
        {
            "location": "/tij/ch21/#defining-annotations", 
            "text": "Annotation definitions look a lot like interface definitions. In fact, they compile to class files like any other Java interface:    @Target ( ElementType . METHOD )   @Retention ( RetentionPolicy . RUNTIME )   public   @interface   Test   {}   An annotation definition also requires the meta-annotations  @Target  and  @Retention .  @Target  defines where you can apply this annotation (a method or a field, for example).  @Retention  defines whether the annotations are available in the source code, in the class files, or at run time.  Annotations will usually contain elements to specify values in your annotations. An annotation without any elements, such as  @Test  above, is called a  marker annotation .  Here is a simple annotation that tracks use cases in a project.  id  and  description  are elements, which resemble method declarations.    @Target ( ElementType . METHOD )   @Retention ( RetentionPolicy . RUNTIME )   public   @interface   UseCase   { \n     public   int   id (); \n     public   String   description ()   default   no description ;   }   Here is a class with three methods annotated as use cases:    public   class   PasswordUtils   { \n   @UseCase ( id   =   47 ,   description   = \n   Passwords must contain at least one numeric ) \n   public   boolean   validatePassword ( String   password )   { \n     return   ( password . matches ( \\\\w*\\\\d\\\\w* )); \n   } \n   @UseCase ( id   =   48 ) \n   public   String   encryptPassword ( String   password )   { \n    return   new   StringBuilder ( password ). reverse (). toString (); \n   } \n   @UseCase ( id   =   49 ,   description   = \n   New passwords can t equal previously used ones ) \n   public   boolean   checkForNewPassword ( \n     List String   prevPasswords ,   String   password )   { \n     return   ! prevPasswords . contains ( password ); \n   }  }   Note that values of the annotation elements are expressed as name-value pairs in parentheses.", 
            "title": "Defining annotations"
        }, 
        {
            "location": "/tij/ch21/#meta-annotations", 
            "text": "There are currently only three standard annotations (described earlier) and four meta-annotations defined in the Java language. The meta-annotations are for annotating annotations:   @Target : Where this annotation can be applied. The possible  ElementType  arguments are:  CONSTRUCTOR : Constructor declaration  FIELD : Field declaration (includes  enum  constants)   LOCAL_VARIABLE : Local variable declaration   METHOD : Method declaration  PACKAGE : Package declaration   PARAMETER : Parameter declaration   TYPE : Class, interface (including annotation type), or enum declaration    @Retention : How long the annotation information is kept. The possible  RetentionPolicy  arguments are:   SOURCE : Annotations are discarded by the compiler.  CLASS : Annotations are available in the class file by the compiler but can be discarded by the VM.   RUNTIME : Annotations are retained by the VM at run time, so they may be read reflectively.    @Documented : Include this annotation in the Javadocs.  @Inherited : Allow subclasses to inherit parent annotations.", 
            "title": "Meta-annotations"
        }, 
        {
            "location": "/tij/ch21/#writing-annotation-processors", 
            "text": "Here is a very simple annotation processor that reads the annotated  PasswordUtils  class and uses reflection to look for  @UseCase  tags. Given a list of id values, it lists the use cases it finds and reports any that are missing:    public   class   UseCaseTracker   { \n   public   static   void   trackUseCases ( List Integer   useCases ,   Class ?   cl )   { \n     for ( Method   m   :   cl . getDeclaredMethods ())   { \n       UseCase   uc   =   m . getAnnotation ( UseCase . class ); \n       if ( uc   !=   null )   { \n         System . out . println ( Found Use Case:   +   uc . id ()   + \n               +   uc . description ()); \n         useCases . remove ( new   Integer ( uc . id ())); \n       } \n     } \n     for ( int   i   :   useCases )   { \n       System . out . println ( Warning: Missing use case-   +   i ); \n     } \n   } \n   public   static   void   main ( String []   args )   { \n     List Integer   useCases   =   new   ArrayList Integer (); \n     Collections . addAll ( useCases ,   47 ,   48 ,   49 ,   50 ); \n     trackUseCases ( useCases ,   PasswordUtils . class ); \n   }  }", 
            "title": "Writing annotation processors"
        }
    ]
}