{
    "docs": [
        {
            "location": "/hfdp/ch8/", 
            "text": "Head First Design Patterns 8 - Template Method Pattern\n\n\n1 Template Method Pattern\n\n\nTemplate Method Pattern defined\n\n\n\n\nThe Template Method Pattern(\u6a21\u7248\u65b9\u6cd5\u6a21\u5f0f) defines the skeleton of an algorithm in a method, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm\u2019s structure.\n\n\n\n\nThis pattern is all about creating a template for an algorithm. A template is  a method that defines an algorithm as a set of steps. One or more of these steps is de\ufb01ned to be abstract and implemented by a subclass. This ensures the algorithm\u2019s structure stays unchanged, while subclasses provide some part of the implementation.\n\n\nTemplate Method Pattern Class Diagram\n\n\n\n\n\n\nThe \nAbstractClass\n contains the template method.\n\n\nThe template method makes use of the \nprimitiveOperation\ns to implement an algorithm. It is decoupled from the actual implementation of these operations.\n\n\nThere may be many \nConcreteClasses\n, each implementing the full set of operations required by the template method. \n\n\n\n\n \nabstract\n \nclass\n \nAbstractClass\n \n{\n\n    \n// Here\ns the template method\n\n    \n// It\ns declared final to prevent subclasses from reworking the sequence of steps in the algorithm.\n\n    \nfinal\n \nvoid\n \ntemplateMethod\n()\n \n{\n \n        \n// The templateMethod defines the sequence of steps,\n\n        \n// each represented by a method.\n\n        \nprimitiveOperation1\n();\n \n        \nprimitiveOperation2\n();\n \n        \nconcreteOperation\n();\n \n    \n}\n \n    \n// In this example, two of the primitive operations \n\n    \n// must be implemented by concrete subclasses.\n\n    \nabstract\n \nvoid\n \nprimitiveOperation1\n();\n \n    \nabstract\n \nvoid\n \nprimitiveOperation2\n();\n \n    \n// We also have a concrete operation defined in the abstract class.\n\n    \nvoid\n \nconcreteOperation\n()\n \n{\n\n        \n// implementation here \n\n    \n}\n\n    \n// A concrete method, but it does nothing!\n\n    \n// We can also have concrete method, which do nothing by default;\n\n    \n// We call these \nhooks\n. Subclasses are free to override these, \n\n    \n// but don\nt have to.\n\n    \nvoid\n \nhook\n()\n \n{}\n\n\n}\n\n\n\n\n\n\nQuestion\n\n\nWhen to use abstract methods and when to use hooks?\n\n\n\n\nUse abstract methods when your subclass MUST provide an implementation of the method or step in the algorithm. \n\n\nUse hooks when that part of the algorithm is optional. With hooks, a subclass may choose to implement that hook, but it doesn\u2019t have to.\n\n\n\n\n\n\nExample - CaffeineBeverage\n\n\nTea and coffee are made in very similar ways. Notice that both recipes follow the same algorithm:\n\n\n\n\nBoil some water.\n\n\nUse the hot water to extract the coffee or tea.\n\n\nPour the resulting beverage into a cup. \n\n\nAdd the appropriate condiments to the beverage.\n\n\n\n\n\n\nCaffeinebeverage\npublic\n \nabstract\n \nclass\n \nCaffeineBeverage\n \n{\n\n    \nfinal\n \nvoid\n \nprepareRecipe\n()\n \n{\n\n        \nboilWater\n();\n\n        \nbrew\n();\n\n        \npourInCup\n();\n\n        \naddCondiments\n();\n\n    \n}\n\n\n    \nabstract\n \nvoid\n \nbrew\n();\n\n    \nabstract\n \nvoid\n \naddCondiments\n();\n\n    \nvoid\n \nboilWater\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nBoiling water\n);\n\n    \n}\n\n    \nvoid\n \npourInCup\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nPouring into cup\n);\n\n    \n}\n\n\n}\n\n\nCaffee/tea\npublic\n \nclass\n \nCoffee\n \nextends\n \nCaffeineBeverage\n \n{\n\n    \npublic\n \nvoid\n \nbrew\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nDripping Coffee through filter\n);\n\n    \n}\n\n    \npublic\n \nvoid\n \naddCondiments\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nAdding Sugar and Milk\n);\n\n    \n}\n\n\n}\n\n\n\npublic\n \nclass\n \nTea\n \nextends\n \nCaffeineBeverage\n \n{\n\n    \npublic\n \nvoid\n \nbrew\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nSteeping the tea\n);\n\n    \n}\n\n    \npublic\n \nvoid\n \naddCondiments\n()\n \n{\n\n        \nSystem\n.\nout\n.\nprintln\n(\nAdding Lemon\n);\n\n    \n}\n\n\n}\n\n\nBeveragetestdrive\npublic\n \nclass\n \nBeverageTestDrive\n \n{\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n\n        \nTea\n \ntea\n \n=\n \nnew\n \nTea\n();\n\n        \nCoffee\n \ncoffee\n \n=\n \nnew\n \nCoffee\n();\n\n\n        \nSystem\n.\nout\n.\nprintln\n(\n\\nMaking tea...\n);\n\n        \ntea\n.\nprepareRecipe\n();\n\n\n        \nSystem\n.\nout\n.\nprintln\n(\n\\nMaking coffee...\n);\n\n        \ncoffee\n.\nprepareRecipe\n();\n\n\n\n        \nTeaWithHook\n \nteaHook\n \n=\n \nnew\n \nTeaWithHook\n();\n\n        \nCoffeeWithHook\n \ncoffeeHook\n \n=\n \nnew\n \nCoffeeWithHook\n();\n\n\n        \nSystem\n.\nout\n.\nprintln\n(\n\\nMaking tea...\n);\n\n        \nteaHook\n.\nprepareRecipe\n();\n\n\n        \nSystem\n.\nout\n.\nprintln\n(\n\\nMaking coffee...\n);\n\n        \ncoffeeHook\n.\nprepareRecipe\n();\n\n    \n}\n\n\n}\n\n\n\n\n\nExample - Arrays sort()\n\n\nLet\u2019s trace through how the Arrays \nsort()\n template method works.\n\n\n\n\nFirst, we need an array of Ducks: \nDuck\n[]\n \nducks\n \n=\n \n{\nnew\n \nDuck\n(\n\u201c\nDaffy\n\u201d\n,\n \n8\n),\n \n...\n \n};\n\n\nThen we call the \nsort()\n template method in the Array class and pass it our ducks: \nArrays.sort(ducks);\n\n\nThe \nsort()\n method (and its helper \nmergesort()\n) control the sort procedure.\n\n\nTo sort an array, you need to compare two items one by one until the entire list is in sorted order.\n\n\nWhen it comes to comparing two ducks, the sort method relies on the Duck\u2019s \ncompareTo()\n method to know how to do this. The \ncompareTo()\n method is called on the first duck and passed the duck to be compared to: \nducks[0].compareTo(ducks[1]);\n\n\nIf the Ducks are not in sorted order, they\u2019re swapped with the concrete swap() method in Arrays.\n\n\nThe sort method continues comparing and swapping Ducks until the array is in the correct order!\n\n\n\n\n\n\nDucksort\nimport\n \njava.util.Arrays\n;\n\n\n\npublic\n \nclass\n \nDuckSortTestDrive\n \n{\n\n    \npublic\n \nstatic\n \nvoid\n \nmain\n(\nString\n[]\n \nargs\n)\n \n{\n\n        \nDuck\n[]\n \nducks\n \n=\n \n{\n \n                        \nnew\n \nDuck\n(\nDaffy\n,\n \n8\n),\n \n                        \nnew\n \nDuck\n(\nDewey\n,\n \n2\n),\n\n                        \nnew\n \nDuck\n(\nHoward\n,\n \n7\n),\n\n                        \nnew\n \nDuck\n(\nLouie\n,\n \n2\n),\n\n                        \nnew\n \nDuck\n(\nDonald\n,\n \n10\n),\n \n                        \nnew\n \nDuck\n(\nHuey\n,\n \n2\n)\n\n         \n};\n\n        \nSystem\n.\nout\n.\nprintln\n(\nBefore sorting:\n);\n\n        \ndisplay\n(\nducks\n);\n\n\n        \nArrays\n.\nsort\n(\nducks\n);\n\n\n        \nSystem\n.\nout\n.\nprintln\n(\n\\nAfter sorting:\n);\n\n        \ndisplay\n(\nducks\n);\n\n    \n}\n\n\n    \npublic\n \nstatic\n \nvoid\n \ndisplay\n(\nDuck\n[]\n \nducks\n)\n \n{\n\n        \nfor\n \n(\nDuck\n \nd\n \n:\n \nducks\n)\n \n{\n\n            \nSystem\n.\nout\n.\nprintln\n(\nd\n);\n\n        \n}\n\n    \n}\n\n\n}\n\n\nDuck\npublic\n \nclass\n \nDuck\n \nimplements\n \nComparable\nDuck\n \n{\n\n    \nString\n \nname\n;\n\n    \nint\n \nweight\n;\n\n\n    \npublic\n \nDuck\n(\nString\n \nname\n,\n \nint\n \nweight\n)\n \n{\n\n        \nthis\n.\nname\n \n=\n \nname\n;\n\n        \nthis\n.\nweight\n \n=\n \nweight\n;\n\n    \n}\n\n\n    \npublic\n \nString\n \ntoString\n()\n \n{\n\n        \nreturn\n \nname\n \n+\n \n weighs \n \n+\n \nweight\n;\n\n    \n}\n\n\n    \npublic\n \nint\n \ncompareTo\n(\nDuck\n \nobject\n)\n \n{\n\n\n        \nDuck\n \notherDuck\n \n=\n \nobject\n;\n\n\n        \nif\n \n(\nthis\n.\nweight\n \n \notherDuck\n.\nweight\n)\n \n{\n\n            \nreturn\n \n-\n1\n;\n\n        \n}\n \nelse\n \nif\n \n(\nthis\n.\nweight\n \n==\n \notherDuck\n.\nweight\n)\n \n{\n\n            \nreturn\n \n0\n;\n\n        \n}\n \nelse\n \n{\n \n// this.weight \n otherDuck.weight\n\n            \nreturn\n \n1\n;\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\nExample - InputStream.read()\n\n\njava.io.InputStream\n has a \nread()\n method. Its subclasses must implement and is used by the template method \nread\n(\nbyte\n \nb\n[],\n \nint\n \noff\n,\n \nint\n \nlen\n)\n.\n\n\n\n\n \npublic\n \nabstract\n \nclass\n \nInputStream\n \nimplements\n \nCloseable\n \n{\n\n    \n...\n\n    \n// Reads the next byte of data from the input stream.\n\n    \npublic\n \nabstract\n \nint\n \nread\n()\n \nthrows\n \nIOException\n;\n\n    \n...\n\n\n\n\n2 The Hollywood Principle\n\n\n\n\nThe Hollywood Principle: Don\u2019t call us, we\u2019ll call you.\n\n\n\n\nWith the Hollywood Principle, we allow low-level components to hook themselves into a system, but the high-level components determine when they are needed, and how. In other words, the high-level components give the low-level components a \u201cdon\u2019t call us, we\u2019ll call you\u201d treatment.", 
            "title": "Chapter 8: Template Method Pattern"
        }, 
        {
            "location": "/hfdp/ch8/#head-first-design-patterns-8-template-method-pattern", 
            "text": "", 
            "title": "Head First Design Patterns 8 - Template Method Pattern"
        }, 
        {
            "location": "/hfdp/ch8/#1-template-method-pattern", 
            "text": "", 
            "title": "1 Template Method Pattern"
        }, 
        {
            "location": "/hfdp/ch8/#template-method-pattern-defined", 
            "text": "The Template Method Pattern(\u6a21\u7248\u65b9\u6cd5\u6a21\u5f0f) defines the skeleton of an algorithm in a method, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm\u2019s structure.   This pattern is all about creating a template for an algorithm. A template is  a method that defines an algorithm as a set of steps. One or more of these steps is de\ufb01ned to be abstract and implemented by a subclass. This ensures the algorithm\u2019s structure stays unchanged, while subclasses provide some part of the implementation.", 
            "title": "Template Method Pattern defined"
        }, 
        {
            "location": "/hfdp/ch8/#template-method-pattern-class-diagram", 
            "text": "The  AbstractClass  contains the template method.  The template method makes use of the  primitiveOperation s to implement an algorithm. It is decoupled from the actual implementation of these operations.  There may be many  ConcreteClasses , each implementing the full set of operations required by the template method.      abstract   class   AbstractClass   { \n     // Here s the template method \n     // It s declared final to prevent subclasses from reworking the sequence of steps in the algorithm. \n     final   void   templateMethod ()   {  \n         // The templateMethod defines the sequence of steps, \n         // each represented by a method. \n         primitiveOperation1 ();  \n         primitiveOperation2 ();  \n         concreteOperation ();  \n     }  \n     // In this example, two of the primitive operations  \n     // must be implemented by concrete subclasses. \n     abstract   void   primitiveOperation1 ();  \n     abstract   void   primitiveOperation2 ();  \n     // We also have a concrete operation defined in the abstract class. \n     void   concreteOperation ()   { \n         // implementation here  \n     } \n     // A concrete method, but it does nothing! \n     // We can also have concrete method, which do nothing by default; \n     // We call these  hooks . Subclasses are free to override these,  \n     // but don t have to. \n     void   hook ()   {}  }    Question  When to use abstract methods and when to use hooks?   Use abstract methods when your subclass MUST provide an implementation of the method or step in the algorithm.   Use hooks when that part of the algorithm is optional. With hooks, a subclass may choose to implement that hook, but it doesn\u2019t have to.", 
            "title": "Template Method Pattern Class Diagram"
        }, 
        {
            "location": "/hfdp/ch8/#example-caffeinebeverage", 
            "text": "Tea and coffee are made in very similar ways. Notice that both recipes follow the same algorithm:   Boil some water.  Use the hot water to extract the coffee or tea.  Pour the resulting beverage into a cup.   Add the appropriate condiments to the beverage.    Caffeinebeverage public   abstract   class   CaffeineBeverage   { \n     final   void   prepareRecipe ()   { \n         boilWater (); \n         brew (); \n         pourInCup (); \n         addCondiments (); \n     } \n\n     abstract   void   brew (); \n     abstract   void   addCondiments (); \n     void   boilWater ()   { \n         System . out . println ( Boiling water ); \n     } \n     void   pourInCup ()   { \n         System . out . println ( Pouring into cup ); \n     }  }  Caffee/tea public   class   Coffee   extends   CaffeineBeverage   { \n     public   void   brew ()   { \n         System . out . println ( Dripping Coffee through filter ); \n     } \n     public   void   addCondiments ()   { \n         System . out . println ( Adding Sugar and Milk ); \n     }  }  public   class   Tea   extends   CaffeineBeverage   { \n     public   void   brew ()   { \n         System . out . println ( Steeping the tea ); \n     } \n     public   void   addCondiments ()   { \n         System . out . println ( Adding Lemon ); \n     }  }  Beveragetestdrive public   class   BeverageTestDrive   { \n     public   static   void   main ( String []   args )   { \n\n         Tea   tea   =   new   Tea (); \n         Coffee   coffee   =   new   Coffee (); \n\n         System . out . println ( \\nMaking tea... ); \n         tea . prepareRecipe (); \n\n         System . out . println ( \\nMaking coffee... ); \n         coffee . prepareRecipe (); \n\n\n         TeaWithHook   teaHook   =   new   TeaWithHook (); \n         CoffeeWithHook   coffeeHook   =   new   CoffeeWithHook (); \n\n         System . out . println ( \\nMaking tea... ); \n         teaHook . prepareRecipe (); \n\n         System . out . println ( \\nMaking coffee... ); \n         coffeeHook . prepareRecipe (); \n     }  }", 
            "title": "Example - CaffeineBeverage"
        }, 
        {
            "location": "/hfdp/ch8/#example-arrays-sort", 
            "text": "Let\u2019s trace through how the Arrays  sort()  template method works.   First, we need an array of Ducks:  Duck []   ducks   =   { new   Duck ( \u201c Daffy \u201d ,   8 ),   ...   };  Then we call the  sort()  template method in the Array class and pass it our ducks:  Arrays.sort(ducks);  The  sort()  method (and its helper  mergesort() ) control the sort procedure.  To sort an array, you need to compare two items one by one until the entire list is in sorted order.  When it comes to comparing two ducks, the sort method relies on the Duck\u2019s  compareTo()  method to know how to do this. The  compareTo()  method is called on the first duck and passed the duck to be compared to:  ducks[0].compareTo(ducks[1]);  If the Ducks are not in sorted order, they\u2019re swapped with the concrete swap() method in Arrays.  The sort method continues comparing and swapping Ducks until the array is in the correct order!    Ducksort import   java.util.Arrays ;  public   class   DuckSortTestDrive   { \n     public   static   void   main ( String []   args )   { \n         Duck []   ducks   =   {  \n                         new   Duck ( Daffy ,   8 ),  \n                         new   Duck ( Dewey ,   2 ), \n                         new   Duck ( Howard ,   7 ), \n                         new   Duck ( Louie ,   2 ), \n                         new   Duck ( Donald ,   10 ),  \n                         new   Duck ( Huey ,   2 ) \n          }; \n         System . out . println ( Before sorting: ); \n         display ( ducks ); \n\n         Arrays . sort ( ducks ); \n\n         System . out . println ( \\nAfter sorting: ); \n         display ( ducks ); \n     } \n\n     public   static   void   display ( Duck []   ducks )   { \n         for   ( Duck   d   :   ducks )   { \n             System . out . println ( d ); \n         } \n     }  }  Duck public   class   Duck   implements   Comparable Duck   { \n     String   name ; \n     int   weight ; \n\n     public   Duck ( String   name ,   int   weight )   { \n         this . name   =   name ; \n         this . weight   =   weight ; \n     } \n\n     public   String   toString ()   { \n         return   name   +    weighs    +   weight ; \n     } \n\n     public   int   compareTo ( Duck   object )   { \n\n         Duck   otherDuck   =   object ; \n\n         if   ( this . weight     otherDuck . weight )   { \n             return   - 1 ; \n         }   else   if   ( this . weight   ==   otherDuck . weight )   { \n             return   0 ; \n         }   else   {   // this.weight   otherDuck.weight \n             return   1 ; \n         } \n     }  }", 
            "title": "Example - Arrays sort()"
        }, 
        {
            "location": "/hfdp/ch8/#example-inputstreamread", 
            "text": "java.io.InputStream  has a  read()  method. Its subclasses must implement and is used by the template method  read ( byte   b [],   int   off ,   int   len ) .     public   abstract   class   InputStream   implements   Closeable   { \n     ... \n     // Reads the next byte of data from the input stream. \n     public   abstract   int   read ()   throws   IOException ; \n     ...", 
            "title": "Example - InputStream.read()"
        }, 
        {
            "location": "/hfdp/ch8/#2-the-hollywood-principle", 
            "text": "The Hollywood Principle: Don\u2019t call us, we\u2019ll call you.   With the Hollywood Principle, we allow low-level components to hook themselves into a system, but the high-level components determine when they are needed, and how. In other words, the high-level components give the low-level components a \u201cdon\u2019t call us, we\u2019ll call you\u201d treatment.", 
            "title": "2 The Hollywood Principle"
        }
    ]
}