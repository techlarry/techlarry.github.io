<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Computer System - techlarry
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="techlarry" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:larryim.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">HomePage</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_blank" href="wiki">WIKI</a></li>
        
        <li id=""><a target="_self" href="notebook.html">NOTEBOOK</a></li>
        
        <li id=""><a target="_self" href="about.html">About</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; techlarry</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">HomePage</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        
        <li><a target="_blank" href="wiki">WIKI</a></li>
        
        <li><a target="_self" href="notebook.html">NOTEBOOK</a></li>
        
        <li><a target="_self" href="about.html">About</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Leetcode.html">Leetcode</a></li>
        
            <li><a href="C/C++.html">C/C++</a></li>
        
            <li><a href="Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html">Python数据结构与算法</a></li>
        
            <li><a href="Course.html">Course</a></li>
        
            <li><a href="Python%E7%89%B9%E6%80%A7.html">Python特性</a></li>
        
            <li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html">机器学习</a></li>
        
            <li><a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html">Python科学计算三维可视化</a></li>
        
            <li><a href="English.html">English</a></li>
        
            <li><a href="Computer%20System.html">Computer System</a></li>
        
            <li><a href="Deep%20Learning.html">Deep Learning</a></li>
        
            <li><a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html">Linux 系统编程</a></li>
        
            <li><a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html">数据库</a></li>
        
            <li><a href="Tensorflow.html">Tensorflow</a></li>
        
            <li><a href="Big%20Data.html">Big Data</a></li>
        
            <li><a href="%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB.html">文献阅读</a></li>
        
            <li><a href="Tools.html">Tools</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="objdump_disassembler.html">
                
                  <h1>Objdump 反汇编</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><code>objdump</code>是一个反汇编器(<code>disassembler</code>)，可以将机器语言生成对应的汇编文件。常用的命令是</p>

<pre><code class="language-text">objdump -d filename.o
</code></pre>

<p>其选项有：</p>

<pre><code class="language-text">--archive-headers 
-a 
显示档案库的成员信息,类似ls -l将lib*.a的信息列出。 

-b bfdname 
--target=bfdname 
指定目标码格式。这不是必须的，objdump能自动识别许多格式，比如： 

objdump -b oasys -m vax -h fu.o 
显示fu.o的头部摘要信息，明确指出该文件是Vax系统下用Oasys编译器生成的目标文件。objdump -i将给出这里可以指定的目标码格式列表。 

-C 
--demangle 
将底层的符号名解码成用户级名字，除了去掉所开头的下划线之外，还使得C++函数名以可理解的方式显示出来。 

--debugging 
-g 
显示调试信息。企图解析保存在文件中的调试信息并以C语言的语法显示出来。仅仅支持某些类型的调试信息。有些其他的格式被readelf -w支持。 

-e 
--debugging-tags 
类似-g选项，但是生成的信息是和ctags工具相兼容的格式。 

--disassemble 
-d 
从objfile中反汇编那些特定指令机器码的section。 

-D 
--disassemble-all 
与 -d 类似，但反汇编所有section. 

--prefix-addresses 
反汇编的时候，显示每一行的完整地址。这是一种比较老的反汇编格式。 

-EB 
-EL 
--endian={big|little} 
指定目标文件的小端。这个项将影响反汇编出来的指令。在反汇编的文件没描述小端信息的时候用。例如S-records. 

-f 
--file-headers 
显示objfile中每个文件的整体头部摘要信息。 

-h 
--section-headers 
--headers 
显示目标文件各个section的头部摘要信息。 

-H 
--help 
简短的帮助信息。 

-i 
--info 
显示对于 -b 或者 -m 选项可用的架构和目标格式列表。 

-j name
--section=name 
仅仅显示指定名称为name的section的信息 

-l
--line-numbers 
用文件名和行号标注相应的目标代码，仅仅和-d、-D或者-r一起使用使用-ld和使用-d的区别不是很大，在源码级调试的时候有用，要求编译时使用了-g之类的调试编译选项。 

-m machine 
--architecture=machine 
指定反汇编目标文件时使用的架构，当待反汇编文件本身没描述架构信息的时候(比如S-records)，这个选项很有用。可以用-i选项列出这里能够指定的架构. 

--reloc 
-r 
显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。 

--dynamic-reloc 
-R 
显示文件的动态重定位入口，仅仅对于动态目标文件意义，比如某些共享库。 

-s 
--full-contents 
显示指定section的完整内容。默认所有的非空section都会被显示。 

-S 
--source 
尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。 

--show-raw-insn 
反汇编的时候，显示每条汇编指令对应的机器码，如不指定--prefix-addresses，这将是缺省选项。 

--no-show-raw-insn 
反汇编时，不显示汇编指令的机器码，如不指定--prefix-addresses，这将是缺省选项。 

--start-address=address 
从指定地址开始显示数据，该选项影响-d、-r和-s选项的输出。 

--stop-address=address 
显示数据直到指定地址为止，该项影响-d、-r和-s选项的输出。 

-t 
--syms 
显示文件的符号表入口。类似于nm -s提供的信息 

-T 
--dynamic-syms 
显示文件的动态符号表入口，仅仅对动态目标文件意义，比如某些共享库。它显示的信息类似于 nm -D|--dynamic 显示的信息。 

-V 
--version 
版本信息 

--all-headers 
-x 
显示所可用的头信息，包括符号表、重定位入口。-x 等价于-a -f -h -r -t 同时指定。 

-z 
--disassemble-zeroes 
一般反汇编输出将省略大块的零，该选项使得这些零块也被反汇编。 

@file 可以将选项集中到一个文件中，然后使用这个@file选项载入。
</code></pre>

<p>下面通过一个简单的例子来说明一下<code>objdump</code>的常见用法，以及它生成的文件的格式。</p>

<p>假设写一个简单的C程序<code>test.c</code>如下：</p>

<pre><code class="language-c">int foo()
{
    int a = 5;
    int b = 0;
    b = a + 3;
}
</code></pre>

<p>用<code>gcc</code>命令<code>gcc test.c -c</code>生成目标文件<code>test.o</code>后, 利用<code>objdump -d test.o &gt; test.s</code>生成类似汇编文件：</p>

<pre><code class="language-text">test.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;foo&gt;:
   0:   55                      push   %rbp
   1:   48 89 e5                mov    %rsp,%rbp
   4:   c7 45 f8 05 00 00 00    movl   $0x5,-0x8(%rbp)
   b:   c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)
  12:   8b 45 f8                mov    -0x8(%rbp),%eax
  15:   83 c0 03                add    $0x3,%eax
  18:   89 45 fc                mov    %eax,-0x4(%rbp)
  1b:   5d                      pop    %rbp
  1c:   c3                      retq
</code></pre>

<p>可以看到的其实这个类似于汇编文件的格式是<code>elf64-x86-64</code>, 下一小节会简单的介绍这个格式。其中最重要的内容是从<code>0000000000000000 &lt;foo&gt;</code>开始到结束的部分。这部分从左到右依次是</p>

<ul>
<li>指令开始的地址<code>memory staring addresses</code></li>
<li>汇编代码对应的二进制指令<code>byte codes for instruction</code></li>
<li>汇编代码<code>assembly codes</code></li>
</ul>

<h3 id="toc_0">显示文件的符号表入口</h3>

<p><code>objdump -t</code> 命令会打印文件的符号表<code>symbol table</code>. 输出的文件一共有7列，从左到右依次是</p>

<ul>
<li>value</li>
<li>class</li>
<li>type</li>
<li>size</li>
<li>line</li>
<li>section</li>
<li>symbol-name</li>
</ul>

<h2 id="toc_1">elf64-x86-64 文件</h2>

<p><code>elf</code>是<code>Executable and Linkable Format</code>(可执行和可链接格式，<a href="http://larryim.cc/Linking.html">看本文</a>)的简称。<code>elf</code>文件格式及其复杂，如果只需要研究<code>objdump</code>产生的反汇编文件没有必要去专门学习<code>elf</code>格式。掌握下面几点，就可以阅读<code>objdump</code>产生的反汇编文件了。<code>objdump</code>产生的<code>elf</code>文件，主要包括以下几个部分：</p>

<ul>
<li>Disassembly of section .init</li>
<li>Disassembly of section .plt</li>
<li>Disassembly of section .text</li>
<li>Disassembly of section .fini</li>
</ul>

<p>下面是一个具体的文件，为了更简洁的展示，每一部分只保留了一小段内容：</p>

<pre><code class="language-text">ctarget:     file format elf64-x86-64


Disassembly of section .init:

0000000000400c48 &lt;_init&gt;:
  400c48:   48 83 ec 08             sub    $0x8,%rsp
  400c4c:   e8 6b 02 00 00          callq  400ebc &lt;call_gmon_start&gt;
  400c51:   48 83 c4 08             add    $0x8,%rsp
  400c55:   c3                      retq   

Disassembly of section .plt:

0000000000400cb0 &lt;strcpy@plt&gt;:
  400cb0:   ff 25 6a 33 20 00       jmpq   *0x20336a(%rip)        # 604020 &lt;_GLOBAL_OFFSET_TABLE_+0x38&gt;
  400cb6:   68 04 00 00 00          pushq  $0x4
  400cbb:   e9 a0 ff ff ff          jmpq   400c60 &lt;_init+0x18&gt;


Disassembly of section .text:

00000000004011ad &lt;main&gt;:
  4011bb:   be c5 1d 40 00          mov    $0x401dc5,%esi
  4011c0:   bf 0b 00 00 00          mov    $0xb,%edi
  4011c5:   e8 86 fb ff ff          callq  400d50 &lt;signal@plt&gt;
  4011cf:   bf 07 00 00 00       
  401384:   c3                      retq   


Disassembly of section .fini:

0000000000402d74 &lt;_fini&gt;:
  402d74:   48 83 ec 08             sub    $0x8,%rsp
  402d78:   48 83 c4 08             add    $0x8,%rsp
  402d7c:   c3                      retq   

</code></pre>

<p>其中<code>.fini</code>部分是有关进程结束的指令。<code>.init</code>部分是有关进程启动的指令，在<code>main()</code>函数执行前会执行。<code>PLT</code>代表<code>Procedure Linkage Table</code>(过程链接表),用来调用在链接阶段未知的外部函数/过程的，在运行时它会动态链接。所以最重要的内容都在<code>.text</code>部分中。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/1/1</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="virtual_memory_and_dynamic_memory_allocate.html">
                
                  <h1>CSAPP - 虚拟内存</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">1 物理/虚拟寻址</h2>

<p>主存是由连续的<strong>字节大小</strong>的单元组成的数组，每字节都有一个唯一的<strong>物理地址</strong>(Physical Adress)。CPU使用物理地址访问内存的方式称为<strong>物理寻址</strong>(Physical adressing)。</p>

<p>早期的PC以及数字信号处理器等使用物理寻址，下面是物理寻址的示意图：</p>

<p><img src="media/15164033620970/physical_address.png" alt="physical_address"/></p>

<p>现代处理器通过生成一个<strong>虚拟地址</strong>(Virtual Address)来访问主存，虚拟地址经过<strong>地址翻译</strong>转换为物理地址。地址翻译由CPU内的<strong>内存管理单元</strong>(Memory Management Unit, <code>MMU</code>)负责.</p>

<p><img src="media/15164033620970/virtual_memory%20.png" alt="virtual_memory "/></p>

<p>虚拟内存充当着三个角色：</p>

<ul>
<li>作为缓存的工具，可以更有效率的使用内存：使用DRAM当做部分的虚拟地址空间的缓存</li>
<li>作为内存管理的工具，简化内存管理：每个进程都有统一的线性地址空间</li>
<li>作为内存保护的工具，分隔地址空间：进程的内存不会相互影响；用户程序不能访问保密的内核信息和代码</li>
</ul>

<p>下面一节具体讲解虚拟内存的这三个角色。</p>

<h2 id="toc_1">2 虚拟内存的三个角色</h2>

<h3 id="toc_2">2.1 作为缓存的工具</h3>

<p>可以把主存DRAM看作是虚拟内存的缓存，类似于L1、L2、L3高速缓存是DRAM内存的缓存。也就是说可以把虚拟内存看成是存储器层次结构的一部分。</p>

<p><img src="media/15164033620970/vm_as_cache.png" alt="vm_as_cache"/></p>

<p>和其他存储器层次结构中的缓存一样，较低层上的数据被分割成块，作为与较高层之间的传输单元。这里较低层是虚拟内存，分割成<strong>虚拟页</strong>(Virtual Page, VP)，虚拟页大小为\(P=2^p\)字节。类似的，这里的较高层，物理内存DRAM，被分割为<strong>物理页</strong>(Physical Page, PP)，大小也为\(P\)，也叫做页桢。</p>

<p>虚拟页的状态分为三种：</p>

<ul>
<li>未分配(Unallocated): 系统还未分配(创建)的页，不占用磁盘空间。</li>
<li>缓存的(Cached): 当前已缓存在物理内存中的已分配页。</li>
<li>未缓存的(Uncached): 未缓存在物理内存中的已分配页。</li>
</ul>

<p>那么具体是怎么判断一个虚拟页的状态呢？怎么知道虚拟页放在哪个物理页中呢？</p>

<p>物理内存中存在一个叫<strong>页表</strong>(page table)的数据结构，由操作系统负责。页表将虚拟页映射到物理页，每次内存管理单元中的<strong>地址翻译硬件</strong>将虚拟地址转换为物理地址时都会读取页表。</p>

<p>页表其实是一个页表条目(Page Table Entry, PTE)的数组。页表条目包含一个有效位(valid bit)和一个n位地址字段。</p>

<p><img src="media/15164033620970/page_table.jpg" alt="page_table"/></p>

<p>在虚拟内存的习惯说法中，DRAM缓存命中/不命中，特称为<strong>页命中</strong>/<strong>缺页</strong>(Page Fault)。</p>

<h3 id="toc_3">2.2 作为内存管理的工具</h3>

<p>操作系统为每个进程提供了一个独立的页表，也就是提供了一个独立的虚拟地址空间。多个虚拟页面可以映射到同一个共享物理页面上。虚拟内存简化了链接和加载、代码和数据共享、以及应用程序的内存分配。</p>

<h3 id="toc_4">2.3 作为内存保护的工具</h3>

<p>一方面，每个进程拥有独立的地址空间使得区分不同进程的私有内存变得容易。另一方面在每个页表条目PTE中，添加了额外的<strong>许可位</strong>(SUP, READ, WRITE, EXEC)来控制对一个虚拟页面内容的访问：</p>

<ul>
<li>SUP位表示进程是否运行在超级用户模式下才能访问</li>
<li>READ/WRITE位控制读和写的访问</li>
<li>EXEC位控制执行的访问</li>
</ul>

<p><img src="media/15164033620970/vm_protection.png" alt="vm_protection"/></p>

<p>如果违反许可条件，那么就触发段错误(segmentation fault)。</p>

<h2 id="toc_5">3 Linux虚拟内存系统</h2>

<p>Linux为每个进程维护了一个单独的虚拟地址空间。Linux将虚拟内存组织成一些<strong>区域</strong>的集合。一个区域就是已分配的虚拟内存的连续片。</p>

<p>Linux虚拟地址空间由如下几个区域组成：</p>

<ul>
<li>代码（<code>.text</code>）: 这里存放的是CPU要执行的指令。代码段是可共享的，相同的代码在内存中只会有一个拷贝，同时这个段是只读的，防止程序由于错误而修改自身的指令。</li>
<li>初始化数据段（<code>.data</code>）: 这里存放的是程序中需要明确赋初始值的变量，例如位于所有函数之外的全局变量：<code>int val=&quot;100</code>。需要强调的是，以上两段都是位于程序的可执行文件中，内核在调用<code>exec</code>函数启动该程序时从源程序文件中读入。</li>
<li>未初始化数据段（<code>.bss</code>）: 位于这一段中的数据，内核在执行该程序前，将其初始化为0或者<code>null</code>。例如出现在任何函数之外的全局变量：int sum;</li>
<li>堆（<code>Heap</code>）: 这个段用于在程序中进行动态内存申请，例如经常用到的<code>malloc</code>，<code>new</code>系列函数就是从这个段中申请内存。</li>
<li>共享库(<code>Shared Library</code>): 用来存放像C标准库和数学哭这样的共享库的代码和数据的区域。</li>
<li>栈（<code>Stack</code>）: 函数中的局部变量以及在函数调用过程中产生的临时变量都保存在此段中，具体见下面一节。</li>
<li>内核虚拟内存：包含内核中的代码和数据结构。</li>
</ul>

<p><img src="media/15089188725996/linux_virtual_memory.png" alt="linux_virtual_memory"/></p>

<h3 id="toc_6">3.1 Linux是如何组织虚拟内存的</h3>

<p>那么Linux具体是怎么组织虚拟内存的呢？Linux内核为系统中的每个进程维护一个单独的任务结构体(<code>task_struct</code>, 在<code>sched.h</code>头文件中)。<code>task_struct</code>中的元素包含运行该进程所需要的所有信息(PID、指向用户栈的指针、可执行目标文件的名字、以及程序计数器)。</p>

<p><img src="media/15164033620970/vm_linux.png" alt="vm_linux"/></p>

<p><code>task_struct</code>中的一个元素指向<code>mm_struct</code>，它描述了虚拟内存的当前状态。<code>pgd</code>指向第一级页表的基址，而<code>mmap</code>指向一个<code>vm_area_struct</code>(区域结构, 定义在<code>mm_types.h</code>)的链表。每个区域结构链表都描述了虚拟地址空间的一个区域，包含以下字段：</p>

<ul>
<li><code>vm_start</code>: 指向区域的起始处</li>
<li><code>vm_end</code>: 指向区域的结束处</li>
<li><code>vm_prot</code>: 描述着区域内包含的所有页的读写许可权限</li>
<li><code>vm_flags</code>: 描述进程共享/私有</li>
<li><code>vm_next</code>: 下一个区域结构</li>
</ul>

<h3 id="toc_7">3.2 Linux 缺页异常处理</h3>

<p>内存管理单元MMU在试图翻译某个虚拟地址A时，触发了一个缺页异常，引起缺页异常处理程序：</p>

<ul>
<li>虚拟地址A是合法的吗？-&gt; 段错误(segment fault)</li>
<li>试图进行的内存访问是合法的吗？ -&gt; 保护异常(也引发段错误)</li>
</ul>

<p><img src="media/15164033620970/linux_page_fault.png" alt="linux_page_fault"/></p>

<h2 id="toc_8">4 动态内存分配</h2>

<p>程序使用动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些数据结构的大小。一般使用动态内存分配器(dynamic memeory allocator)来分配动态内存。</p>

<p>分配器根据哪个实体来负责释放已分配的块，分为两种：</p>

<ul>
<li>显示分配器(explicit allocator)：要求程序显示地释放任何已分配的块。例如C中的malloc/free，C++中的new/delete。</li>
<li>隐式分配器(implicit allocator): 除此之外，自动释放未使用的已分配块(垃圾收集，garbage collection)。</li>
</ul>

<h3 id="toc_9">4.2 显式分配器的要求和目标</h3>

<h4 id="toc_10">4.2.1 分配器的要求</h4>

<p>分配器有如下的要求：</p>

<ul>
<li>处理任意请求序列</li>
<li>立即相应请求</li>
<li>只使用堆</li>
<li>对齐块(对齐要求)</li>
<li>不修改已分配的块</li>
</ul>

<h4 id="toc_11">4.2.2 分配器的目标</h4>

<p>分配器试图最大化吞吐率和内存利用率</p>

<ul>
<li>最大化吞吐率(吞吐率：每个单位时间里完成的请求数)</li>
<li>最大化内存利用率</li>
</ul>

<p>最大化吞吐率和最大化利用率之间是相互 <u>牵制</u> 的，分配器设计的目标是在这两者之间找到一个适当的平衡。</p>

<p>造成利用率很低的主要原因是<strong>碎片</strong>(fragmentation)现象。当有效载荷比块要小时，发生<strong>内部碎片</strong>(Internal fragmentation)，引起的原因有：对齐等。</p>

<p><img src="media/15164033620970/internal_fragmentation.png" alt="internal_fragmentation"/></p>

<p>当即使有足够的累积的块内存，但是没有单一块能够满足需求时，发生<strong>外部碎片</strong>(external fragmentation)：</p>

<p><img src="media/15164033620970/external_fragmentation.png" alt="external_fragmentation"/></p>

<p>外部碎片还取决于将来的请求，例如上图，如果最后的p4请求4个字节呢？也就不会发生碎片。正因为外部碎片难以量化且不可能预测，所以分配器通常采用启发式策略来试图维持少量的大空闲块，而不是维持大量的小空闲块。</p>

<h3 id="toc_12">4.3 实现方法</h3>

<ul>
<li>隐式空闲列表 Implicit Free List</li>
<li>显式空闲列表 Explicit Free List</li>
<li>分离式空闲列表 Segregated Free List</li>
</ul>

<h4 id="toc_13">4.3.1 隐式空闲列表</h4>

<p><img src="media/15164033620970/implicit_list.png" alt="implicit_list"/></p>

<p>隐式空闲链表优点是简单，缺点是操作开销大。因为无论是分配还是释放块，都需要对隐式空闲列表进行搜索，复杂度是\(O(n)\)，\(n\)是已分配块和空闲块的总数。</p>

<h4 id="toc_14">4.3.1 显式空闲列表</h4>

<p><img src="media/15164033620970/explict_list.png" alt="explict_list"/></p>

<h4 id="toc_15">4.3.1 分离式空闲列表</h4>

<h2 id="toc_16">5 C程序中常见的与内存有关的错误</h2>

<h4 id="toc_17">5.1 间接引用坏指针</h4>

<p>这是非常常见的例子，没有引用对应的地址，少了 &amp;</p>

<pre><code class="language-c">int val;
scanf(&quot;%d&quot;, val); // 正确应该是scanf(&quot;%d, &amp;val);
</code></pre>

<h4 id="toc_18">5.2 读未初始化的内存</h4>

<p><strong>堆内存是没有被初始化为0的</strong>：</p>

<pre><code class="language-c">/* return y = Ax */
int *matvec(int **A, int *x) {
    int *y = malloc(N * sizeof(int));
    int i, j;
    
    for (i = 0; i &lt; N; i++)
        for (j = 0; j &lt; N; j++)
            y[i] += A[i][j] * x[j];
    return y;
}
</code></pre>

<p>正确的方法是显式地将y[i]设置为0，或者使用<code>calloc</code>。</p>

<h4 id="toc_19">5.3 允许栈缓冲区溢出</h4>

<p>没有检查字符串的长度（经典的缓冲区溢出攻击也是利用相同的机制）</p>

<pre><code class="language-c">char s[8];
int i;
gets(s); /* stack buffer overflow, reads &quot;123456789&quot; from stdin */
</code></pre>

<h4 id="toc_20">5.4 引用不存在的变量</h4>

<p>尽管指针仍然指向一个合法的内存地址，但是已经不再指向一个合法的变量了。以后在程序中调用其他函数时，内存将重用它们的栈针。</p>

<pre><code class="language-c">int *foo() {
    int val;
    
    return &amp;val;
}
</code></pre>

<h4 id="toc_21">5.5 多次释放</h4>

<p>这个不用多说，不能重复搞两次</p>

<pre><code class="language-c">x = malloc(N * sizeof(int));
//  &lt;manipulate x&gt;
free(x);
y = malloc(M * sizeof(int));
//  &lt;manipulate y&gt;
free(x);
</code></pre>

<h4 id="toc_22">5.6 引用已经被释放的堆块中的数据</h4>

<p>同样是很明显的错误，不要犯</p>

<pre><code class="language-c">x = malloc(N * sizeof(int));
//  &lt;manipulate x&gt;
free(x);
//  ....
y = malloc(M * sizeof(int));
for (i = 0; i &lt; M; i++)
    y[i] = x[i]++;
</code></pre>

<h4 id="toc_23">内存泄漏</h4>

<p>5.7忘记释放已分配块：</p>

<pre><code class="language-c">foo() {
    int *x = malloc(N * sizeof(int));
    // ...
    return ;
}
</code></pre>

<p>或者只释放了数据结构的一部分：</p>

<pre><code class="language-c">struct list {
    int val;
    struct list *next;
};
foo() {
    struct list *head = malloc(sizeof(struct list));
    head-&gt;val = 0;
    head-&gt;next = NULL;
    //...
    free(head);
    return;
}
</code></pre>

<h2 id="toc_24">6 core i7内存系统</h2>

<p>Core i7在2008年冬季发布，基于全新Nehalem架构，它的芯片结构如下所示：</p>

<p><img src="media/15164033620970/15312857062358.png" alt=""/></p>

<p>抽象的内存系统：</p>

<p><img src="media/15164033620970/corei7.png" alt="corei7"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/1/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="Computer_memory.html">
                
                  <h1>CSAPP - 存储器层次结构</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>存储器系统(memory system)是一个具有不同 <u>容量</u> 、 <u>成本</u> 和 <u>访问时间</u> 的存储设备的层次结构。</p>

<p><strong>局部性</strong>(locality)：具有良好局部性的程序倾向于一次又一次地访问相同的数据项集合，或是倾向于访问邻近的数据项集合。</p>

<h2 id="toc_0">1 存储技术</h2>

<h3 id="toc_1">1.1 RAM</h3>

<p>随机访问存储器(Random-Access Memory, RAM)分为两类：静态(SRAM)和动态(DRAM)的。SRAM比DRAM更快，但也贵得多。</p>

<h3 id="toc_2">1.2 磁盘</h3>

<p>磁盘是由盘片(platter)构成的。每个盘片如同切西瓜一样被“切”成一块一块的扇面，同时沿着半径的方向被划分成了一组同心圆(磁道, track)，每条磁道被扇面切成很多的扇形区域叫做扇区（sector, 扇区是从磁盘读出和写入信息的最小单位，包含相等数量的数据位，通常为512字节），不同盘片上的同半径磁道组成了柱面。</p>

<p><img src="media/15089188725996/15312767746205.jpg" alt=""/></p>

<p>磁盘的容量： 磁头数 × 磁道数 × 每道扇区数 × 每扇区字节数</p>

<h2 id="toc_3">2 局部性</h2>

<p>一个编写良好的计算机程序常常具有良好的局部性(locality)。也就是，它们倾向于引用邻近于其他最近引用过的数据项的数据项(空间局部性)，或者最近引用过的数据项本身(时间局部性)。</p>

<p>现代计算机系统的各个层次，从硬件到操作系统、再到应用程序，它们的设计都利用了局部性。</p>

<h2 id="toc_4">3 存储器层次结构 Memory Hierarchy</h2>

<p>一般而言，从高层往低层走，存储设备变得更慢、更便宜和更大。</p>

<p><img src="media/15128019428341/15128077150126.png" alt="存储器层次结构"/></p>

<h2 id="toc_5">虚拟内存 Virtual Memory</h2>

<p>虚拟内存(<code>Virtual Memory</code>)是一个抽象概念。它为每个进程提供了假象，即每个进程都在独占地使用内存。每个进程看到的内存都是一致的，称为虚拟地址空间<code>Virtual Address Space</code>.</p>

<p>虚拟内存在不同操作系统上有区别，以Linux系统为例,下面是<code>Linux  x86-64运行时的内存映像</code>。</p>

<p><img src="media/15089188725996/linux_virtual_memory.png" alt="linux_virtual_memory"/></p>

<p>虚拟地址空间由如下几部分组成：</p>

<ul>
<li>代码（<code>.text</code>）: 这里存放的是CPU要执行的指令。代码段是可共享的，相同的代码在内存中只会有一个拷贝，同时这个段是只读的，防止程序由于错误而修改自身的指令。</li>
<li>初始化数据段（<code>.data</code>）: 这里存放的是程序中需要明确赋初始值的变量，例如位于所有函数之外的全局变量：<code>int val=&quot;100</code>。需要强调的是，以上两段都是位于程序的可执行文件中，内核在调用<code>exec</code>函数启动该程序时从源程序文件中读入。</li>
<li>未初始化数据段（<code>.bss</code>）: 位于这一段中的数据，内核在执行该程序前，将其初始化为0或者<code>null</code>。例如出现在任何函数之外的全局变量：int sum;</li>
<li>堆（<code>Heap</code>）: 这个段用于在程序中进行动态内存申请，例如经常用到的<code>malloc</code>，<code>new</code>系列函数就是从这个段中申请内存。</li>
<li>共享库(<code>Shared Library</code>): 用来存放像C标准库和数学哭这样的共享库的代码和数据的区域。</li>
<li>栈（<code>Stack</code>）: 函数中的局部变量以及在函数调用过程中产生的临时变量都保存在此段中，具体见下面一节。</li>
<li>内核虚拟内存：包含内核中的代码和数据结构。</li>
</ul>

<p>注意：</p>

<ul>
<li>底部内存地址是最小的，越往上地址越大。</li>
<li>堆(正向增长)和栈(反向增长)的生长方向(箭头➡️所指方向)是相反的。</li>
</ul>

<p>下面是程序示意：</p>

<pre><code class="language-c"> #include&lt;stdio.h&gt;    
 #include &lt;malloc.h&gt;    
     
 void print(char *,int);    
 int main()    
{    
      char *s1 = &quot;abcde&quot;;  //&quot;abcde&quot;作为字符串常量存储在常量区 s1、s2、s5拥有相同的地址  
      char *s2 = &quot;abcde&quot;;    
      char s3[] = &quot;abcd&quot;;    
      long int *s4[100];    
      char *s5 = &quot;abcde&quot;;    
      int a = 5;    
      int b =6;//a,b在栈上，&amp;a&gt;&amp;b地址反向增长    
     
     printf(&quot;variables address in main function: s1=%p  s2=%p s3=%p s4=%p s5=%p a=%p b=%p \n&quot;,     
             s1,s2,s3,s4,s5,&amp;a,&amp;b);   
     printf(&quot;variables address in processcall:n&quot;);    
        print(&quot;ddddddddd&quot;,5);//参数入栈从右至左进行,p先进栈,str后进 &amp;p&gt;&amp;str    
     printf(&quot;main=%p print=%p \n&quot;,main,print);    
     //打印代码段中主函数和子函数的地址，编译时先编译的地址低，后编译的地址高main&lt;print    
 }    
  
 void print(char *str,int p)    
{    
     char *s1 = &quot;abcde&quot;;  //abcde在常量区，s1在栈上    
     char *s2 = &quot;abcde&quot;;  //abcde在常量区，s2在栈上 s2-s1=6可能等于0，编译器优化了相同的常量，只在内存保存一份    
     //而&amp;s1&gt;&amp;s2    
     char s3[] = &quot;abcdeee&quot;;//abcdeee在常量区，s3在栈上，数组保存的内容为abcdeee的一份拷贝    
     long int *s4[100];    
     char *s5 = &quot;abcde&quot;;    
     int a = 5;    
     int b =6;    
     int c;    
     int d;           //a,b,c,d均在栈上，&amp;a&gt;&amp;b&gt;&amp;c&gt;&amp;d地址反向增长    
     char *q=str;   
     int m=p;           
     char *r=(char *)malloc(1);    
     char *w=(char *)malloc(1) ;  // r&lt;w 堆正向增长    
    
     printf(&quot;s1=%p s2=%p s3=%p s4=%p s5=%p a=%p b=%p c=%p d=%p str=%p q=%p p=%p m=%p r=%p w=%p \n&quot;,    
            s1,s2,s3,s4,s5,&amp;a,&amp;b,&amp;c,&amp;d,&amp;str,q,&amp;p,&amp;m,r,w);   
     /* 栈和堆是在程序运行时候动态分配的，局部变量均在栈上分配。 
        栈是反向增长的，地址递减；malloc等分配的内存空间在堆空间。堆是正向增长的，地址递增。   
        r,w变量在栈上(则&amp;r&gt;&amp;w)，r,w所指内容在堆中(即r&lt;w)。*/   
 }    
   
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="memory_alignment.html">
                
                  <h1>内存对齐</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>许多计算机系统对基本数据类型的合法地址做出了一些限制， <u>要求某种类型对象的地址必须是某个值\(K\)(通常是2、4或8)的倍数</u> 。这种<strong>对齐限制</strong>简化了处理器和内存系统之间的硬件设计。例如，假设一个处理器总是从内存中取8个字节，则地址必须为8的倍数。如果我们能保证将所有的double类型的数据对齐成8的倍数，那么就可以用一个内存操作来读或者写值了。否则，我们可能需要执行两次内存访问，因为对象可能被放在两个8字节内存块中。</p>

<p>例如：</p>

<pre><code class="language-c">#include &lt;iostream&gt;
using namespace std;
struct A{
    char a;
    int b;
    short c;
};

struct B{
    short c;
    char a;
    int b;
};

int main(){
    cout&lt;&lt;sizeof(A)&lt;&lt;endl; //结果是12
    cout&lt;&lt;sizeof(B)&lt;&lt;endl; //结果是8
    return 0;
}
</code></pre>

<p>以上结构体变量数量和类型完全相同，但是因为对齐限制，却得到了不同的结果。具体为什么会这样，请参考下面的对齐原则。</p>

<h2 id="toc_0">对齐原则</h2>

<ul>
<li>任何\(K\)字节的基本对象的地址必须是K的倍数: \(\text{align}(x) = \text{sizeof}(x) = K\)</li>
<li>结构体内存对齐要求结构体内每一个成员变量都是内存对齐的；</li>
<li>结构体本身也要对齐。</li>
</ul>

<p>除此之外，程序员可自己指定数据的对齐大小，通过使用<code>pragma pack(x)</code>预处理命令，指定对齐大小为\(\text{pack_align}=x\)。只能指定\(2^n\)作为对齐大小，对于指定对齐大小为6、9、10这样的编译器不会理会。</p>

<pre><code class="language-c">#pragma pack(x)
//...
#pragma pack()
</code></pre>

<p>使用<code>pragma pack(x)</code>预处理命令后，对齐大小为</p>

<p>\[\text{align}(x) = \min(\text{sizeof}(x) , \text{pack_align})\] </p>

<p>即<code>sizeof(x)</code>和指定对齐大小哪个小，对齐大小就为哪个。</p>

<p>通过以下例子可以更好地掌握内存对齐原则：</p>

<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;stddef.h&gt;


#pragma pack(1)
    //此处指定对齐大小为1
    //对于a，实际对齐大小为min(sizeof(int),1)=min(4,1)=1
    //对于b，实际对齐大小为min(sizeof(char),1)=min(1,1)=1
    //编译器会确保TEST_A首地址即a的地首址是1字节对齐的，此时a对齐
    //对于b，由于b要求首地址1字节对齐，这显然对于任何地址都合适，所以a,b都是对齐的
    //对于TEST_A数组，第一个TEST_A是对齐的（假设其地址为0），则第二个TEST_A的首地址为(0+5=5)，对于第二个TEST_A的两个变量a，b均对齐
    //OK,对齐合理。因此整个结构体的大小为5   
typedef struct TEST_A
{
    int a;
    char b;
} A;
#pragma  pack()


#pragma pack(2)
    //此处指定对齐大小为2
    //对于a，实际对齐大小为min(sizeof(int),2)=min(4,2)=2
    //对于b，实际对齐大小为min(sizeof(char),2)=min(1,2)=1
    //编译器会确保TEST_A首地址即a的地首址是2字节对齐的，此时a对齐
    //对于b，由于b要求首地址1字节对齐，这显然对于任何地址都合适，所以a,b都是对齐的
    //对于TEST_B数组，第一个TEST_B是对齐的（假设其地址为0），则第二个TEST_B的首地址为(0+5=5)，对于第二个TEST_B的变量a，显然地址5是不对齐于2字节的
    //因此，需要在TEST_B的变量b后面填充1字节，此时连续相连的TEST_B数组才会对齐
    //OK,对齐合理。因此整个结构体的大小为5+1=6
typedef struct TEST_B
{
    int a;
    char b;
} B;
#pragma  pack()

   
#pragma pack(4)
    //此处指定对齐大小为4
    //对于a，实际对齐大小为min(sizeof(int),2)=min(4,4)=4
    //对于b，实际对齐大小为min(sizeof(char),2)=min(1,4)=1
    //编译器会确保TEST_A首地址即a的地首址是4字节对齐的，此时a对齐
    //对于b，由于b要求首地址1字节对齐，这显然对于任何地址都合适，所以a,b都是对齐的
    //对于TEST_C数组，第一个TEST_C是对齐的（假设其地址为0），则第二个TEST_C的首地址为(0+5=5)，对于第二个TEST_C的变量a，显然地址5是不对齐于4字节的
    //因此，需要在TEST_C的变量b后面填充3字节，此时连续相连的TEST_C数组才会对齐
    //OK,对齐合理。因此整个结构体的大小为5+3=8
typedef struct TEST_C
{
    int a;
    char b;
} C;
#pragma  pack()


#pragma pack(8)
    //此处指定对齐大小为8
    //对于a，实际对齐大小为min(sizeof(int),8)=min(4,8)=4
    //对于b，实际对齐大小为min(sizeof(char),8)=min(1,8)=1
    //编译器会确保TEST_A首地址即a的地首址是4字节对齐的，此时a对齐
    //对于b，由于b要求首地址1字节对齐，这显然对于任何地址都合适，所以a,b都是对齐的
    //对于TEST_D数组，第一个TEST_D是对齐的（假设其地址为0），则第二个TEST_D的首地址为(0+5=5)，对于第二个TEST_D的变量a，显然地址5是不对齐于4字节的
    //因此，需要在TEST_D的变量b后面填充3字节，此时连续相连的TEST_D数组才会对齐
    //OK,对齐合理。因此整个结构体的大小为5+3=8
typedef struct TEST_D
{
    int a;
    char b;
} D;
#pragma  pack()



#pragma pack(8)
    //此处指定对齐大小为8
    //对于a，实际对齐大小为min(sizeof(int),8)=min(4,8)=4
    //对于b，实际对齐大小为min(sizeof(char),8)=min(1,8)=1
    //对于c，这是一个数组，数组的对齐大小与其单元一致，因而align(c)=align(double)=min(sizeof(double),8)=min(8,8)=8
    //对于d，实际对齐大小为min(sizeof(char),8)=min(1,8)=1
    //编译器会确保TEST_A首地址即a的地首址是4字节对齐的，此时a对齐
    //对于b，由于b要求首地址1字节对齐，这显然对于任何地址都合适，所以a,b都是对齐的
    //对于c，由于c要求首地址8字节对齐，因此前面的a+b=5，还要在c后面补上3个字节才能对齐
    //对于d，显而易见，任何地址均对齐，此时结构体大小为4+1+3+10*8+1=89
    //对于TEST_E数组，第一个TEST_E是对齐的（假设其地址为0），则第二个TEST_E的首地址为(0+89=89)，对于第二个TEST_E的变量a，显然地址89是不对齐于4字节的
    //因此，需要在TEST_E的变量d后面填充7字节，此时连续相连的TEST_E数组才会对齐 
    //(注意：此处不仅要确保下一个TEST_E的a,b变量对齐，还要确保c也对齐，所以这里不是填充3字节，而是填充7字节）
    //OK,对齐合理。因此整个结构体的大小为(4)+(1+3)+(10*8)+(1+7)=96
typedef struct TEST_E
{
    int a;
    char b;
    double c[10];
    char d;
} E;
#pragma  pack()

int main()
{
    A A1;
    B B1;
    C C1;
    D D1;
    E E1, E2;
    printf(&quot;A:%zu, %zu\n&quot;, sizeof(A1), sizeof(A1));
    printf(&quot;B:%zu\n&quot;, sizeof(B1));
    printf(&quot;C:%zu\n&quot;, sizeof(C1));
    printf(&quot;D:%zu\n&quot;, sizeof(D1));
    printf(&quot;E:%zu, %zu\n&quot;, sizeof(E1), sizeof(E2));

    return 0;
}
</code></pre>

<pre><code class="language-text">A:5, 5
B:6
C:8
D:8
E:96, 96
</code></pre>

<h2 id="toc_1">内存对齐原因</h2>

<p>可能你对内存印象是，内存是由一个个字节组成的：</p>

<p><img src="media/15164914975645/howProgrammersSeeMemory.jpg" alt=""/></p>

<p>但是很可惜，CPU却不是这么看待的：</p>

<p><img src="media/15164914975645/howProcessorsSeeMemory.jpg" alt=""/></p>

<p>内存读取是按块进行的，块的大小称为<strong>粒度</strong>（granularity)。实际上在存储器层次结构上的较低层向较高层传输数据的时候都是按块进行的。也就是说，数据从内存到寄存器，要经过诸多关卡(在core i7上，有L1、L2和L3高速缓存)，每个关卡都有不同的粒度。所以为了提高速度，不仅仅大的对象要保证对齐，连对象内部的数据，也需要对齐到2的幂。</p>

<p>以内存读取为例，我们仔细看看为什么内存不对齐会影响读取速度？</p>

<p>假设CPU要读取一个4字节大小的数据到寄存器中（假设内存读取粒度是4），分两种情况讨论：</p>

<ul>
<li>1.数据从0字节开始</li>
<li>2.数据从1字节开始</li>
</ul>

<p>当数据从0字节开始的时候，直接将0-3四个字节完全读取到寄存器，就算完成了。</p>

<p><img src="media/15164914975645/quadByteAccess.jpg" alt=""/></p>

<p>当数据从1字节开始的时候，问题很复杂，首先先将前4个字节读到寄存器，并再次读取4-7字节的数据进寄存器，接着把0字节，5、6、7字节的数据剔除，最后合并1、2、3、4字节的数据进寄存器，对一个内存未对齐的寄存器进行了这么多额外操作，大大降低了性能。</p>

<p><img src="media/15164914975645/unalignedAccess.jpg" alt=""/></p>

<h2 id="toc_2">参考</h2>

<ul>
<li>1. 深入理解计算机体系（第三版）</li>
<li>2. <a href="https://zh.wikipedia.org/zh-hans/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E9%BD%90">数据结构对齐 维基百科</a></li>
<li>3. <a href="https://www.cnblogs.com/xylc/p/3780907.html">https://www.cnblogs.com/xylc/p/3780907.html</a></li>
<li>4. <a href="https://www.cnblogs.com/jijiji/p/4854581.html">https://www.cnblogs.com/jijiji/p/4854581.html</a></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/1/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="valgrind_usuage.html">
                
                  <h1>valgrind</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><code>Valgrind</code>(/ˈvælɡrɪnd/) is an instrumentation framework for building dynamic analysis tools. There are Valgrind tools that can automatically detect many memory management and threading bugs, and profile your programs in detail. You can also use Valgrind to build new tools.</p>

<p>The Valgrind distribution currently includes six production-quality tools: </p>

<ul>
<li>a memory error detector</li>
<li>two thread error detectors </li>
<li>a cache and branch-prediction profiler</li>
<li>a call-graph generating cache and branch-prediction profiler</li>
<li>a heap profiler.</li>
</ul>

<p>It also includes three experimental tools: </p>

<ul>
<li>a stack/global array overrun detector,</li>
<li>a second heap profiler that examines how heap blocks are used</li>
<li>a SimPoint basic block vector generator.</li>
</ul>

<h3 id="toc_0">Installing on Mac</h3>

<p>The simplest way to install <code>valgrind</code> is using <code>brew</code>:</p>

<pre><code class="language-text">brew install --HEAD valgrind
</code></pre>

<h3 id="toc_1">Demo</h3>

<p>Writing a C program named &#39;arrays.c&#39; without freeing the memory after allocating it dynamically using <code>malloc</code>, for example,</p>

<pre><code class="language-text">int* heap_array = (int*) malloc(sizeof(int) * 5);
free(heap_array); ## deleting the statement...
</code></pre>

<p>After running by command</p>

<pre><code class="language-text">valgrind ./arrays
</code></pre>

<p>you will see &quot;<strong>definitely lost: 20 bytes in 1 blocks</strong>!!&quot;</p>

<p><img src="media/15089186263565/Screen%20Shot%202017-10-25%20at%204.35.47%20PM.png" alt="Screen Shot 2017-10-25 at 4.35.47 P"/></p>

<h3 id="toc_2">Reference</h3>

<ul>
<li><a href="https://stackoverflow.com/questions/26564125/yosemite-and-valgrind">Yosemite and Valgrind</a></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Computer%20System.html'>Computer System</a></span>
          				  
          					    <span class="posted-in"><a href='Tools.html'>Tools</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Computer System_1.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Computer System_3.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="http://or9a8nskt.bkt.clouddn.com/figure.jpeg" /></div>
            
                <h1>techlarry</h1>
                <div class="site-des">他山之石，可以攻玉</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/techlarry" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:wang.zhen.hua.larry@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Leetcode.html"><strong>Leetcode</strong></a>
        
            <a href="C/C++.html"><strong>C/C++</strong></a>
        
            <a href="Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html"><strong>Python数据结构与算法</strong></a>
        
            <a href="Course.html"><strong>Course</strong></a>
        
            <a href="Python%E7%89%B9%E6%80%A7.html"><strong>Python特性</strong></a>
        
            <a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html"><strong>机器学习</strong></a>
        
            <a href="Python%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96.html"><strong>Python科学计算三维可视化</strong></a>
        
            <a href="English.html"><strong>English</strong></a>
        
            <a href="Computer%20System.html"><strong>Computer System</strong></a>
        
            <a href="Deep%20Learning.html"><strong>Deep Learning</strong></a>
        
            <a href="Linux%20%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.html"><strong>Linux 系统编程</strong></a>
        
            <a href="%E6%95%B0%E6%8D%AE%E5%BA%93.html"><strong>数据库</strong></a>
        
            <a href="Tensorflow.html"><strong>Tensorflow</strong></a>
        
            <a href="Big%20Data.html"><strong>Big Data</strong></a>
        
            <a href="%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB.html"><strong>文献阅读</strong></a>
        
            <a href="Tools.html"><strong>Tools</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="os_concepts_threads_and_concurrency.html">Operating System Concepts 4 - Threads & Concurrency</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="os-concets-processes.html">Operating System Concepts 3 - Processes</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="csapp-internet-programming.html">CSAPP - 网络编程</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="hadoop_mapreduce.html">Hadoop和MapReduce入门</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="Linking.html">CSAPP - 链接</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
